/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ 3562:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getHash = getHash;
exports.createCurve = createCurve;
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const hmac_1 = __webpack_require__(9615);
const utils_1 = __webpack_require__(9175);
const weierstrass_js_1 = __webpack_require__(1705);
// connects noble-curves to noble-hashes
function getHash(hash) {
    return {
        hash,
        hmac: (key, ...msgs) => (0, hmac_1.hmac)(hash, key, (0, utils_1.concatBytes)(...msgs)),
        randomBytes: utils_1.randomBytes,
    };
}
function createCurve(curveDef, defHash) {
    const create = (hash) => (0, weierstrass_js_1.weierstrass)({ ...curveDef, ...getHash(hash) });
    return Object.freeze({ ...create(defHash), create });
}
//# sourceMappingURL=_shortw_utils.js.map

/***/ }),

/***/ 2422:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.wNAF = wNAF;
exports.pippenger = pippenger;
exports.validateBasic = validateBasic;
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
// Abelian group utilities
const modular_js_1 = __webpack_require__(4967);
const utils_js_1 = __webpack_require__(1484);
const _0n = BigInt(0);
const _1n = BigInt(1);
// Since points in different groups cannot be equal (different object constructor),
// we can have single place to store precomputes
const pointPrecomputes = new WeakMap();
const pointWindowSizes = new WeakMap(); // This allows use make points immutable (nothing changes inside)
// Elliptic curve multiplication of Point by scalar. Fragile.
// Scalars should always be less than curve order: this should be checked inside of a curve itself.
// Creates precomputation tables for fast multiplication:
// - private scalar is split by fixed size windows of W bits
// - every window point is collected from window's table & added to accumulator
// - since windows are different, same point inside tables won't be accessed more than once per calc
// - each multiplication is 'Math.ceil(CURVE_ORDER / ùëä) + 1' point additions (fixed for any scalar)
// - +1 window is neccessary for wNAF
// - wNAF reduces table size: 2x less memory + 2x faster generation, but 10% slower multiplication
// TODO: Research returning 2d JS array of windows, instead of a single window. This would allow
// windows to be in different memory locations
function wNAF(c, bits) {
    const constTimeNegate = (condition, item) => {
        const neg = item.negate();
        return condition ? neg : item;
    };
    const validateW = (W) => {
        if (!Number.isSafeInteger(W) || W <= 0 || W > bits)
            throw new Error(`Wrong window size=${W}, should be [1..${bits}]`);
    };
    const opts = (W) => {
        validateW(W);
        const windows = Math.ceil(bits / W) + 1; // +1, because
        const windowSize = 2 ** (W - 1); // -1 because we skip zero
        return { windows, windowSize };
    };
    return {
        constTimeNegate,
        // non-const time multiplication ladder
        unsafeLadder(elm, n) {
            let p = c.ZERO;
            let d = elm;
            while (n > _0n) {
                if (n & _1n)
                    p = p.add(d);
                d = d.double();
                n >>= _1n;
            }
            return p;
        },
        /**
         * Creates a wNAF precomputation window. Used for caching.
         * Default window size is set by `utils.precompute()` and is equal to 8.
         * Number of precomputed points depends on the curve size:
         * 2^(ùëä‚àí1) * (Math.ceil(ùëõ / ùëä) + 1), where:
         * - ùëä is the window size
         * - ùëõ is the bitlength of the curve order.
         * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
         * @returns precomputed point tables flattened to a single array
         */
        precomputeWindow(elm, W) {
            const { windows, windowSize } = opts(W);
            const points = [];
            let p = elm;
            let base = p;
            for (let window = 0; window < windows; window++) {
                base = p;
                points.push(base);
                // =1, because we skip zero
                for (let i = 1; i < windowSize; i++) {
                    base = base.add(p);
                    points.push(base);
                }
                p = base.double();
            }
            return points;
        },
        /**
         * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
         * @param W window size
         * @param precomputes precomputed tables
         * @param n scalar (we don't check here, but should be less than curve order)
         * @returns real and fake (for const-time) points
         */
        wNAF(W, precomputes, n) {
            // TODO: maybe check that scalar is less than group order? wNAF behavious is undefined otherwise
            // But need to carefully remove other checks before wNAF. ORDER == bits here
            const { windows, windowSize } = opts(W);
            let p = c.ZERO;
            let f = c.BASE;
            const mask = BigInt(2 ** W - 1); // Create mask with W ones: 0b1111 for W=4 etc.
            const maxNumber = 2 ** W;
            const shiftBy = BigInt(W);
            for (let window = 0; window < windows; window++) {
                const offset = window * windowSize;
                // Extract W bits.
                let wbits = Number(n & mask);
                // Shift number by W bits.
                n >>= shiftBy;
                // If the bits are bigger than max size, we'll split those.
                // +224 => 256 - 32
                if (wbits > windowSize) {
                    wbits -= maxNumber;
                    n += _1n;
                }
                // This code was first written with assumption that 'f' and 'p' will never be infinity point:
                // since each addition is multiplied by 2 ** W, it cannot cancel each other. However,
                // there is negate now: it is possible that negated element from low value
                // would be the same as high element, which will create carry into next window.
                // It's not obvious how this can fail, but still worth investigating later.
                // Check if we're onto Zero point.
                // Add random point inside current window to f.
                const offset1 = offset;
                const offset2 = offset + Math.abs(wbits) - 1; // -1 because we skip zero
                const cond1 = window % 2 !== 0;
                const cond2 = wbits < 0;
                if (wbits === 0) {
                    // The most important part for const-time getPublicKey
                    f = f.add(constTimeNegate(cond1, precomputes[offset1]));
                }
                else {
                    p = p.add(constTimeNegate(cond2, precomputes[offset2]));
                }
            }
            // JIT-compiler should not eliminate f here, since it will later be used in normalizeZ()
            // Even if the variable is still unused, there are some checks which will
            // throw an exception, so compiler needs to prove they won't happen, which is hard.
            // At this point there is a way to F be infinity-point even if p is not,
            // which makes it less const-time: around 1 bigint multiply.
            return { p, f };
        },
        wNAFCached(P, n, transform) {
            const W = pointWindowSizes.get(P) || 1;
            // Calculate precomputes on a first run, reuse them after
            let comp = pointPrecomputes.get(P);
            if (!comp) {
                comp = this.precomputeWindow(P, W);
                if (W !== 1)
                    pointPrecomputes.set(P, transform(comp));
            }
            return this.wNAF(W, comp, n);
        },
        // We calculate precomputes for elliptic curve point multiplication
        // using windowed method. This specifies window size and
        // stores precomputed values. Usually only base point would be precomputed.
        setWindowSize(P, W) {
            validateW(W);
            pointWindowSizes.set(P, W);
            pointPrecomputes.delete(P);
        },
    };
}
/**
 * Pippenger algorithm for multi-scalar multiplication (MSM).
 * MSM is basically (Pa + Qb + Rc + ...).
 * 30x faster vs naive addition on L=4096, 10x faster with precomputes.
 * For N=254bit, L=1, it does: 1024 ADD + 254 DBL. For L=5: 1536 ADD + 254 DBL.
 * Algorithmically constant-time (for same L), even when 1 point + scalar, or when scalar = 0.
 * @param c Curve Point constructor
 * @param field field over CURVE.N - important that it's not over CURVE.P
 * @param points array of L curve points
 * @param scalars array of L scalars (aka private keys / bigints)
 */
function pippenger(c, field, points, scalars) {
    // If we split scalars by some window (let's say 8 bits), every chunk will only
    // take 256 buckets even if there are 4096 scalars, also re-uses double.
    // TODO:
    // - https://eprint.iacr.org/2024/750.pdf
    // - https://tches.iacr.org/index.php/TCHES/article/view/10287
    // 0 is accepted in scalars
    if (!Array.isArray(points) || !Array.isArray(scalars) || scalars.length !== points.length)
        throw new Error('arrays of points and scalars must have equal length');
    scalars.forEach((s, i) => {
        if (!field.isValid(s))
            throw new Error(`wrong scalar at index ${i}`);
    });
    points.forEach((p, i) => {
        if (!(p instanceof c))
            throw new Error(`wrong point at index ${i}`);
    });
    const wbits = (0, utils_js_1.bitLen)(BigInt(points.length));
    const windowSize = wbits > 12 ? wbits - 3 : wbits > 4 ? wbits - 2 : wbits ? 2 : 1; // in bits
    const MASK = (1 << windowSize) - 1;
    const buckets = new Array(MASK + 1).fill(c.ZERO); // +1 for zero array
    const lastBits = Math.floor((field.BITS - 1) / windowSize) * windowSize;
    let sum = c.ZERO;
    for (let i = lastBits; i >= 0; i -= windowSize) {
        buckets.fill(c.ZERO);
        for (let j = 0; j < scalars.length; j++) {
            const scalar = scalars[j];
            const wbits = Number((scalar >> BigInt(i)) & BigInt(MASK));
            buckets[wbits] = buckets[wbits].add(points[j]);
        }
        let resI = c.ZERO; // not using this will do small speed-up, but will lose ct
        // Skip first bucket, because it is zero
        for (let j = buckets.length - 1, sumI = c.ZERO; j > 0; j--) {
            sumI = sumI.add(buckets[j]);
            resI = resI.add(sumI);
        }
        sum = sum.add(resI);
        if (i !== 0)
            for (let j = 0; j < windowSize; j++)
                sum = sum.double();
    }
    return sum;
}
function validateBasic(curve) {
    (0, modular_js_1.validateField)(curve.Fp);
    (0, utils_js_1.validateObject)(curve, {
        n: 'bigint',
        h: 'bigint',
        Gx: 'field',
        Gy: 'field',
    }, {
        nBitLength: 'isSafeInteger',
        nByteLength: 'isSafeInteger',
    });
    // Set defaults
    return Object.freeze({
        ...(0, modular_js_1.nLength)(curve.n, curve.nBitLength),
        ...curve,
        ...{ p: curve.Fp.ORDER },
    });
}
//# sourceMappingURL=curve.js.map

/***/ }),

/***/ 6377:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.twistedEdwards = twistedEdwards;
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
// Twisted Edwards curve. The formula is: ax¬≤ + y¬≤ = 1 + dx¬≤y¬≤
const curve_js_1 = __webpack_require__(2422);
const modular_js_1 = __webpack_require__(4967);
const ut = __webpack_require__(1484);
const utils_js_1 = __webpack_require__(1484);
// Be friendly to bad ECMAScript parsers by not using bigint literals
// prettier-ignore
const _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _8n = BigInt(8);
// verification rule is either zip215 or rfc8032 / nist186-5. Consult fromHex:
const VERIFY_DEFAULT = { zip215: true };
function validateOpts(curve) {
    const opts = (0, curve_js_1.validateBasic)(curve);
    ut.validateObject(curve, {
        hash: 'function',
        a: 'bigint',
        d: 'bigint',
        randomBytes: 'function',
    }, {
        adjustScalarBytes: 'function',
        domain: 'function',
        uvRatio: 'function',
        mapToCurve: 'function',
    });
    // Set defaults
    return Object.freeze({ ...opts });
}
/**
 * Creates Twisted Edwards curve with EdDSA signatures.
 * @example
 * import { Field } from '@noble/curves/abstract/modular';
 * // Before that, define BigInt-s: a, d, p, n, Gx, Gy, h
 * const curve = twistedEdwards({ a, d, Fp: Field(p), n, Gx, Gy, h })
 */
function twistedEdwards(curveDef) {
    const CURVE = validateOpts(curveDef);
    const { Fp, n: CURVE_ORDER, prehash: prehash, hash: cHash, randomBytes, nByteLength, h: cofactor, } = CURVE;
    const MASK = _2n << (BigInt(nByteLength * 8) - _1n);
    const modP = Fp.create; // Function overrides
    const Fn = (0, modular_js_1.Field)(CURVE.n, CURVE.nBitLength);
    // sqrt(u/v)
    const uvRatio = CURVE.uvRatio ||
        ((u, v) => {
            try {
                return { isValid: true, value: Fp.sqrt(u * Fp.inv(v)) };
            }
            catch (e) {
                return { isValid: false, value: _0n };
            }
        });
    const adjustScalarBytes = CURVE.adjustScalarBytes || ((bytes) => bytes); // NOOP
    const domain = CURVE.domain ||
        ((data, ctx, phflag) => {
            (0, utils_js_1.abool)('phflag', phflag);
            if (ctx.length || phflag)
                throw new Error('Contexts/pre-hash are not supported');
            return data;
        }); // NOOP
    // 0 <= n < MASK
    // Coordinates larger than Fp.ORDER are allowed for zip215
    function aCoordinate(title, n) {
        ut.aInRange('coordinate ' + title, n, _0n, MASK);
    }
    function assertPoint(other) {
        if (!(other instanceof Point))
            throw new Error('ExtendedPoint expected');
    }
    // Converts Extended point to default (x, y) coordinates.
    // Can accept precomputed Z^-1 - for example, from invertBatch.
    const toAffineMemo = (0, utils_js_1.memoized)((p, iz) => {
        const { ex: x, ey: y, ez: z } = p;
        const is0 = p.is0();
        if (iz == null)
            iz = is0 ? _8n : Fp.inv(z); // 8 was chosen arbitrarily
        const ax = modP(x * iz);
        const ay = modP(y * iz);
        const zz = modP(z * iz);
        if (is0)
            return { x: _0n, y: _1n };
        if (zz !== _1n)
            throw new Error('invZ was invalid');
        return { x: ax, y: ay };
    });
    const assertValidMemo = (0, utils_js_1.memoized)((p) => {
        const { a, d } = CURVE;
        if (p.is0())
            throw new Error('bad point: ZERO'); // TODO: optimize, with vars below?
        // Equation in affine coordinates: ax¬≤ + y¬≤ = 1 + dx¬≤y¬≤
        // Equation in projective coordinates (X/Z, Y/Z, Z):  (aX¬≤ + Y¬≤)Z¬≤ = Z‚Å¥ + dX¬≤Y¬≤
        const { ex: X, ey: Y, ez: Z, et: T } = p;
        const X2 = modP(X * X); // X¬≤
        const Y2 = modP(Y * Y); // Y¬≤
        const Z2 = modP(Z * Z); // Z¬≤
        const Z4 = modP(Z2 * Z2); // Z‚Å¥
        const aX2 = modP(X2 * a); // aX¬≤
        const left = modP(Z2 * modP(aX2 + Y2)); // (aX¬≤ + Y¬≤)Z¬≤
        const right = modP(Z4 + modP(d * modP(X2 * Y2))); // Z‚Å¥ + dX¬≤Y¬≤
        if (left !== right)
            throw new Error('bad point: equation left != right (1)');
        // In Extended coordinates we also have T, which is x*y=T/Z: check X*Y == Z*T
        const XY = modP(X * Y);
        const ZT = modP(Z * T);
        if (XY !== ZT)
            throw new Error('bad point: equation left != right (2)');
        return true;
    });
    // Extended Point works in extended coordinates: (x, y, z, t) ‚àã (x=x/z, y=y/z, t=xy).
    // https://en.wikipedia.org/wiki/Twisted_Edwards_curve#Extended_coordinates
    class Point {
        constructor(ex, ey, ez, et) {
            this.ex = ex;
            this.ey = ey;
            this.ez = ez;
            this.et = et;
            aCoordinate('x', ex);
            aCoordinate('y', ey);
            aCoordinate('z', ez);
            aCoordinate('t', et);
            Object.freeze(this);
        }
        get x() {
            return this.toAffine().x;
        }
        get y() {
            return this.toAffine().y;
        }
        static fromAffine(p) {
            if (p instanceof Point)
                throw new Error('extended point not allowed');
            const { x, y } = p || {};
            aCoordinate('x', x);
            aCoordinate('y', y);
            return new Point(x, y, _1n, modP(x * y));
        }
        static normalizeZ(points) {
            const toInv = Fp.invertBatch(points.map((p) => p.ez));
            return points.map((p, i) => p.toAffine(toInv[i])).map(Point.fromAffine);
        }
        // Multiscalar Multiplication
        static msm(points, scalars) {
            return (0, curve_js_1.pippenger)(Point, Fn, points, scalars);
        }
        // "Private method", don't use it directly
        _setWindowSize(windowSize) {
            wnaf.setWindowSize(this, windowSize);
        }
        // Not required for fromHex(), which always creates valid points.
        // Could be useful for fromAffine().
        assertValidity() {
            assertValidMemo(this);
        }
        // Compare one point to another.
        equals(other) {
            assertPoint(other);
            const { ex: X1, ey: Y1, ez: Z1 } = this;
            const { ex: X2, ey: Y2, ez: Z2 } = other;
            const X1Z2 = modP(X1 * Z2);
            const X2Z1 = modP(X2 * Z1);
            const Y1Z2 = modP(Y1 * Z2);
            const Y2Z1 = modP(Y2 * Z1);
            return X1Z2 === X2Z1 && Y1Z2 === Y2Z1;
        }
        is0() {
            return this.equals(Point.ZERO);
        }
        negate() {
            // Flips point sign to a negative one (-x, y in affine coords)
            return new Point(modP(-this.ex), this.ey, this.ez, modP(-this.et));
        }
        // Fast algo for doubling Extended Point.
        // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#doubling-dbl-2008-hwcd
        // Cost: 4M + 4S + 1*a + 6add + 1*2.
        double() {
            const { a } = CURVE;
            const { ex: X1, ey: Y1, ez: Z1 } = this;
            const A = modP(X1 * X1); // A = X12
            const B = modP(Y1 * Y1); // B = Y12
            const C = modP(_2n * modP(Z1 * Z1)); // C = 2*Z12
            const D = modP(a * A); // D = a*A
            const x1y1 = X1 + Y1;
            const E = modP(modP(x1y1 * x1y1) - A - B); // E = (X1+Y1)2-A-B
            const G = D + B; // G = D+B
            const F = G - C; // F = G-C
            const H = D - B; // H = D-B
            const X3 = modP(E * F); // X3 = E*F
            const Y3 = modP(G * H); // Y3 = G*H
            const T3 = modP(E * H); // T3 = E*H
            const Z3 = modP(F * G); // Z3 = F*G
            return new Point(X3, Y3, Z3, T3);
        }
        // Fast algo for adding 2 Extended Points.
        // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#addition-add-2008-hwcd
        // Cost: 9M + 1*a + 1*d + 7add.
        add(other) {
            assertPoint(other);
            const { a, d } = CURVE;
            const { ex: X1, ey: Y1, ez: Z1, et: T1 } = this;
            const { ex: X2, ey: Y2, ez: Z2, et: T2 } = other;
            // Faster algo for adding 2 Extended Points when curve's a=-1.
            // http://hyperelliptic.org/EFD/g1p/auto-twisted-extended-1.html#addition-add-2008-hwcd-4
            // Cost: 8M + 8add + 2*2.
            // Note: It does not check whether the `other` point is valid.
            if (a === BigInt(-1)) {
                const A = modP((Y1 - X1) * (Y2 + X2));
                const B = modP((Y1 + X1) * (Y2 - X2));
                const F = modP(B - A);
                if (F === _0n)
                    return this.double(); // Same point. Tests say it doesn't affect timing
                const C = modP(Z1 * _2n * T2);
                const D = modP(T1 * _2n * Z2);
                const E = D + C;
                const G = B + A;
                const H = D - C;
                const X3 = modP(E * F);
                const Y3 = modP(G * H);
                const T3 = modP(E * H);
                const Z3 = modP(F * G);
                return new Point(X3, Y3, Z3, T3);
            }
            const A = modP(X1 * X2); // A = X1*X2
            const B = modP(Y1 * Y2); // B = Y1*Y2
            const C = modP(T1 * d * T2); // C = T1*d*T2
            const D = modP(Z1 * Z2); // D = Z1*Z2
            const E = modP((X1 + Y1) * (X2 + Y2) - A - B); // E = (X1+Y1)*(X2+Y2)-A-B
            const F = D - C; // F = D-C
            const G = D + C; // G = D+C
            const H = modP(B - a * A); // H = B-a*A
            const X3 = modP(E * F); // X3 = E*F
            const Y3 = modP(G * H); // Y3 = G*H
            const T3 = modP(E * H); // T3 = E*H
            const Z3 = modP(F * G); // Z3 = F*G
            return new Point(X3, Y3, Z3, T3);
        }
        subtract(other) {
            return this.add(other.negate());
        }
        wNAF(n) {
            return wnaf.wNAFCached(this, n, Point.normalizeZ);
        }
        // Constant-time multiplication.
        multiply(scalar) {
            const n = scalar;
            ut.aInRange('scalar', n, _1n, CURVE_ORDER); // 1 <= scalar < L
            const { p, f } = this.wNAF(n);
            return Point.normalizeZ([p, f])[0];
        }
        // Non-constant-time multiplication. Uses double-and-add algorithm.
        // It's faster, but should only be used when you don't care about
        // an exposed private key e.g. sig verification.
        // Does NOT allow scalars higher than CURVE.n.
        multiplyUnsafe(scalar) {
            const n = scalar;
            ut.aInRange('scalar', n, _0n, CURVE_ORDER); // 0 <= scalar < L
            if (n === _0n)
                return I;
            if (this.equals(I) || n === _1n)
                return this;
            if (this.equals(G))
                return this.wNAF(n).p;
            return wnaf.unsafeLadder(this, n);
        }
        // Checks if point is of small order.
        // If you add something to small order point, you will have "dirty"
        // point with torsion component.
        // Multiplies point by cofactor and checks if the result is 0.
        isSmallOrder() {
            return this.multiplyUnsafe(cofactor).is0();
        }
        // Multiplies point by curve order and checks if the result is 0.
        // Returns `false` is the point is dirty.
        isTorsionFree() {
            return wnaf.unsafeLadder(this, CURVE_ORDER).is0();
        }
        // Converts Extended point to default (x, y) coordinates.
        // Can accept precomputed Z^-1 - for example, from invertBatch.
        toAffine(iz) {
            return toAffineMemo(this, iz);
        }
        clearCofactor() {
            const { h: cofactor } = CURVE;
            if (cofactor === _1n)
                return this;
            return this.multiplyUnsafe(cofactor);
        }
        // Converts hash string or Uint8Array to Point.
        // Uses algo from RFC8032 5.1.3.
        static fromHex(hex, zip215 = false) {
            const { d, a } = CURVE;
            const len = Fp.BYTES;
            hex = (0, utils_js_1.ensureBytes)('pointHex', hex, len); // copy hex to a new array
            (0, utils_js_1.abool)('zip215', zip215);
            const normed = hex.slice(); // copy again, we'll manipulate it
            const lastByte = hex[len - 1]; // select last byte
            normed[len - 1] = lastByte & ~0x80; // clear last bit
            const y = ut.bytesToNumberLE(normed);
            // RFC8032 prohibits >= p, but ZIP215 doesn't
            // zip215=true:  0 <= y < MASK (2^256 for ed25519)
            // zip215=false: 0 <= y < P (2^255-19 for ed25519)
            const max = zip215 ? MASK : Fp.ORDER;
            ut.aInRange('pointHex.y', y, _0n, max);
            // Ed25519: x¬≤ = (y¬≤-1)/(dy¬≤+1) mod p. Ed448: x¬≤ = (y¬≤-1)/(dy¬≤-1) mod p. Generic case:
            // ax¬≤+y¬≤=1+dx¬≤y¬≤ => y¬≤-1=dx¬≤y¬≤-ax¬≤ => y¬≤-1=x¬≤(dy¬≤-a) => x¬≤=(y¬≤-1)/(dy¬≤-a)
            const y2 = modP(y * y); // denominator is always non-0 mod p.
            const u = modP(y2 - _1n); // u = y¬≤ - 1
            const v = modP(d * y2 - a); // v = d y¬≤ + 1.
            let { isValid, value: x } = uvRatio(u, v); // ‚àö(u/v)
            if (!isValid)
                throw new Error('Point.fromHex: invalid y coordinate');
            const isXOdd = (x & _1n) === _1n; // There are 2 square roots. Use x_0 bit to select proper
            const isLastByteOdd = (lastByte & 0x80) !== 0; // x_0, last bit
            if (!zip215 && x === _0n && isLastByteOdd)
                // if x=0 and x_0 = 1, fail
                throw new Error('Point.fromHex: x=0 and x_0=1');
            if (isLastByteOdd !== isXOdd)
                x = modP(-x); // if x_0 != x mod 2, set x = p-x
            return Point.fromAffine({ x, y });
        }
        static fromPrivateKey(privKey) {
            return getExtendedPublicKey(privKey).point;
        }
        toRawBytes() {
            const { x, y } = this.toAffine();
            const bytes = ut.numberToBytesLE(y, Fp.BYTES); // each y has 2 x values (x, -y)
            bytes[bytes.length - 1] |= x & _1n ? 0x80 : 0; // when compressing, it's enough to store y
            return bytes; // and use the last byte to encode sign of x
        }
        toHex() {
            return ut.bytesToHex(this.toRawBytes()); // Same as toRawBytes, but returns string.
        }
    }
    Point.BASE = new Point(CURVE.Gx, CURVE.Gy, _1n, modP(CURVE.Gx * CURVE.Gy));
    Point.ZERO = new Point(_0n, _1n, _1n, _0n); // 0, 1, 1, 0
    const { BASE: G, ZERO: I } = Point;
    const wnaf = (0, curve_js_1.wNAF)(Point, nByteLength * 8);
    function modN(a) {
        return (0, modular_js_1.mod)(a, CURVE_ORDER);
    }
    // Little-endian SHA512 with modulo n
    function modN_LE(hash) {
        return modN(ut.bytesToNumberLE(hash));
    }
    /** Convenience method that creates public key and other stuff. RFC8032 5.1.5 */
    function getExtendedPublicKey(key) {
        const len = nByteLength;
        key = (0, utils_js_1.ensureBytes)('private key', key, len);
        // Hash private key with curve's hash function to produce uniformingly random input
        // Check byte lengths: ensure(64, h(ensure(32, key)))
        const hashed = (0, utils_js_1.ensureBytes)('hashed private key', cHash(key), 2 * len);
        const head = adjustScalarBytes(hashed.slice(0, len)); // clear first half bits, produce FE
        const prefix = hashed.slice(len, 2 * len); // second half is called key prefix (5.1.6)
        const scalar = modN_LE(head); // The actual private scalar
        const point = G.multiply(scalar); // Point on Edwards curve aka public key
        const pointBytes = point.toRawBytes(); // Uint8Array representation
        return { head, prefix, scalar, point, pointBytes };
    }
    // Calculates EdDSA pub key. RFC8032 5.1.5. Privkey is hashed. Use first half with 3 bits cleared
    function getPublicKey(privKey) {
        return getExtendedPublicKey(privKey).pointBytes;
    }
    // int('LE', SHA512(dom2(F, C) || msgs)) mod N
    function hashDomainToScalar(context = new Uint8Array(), ...msgs) {
        const msg = ut.concatBytes(...msgs);
        return modN_LE(cHash(domain(msg, (0, utils_js_1.ensureBytes)('context', context), !!prehash)));
    }
    /** Signs message with privateKey. RFC8032 5.1.6 */
    function sign(msg, privKey, options = {}) {
        msg = (0, utils_js_1.ensureBytes)('message', msg);
        if (prehash)
            msg = prehash(msg); // for ed25519ph etc.
        const { prefix, scalar, pointBytes } = getExtendedPublicKey(privKey);
        const r = hashDomainToScalar(options.context, prefix, msg); // r = dom2(F, C) || prefix || PH(M)
        const R = G.multiply(r).toRawBytes(); // R = rG
        const k = hashDomainToScalar(options.context, R, pointBytes, msg); // R || A || PH(M)
        const s = modN(r + k * scalar); // S = (r + k * s) mod L
        ut.aInRange('signature.s', s, _0n, CURVE_ORDER); // 0 <= s < l
        const res = ut.concatBytes(R, ut.numberToBytesLE(s, Fp.BYTES));
        return (0, utils_js_1.ensureBytes)('result', res, nByteLength * 2); // 64-byte signature
    }
    const verifyOpts = VERIFY_DEFAULT;
    function verify(sig, msg, publicKey, options = verifyOpts) {
        const { context, zip215 } = options;
        const len = Fp.BYTES; // Verifies EdDSA signature against message and public key. RFC8032 5.1.7.
        sig = (0, utils_js_1.ensureBytes)('signature', sig, 2 * len); // An extended group equation is checked.
        msg = (0, utils_js_1.ensureBytes)('message', msg);
        if (zip215 !== undefined)
            (0, utils_js_1.abool)('zip215', zip215);
        if (prehash)
            msg = prehash(msg); // for ed25519ph, etc
        const s = ut.bytesToNumberLE(sig.slice(len, 2 * len));
        // zip215: true is good for consensus-critical apps and allows points < 2^256
        // zip215: false follows RFC8032 / NIST186-5 and restricts points to CURVE.p
        let A, R, SB;
        try {
            A = Point.fromHex(publicKey, zip215);
            R = Point.fromHex(sig.slice(0, len), zip215);
            SB = G.multiplyUnsafe(s); // 0 <= s < l is done inside
        }
        catch (error) {
            return false;
        }
        if (!zip215 && A.isSmallOrder())
            return false;
        const k = hashDomainToScalar(context, R.toRawBytes(), A.toRawBytes(), msg);
        const RkA = R.add(A.multiplyUnsafe(k));
        // [8][S]B = [8]R + [8][k]A'
        return RkA.subtract(SB).clearCofactor().equals(Point.ZERO);
    }
    G._setWindowSize(8); // Enable precomputes. Slows down first publicKey computation by 20ms.
    const utils = {
        getExtendedPublicKey,
        // ed25519 private keys are uniform 32b. No need to check for modulo bias, like in secp256k1.
        randomPrivateKey: () => randomBytes(Fp.BYTES),
        /**
         * We're doing scalar multiplication (used in getPublicKey etc) with precomputed BASE_POINT
         * values. This slows down first getPublicKey() by milliseconds (see Speed section),
         * but allows to speed-up subsequent getPublicKey() calls up to 20x.
         * @param windowSize 2, 4, 8, 16
         */
        precompute(windowSize = 8, point = Point.BASE) {
            point._setWindowSize(windowSize);
            point.multiply(BigInt(3));
            return point;
        },
    };
    return {
        CURVE,
        getPublicKey,
        sign,
        verify,
        ExtendedPoint: Point,
        utils,
    };
}
//# sourceMappingURL=edwards.js.map

/***/ }),

/***/ 1761:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.expand_message_xmd = expand_message_xmd;
exports.expand_message_xof = expand_message_xof;
exports.hash_to_field = hash_to_field;
exports.isogenyMap = isogenyMap;
exports.createHasher = createHasher;
const modular_js_1 = __webpack_require__(4967);
const utils_js_1 = __webpack_require__(1484);
// Octet Stream to Integer. "spec" implementation of os2ip is 2.5x slower vs bytesToNumberBE.
const os2ip = utils_js_1.bytesToNumberBE;
// Integer to Octet Stream (numberToBytesBE)
function i2osp(value, length) {
    anum(value);
    anum(length);
    if (value < 0 || value >= 1 << (8 * length)) {
        throw new Error(`bad I2OSP call: value=${value} length=${length}`);
    }
    const res = Array.from({ length }).fill(0);
    for (let i = length - 1; i >= 0; i--) {
        res[i] = value & 0xff;
        value >>>= 8;
    }
    return new Uint8Array(res);
}
function strxor(a, b) {
    const arr = new Uint8Array(a.length);
    for (let i = 0; i < a.length; i++) {
        arr[i] = a[i] ^ b[i];
    }
    return arr;
}
function anum(item) {
    if (!Number.isSafeInteger(item))
        throw new Error('number expected');
}
// Produces a uniformly random byte string using a cryptographic hash function H that outputs b bits
// https://www.rfc-editor.org/rfc/rfc9380#section-5.3.1
function expand_message_xmd(msg, DST, lenInBytes, H) {
    (0, utils_js_1.abytes)(msg);
    (0, utils_js_1.abytes)(DST);
    anum(lenInBytes);
    // https://www.rfc-editor.org/rfc/rfc9380#section-5.3.3
    if (DST.length > 255)
        DST = H((0, utils_js_1.concatBytes)((0, utils_js_1.utf8ToBytes)('H2C-OVERSIZE-DST-'), DST));
    const { outputLen: b_in_bytes, blockLen: r_in_bytes } = H;
    const ell = Math.ceil(lenInBytes / b_in_bytes);
    if (lenInBytes > 65535 || ell > 255)
        throw new Error('expand_message_xmd: invalid lenInBytes');
    const DST_prime = (0, utils_js_1.concatBytes)(DST, i2osp(DST.length, 1));
    const Z_pad = i2osp(0, r_in_bytes);
    const l_i_b_str = i2osp(lenInBytes, 2); // len_in_bytes_str
    const b = new Array(ell);
    const b_0 = H((0, utils_js_1.concatBytes)(Z_pad, msg, l_i_b_str, i2osp(0, 1), DST_prime));
    b[0] = H((0, utils_js_1.concatBytes)(b_0, i2osp(1, 1), DST_prime));
    for (let i = 1; i <= ell; i++) {
        const args = [strxor(b_0, b[i - 1]), i2osp(i + 1, 1), DST_prime];
        b[i] = H((0, utils_js_1.concatBytes)(...args));
    }
    const pseudo_random_bytes = (0, utils_js_1.concatBytes)(...b);
    return pseudo_random_bytes.slice(0, lenInBytes);
}
// Produces a uniformly random byte string using an extendable-output function (XOF) H.
// 1. The collision resistance of H MUST be at least k bits.
// 2. H MUST be an XOF that has been proved indifferentiable from
//    a random oracle under a reasonable cryptographic assumption.
// https://www.rfc-editor.org/rfc/rfc9380#section-5.3.2
function expand_message_xof(msg, DST, lenInBytes, k, H) {
    (0, utils_js_1.abytes)(msg);
    (0, utils_js_1.abytes)(DST);
    anum(lenInBytes);
    // https://www.rfc-editor.org/rfc/rfc9380#section-5.3.3
    // DST = H('H2C-OVERSIZE-DST-' || a_very_long_DST, Math.ceil((lenInBytes * k) / 8));
    if (DST.length > 255) {
        const dkLen = Math.ceil((2 * k) / 8);
        DST = H.create({ dkLen }).update((0, utils_js_1.utf8ToBytes)('H2C-OVERSIZE-DST-')).update(DST).digest();
    }
    if (lenInBytes > 65535 || DST.length > 255)
        throw new Error('expand_message_xof: invalid lenInBytes');
    return (H.create({ dkLen: lenInBytes })
        .update(msg)
        .update(i2osp(lenInBytes, 2))
        // 2. DST_prime = DST || I2OSP(len(DST), 1)
        .update(DST)
        .update(i2osp(DST.length, 1))
        .digest());
}
/**
 * Hashes arbitrary-length byte strings to a list of one or more elements of a finite field F
 * https://www.rfc-editor.org/rfc/rfc9380#section-5.2
 * @param msg a byte string containing the message to hash
 * @param count the number of elements of F to output
 * @param options `{DST: string, p: bigint, m: number, k: number, expand: 'xmd' | 'xof', hash: H}`, see above
 * @returns [u_0, ..., u_(count - 1)], a list of field elements.
 */
function hash_to_field(msg, count, options) {
    (0, utils_js_1.validateObject)(options, {
        DST: 'stringOrUint8Array',
        p: 'bigint',
        m: 'isSafeInteger',
        k: 'isSafeInteger',
        hash: 'hash',
    });
    const { p, k, m, hash, expand, DST: _DST } = options;
    (0, utils_js_1.abytes)(msg);
    anum(count);
    const DST = typeof _DST === 'string' ? (0, utils_js_1.utf8ToBytes)(_DST) : _DST;
    const log2p = p.toString(2).length;
    const L = Math.ceil((log2p + k) / 8); // section 5.1 of ietf draft link above
    const len_in_bytes = count * m * L;
    let prb; // pseudo_random_bytes
    if (expand === 'xmd') {
        prb = expand_message_xmd(msg, DST, len_in_bytes, hash);
    }
    else if (expand === 'xof') {
        prb = expand_message_xof(msg, DST, len_in_bytes, k, hash);
    }
    else if (expand === '_internal_pass') {
        // for internal tests only
        prb = msg;
    }
    else {
        throw new Error('expand must be "xmd" or "xof"');
    }
    const u = new Array(count);
    for (let i = 0; i < count; i++) {
        const e = new Array(m);
        for (let j = 0; j < m; j++) {
            const elm_offset = L * (j + i * m);
            const tv = prb.subarray(elm_offset, elm_offset + L);
            e[j] = (0, modular_js_1.mod)(os2ip(tv), p);
        }
        u[i] = e;
    }
    return u;
}
function isogenyMap(field, map) {
    // Make same order as in spec
    const COEFF = map.map((i) => Array.from(i).reverse());
    return (x, y) => {
        const [xNum, xDen, yNum, yDen] = COEFF.map((val) => val.reduce((acc, i) => field.add(field.mul(acc, x), i)));
        x = field.div(xNum, xDen); // xNum / xDen
        y = field.mul(y, field.div(yNum, yDen)); // y * (yNum / yDev)
        return { x, y };
    };
}
function createHasher(Point, mapToCurve, def) {
    if (typeof mapToCurve !== 'function')
        throw new Error('mapToCurve() must be defined');
    return {
        // Encodes byte string to elliptic curve.
        // hash_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3
        hashToCurve(msg, options) {
            const u = hash_to_field(msg, 2, { ...def, DST: def.DST, ...options });
            const u0 = Point.fromAffine(mapToCurve(u[0]));
            const u1 = Point.fromAffine(mapToCurve(u[1]));
            const P = u0.add(u1).clearCofactor();
            P.assertValidity();
            return P;
        },
        // Encodes byte string to elliptic curve.
        // encode_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3
        encodeToCurve(msg, options) {
            const u = hash_to_field(msg, 1, { ...def, DST: def.encodeDST, ...options });
            const P = Point.fromAffine(mapToCurve(u[0])).clearCofactor();
            P.assertValidity();
            return P;
        },
        // Same as encodeToCurve, but without hash
        mapToCurve(scalars) {
            if (!Array.isArray(scalars))
                throw new Error('mapToCurve: expected array of bigints');
            for (const i of scalars)
                if (typeof i !== 'bigint')
                    throw new Error(`mapToCurve: expected array of bigints, got ${i} in array`);
            const P = Point.fromAffine(mapToCurve(scalars)).clearCofactor();
            P.assertValidity();
            return P;
        },
    };
}
//# sourceMappingURL=hash-to-curve.js.map

/***/ }),

/***/ 4967:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isNegativeLE = void 0;
exports.mod = mod;
exports.pow = pow;
exports.pow2 = pow2;
exports.invert = invert;
exports.tonelliShanks = tonelliShanks;
exports.FpSqrt = FpSqrt;
exports.validateField = validateField;
exports.FpPow = FpPow;
exports.FpInvertBatch = FpInvertBatch;
exports.FpDiv = FpDiv;
exports.FpLegendre = FpLegendre;
exports.FpIsSquare = FpIsSquare;
exports.nLength = nLength;
exports.Field = Field;
exports.FpSqrtOdd = FpSqrtOdd;
exports.FpSqrtEven = FpSqrtEven;
exports.hashToPrivateScalar = hashToPrivateScalar;
exports.getFieldBytesLength = getFieldBytesLength;
exports.getMinHashLength = getMinHashLength;
exports.mapHashToField = mapHashToField;
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
// Utilities for modular arithmetics and finite fields
const utils_js_1 = __webpack_require__(1484);
// prettier-ignore
const _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3);
// prettier-ignore
const _4n = BigInt(4), _5n = BigInt(5), _8n = BigInt(8);
// prettier-ignore
const _9n = BigInt(9), _16n = BigInt(16);
// Calculates a modulo b
function mod(a, b) {
    const result = a % b;
    return result >= _0n ? result : b + result;
}
/**
 * Efficiently raise num to power and do modular division.
 * Unsafe in some contexts: uses ladder, so can expose bigint bits.
 * @example
 * pow(2n, 6n, 11n) // 64n % 11n == 9n
 */
// TODO: use field version && remove
function pow(num, power, modulo) {
    if (modulo <= _0n || power < _0n)
        throw new Error('Expected power/modulo > 0');
    if (modulo === _1n)
        return _0n;
    let res = _1n;
    while (power > _0n) {
        if (power & _1n)
            res = (res * num) % modulo;
        num = (num * num) % modulo;
        power >>= _1n;
    }
    return res;
}
// Does x ^ (2 ^ power) mod p. pow2(30, 4) == 30 ^ (2 ^ 4)
function pow2(x, power, modulo) {
    let res = x;
    while (power-- > _0n) {
        res *= res;
        res %= modulo;
    }
    return res;
}
// Inverses number over modulo
function invert(number, modulo) {
    if (number === _0n || modulo <= _0n) {
        throw new Error(`invert: expected positive integers, got n=${number} mod=${modulo}`);
    }
    // Euclidean GCD https://brilliant.org/wiki/extended-euclidean-algorithm/
    // Fermat's little theorem "CT-like" version inv(n) = n^(m-2) mod m is 30x slower.
    let a = mod(number, modulo);
    let b = modulo;
    // prettier-ignore
    let x = _0n, y = _1n, u = _1n, v = _0n;
    while (a !== _0n) {
        // JIT applies optimization if those two lines follow each other
        const q = b / a;
        const r = b % a;
        const m = x - u * q;
        const n = y - v * q;
        // prettier-ignore
        b = a, a = r, x = u, y = v, u = m, v = n;
    }
    const gcd = b;
    if (gcd !== _1n)
        throw new Error('invert: does not exist');
    return mod(x, modulo);
}
/**
 * Tonelli-Shanks square root search algorithm.
 * 1. https://eprint.iacr.org/2012/685.pdf (page 12)
 * 2. Square Roots from 1; 24, 51, 10 to Dan Shanks
 * Will start an infinite loop if field order P is not prime.
 * @param P field order
 * @returns function that takes field Fp (created from P) and number n
 */
function tonelliShanks(P) {
    // Legendre constant: used to calculate Legendre symbol (a | p),
    // which denotes the value of a^((p-1)/2) (mod p).
    // (a | p) ‚â° 1    if a is a square (mod p)
    // (a | p) ‚â° -1   if a is not a square (mod p)
    // (a | p) ‚â° 0    if a ‚â° 0 (mod p)
    const legendreC = (P - _1n) / _2n;
    let Q, S, Z;
    // Step 1: By factoring out powers of 2 from p - 1,
    // find q and s such that p - 1 = q*(2^s) with q odd
    for (Q = P - _1n, S = 0; Q % _2n === _0n; Q /= _2n, S++)
        ;
    // Step 2: Select a non-square z such that (z | p) ‚â° -1 and set c ‚â° zq
    for (Z = _2n; Z < P && pow(Z, legendreC, P) !== P - _1n; Z++)
        ;
    // Fast-path
    if (S === 1) {
        const p1div4 = (P + _1n) / _4n;
        return function tonelliFast(Fp, n) {
            const root = Fp.pow(n, p1div4);
            if (!Fp.eql(Fp.sqr(root), n))
                throw new Error('Cannot find square root');
            return root;
        };
    }
    // Slow-path
    const Q1div2 = (Q + _1n) / _2n;
    return function tonelliSlow(Fp, n) {
        // Step 0: Check that n is indeed a square: (n | p) should not be ‚â° -1
        if (Fp.pow(n, legendreC) === Fp.neg(Fp.ONE))
            throw new Error('Cannot find square root');
        let r = S;
        // TODO: will fail at Fp2/etc
        let g = Fp.pow(Fp.mul(Fp.ONE, Z), Q); // will update both x and b
        let x = Fp.pow(n, Q1div2); // first guess at the square root
        let b = Fp.pow(n, Q); // first guess at the fudge factor
        while (!Fp.eql(b, Fp.ONE)) {
            if (Fp.eql(b, Fp.ZERO))
                return Fp.ZERO; // https://en.wikipedia.org/wiki/Tonelli%E2%80%93Shanks_algorithm (4. If t = 0, return r = 0)
            // Find m such b^(2^m)==1
            let m = 1;
            for (let t2 = Fp.sqr(b); m < r; m++) {
                if (Fp.eql(t2, Fp.ONE))
                    break;
                t2 = Fp.sqr(t2); // t2 *= t2
            }
            // NOTE: r-m-1 can be bigger than 32, need to convert to bigint before shift, otherwise there will be overflow
            const ge = Fp.pow(g, _1n << BigInt(r - m - 1)); // ge = 2^(r-m-1)
            g = Fp.sqr(ge); // g = ge * ge
            x = Fp.mul(x, ge); // x *= ge
            b = Fp.mul(b, g); // b *= g
            r = m;
        }
        return x;
    };
}
function FpSqrt(P) {
    // NOTE: different algorithms can give different roots, it is up to user to decide which one they want.
    // For example there is FpSqrtOdd/FpSqrtEven to choice root based on oddness (used for hash-to-curve).
    // P ‚â° 3 (mod 4)
    // ‚àön = n^((P+1)/4)
    if (P % _4n === _3n) {
        // Not all roots possible!
        // const ORDER =
        //   0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaabn;
        // const NUM = 72057594037927816n;
        const p1div4 = (P + _1n) / _4n;
        return function sqrt3mod4(Fp, n) {
            const root = Fp.pow(n, p1div4);
            // Throw if root**2 != n
            if (!Fp.eql(Fp.sqr(root), n))
                throw new Error('Cannot find square root');
            return root;
        };
    }
    // Atkin algorithm for q ‚â° 5 (mod 8), https://eprint.iacr.org/2012/685.pdf (page 10)
    if (P % _8n === _5n) {
        const c1 = (P - _5n) / _8n;
        return function sqrt5mod8(Fp, n) {
            const n2 = Fp.mul(n, _2n);
            const v = Fp.pow(n2, c1);
            const nv = Fp.mul(n, v);
            const i = Fp.mul(Fp.mul(nv, _2n), v);
            const root = Fp.mul(nv, Fp.sub(i, Fp.ONE));
            if (!Fp.eql(Fp.sqr(root), n))
                throw new Error('Cannot find square root');
            return root;
        };
    }
    // P ‚â° 9 (mod 16)
    if (P % _16n === _9n) {
        // NOTE: tonelli is too slow for bls-Fp2 calculations even on start
        // Means we cannot use sqrt for constants at all!
        //
        // const c1 = Fp.sqrt(Fp.negate(Fp.ONE)); //  1. c1 = sqrt(-1) in F, i.e., (c1^2) == -1 in F
        // const c2 = Fp.sqrt(c1);                //  2. c2 = sqrt(c1) in F, i.e., (c2^2) == c1 in F
        // const c3 = Fp.sqrt(Fp.negate(c1));     //  3. c3 = sqrt(-c1) in F, i.e., (c3^2) == -c1 in F
        // const c4 = (P + _7n) / _16n;           //  4. c4 = (q + 7) / 16        # Integer arithmetic
        // sqrt = (x) => {
        //   let tv1 = Fp.pow(x, c4);             //  1. tv1 = x^c4
        //   let tv2 = Fp.mul(c1, tv1);           //  2. tv2 = c1 * tv1
        //   const tv3 = Fp.mul(c2, tv1);         //  3. tv3 = c2 * tv1
        //   let tv4 = Fp.mul(c3, tv1);           //  4. tv4 = c3 * tv1
        //   const e1 = Fp.equals(Fp.square(tv2), x); //  5.  e1 = (tv2^2) == x
        //   const e2 = Fp.equals(Fp.square(tv3), x); //  6.  e2 = (tv3^2) == x
        //   tv1 = Fp.cmov(tv1, tv2, e1); //  7. tv1 = CMOV(tv1, tv2, e1)  # Select tv2 if (tv2^2) == x
        //   tv2 = Fp.cmov(tv4, tv3, e2); //  8. tv2 = CMOV(tv4, tv3, e2)  # Select tv3 if (tv3^2) == x
        //   const e3 = Fp.equals(Fp.square(tv2), x); //  9.  e3 = (tv2^2) == x
        //   return Fp.cmov(tv1, tv2, e3); //  10.  z = CMOV(tv1, tv2, e3)  # Select the sqrt from tv1 and tv2
        // }
    }
    // Other cases: Tonelli-Shanks algorithm
    return tonelliShanks(P);
}
// Little-endian check for first LE bit (last BE bit);
const isNegativeLE = (num, modulo) => (mod(num, modulo) & _1n) === _1n;
exports.isNegativeLE = isNegativeLE;
// prettier-ignore
const FIELD_FIELDS = [
    'create', 'isValid', 'is0', 'neg', 'inv', 'sqrt', 'sqr',
    'eql', 'add', 'sub', 'mul', 'pow', 'div',
    'addN', 'subN', 'mulN', 'sqrN'
];
function validateField(field) {
    const initial = {
        ORDER: 'bigint',
        MASK: 'bigint',
        BYTES: 'isSafeInteger',
        BITS: 'isSafeInteger',
    };
    const opts = FIELD_FIELDS.reduce((map, val) => {
        map[val] = 'function';
        return map;
    }, initial);
    return (0, utils_js_1.validateObject)(field, opts);
}
// Generic field functions
/**
 * Same as `pow` but for Fp: non-constant-time.
 * Unsafe in some contexts: uses ladder, so can expose bigint bits.
 */
function FpPow(f, num, power) {
    // Should have same speed as pow for bigints
    // TODO: benchmark!
    if (power < _0n)
        throw new Error('Expected power > 0');
    if (power === _0n)
        return f.ONE;
    if (power === _1n)
        return num;
    let p = f.ONE;
    let d = num;
    while (power > _0n) {
        if (power & _1n)
            p = f.mul(p, d);
        d = f.sqr(d);
        power >>= _1n;
    }
    return p;
}
/**
 * Efficiently invert an array of Field elements.
 * `inv(0)` will return `undefined` here: make sure to throw an error.
 */
function FpInvertBatch(f, nums) {
    const tmp = new Array(nums.length);
    // Walk from first to last, multiply them by each other MOD p
    const lastMultiplied = nums.reduce((acc, num, i) => {
        if (f.is0(num))
            return acc;
        tmp[i] = acc;
        return f.mul(acc, num);
    }, f.ONE);
    // Invert last element
    const inverted = f.inv(lastMultiplied);
    // Walk from last to first, multiply them by inverted each other MOD p
    nums.reduceRight((acc, num, i) => {
        if (f.is0(num))
            return acc;
        tmp[i] = f.mul(acc, tmp[i]);
        return f.mul(acc, num);
    }, inverted);
    return tmp;
}
function FpDiv(f, lhs, rhs) {
    return f.mul(lhs, typeof rhs === 'bigint' ? invert(rhs, f.ORDER) : f.inv(rhs));
}
function FpLegendre(order) {
    // (a | p) ‚â° 1    if a is a square (mod p), quadratic residue
    // (a | p) ‚â° -1   if a is not a square (mod p), quadratic non residue
    // (a | p) ‚â° 0    if a ‚â° 0 (mod p)
    const legendreConst = (order - _1n) / _2n; // Integer arithmetic
    return (f, x) => f.pow(x, legendreConst);
}
// This function returns True whenever the value x is a square in the field F.
function FpIsSquare(f) {
    const legendre = FpLegendre(f.ORDER);
    return (x) => {
        const p = legendre(f, x);
        return f.eql(p, f.ZERO) || f.eql(p, f.ONE);
    };
}
// CURVE.n lengths
function nLength(n, nBitLength) {
    // Bit size, byte size of CURVE.n
    const _nBitLength = nBitLength !== undefined ? nBitLength : n.toString(2).length;
    const nByteLength = Math.ceil(_nBitLength / 8);
    return { nBitLength: _nBitLength, nByteLength };
}
/**
 * Initializes a finite field over prime. **Non-primes are not supported.**
 * Do not init in loop: slow. Very fragile: always run a benchmark on a change.
 * Major performance optimizations:
 * * a) denormalized operations like mulN instead of mul
 * * b) same object shape: never add or remove keys
 * * c) Object.freeze
 * NOTE: operations don't check 'isValid' for all elements for performance reasons,
 * it is caller responsibility to check this.
 * This is low-level code, please make sure you know what you doing.
 * @param ORDER prime positive bigint
 * @param bitLen how many bits the field consumes
 * @param isLE (def: false) if encoding / decoding should be in little-endian
 * @param redef optional faster redefinitions of sqrt and other methods
 */
function Field(ORDER, bitLen, isLE = false, redef = {}) {
    if (ORDER <= _0n)
        throw new Error(`Expected Field ORDER > 0, got ${ORDER}`);
    const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, bitLen);
    if (BYTES > 2048)
        throw new Error('Field lengths over 2048 bytes are not supported');
    const sqrtP = FpSqrt(ORDER);
    const f = Object.freeze({
        ORDER,
        BITS,
        BYTES,
        MASK: (0, utils_js_1.bitMask)(BITS),
        ZERO: _0n,
        ONE: _1n,
        create: (num) => mod(num, ORDER),
        isValid: (num) => {
            if (typeof num !== 'bigint')
                throw new Error(`Invalid field element: expected bigint, got ${typeof num}`);
            return _0n <= num && num < ORDER; // 0 is valid element, but it's not invertible
        },
        is0: (num) => num === _0n,
        isOdd: (num) => (num & _1n) === _1n,
        neg: (num) => mod(-num, ORDER),
        eql: (lhs, rhs) => lhs === rhs,
        sqr: (num) => mod(num * num, ORDER),
        add: (lhs, rhs) => mod(lhs + rhs, ORDER),
        sub: (lhs, rhs) => mod(lhs - rhs, ORDER),
        mul: (lhs, rhs) => mod(lhs * rhs, ORDER),
        pow: (num, power) => FpPow(f, num, power),
        div: (lhs, rhs) => mod(lhs * invert(rhs, ORDER), ORDER),
        // Same as above, but doesn't normalize
        sqrN: (num) => num * num,
        addN: (lhs, rhs) => lhs + rhs,
        subN: (lhs, rhs) => lhs - rhs,
        mulN: (lhs, rhs) => lhs * rhs,
        inv: (num) => invert(num, ORDER),
        sqrt: redef.sqrt || ((n) => sqrtP(f, n)),
        invertBatch: (lst) => FpInvertBatch(f, lst),
        // TODO: do we really need constant cmov?
        // We don't have const-time bigints anyway, so probably will be not very useful
        cmov: (a, b, c) => (c ? b : a),
        toBytes: (num) => (isLE ? (0, utils_js_1.numberToBytesLE)(num, BYTES) : (0, utils_js_1.numberToBytesBE)(num, BYTES)),
        fromBytes: (bytes) => {
            if (bytes.length !== BYTES)
                throw new Error(`Fp.fromBytes: expected ${BYTES}, got ${bytes.length}`);
            return isLE ? (0, utils_js_1.bytesToNumberLE)(bytes) : (0, utils_js_1.bytesToNumberBE)(bytes);
        },
    });
    return Object.freeze(f);
}
function FpSqrtOdd(Fp, elm) {
    if (!Fp.isOdd)
        throw new Error(`Field doesn't have isOdd`);
    const root = Fp.sqrt(elm);
    return Fp.isOdd(root) ? root : Fp.neg(root);
}
function FpSqrtEven(Fp, elm) {
    if (!Fp.isOdd)
        throw new Error(`Field doesn't have isOdd`);
    const root = Fp.sqrt(elm);
    return Fp.isOdd(root) ? Fp.neg(root) : root;
}
/**
 * "Constant-time" private key generation utility.
 * Same as mapKeyToField, but accepts less bytes (40 instead of 48 for 32-byte field).
 * Which makes it slightly more biased, less secure.
 * @deprecated use mapKeyToField instead
 */
function hashToPrivateScalar(hash, groupOrder, isLE = false) {
    hash = (0, utils_js_1.ensureBytes)('privateHash', hash);
    const hashLen = hash.length;
    const minLen = nLength(groupOrder).nByteLength + 8;
    if (minLen < 24 || hashLen < minLen || hashLen > 1024)
        throw new Error(`hashToPrivateScalar: expected ${minLen}-1024 bytes of input, got ${hashLen}`);
    const num = isLE ? (0, utils_js_1.bytesToNumberLE)(hash) : (0, utils_js_1.bytesToNumberBE)(hash);
    return mod(num, groupOrder - _1n) + _1n;
}
/**
 * Returns total number of bytes consumed by the field element.
 * For example, 32 bytes for usual 256-bit weierstrass curve.
 * @param fieldOrder number of field elements, usually CURVE.n
 * @returns byte length of field
 */
function getFieldBytesLength(fieldOrder) {
    if (typeof fieldOrder !== 'bigint')
        throw new Error('field order must be bigint');
    const bitLength = fieldOrder.toString(2).length;
    return Math.ceil(bitLength / 8);
}
/**
 * Returns minimal amount of bytes that can be safely reduced
 * by field order.
 * Should be 2^-128 for 128-bit curve such as P256.
 * @param fieldOrder number of field elements, usually CURVE.n
 * @returns byte length of target hash
 */
function getMinHashLength(fieldOrder) {
    const length = getFieldBytesLength(fieldOrder);
    return length + Math.ceil(length / 2);
}
/**
 * "Constant-time" private key generation utility.
 * Can take (n + n/2) or more bytes of uniform input e.g. from CSPRNG or KDF
 * and convert them into private scalar, with the modulo bias being negligible.
 * Needs at least 48 bytes of input for 32-byte private key.
 * https://research.kudelskisecurity.com/2020/07/28/the-definitive-guide-to-modulo-bias-and-how-to-avoid-it/
 * FIPS 186-5, A.2 https://csrc.nist.gov/publications/detail/fips/186/5/final
 * RFC 9380, https://www.rfc-editor.org/rfc/rfc9380#section-5
 * @param hash hash output from SHA3 or a similar function
 * @param groupOrder size of subgroup - (e.g. secp256k1.CURVE.n)
 * @param isLE interpret hash bytes as LE num
 * @returns valid private scalar
 */
function mapHashToField(key, fieldOrder, isLE = false) {
    const len = key.length;
    const fieldLen = getFieldBytesLength(fieldOrder);
    const minLen = getMinHashLength(fieldOrder);
    // No small numbers: need to understand bias story. No huge numbers: easier to detect JS timings.
    if (len < 16 || len < minLen || len > 1024)
        throw new Error(`expected ${minLen}-1024 bytes of input, got ${len}`);
    const num = isLE ? (0, utils_js_1.bytesToNumberBE)(key) : (0, utils_js_1.bytesToNumberLE)(key);
    // `mod(x, 11)` can sometimes produce 0. `mod(x, 10) + 1` is the same, but no 0
    const reduced = mod(num, fieldOrder - _1n) + _1n;
    return isLE ? (0, utils_js_1.numberToBytesLE)(reduced, fieldLen) : (0, utils_js_1.numberToBytesBE)(reduced, fieldLen);
}
//# sourceMappingURL=modular.js.map

/***/ }),

/***/ 2854:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.montgomery = montgomery;
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const modular_js_1 = __webpack_require__(4967);
const utils_js_1 = __webpack_require__(1484);
const _0n = BigInt(0);
const _1n = BigInt(1);
function validateOpts(curve) {
    (0, utils_js_1.validateObject)(curve, {
        a: 'bigint',
    }, {
        montgomeryBits: 'isSafeInteger',
        nByteLength: 'isSafeInteger',
        adjustScalarBytes: 'function',
        domain: 'function',
        powPminus2: 'function',
        Gu: 'bigint',
    });
    // Set defaults
    return Object.freeze({ ...curve });
}
// NOTE: not really montgomery curve, just bunch of very specific methods for X25519/X448 (RFC 7748, https://www.rfc-editor.org/rfc/rfc7748)
// Uses only one coordinate instead of two
function montgomery(curveDef) {
    const CURVE = validateOpts(curveDef);
    const { P } = CURVE;
    const modP = (n) => (0, modular_js_1.mod)(n, P);
    const montgomeryBits = CURVE.montgomeryBits;
    const montgomeryBytes = Math.ceil(montgomeryBits / 8);
    const fieldLen = CURVE.nByteLength;
    const adjustScalarBytes = CURVE.adjustScalarBytes || ((bytes) => bytes);
    const powPminus2 = CURVE.powPminus2 || ((x) => (0, modular_js_1.pow)(x, P - BigInt(2), P));
    // cswap from RFC7748. But it is not from RFC7748!
    /*
      cswap(swap, x_2, x_3):
           dummy = mask(swap) AND (x_2 XOR x_3)
           x_2 = x_2 XOR dummy
           x_3 = x_3 XOR dummy
           Return (x_2, x_3)
    Where mask(swap) is the all-1 or all-0 word of the same length as x_2
     and x_3, computed, e.g., as mask(swap) = 0 - swap.
    */
    function cswap(swap, x_2, x_3) {
        const dummy = modP(swap * (x_2 - x_3));
        x_2 = modP(x_2 - dummy);
        x_3 = modP(x_3 + dummy);
        return [x_2, x_3];
    }
    // x25519 from 4
    // The constant a24 is (486662 - 2) / 4 = 121665 for curve25519/X25519
    const a24 = (CURVE.a - BigInt(2)) / BigInt(4);
    /**
     *
     * @param pointU u coordinate (x) on Montgomery Curve 25519
     * @param scalar by which the point would be multiplied
     * @returns new Point on Montgomery curve
     */
    function montgomeryLadder(u, scalar) {
        (0, utils_js_1.aInRange)('u', u, _0n, P);
        (0, utils_js_1.aInRange)('scalar', scalar, _0n, P);
        // Section 5: Implementations MUST accept non-canonical values and process them as
        // if they had been reduced modulo the field prime.
        const k = scalar;
        const x_1 = u;
        let x_2 = _1n;
        let z_2 = _0n;
        let x_3 = u;
        let z_3 = _1n;
        let swap = _0n;
        let sw;
        for (let t = BigInt(montgomeryBits - 1); t >= _0n; t--) {
            const k_t = (k >> t) & _1n;
            swap ^= k_t;
            sw = cswap(swap, x_2, x_3);
            x_2 = sw[0];
            x_3 = sw[1];
            sw = cswap(swap, z_2, z_3);
            z_2 = sw[0];
            z_3 = sw[1];
            swap = k_t;
            const A = x_2 + z_2;
            const AA = modP(A * A);
            const B = x_2 - z_2;
            const BB = modP(B * B);
            const E = AA - BB;
            const C = x_3 + z_3;
            const D = x_3 - z_3;
            const DA = modP(D * A);
            const CB = modP(C * B);
            const dacb = DA + CB;
            const da_cb = DA - CB;
            x_3 = modP(dacb * dacb);
            z_3 = modP(x_1 * modP(da_cb * da_cb));
            x_2 = modP(AA * BB);
            z_2 = modP(E * (AA + modP(a24 * E)));
        }
        // (x_2, x_3) = cswap(swap, x_2, x_3)
        sw = cswap(swap, x_2, x_3);
        x_2 = sw[0];
        x_3 = sw[1];
        // (z_2, z_3) = cswap(swap, z_2, z_3)
        sw = cswap(swap, z_2, z_3);
        z_2 = sw[0];
        z_3 = sw[1];
        // z_2^(p - 2)
        const z2 = powPminus2(z_2);
        // Return x_2 * (z_2^(p - 2))
        return modP(x_2 * z2);
    }
    function encodeUCoordinate(u) {
        return (0, utils_js_1.numberToBytesLE)(modP(u), montgomeryBytes);
    }
    function decodeUCoordinate(uEnc) {
        // Section 5: When receiving such an array, implementations of X25519
        // MUST mask the most significant bit in the final byte.
        const u = (0, utils_js_1.ensureBytes)('u coordinate', uEnc, montgomeryBytes);
        if (fieldLen === 32)
            u[31] &= 127; // 0b0111_1111
        return (0, utils_js_1.bytesToNumberLE)(u);
    }
    function decodeScalar(n) {
        const bytes = (0, utils_js_1.ensureBytes)('scalar', n);
        const len = bytes.length;
        if (len !== montgomeryBytes && len !== fieldLen)
            throw new Error(`Expected ${montgomeryBytes} or ${fieldLen} bytes, got ${len}`);
        return (0, utils_js_1.bytesToNumberLE)(adjustScalarBytes(bytes));
    }
    function scalarMult(scalar, u) {
        const pointU = decodeUCoordinate(u);
        const _scalar = decodeScalar(scalar);
        const pu = montgomeryLadder(pointU, _scalar);
        // The result was not contributory
        // https://cr.yp.to/ecdh.html#validate
        if (pu === _0n)
            throw new Error('Invalid private or public key received');
        return encodeUCoordinate(pu);
    }
    // Computes public key from private. By doing scalar multiplication of base point.
    const GuBytes = encodeUCoordinate(CURVE.Gu);
    function scalarMultBase(scalar) {
        return scalarMult(scalar, GuBytes);
    }
    return {
        scalarMult,
        scalarMultBase,
        getSharedSecret: (privateKey, publicKey) => scalarMult(privateKey, publicKey),
        getPublicKey: (privateKey) => scalarMultBase(privateKey),
        utils: { randomPrivateKey: () => CURVE.randomBytes(CURVE.nByteLength) },
        GuBytes: GuBytes,
    };
}
//# sourceMappingURL=montgomery.js.map

/***/ }),

/***/ 1484:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.notImplemented = exports.bitMask = void 0;
exports.isBytes = isBytes;
exports.abytes = abytes;
exports.abool = abool;
exports.bytesToHex = bytesToHex;
exports.numberToHexUnpadded = numberToHexUnpadded;
exports.hexToNumber = hexToNumber;
exports.hexToBytes = hexToBytes;
exports.bytesToNumberBE = bytesToNumberBE;
exports.bytesToNumberLE = bytesToNumberLE;
exports.numberToBytesBE = numberToBytesBE;
exports.numberToBytesLE = numberToBytesLE;
exports.numberToVarBytesBE = numberToVarBytesBE;
exports.ensureBytes = ensureBytes;
exports.concatBytes = concatBytes;
exports.equalBytes = equalBytes;
exports.utf8ToBytes = utf8ToBytes;
exports.inRange = inRange;
exports.aInRange = aInRange;
exports.bitLen = bitLen;
exports.bitGet = bitGet;
exports.bitSet = bitSet;
exports.createHmacDrbg = createHmacDrbg;
exports.validateObject = validateObject;
exports.memoized = memoized;
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
// 100 lines of code in the file are duplicated from noble-hashes (utils).
// This is OK: `abstract` directory does not use noble-hashes.
// User may opt-in into using different hashing library. This way, noble-hashes
// won't be included into their bundle.
const _0n = /* @__PURE__ */ BigInt(0);
const _1n = /* @__PURE__ */ BigInt(1);
const _2n = /* @__PURE__ */ BigInt(2);
function isBytes(a) {
    return (a instanceof Uint8Array ||
        (a != null && typeof a === 'object' && a.constructor.name === 'Uint8Array'));
}
function abytes(item) {
    if (!isBytes(item))
        throw new Error('Uint8Array expected');
}
function abool(title, value) {
    if (typeof value !== 'boolean')
        throw new Error(`${title} must be valid boolean, got "${value}".`);
}
// Array where index 0xf0 (240) is mapped to string 'f0'
const hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, '0'));
/**
 * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'
 */
function bytesToHex(bytes) {
    abytes(bytes);
    // pre-caching improves the speed 6x
    let hex = '';
    for (let i = 0; i < bytes.length; i++) {
        hex += hexes[bytes[i]];
    }
    return hex;
}
function numberToHexUnpadded(num) {
    const hex = num.toString(16);
    return hex.length & 1 ? `0${hex}` : hex;
}
function hexToNumber(hex) {
    if (typeof hex !== 'string')
        throw new Error('hex string expected, got ' + typeof hex);
    // Big Endian
    return BigInt(hex === '' ? '0' : `0x${hex}`);
}
// We use optimized technique to convert hex string to byte array
const asciis = { _0: 48, _9: 57, _A: 65, _F: 70, _a: 97, _f: 102 };
function asciiToBase16(char) {
    if (char >= asciis._0 && char <= asciis._9)
        return char - asciis._0;
    if (char >= asciis._A && char <= asciis._F)
        return char - (asciis._A - 10);
    if (char >= asciis._a && char <= asciis._f)
        return char - (asciis._a - 10);
    return;
}
/**
 * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])
 */
function hexToBytes(hex) {
    if (typeof hex !== 'string')
        throw new Error('hex string expected, got ' + typeof hex);
    const hl = hex.length;
    const al = hl / 2;
    if (hl % 2)
        throw new Error('padded hex string expected, got unpadded hex of length ' + hl);
    const array = new Uint8Array(al);
    for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {
        const n1 = asciiToBase16(hex.charCodeAt(hi));
        const n2 = asciiToBase16(hex.charCodeAt(hi + 1));
        if (n1 === undefined || n2 === undefined) {
            const char = hex[hi] + hex[hi + 1];
            throw new Error('hex string expected, got non-hex character "' + char + '" at index ' + hi);
        }
        array[ai] = n1 * 16 + n2;
    }
    return array;
}
// BE: Big Endian, LE: Little Endian
function bytesToNumberBE(bytes) {
    return hexToNumber(bytesToHex(bytes));
}
function bytesToNumberLE(bytes) {
    abytes(bytes);
    return hexToNumber(bytesToHex(Uint8Array.from(bytes).reverse()));
}
function numberToBytesBE(n, len) {
    return hexToBytes(n.toString(16).padStart(len * 2, '0'));
}
function numberToBytesLE(n, len) {
    return numberToBytesBE(n, len).reverse();
}
// Unpadded, rarely used
function numberToVarBytesBE(n) {
    return hexToBytes(numberToHexUnpadded(n));
}
/**
 * Takes hex string or Uint8Array, converts to Uint8Array.
 * Validates output length.
 * Will throw error for other types.
 * @param title descriptive title for an error e.g. 'private key'
 * @param hex hex string or Uint8Array
 * @param expectedLength optional, will compare to result array's length
 * @returns
 */
function ensureBytes(title, hex, expectedLength) {
    let res;
    if (typeof hex === 'string') {
        try {
            res = hexToBytes(hex);
        }
        catch (e) {
            throw new Error(`${title} must be valid hex string, got "${hex}". Cause: ${e}`);
        }
    }
    else if (isBytes(hex)) {
        // Uint8Array.from() instead of hash.slice() because node.js Buffer
        // is instance of Uint8Array, and its slice() creates **mutable** copy
        res = Uint8Array.from(hex);
    }
    else {
        throw new Error(`${title} must be hex string or Uint8Array`);
    }
    const len = res.length;
    if (typeof expectedLength === 'number' && len !== expectedLength)
        throw new Error(`${title} expected ${expectedLength} bytes, got ${len}`);
    return res;
}
/**
 * Copies several Uint8Arrays into one.
 */
function concatBytes(...arrays) {
    let sum = 0;
    for (let i = 0; i < arrays.length; i++) {
        const a = arrays[i];
        abytes(a);
        sum += a.length;
    }
    const res = new Uint8Array(sum);
    for (let i = 0, pad = 0; i < arrays.length; i++) {
        const a = arrays[i];
        res.set(a, pad);
        pad += a.length;
    }
    return res;
}
// Compares 2 u8a-s in kinda constant time
function equalBytes(a, b) {
    if (a.length !== b.length)
        return false;
    let diff = 0;
    for (let i = 0; i < a.length; i++)
        diff |= a[i] ^ b[i];
    return diff === 0;
}
/**
 * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])
 */
function utf8ToBytes(str) {
    if (typeof str !== 'string')
        throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809
}
// Is positive bigint
const isPosBig = (n) => typeof n === 'bigint' && _0n <= n;
function inRange(n, min, max) {
    return isPosBig(n) && isPosBig(min) && isPosBig(max) && min <= n && n < max;
}
/**
 * Asserts min <= n < max. NOTE: It's < max and not <= max.
 * @example
 * aInRange('x', x, 1n, 256n); // would assume x is in (1n..255n)
 */
function aInRange(title, n, min, max) {
    // Why min <= n < max and not a (min < n < max) OR b (min <= n <= max)?
    // consider P=256n, min=0n, max=P
    // - a for min=0 would require -1:          `inRange('x', x, -1n, P)`
    // - b would commonly require subtraction:  `inRange('x', x, 0n, P - 1n)`
    // - our way is the cleanest:               `inRange('x', x, 0n, P)
    if (!inRange(n, min, max))
        throw new Error(`expected valid ${title}: ${min} <= n < ${max}, got ${typeof n} ${n}`);
}
// Bit operations
/**
 * Calculates amount of bits in a bigint.
 * Same as `n.toString(2).length`
 */
function bitLen(n) {
    let len;
    for (len = 0; n > _0n; n >>= _1n, len += 1)
        ;
    return len;
}
/**
 * Gets single bit at position.
 * NOTE: first bit position is 0 (same as arrays)
 * Same as `!!+Array.from(n.toString(2)).reverse()[pos]`
 */
function bitGet(n, pos) {
    return (n >> BigInt(pos)) & _1n;
}
/**
 * Sets single bit at position.
 */
function bitSet(n, pos, value) {
    return n | ((value ? _1n : _0n) << BigInt(pos));
}
/**
 * Calculate mask for N bits. Not using ** operator with bigints because of old engines.
 * Same as BigInt(`0b${Array(i).fill('1').join('')}`)
 */
const bitMask = (n) => (_2n << BigInt(n - 1)) - _1n;
exports.bitMask = bitMask;
// DRBG
const u8n = (data) => new Uint8Array(data); // creates Uint8Array
const u8fr = (arr) => Uint8Array.from(arr); // another shortcut
/**
 * Minimal HMAC-DRBG from NIST 800-90 for RFC6979 sigs.
 * @returns function that will call DRBG until 2nd arg returns something meaningful
 * @example
 *   const drbg = createHmacDRBG<Key>(32, 32, hmac);
 *   drbg(seed, bytesToKey); // bytesToKey must return Key or undefined
 */
function createHmacDrbg(hashLen, qByteLen, hmacFn) {
    if (typeof hashLen !== 'number' || hashLen < 2)
        throw new Error('hashLen must be a number');
    if (typeof qByteLen !== 'number' || qByteLen < 2)
        throw new Error('qByteLen must be a number');
    if (typeof hmacFn !== 'function')
        throw new Error('hmacFn must be a function');
    // Step B, Step C: set hashLen to 8*ceil(hlen/8)
    let v = u8n(hashLen); // Minimal non-full-spec HMAC-DRBG from NIST 800-90 for RFC6979 sigs.
    let k = u8n(hashLen); // Steps B and C of RFC6979 3.2: set hashLen, in our case always same
    let i = 0; // Iterations counter, will throw when over 1000
    const reset = () => {
        v.fill(1);
        k.fill(0);
        i = 0;
    };
    const h = (...b) => hmacFn(k, v, ...b); // hmac(k)(v, ...values)
    const reseed = (seed = u8n()) => {
        // HMAC-DRBG reseed() function. Steps D-G
        k = h(u8fr([0x00]), seed); // k = hmac(k || v || 0x00 || seed)
        v = h(); // v = hmac(k || v)
        if (seed.length === 0)
            return;
        k = h(u8fr([0x01]), seed); // k = hmac(k || v || 0x01 || seed)
        v = h(); // v = hmac(k || v)
    };
    const gen = () => {
        // HMAC-DRBG generate() function
        if (i++ >= 1000)
            throw new Error('drbg: tried 1000 values');
        let len = 0;
        const out = [];
        while (len < qByteLen) {
            v = h();
            const sl = v.slice();
            out.push(sl);
            len += v.length;
        }
        return concatBytes(...out);
    };
    const genUntil = (seed, pred) => {
        reset();
        reseed(seed); // Steps D-G
        let res = undefined; // Step H: grind until k is in [1..n-1]
        while (!(res = pred(gen())))
            reseed();
        reset();
        return res;
    };
    return genUntil;
}
// Validating curves and fields
const validatorFns = {
    bigint: (val) => typeof val === 'bigint',
    function: (val) => typeof val === 'function',
    boolean: (val) => typeof val === 'boolean',
    string: (val) => typeof val === 'string',
    stringOrUint8Array: (val) => typeof val === 'string' || isBytes(val),
    isSafeInteger: (val) => Number.isSafeInteger(val),
    array: (val) => Array.isArray(val),
    field: (val, object) => object.Fp.isValid(val),
    hash: (val) => typeof val === 'function' && Number.isSafeInteger(val.outputLen),
};
// type Record<K extends string | number | symbol, T> = { [P in K]: T; }
function validateObject(object, validators, optValidators = {}) {
    const checkField = (fieldName, type, isOptional) => {
        const checkVal = validatorFns[type];
        if (typeof checkVal !== 'function')
            throw new Error(`Invalid validator "${type}", expected function`);
        const val = object[fieldName];
        if (isOptional && val === undefined)
            return;
        if (!checkVal(val, object)) {
            throw new Error(`Invalid param ${String(fieldName)}=${val} (${typeof val}), expected ${type}`);
        }
    };
    for (const [fieldName, type] of Object.entries(validators))
        checkField(fieldName, type, false);
    for (const [fieldName, type] of Object.entries(optValidators))
        checkField(fieldName, type, true);
    return object;
}
// validate type tests
// const o: { a: number; b: number; c: number } = { a: 1, b: 5, c: 6 };
// const z0 = validateObject(o, { a: 'isSafeInteger' }, { c: 'bigint' }); // Ok!
// // Should fail type-check
// const z1 = validateObject(o, { a: 'tmp' }, { c: 'zz' });
// const z2 = validateObject(o, { a: 'isSafeInteger' }, { c: 'zz' });
// const z3 = validateObject(o, { test: 'boolean', z: 'bug' });
// const z4 = validateObject(o, { a: 'boolean', z: 'bug' });
/**
 * throws not implemented error
 */
const notImplemented = () => {
    throw new Error('not implemented');
};
exports.notImplemented = notImplemented;
/**
 * Memoizes (caches) computation result.
 * Uses WeakMap: the value is going auto-cleaned by GC after last reference is removed.
 */
function memoized(fn) {
    const map = new WeakMap();
    return (arg, ...args) => {
        const val = map.get(arg);
        if (val !== undefined)
            return val;
        const computed = fn(arg, ...args);
        map.set(arg, computed);
        return computed;
    };
}
//# sourceMappingURL=utils.js.map

/***/ }),

/***/ 1705:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DER = void 0;
exports.weierstrassPoints = weierstrassPoints;
exports.weierstrass = weierstrass;
exports.SWUFpSqrtRatio = SWUFpSqrtRatio;
exports.mapToCurveSimpleSWU = mapToCurveSimpleSWU;
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
// Short Weierstrass curve. The formula is: y¬≤ = x¬≥ + ax + b
const curve_js_1 = __webpack_require__(2422);
const mod = __webpack_require__(4967);
const ut = __webpack_require__(1484);
const utils_js_1 = __webpack_require__(1484);
function validateSigVerOpts(opts) {
    if (opts.lowS !== undefined)
        (0, utils_js_1.abool)('lowS', opts.lowS);
    if (opts.prehash !== undefined)
        (0, utils_js_1.abool)('prehash', opts.prehash);
}
function validatePointOpts(curve) {
    const opts = (0, curve_js_1.validateBasic)(curve);
    ut.validateObject(opts, {
        a: 'field',
        b: 'field',
    }, {
        allowedPrivateKeyLengths: 'array',
        wrapPrivateKey: 'boolean',
        isTorsionFree: 'function',
        clearCofactor: 'function',
        allowInfinityPoint: 'boolean',
        fromBytes: 'function',
        toBytes: 'function',
    });
    const { endo, Fp, a } = opts;
    if (endo) {
        if (!Fp.eql(a, Fp.ZERO)) {
            throw new Error('Endomorphism can only be defined for Koblitz curves that have a=0');
        }
        if (typeof endo !== 'object' ||
            typeof endo.beta !== 'bigint' ||
            typeof endo.splitScalar !== 'function') {
            throw new Error('Expected endomorphism with beta: bigint and splitScalar: function');
        }
    }
    return Object.freeze({ ...opts });
}
const { bytesToNumberBE: b2n, hexToBytes: h2b } = ut;
/**
 * ASN.1 DER encoding utilities. ASN is very complex & fragile. Format:
 *
 *     [0x30 (SEQUENCE), bytelength, 0x02 (INTEGER), intLength, R, 0x02 (INTEGER), intLength, S]
 *
 * Docs: https://letsencrypt.org/docs/a-warm-welcome-to-asn1-and-der/, https://luca.ntop.org/Teaching/Appunti/asn1.html
 */
exports.DER = {
    // asn.1 DER encoding utils
    Err: class DERErr extends Error {
        constructor(m = '') {
            super(m);
        }
    },
    // Basic building block is TLV (Tag-Length-Value)
    _tlv: {
        encode: (tag, data) => {
            const { Err: E } = exports.DER;
            if (tag < 0 || tag > 256)
                throw new E('tlv.encode: wrong tag');
            if (data.length & 1)
                throw new E('tlv.encode: unpadded data');
            const dataLen = data.length / 2;
            const len = ut.numberToHexUnpadded(dataLen);
            if ((len.length / 2) & 128)
                throw new E('tlv.encode: long form length too big');
            // length of length with long form flag
            const lenLen = dataLen > 127 ? ut.numberToHexUnpadded((len.length / 2) | 128) : '';
            return `${ut.numberToHexUnpadded(tag)}${lenLen}${len}${data}`;
        },
        // v - value, l - left bytes (unparsed)
        decode(tag, data) {
            const { Err: E } = exports.DER;
            let pos = 0;
            if (tag < 0 || tag > 256)
                throw new E('tlv.encode: wrong tag');
            if (data.length < 2 || data[pos++] !== tag)
                throw new E('tlv.decode: wrong tlv');
            const first = data[pos++];
            const isLong = !!(first & 128); // First bit of first length byte is flag for short/long form
            let length = 0;
            if (!isLong)
                length = first;
            else {
                // Long form: [longFlag(1bit), lengthLength(7bit), length (BE)]
                const lenLen = first & 127;
                if (!lenLen)
                    throw new E('tlv.decode(long): indefinite length not supported');
                if (lenLen > 4)
                    throw new E('tlv.decode(long): byte length is too big'); // this will overflow u32 in js
                const lengthBytes = data.subarray(pos, pos + lenLen);
                if (lengthBytes.length !== lenLen)
                    throw new E('tlv.decode: length bytes not complete');
                if (lengthBytes[0] === 0)
                    throw new E('tlv.decode(long): zero leftmost byte');
                for (const b of lengthBytes)
                    length = (length << 8) | b;
                pos += lenLen;
                if (length < 128)
                    throw new E('tlv.decode(long): not minimal encoding');
            }
            const v = data.subarray(pos, pos + length);
            if (v.length !== length)
                throw new E('tlv.decode: wrong value length');
            return { v, l: data.subarray(pos + length) };
        },
    },
    // https://crypto.stackexchange.com/a/57734 Leftmost bit of first byte is 'negative' flag,
    // since we always use positive integers here. It must always be empty:
    // - add zero byte if exists
    // - if next byte doesn't have a flag, leading zero is not allowed (minimal encoding)
    _int: {
        encode(num) {
            const { Err: E } = exports.DER;
            if (num < _0n)
                throw new E('integer: negative integers are not allowed');
            let hex = ut.numberToHexUnpadded(num);
            // Pad with zero byte if negative flag is present
            if (Number.parseInt(hex[0], 16) & 0b1000)
                hex = '00' + hex;
            if (hex.length & 1)
                throw new E('unexpected assertion');
            return hex;
        },
        decode(data) {
            const { Err: E } = exports.DER;
            if (data[0] & 128)
                throw new E('Invalid signature integer: negative');
            if (data[0] === 0x00 && !(data[1] & 128))
                throw new E('Invalid signature integer: unnecessary leading zero');
            return b2n(data);
        },
    },
    toSig(hex) {
        // parse DER signature
        const { Err: E, _int: int, _tlv: tlv } = exports.DER;
        const data = typeof hex === 'string' ? h2b(hex) : hex;
        ut.abytes(data);
        const { v: seqBytes, l: seqLeftBytes } = tlv.decode(0x30, data);
        if (seqLeftBytes.length)
            throw new E('Invalid signature: left bytes after parsing');
        const { v: rBytes, l: rLeftBytes } = tlv.decode(0x02, seqBytes);
        const { v: sBytes, l: sLeftBytes } = tlv.decode(0x02, rLeftBytes);
        if (sLeftBytes.length)
            throw new E('Invalid signature: left bytes after parsing');
        return { r: int.decode(rBytes), s: int.decode(sBytes) };
    },
    hexFromSig(sig) {
        const { _tlv: tlv, _int: int } = exports.DER;
        const seq = `${tlv.encode(0x02, int.encode(sig.r))}${tlv.encode(0x02, int.encode(sig.s))}`;
        return tlv.encode(0x30, seq);
    },
};
// Be friendly to bad ECMAScript parsers by not using bigint literals
// prettier-ignore
const _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3), _4n = BigInt(4);
function weierstrassPoints(opts) {
    const CURVE = validatePointOpts(opts);
    const { Fp } = CURVE; // All curves has same field / group length as for now, but they can differ
    const Fn = mod.Field(CURVE.n, CURVE.nBitLength);
    const toBytes = CURVE.toBytes ||
        ((_c, point, _isCompressed) => {
            const a = point.toAffine();
            return ut.concatBytes(Uint8Array.from([0x04]), Fp.toBytes(a.x), Fp.toBytes(a.y));
        });
    const fromBytes = CURVE.fromBytes ||
        ((bytes) => {
            // const head = bytes[0];
            const tail = bytes.subarray(1);
            // if (head !== 0x04) throw new Error('Only non-compressed encoding is supported');
            const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));
            const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));
            return { x, y };
        });
    /**
     * y¬≤ = x¬≥ + ax + b: Short weierstrass curve formula
     * @returns y¬≤
     */
    function weierstrassEquation(x) {
        const { a, b } = CURVE;
        const x2 = Fp.sqr(x); // x * x
        const x3 = Fp.mul(x2, x); // x2 * x
        return Fp.add(Fp.add(x3, Fp.mul(x, a)), b); // x3 + a * x + b
    }
    // Validate whether the passed curve params are valid.
    // We check if curve equation works for generator point.
    // `assertValidity()` won't work: `isTorsionFree()` is not available at this point in bls12-381.
    // ProjectivePoint class has not been initialized yet.
    if (!Fp.eql(Fp.sqr(CURVE.Gy), weierstrassEquation(CURVE.Gx)))
        throw new Error('bad generator point: equation left != right');
    // Valid group elements reside in range 1..n-1
    function isWithinCurveOrder(num) {
        return ut.inRange(num, _1n, CURVE.n);
    }
    // Validates if priv key is valid and converts it to bigint.
    // Supports options allowedPrivateKeyLengths and wrapPrivateKey.
    function normPrivateKeyToScalar(key) {
        const { allowedPrivateKeyLengths: lengths, nByteLength, wrapPrivateKey, n: N } = CURVE;
        if (lengths && typeof key !== 'bigint') {
            if (ut.isBytes(key))
                key = ut.bytesToHex(key);
            // Normalize to hex string, pad. E.g. P521 would norm 130-132 char hex to 132-char bytes
            if (typeof key !== 'string' || !lengths.includes(key.length))
                throw new Error('Invalid key');
            key = key.padStart(nByteLength * 2, '0');
        }
        let num;
        try {
            num =
                typeof key === 'bigint'
                    ? key
                    : ut.bytesToNumberBE((0, utils_js_1.ensureBytes)('private key', key, nByteLength));
        }
        catch (error) {
            throw new Error(`private key must be ${nByteLength} bytes, hex or bigint, not ${typeof key}`);
        }
        if (wrapPrivateKey)
            num = mod.mod(num, N); // disabled by default, enabled for BLS
        ut.aInRange('private key', num, _1n, N); // num in range [1..N-1]
        return num;
    }
    function assertPrjPoint(other) {
        if (!(other instanceof Point))
            throw new Error('ProjectivePoint expected');
    }
    // Memoized toAffine / validity check. They are heavy. Points are immutable.
    // Converts Projective point to affine (x, y) coordinates.
    // Can accept precomputed Z^-1 - for example, from invertBatch.
    // (x, y, z) ‚àã (x=x/z, y=y/z)
    const toAffineMemo = (0, utils_js_1.memoized)((p, iz) => {
        const { px: x, py: y, pz: z } = p;
        // Fast-path for normalized points
        if (Fp.eql(z, Fp.ONE))
            return { x, y };
        const is0 = p.is0();
        // If invZ was 0, we return zero point. However we still want to execute
        // all operations, so we replace invZ with a random number, 1.
        if (iz == null)
            iz = is0 ? Fp.ONE : Fp.inv(z);
        const ax = Fp.mul(x, iz);
        const ay = Fp.mul(y, iz);
        const zz = Fp.mul(z, iz);
        if (is0)
            return { x: Fp.ZERO, y: Fp.ZERO };
        if (!Fp.eql(zz, Fp.ONE))
            throw new Error('invZ was invalid');
        return { x: ax, y: ay };
    });
    // NOTE: on exception this will crash 'cached' and no value will be set.
    // Otherwise true will be return
    const assertValidMemo = (0, utils_js_1.memoized)((p) => {
        if (p.is0()) {
            // (0, 1, 0) aka ZERO is invalid in most contexts.
            // In BLS, ZERO can be serialized, so we allow it.
            // (0, 0, 0) is wrong representation of ZERO and is always invalid.
            if (CURVE.allowInfinityPoint && !Fp.is0(p.py))
                return;
            throw new Error('bad point: ZERO');
        }
        // Some 3rd-party test vectors require different wording between here & `fromCompressedHex`
        const { x, y } = p.toAffine();
        // Check if x, y are valid field elements
        if (!Fp.isValid(x) || !Fp.isValid(y))
            throw new Error('bad point: x or y not FE');
        const left = Fp.sqr(y); // y¬≤
        const right = weierstrassEquation(x); // x¬≥ + ax + b
        if (!Fp.eql(left, right))
            throw new Error('bad point: equation left != right');
        if (!p.isTorsionFree())
            throw new Error('bad point: not in prime-order subgroup');
        return true;
    });
    /**
     * Projective Point works in 3d / projective (homogeneous) coordinates: (x, y, z) ‚àã (x=x/z, y=y/z)
     * Default Point works in 2d / affine coordinates: (x, y)
     * We're doing calculations in projective, because its operations don't require costly inversion.
     */
    class Point {
        constructor(px, py, pz) {
            this.px = px;
            this.py = py;
            this.pz = pz;
            if (px == null || !Fp.isValid(px))
                throw new Error('x required');
            if (py == null || !Fp.isValid(py))
                throw new Error('y required');
            if (pz == null || !Fp.isValid(pz))
                throw new Error('z required');
            Object.freeze(this);
        }
        // Does not validate if the point is on-curve.
        // Use fromHex instead, or call assertValidity() later.
        static fromAffine(p) {
            const { x, y } = p || {};
            if (!p || !Fp.isValid(x) || !Fp.isValid(y))
                throw new Error('invalid affine point');
            if (p instanceof Point)
                throw new Error('projective point not allowed');
            const is0 = (i) => Fp.eql(i, Fp.ZERO);
            // fromAffine(x:0, y:0) would produce (x:0, y:0, z:1), but we need (x:0, y:1, z:0)
            if (is0(x) && is0(y))
                return Point.ZERO;
            return new Point(x, y, Fp.ONE);
        }
        get x() {
            return this.toAffine().x;
        }
        get y() {
            return this.toAffine().y;
        }
        /**
         * Takes a bunch of Projective Points but executes only one
         * inversion on all of them. Inversion is very slow operation,
         * so this improves performance massively.
         * Optimization: converts a list of projective points to a list of identical points with Z=1.
         */
        static normalizeZ(points) {
            const toInv = Fp.invertBatch(points.map((p) => p.pz));
            return points.map((p, i) => p.toAffine(toInv[i])).map(Point.fromAffine);
        }
        /**
         * Converts hash string or Uint8Array to Point.
         * @param hex short/long ECDSA hex
         */
        static fromHex(hex) {
            const P = Point.fromAffine(fromBytes((0, utils_js_1.ensureBytes)('pointHex', hex)));
            P.assertValidity();
            return P;
        }
        // Multiplies generator point by privateKey.
        static fromPrivateKey(privateKey) {
            return Point.BASE.multiply(normPrivateKeyToScalar(privateKey));
        }
        // Multiscalar Multiplication
        static msm(points, scalars) {
            return (0, curve_js_1.pippenger)(Point, Fn, points, scalars);
        }
        // "Private method", don't use it directly
        _setWindowSize(windowSize) {
            wnaf.setWindowSize(this, windowSize);
        }
        // A point on curve is valid if it conforms to equation.
        assertValidity() {
            assertValidMemo(this);
        }
        hasEvenY() {
            const { y } = this.toAffine();
            if (Fp.isOdd)
                return !Fp.isOdd(y);
            throw new Error("Field doesn't support isOdd");
        }
        /**
         * Compare one point to another.
         */
        equals(other) {
            assertPrjPoint(other);
            const { px: X1, py: Y1, pz: Z1 } = this;
            const { px: X2, py: Y2, pz: Z2 } = other;
            const U1 = Fp.eql(Fp.mul(X1, Z2), Fp.mul(X2, Z1));
            const U2 = Fp.eql(Fp.mul(Y1, Z2), Fp.mul(Y2, Z1));
            return U1 && U2;
        }
        /**
         * Flips point to one corresponding to (x, -y) in Affine coordinates.
         */
        negate() {
            return new Point(this.px, Fp.neg(this.py), this.pz);
        }
        // Renes-Costello-Batina exception-free doubling formula.
        // There is 30% faster Jacobian formula, but it is not complete.
        // https://eprint.iacr.org/2015/1060, algorithm 3
        // Cost: 8M + 3S + 3*a + 2*b3 + 15add.
        double() {
            const { a, b } = CURVE;
            const b3 = Fp.mul(b, _3n);
            const { px: X1, py: Y1, pz: Z1 } = this;
            let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO; // prettier-ignore
            let t0 = Fp.mul(X1, X1); // step 1
            let t1 = Fp.mul(Y1, Y1);
            let t2 = Fp.mul(Z1, Z1);
            let t3 = Fp.mul(X1, Y1);
            t3 = Fp.add(t3, t3); // step 5
            Z3 = Fp.mul(X1, Z1);
            Z3 = Fp.add(Z3, Z3);
            X3 = Fp.mul(a, Z3);
            Y3 = Fp.mul(b3, t2);
            Y3 = Fp.add(X3, Y3); // step 10
            X3 = Fp.sub(t1, Y3);
            Y3 = Fp.add(t1, Y3);
            Y3 = Fp.mul(X3, Y3);
            X3 = Fp.mul(t3, X3);
            Z3 = Fp.mul(b3, Z3); // step 15
            t2 = Fp.mul(a, t2);
            t3 = Fp.sub(t0, t2);
            t3 = Fp.mul(a, t3);
            t3 = Fp.add(t3, Z3);
            Z3 = Fp.add(t0, t0); // step 20
            t0 = Fp.add(Z3, t0);
            t0 = Fp.add(t0, t2);
            t0 = Fp.mul(t0, t3);
            Y3 = Fp.add(Y3, t0);
            t2 = Fp.mul(Y1, Z1); // step 25
            t2 = Fp.add(t2, t2);
            t0 = Fp.mul(t2, t3);
            X3 = Fp.sub(X3, t0);
            Z3 = Fp.mul(t2, t1);
            Z3 = Fp.add(Z3, Z3); // step 30
            Z3 = Fp.add(Z3, Z3);
            return new Point(X3, Y3, Z3);
        }
        // Renes-Costello-Batina exception-free addition formula.
        // There is 30% faster Jacobian formula, but it is not complete.
        // https://eprint.iacr.org/2015/1060, algorithm 1
        // Cost: 12M + 0S + 3*a + 3*b3 + 23add.
        add(other) {
            assertPrjPoint(other);
            const { px: X1, py: Y1, pz: Z1 } = this;
            const { px: X2, py: Y2, pz: Z2 } = other;
            let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO; // prettier-ignore
            const a = CURVE.a;
            const b3 = Fp.mul(CURVE.b, _3n);
            let t0 = Fp.mul(X1, X2); // step 1
            let t1 = Fp.mul(Y1, Y2);
            let t2 = Fp.mul(Z1, Z2);
            let t3 = Fp.add(X1, Y1);
            let t4 = Fp.add(X2, Y2); // step 5
            t3 = Fp.mul(t3, t4);
            t4 = Fp.add(t0, t1);
            t3 = Fp.sub(t3, t4);
            t4 = Fp.add(X1, Z1);
            let t5 = Fp.add(X2, Z2); // step 10
            t4 = Fp.mul(t4, t5);
            t5 = Fp.add(t0, t2);
            t4 = Fp.sub(t4, t5);
            t5 = Fp.add(Y1, Z1);
            X3 = Fp.add(Y2, Z2); // step 15
            t5 = Fp.mul(t5, X3);
            X3 = Fp.add(t1, t2);
            t5 = Fp.sub(t5, X3);
            Z3 = Fp.mul(a, t4);
            X3 = Fp.mul(b3, t2); // step 20
            Z3 = Fp.add(X3, Z3);
            X3 = Fp.sub(t1, Z3);
            Z3 = Fp.add(t1, Z3);
            Y3 = Fp.mul(X3, Z3);
            t1 = Fp.add(t0, t0); // step 25
            t1 = Fp.add(t1, t0);
            t2 = Fp.mul(a, t2);
            t4 = Fp.mul(b3, t4);
            t1 = Fp.add(t1, t2);
            t2 = Fp.sub(t0, t2); // step 30
            t2 = Fp.mul(a, t2);
            t4 = Fp.add(t4, t2);
            t0 = Fp.mul(t1, t4);
            Y3 = Fp.add(Y3, t0);
            t0 = Fp.mul(t5, t4); // step 35
            X3 = Fp.mul(t3, X3);
            X3 = Fp.sub(X3, t0);
            t0 = Fp.mul(t3, t1);
            Z3 = Fp.mul(t5, Z3);
            Z3 = Fp.add(Z3, t0); // step 40
            return new Point(X3, Y3, Z3);
        }
        subtract(other) {
            return this.add(other.negate());
        }
        is0() {
            return this.equals(Point.ZERO);
        }
        wNAF(n) {
            return wnaf.wNAFCached(this, n, Point.normalizeZ);
        }
        /**
         * Non-constant-time multiplication. Uses double-and-add algorithm.
         * It's faster, but should only be used when you don't care about
         * an exposed private key e.g. sig verification, which works over *public* keys.
         */
        multiplyUnsafe(sc) {
            ut.aInRange('scalar', sc, _0n, CURVE.n);
            const I = Point.ZERO;
            if (sc === _0n)
                return I;
            if (sc === _1n)
                return this;
            const { endo } = CURVE;
            if (!endo)
                return wnaf.unsafeLadder(this, sc);
            // Apply endomorphism
            let { k1neg, k1, k2neg, k2 } = endo.splitScalar(sc);
            let k1p = I;
            let k2p = I;
            let d = this;
            while (k1 > _0n || k2 > _0n) {
                if (k1 & _1n)
                    k1p = k1p.add(d);
                if (k2 & _1n)
                    k2p = k2p.add(d);
                d = d.double();
                k1 >>= _1n;
                k2 >>= _1n;
            }
            if (k1neg)
                k1p = k1p.negate();
            if (k2neg)
                k2p = k2p.negate();
            k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);
            return k1p.add(k2p);
        }
        /**
         * Constant time multiplication.
         * Uses wNAF method. Windowed method may be 10% faster,
         * but takes 2x longer to generate and consumes 2x memory.
         * Uses precomputes when available.
         * Uses endomorphism for Koblitz curves.
         * @param scalar by which the point would be multiplied
         * @returns New point
         */
        multiply(scalar) {
            const { endo, n: N } = CURVE;
            ut.aInRange('scalar', scalar, _1n, N);
            let point, fake; // Fake point is used to const-time mult
            if (endo) {
                const { k1neg, k1, k2neg, k2 } = endo.splitScalar(scalar);
                let { p: k1p, f: f1p } = this.wNAF(k1);
                let { p: k2p, f: f2p } = this.wNAF(k2);
                k1p = wnaf.constTimeNegate(k1neg, k1p);
                k2p = wnaf.constTimeNegate(k2neg, k2p);
                k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);
                point = k1p.add(k2p);
                fake = f1p.add(f2p);
            }
            else {
                const { p, f } = this.wNAF(scalar);
                point = p;
                fake = f;
            }
            // Normalize `z` for both points, but return only real one
            return Point.normalizeZ([point, fake])[0];
        }
        /**
         * Efficiently calculate `aP + bQ`. Unsafe, can expose private key, if used incorrectly.
         * Not using Strauss-Shamir trick: precomputation tables are faster.
         * The trick could be useful if both P and Q are not G (not in our case).
         * @returns non-zero affine point
         */
        multiplyAndAddUnsafe(Q, a, b) {
            const G = Point.BASE; // No Strauss-Shamir trick: we have 10% faster G precomputes
            const mul = (P, a // Select faster multiply() method
            ) => (a === _0n || a === _1n || !P.equals(G) ? P.multiplyUnsafe(a) : P.multiply(a));
            const sum = mul(this, a).add(mul(Q, b));
            return sum.is0() ? undefined : sum;
        }
        // Converts Projective point to affine (x, y) coordinates.
        // Can accept precomputed Z^-1 - for example, from invertBatch.
        // (x, y, z) ‚àã (x=x/z, y=y/z)
        toAffine(iz) {
            return toAffineMemo(this, iz);
        }
        isTorsionFree() {
            const { h: cofactor, isTorsionFree } = CURVE;
            if (cofactor === _1n)
                return true; // No subgroups, always torsion-free
            if (isTorsionFree)
                return isTorsionFree(Point, this);
            throw new Error('isTorsionFree() has not been declared for the elliptic curve');
        }
        clearCofactor() {
            const { h: cofactor, clearCofactor } = CURVE;
            if (cofactor === _1n)
                return this; // Fast-path
            if (clearCofactor)
                return clearCofactor(Point, this);
            return this.multiplyUnsafe(CURVE.h);
        }
        toRawBytes(isCompressed = true) {
            (0, utils_js_1.abool)('isCompressed', isCompressed);
            this.assertValidity();
            return toBytes(Point, this, isCompressed);
        }
        toHex(isCompressed = true) {
            (0, utils_js_1.abool)('isCompressed', isCompressed);
            return ut.bytesToHex(this.toRawBytes(isCompressed));
        }
    }
    Point.BASE = new Point(CURVE.Gx, CURVE.Gy, Fp.ONE);
    Point.ZERO = new Point(Fp.ZERO, Fp.ONE, Fp.ZERO);
    const _bits = CURVE.nBitLength;
    const wnaf = (0, curve_js_1.wNAF)(Point, CURVE.endo ? Math.ceil(_bits / 2) : _bits);
    // Validate if generator point is on curve
    return {
        CURVE,
        ProjectivePoint: Point,
        normPrivateKeyToScalar,
        weierstrassEquation,
        isWithinCurveOrder,
    };
}
function validateOpts(curve) {
    const opts = (0, curve_js_1.validateBasic)(curve);
    ut.validateObject(opts, {
        hash: 'hash',
        hmac: 'function',
        randomBytes: 'function',
    }, {
        bits2int: 'function',
        bits2int_modN: 'function',
        lowS: 'boolean',
    });
    return Object.freeze({ lowS: true, ...opts });
}
/**
 * Creates short weierstrass curve and ECDSA signature methods for it.
 * @example
 * import { Field } from '@noble/curves/abstract/modular';
 * // Before that, define BigInt-s: a, b, p, n, Gx, Gy
 * const curve = weierstrass({ a, b, Fp: Field(p), n, Gx, Gy, h: 1n })
 */
function weierstrass(curveDef) {
    const CURVE = validateOpts(curveDef);
    const { Fp, n: CURVE_ORDER } = CURVE;
    const compressedLen = Fp.BYTES + 1; // e.g. 33 for 32
    const uncompressedLen = 2 * Fp.BYTES + 1; // e.g. 65 for 32
    function modN(a) {
        return mod.mod(a, CURVE_ORDER);
    }
    function invN(a) {
        return mod.invert(a, CURVE_ORDER);
    }
    const { ProjectivePoint: Point, normPrivateKeyToScalar, weierstrassEquation, isWithinCurveOrder, } = weierstrassPoints({
        ...CURVE,
        toBytes(_c, point, isCompressed) {
            const a = point.toAffine();
            const x = Fp.toBytes(a.x);
            const cat = ut.concatBytes;
            (0, utils_js_1.abool)('isCompressed', isCompressed);
            if (isCompressed) {
                return cat(Uint8Array.from([point.hasEvenY() ? 0x02 : 0x03]), x);
            }
            else {
                return cat(Uint8Array.from([0x04]), x, Fp.toBytes(a.y));
            }
        },
        fromBytes(bytes) {
            const len = bytes.length;
            const head = bytes[0];
            const tail = bytes.subarray(1);
            // this.assertValidity() is done inside of fromHex
            if (len === compressedLen && (head === 0x02 || head === 0x03)) {
                const x = ut.bytesToNumberBE(tail);
                if (!ut.inRange(x, _1n, Fp.ORDER))
                    throw new Error('Point is not on curve');
                const y2 = weierstrassEquation(x); // y¬≤ = x¬≥ + ax + b
                let y;
                try {
                    y = Fp.sqrt(y2); // y = y¬≤ ^ (p+1)/4
                }
                catch (sqrtError) {
                    const suffix = sqrtError instanceof Error ? ': ' + sqrtError.message : '';
                    throw new Error('Point is not on curve' + suffix);
                }
                const isYOdd = (y & _1n) === _1n;
                // ECDSA
                const isHeadOdd = (head & 1) === 1;
                if (isHeadOdd !== isYOdd)
                    y = Fp.neg(y);
                return { x, y };
            }
            else if (len === uncompressedLen && head === 0x04) {
                const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));
                const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));
                return { x, y };
            }
            else {
                throw new Error(`Point of length ${len} was invalid. Expected ${compressedLen} compressed bytes or ${uncompressedLen} uncompressed bytes`);
            }
        },
    });
    const numToNByteStr = (num) => ut.bytesToHex(ut.numberToBytesBE(num, CURVE.nByteLength));
    function isBiggerThanHalfOrder(number) {
        const HALF = CURVE_ORDER >> _1n;
        return number > HALF;
    }
    function normalizeS(s) {
        return isBiggerThanHalfOrder(s) ? modN(-s) : s;
    }
    // slice bytes num
    const slcNum = (b, from, to) => ut.bytesToNumberBE(b.slice(from, to));
    /**
     * ECDSA signature with its (r, s) properties. Supports DER & compact representations.
     */
    class Signature {
        constructor(r, s, recovery) {
            this.r = r;
            this.s = s;
            this.recovery = recovery;
            this.assertValidity();
        }
        // pair (bytes of r, bytes of s)
        static fromCompact(hex) {
            const l = CURVE.nByteLength;
            hex = (0, utils_js_1.ensureBytes)('compactSignature', hex, l * 2);
            return new Signature(slcNum(hex, 0, l), slcNum(hex, l, 2 * l));
        }
        // DER encoded ECDSA signature
        // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script
        static fromDER(hex) {
            const { r, s } = exports.DER.toSig((0, utils_js_1.ensureBytes)('DER', hex));
            return new Signature(r, s);
        }
        assertValidity() {
            ut.aInRange('r', this.r, _1n, CURVE_ORDER); // r in [1..N]
            ut.aInRange('s', this.s, _1n, CURVE_ORDER); // s in [1..N]
        }
        addRecoveryBit(recovery) {
            return new Signature(this.r, this.s, recovery);
        }
        recoverPublicKey(msgHash) {
            const { r, s, recovery: rec } = this;
            const h = bits2int_modN((0, utils_js_1.ensureBytes)('msgHash', msgHash)); // Truncate hash
            if (rec == null || ![0, 1, 2, 3].includes(rec))
                throw new Error('recovery id invalid');
            const radj = rec === 2 || rec === 3 ? r + CURVE.n : r;
            if (radj >= Fp.ORDER)
                throw new Error('recovery id 2 or 3 invalid');
            const prefix = (rec & 1) === 0 ? '02' : '03';
            const R = Point.fromHex(prefix + numToNByteStr(radj));
            const ir = invN(radj); // r^-1
            const u1 = modN(-h * ir); // -hr^-1
            const u2 = modN(s * ir); // sr^-1
            const Q = Point.BASE.multiplyAndAddUnsafe(R, u1, u2); // (sr^-1)R-(hr^-1)G = -(hr^-1)G + (sr^-1)
            if (!Q)
                throw new Error('point at infinify'); // unsafe is fine: no priv data leaked
            Q.assertValidity();
            return Q;
        }
        // Signatures should be low-s, to prevent malleability.
        hasHighS() {
            return isBiggerThanHalfOrder(this.s);
        }
        normalizeS() {
            return this.hasHighS() ? new Signature(this.r, modN(-this.s), this.recovery) : this;
        }
        // DER-encoded
        toDERRawBytes() {
            return ut.hexToBytes(this.toDERHex());
        }
        toDERHex() {
            return exports.DER.hexFromSig({ r: this.r, s: this.s });
        }
        // padded bytes of r, then padded bytes of s
        toCompactRawBytes() {
            return ut.hexToBytes(this.toCompactHex());
        }
        toCompactHex() {
            return numToNByteStr(this.r) + numToNByteStr(this.s);
        }
    }
    const utils = {
        isValidPrivateKey(privateKey) {
            try {
                normPrivateKeyToScalar(privateKey);
                return true;
            }
            catch (error) {
                return false;
            }
        },
        normPrivateKeyToScalar: normPrivateKeyToScalar,
        /**
         * Produces cryptographically secure private key from random of size
         * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.
         */
        randomPrivateKey: () => {
            const length = mod.getMinHashLength(CURVE.n);
            return mod.mapHashToField(CURVE.randomBytes(length), CURVE.n);
        },
        /**
         * Creates precompute table for an arbitrary EC point. Makes point "cached".
         * Allows to massively speed-up `point.multiply(scalar)`.
         * @returns cached point
         * @example
         * const fast = utils.precompute(8, ProjectivePoint.fromHex(someonesPubKey));
         * fast.multiply(privKey); // much faster ECDH now
         */
        precompute(windowSize = 8, point = Point.BASE) {
            point._setWindowSize(windowSize);
            point.multiply(BigInt(3)); // 3 is arbitrary, just need any number here
            return point;
        },
    };
    /**
     * Computes public key for a private key. Checks for validity of the private key.
     * @param privateKey private key
     * @param isCompressed whether to return compact (default), or full key
     * @returns Public key, full when isCompressed=false; short when isCompressed=true
     */
    function getPublicKey(privateKey, isCompressed = true) {
        return Point.fromPrivateKey(privateKey).toRawBytes(isCompressed);
    }
    /**
     * Quick and dirty check for item being public key. Does not validate hex, or being on-curve.
     */
    function isProbPub(item) {
        const arr = ut.isBytes(item);
        const str = typeof item === 'string';
        const len = (arr || str) && item.length;
        if (arr)
            return len === compressedLen || len === uncompressedLen;
        if (str)
            return len === 2 * compressedLen || len === 2 * uncompressedLen;
        if (item instanceof Point)
            return true;
        return false;
    }
    /**
     * ECDH (Elliptic Curve Diffie Hellman).
     * Computes shared public key from private key and public key.
     * Checks: 1) private key validity 2) shared key is on-curve.
     * Does NOT hash the result.
     * @param privateA private key
     * @param publicB different public key
     * @param isCompressed whether to return compact (default), or full key
     * @returns shared public key
     */
    function getSharedSecret(privateA, publicB, isCompressed = true) {
        if (isProbPub(privateA))
            throw new Error('first arg must be private key');
        if (!isProbPub(publicB))
            throw new Error('second arg must be public key');
        const b = Point.fromHex(publicB); // check for being on-curve
        return b.multiply(normPrivateKeyToScalar(privateA)).toRawBytes(isCompressed);
    }
    // RFC6979: ensure ECDSA msg is X bytes and < N. RFC suggests optional truncating via bits2octets.
    // FIPS 186-4 4.6 suggests the leftmost min(nBitLen, outLen) bits, which matches bits2int.
    // bits2int can produce res>N, we can do mod(res, N) since the bitLen is the same.
    // int2octets can't be used; pads small msgs with 0: unacceptatble for trunc as per RFC vectors
    const bits2int = CURVE.bits2int ||
        function (bytes) {
            // For curves with nBitLength % 8 !== 0: bits2octets(bits2octets(m)) !== bits2octets(m)
            // for some cases, since bytes.length * 8 is not actual bitLength.
            const num = ut.bytesToNumberBE(bytes); // check for == u8 done here
            const delta = bytes.length * 8 - CURVE.nBitLength; // truncate to nBitLength leftmost bits
            return delta > 0 ? num >> BigInt(delta) : num;
        };
    const bits2int_modN = CURVE.bits2int_modN ||
        function (bytes) {
            return modN(bits2int(bytes)); // can't use bytesToNumberBE here
        };
    // NOTE: pads output with zero as per spec
    const ORDER_MASK = ut.bitMask(CURVE.nBitLength);
    /**
     * Converts to bytes. Checks if num in `[0..ORDER_MASK-1]` e.g.: `[0..2^256-1]`.
     */
    function int2octets(num) {
        ut.aInRange(`num < 2^${CURVE.nBitLength}`, num, _0n, ORDER_MASK);
        // works with order, can have different size than numToField!
        return ut.numberToBytesBE(num, CURVE.nByteLength);
    }
    // Steps A, D of RFC6979 3.2
    // Creates RFC6979 seed; converts msg/privKey to numbers.
    // Used only in sign, not in verify.
    // NOTE: we cannot assume here that msgHash has same amount of bytes as curve order, this will be wrong at least for P521.
    // Also it can be bigger for P224 + SHA256
    function prepSig(msgHash, privateKey, opts = defaultSigOpts) {
        if (['recovered', 'canonical'].some((k) => k in opts))
            throw new Error('sign() legacy options not supported');
        const { hash, randomBytes } = CURVE;
        let { lowS, prehash, extraEntropy: ent } = opts; // generates low-s sigs by default
        if (lowS == null)
            lowS = true; // RFC6979 3.2: we skip step A, because we already provide hash
        msgHash = (0, utils_js_1.ensureBytes)('msgHash', msgHash);
        validateSigVerOpts(opts);
        if (prehash)
            msgHash = (0, utils_js_1.ensureBytes)('prehashed msgHash', hash(msgHash));
        // We can't later call bits2octets, since nested bits2int is broken for curves
        // with nBitLength % 8 !== 0. Because of that, we unwrap it here as int2octets call.
        // const bits2octets = (bits) => int2octets(bits2int_modN(bits))
        const h1int = bits2int_modN(msgHash);
        const d = normPrivateKeyToScalar(privateKey); // validate private key, convert to bigint
        const seedArgs = [int2octets(d), int2octets(h1int)];
        // extraEntropy. RFC6979 3.6: additional k' (optional).
        if (ent != null && ent !== false) {
            // K = HMAC_K(V || 0x00 || int2octets(x) || bits2octets(h1) || k')
            const e = ent === true ? randomBytes(Fp.BYTES) : ent; // generate random bytes OR pass as-is
            seedArgs.push((0, utils_js_1.ensureBytes)('extraEntropy', e)); // check for being bytes
        }
        const seed = ut.concatBytes(...seedArgs); // Step D of RFC6979 3.2
        const m = h1int; // NOTE: no need to call bits2int second time here, it is inside truncateHash!
        // Converts signature params into point w r/s, checks result for validity.
        function k2sig(kBytes) {
            // RFC 6979 Section 3.2, step 3: k = bits2int(T)
            const k = bits2int(kBytes); // Cannot use fields methods, since it is group element
            if (!isWithinCurveOrder(k))
                return; // Important: all mod() calls here must be done over N
            const ik = invN(k); // k^-1 mod n
            const q = Point.BASE.multiply(k).toAffine(); // q = Gk
            const r = modN(q.x); // r = q.x mod n
            if (r === _0n)
                return;
            // Can use scalar blinding b^-1(bm + bdr) where b ‚àà [1,q‚àí1] according to
            // https://tches.iacr.org/index.php/TCHES/article/view/7337/6509. We've decided against it:
            // a) dependency on CSPRNG b) 15% slowdown c) doesn't really help since bigints are not CT
            const s = modN(ik * modN(m + r * d)); // Not using blinding here
            if (s === _0n)
                return;
            let recovery = (q.x === r ? 0 : 2) | Number(q.y & _1n); // recovery bit (2 or 3, when q.x > n)
            let normS = s;
            if (lowS && isBiggerThanHalfOrder(s)) {
                normS = normalizeS(s); // if lowS was passed, ensure s is always
                recovery ^= 1; // // in the bottom half of N
            }
            return new Signature(r, normS, recovery); // use normS, not s
        }
        return { seed, k2sig };
    }
    const defaultSigOpts = { lowS: CURVE.lowS, prehash: false };
    const defaultVerOpts = { lowS: CURVE.lowS, prehash: false };
    /**
     * Signs message hash with a private key.
     * ```
     * sign(m, d, k) where
     *   (x, y) = G √ó k
     *   r = x mod n
     *   s = (m + dr)/k mod n
     * ```
     * @param msgHash NOT message. msg needs to be hashed to `msgHash`, or use `prehash`.
     * @param privKey private key
     * @param opts lowS for non-malleable sigs. extraEntropy for mixing randomness into k. prehash will hash first arg.
     * @returns signature with recovery param
     */
    function sign(msgHash, privKey, opts = defaultSigOpts) {
        const { seed, k2sig } = prepSig(msgHash, privKey, opts); // Steps A, D of RFC6979 3.2.
        const C = CURVE;
        const drbg = ut.createHmacDrbg(C.hash.outputLen, C.nByteLength, C.hmac);
        return drbg(seed, k2sig); // Steps B, C, D, E, F, G
    }
    // Enable precomputes. Slows down first publicKey computation by 20ms.
    Point.BASE._setWindowSize(8);
    // utils.precompute(8, ProjectivePoint.BASE)
    /**
     * Verifies a signature against message hash and public key.
     * Rejects lowS signatures by default: to override,
     * specify option `{lowS: false}`. Implements section 4.1.4 from https://www.secg.org/sec1-v2.pdf:
     *
     * ```
     * verify(r, s, h, P) where
     *   U1 = hs^-1 mod n
     *   U2 = rs^-1 mod n
     *   R = U1‚ãÖG - U2‚ãÖP
     *   mod(R.x, n) == r
     * ```
     */
    function verify(signature, msgHash, publicKey, opts = defaultVerOpts) {
        const sg = signature;
        msgHash = (0, utils_js_1.ensureBytes)('msgHash', msgHash);
        publicKey = (0, utils_js_1.ensureBytes)('publicKey', publicKey);
        if ('strict' in opts)
            throw new Error('options.strict was renamed to lowS');
        validateSigVerOpts(opts);
        const { lowS, prehash } = opts;
        let _sig = undefined;
        let P;
        try {
            if (typeof sg === 'string' || ut.isBytes(sg)) {
                // Signature can be represented in 2 ways: compact (2*nByteLength) & DER (variable-length).
                // Since DER can also be 2*nByteLength bytes, we check for it first.
                try {
                    _sig = Signature.fromDER(sg);
                }
                catch (derError) {
                    if (!(derError instanceof exports.DER.Err))
                        throw derError;
                    _sig = Signature.fromCompact(sg);
                }
            }
            else if (typeof sg === 'object' && typeof sg.r === 'bigint' && typeof sg.s === 'bigint') {
                const { r, s } = sg;
                _sig = new Signature(r, s);
            }
            else {
                throw new Error('PARSE');
            }
            P = Point.fromHex(publicKey);
        }
        catch (error) {
            if (error.message === 'PARSE')
                throw new Error(`signature must be Signature instance, Uint8Array or hex string`);
            return false;
        }
        if (lowS && _sig.hasHighS())
            return false;
        if (prehash)
            msgHash = CURVE.hash(msgHash);
        const { r, s } = _sig;
        const h = bits2int_modN(msgHash); // Cannot use fields methods, since it is group element
        const is = invN(s); // s^-1
        const u1 = modN(h * is); // u1 = hs^-1 mod n
        const u2 = modN(r * is); // u2 = rs^-1 mod n
        const R = Point.BASE.multiplyAndAddUnsafe(P, u1, u2)?.toAffine(); // R = u1‚ãÖG + u2‚ãÖP
        if (!R)
            return false;
        const v = modN(R.x);
        return v === r;
    }
    return {
        CURVE,
        getPublicKey,
        getSharedSecret,
        sign,
        verify,
        ProjectivePoint: Point,
        Signature,
        utils,
    };
}
/**
 * Implementation of the Shallue and van de Woestijne method for any weierstrass curve.
 * TODO: check if there is a way to merge this with uvRatio in Edwards; move to modular.
 * b = True and y = sqrt(u / v) if (u / v) is square in F, and
 * b = False and y = sqrt(Z * (u / v)) otherwise.
 * @param Fp
 * @param Z
 * @returns
 */
function SWUFpSqrtRatio(Fp, Z) {
    // Generic implementation
    const q = Fp.ORDER;
    let l = _0n;
    for (let o = q - _1n; o % _2n === _0n; o /= _2n)
        l += _1n;
    const c1 = l; // 1. c1, the largest integer such that 2^c1 divides q - 1.
    // We need 2n ** c1 and 2n ** (c1-1). We can't use **; but we can use <<.
    // 2n ** c1 == 2n << (c1-1)
    const _2n_pow_c1_1 = _2n << (c1 - _1n - _1n);
    const _2n_pow_c1 = _2n_pow_c1_1 * _2n;
    const c2 = (q - _1n) / _2n_pow_c1; // 2. c2 = (q - 1) / (2^c1)  # Integer arithmetic
    const c3 = (c2 - _1n) / _2n; // 3. c3 = (c2 - 1) / 2            # Integer arithmetic
    const c4 = _2n_pow_c1 - _1n; // 4. c4 = 2^c1 - 1                # Integer arithmetic
    const c5 = _2n_pow_c1_1; // 5. c5 = 2^(c1 - 1)                  # Integer arithmetic
    const c6 = Fp.pow(Z, c2); // 6. c6 = Z^c2
    const c7 = Fp.pow(Z, (c2 + _1n) / _2n); // 7. c7 = Z^((c2 + 1) / 2)
    let sqrtRatio = (u, v) => {
        let tv1 = c6; // 1. tv1 = c6
        let tv2 = Fp.pow(v, c4); // 2. tv2 = v^c4
        let tv3 = Fp.sqr(tv2); // 3. tv3 = tv2^2
        tv3 = Fp.mul(tv3, v); // 4. tv3 = tv3 * v
        let tv5 = Fp.mul(u, tv3); // 5. tv5 = u * tv3
        tv5 = Fp.pow(tv5, c3); // 6. tv5 = tv5^c3
        tv5 = Fp.mul(tv5, tv2); // 7. tv5 = tv5 * tv2
        tv2 = Fp.mul(tv5, v); // 8. tv2 = tv5 * v
        tv3 = Fp.mul(tv5, u); // 9. tv3 = tv5 * u
        let tv4 = Fp.mul(tv3, tv2); // 10. tv4 = tv3 * tv2
        tv5 = Fp.pow(tv4, c5); // 11. tv5 = tv4^c5
        let isQR = Fp.eql(tv5, Fp.ONE); // 12. isQR = tv5 == 1
        tv2 = Fp.mul(tv3, c7); // 13. tv2 = tv3 * c7
        tv5 = Fp.mul(tv4, tv1); // 14. tv5 = tv4 * tv1
        tv3 = Fp.cmov(tv2, tv3, isQR); // 15. tv3 = CMOV(tv2, tv3, isQR)
        tv4 = Fp.cmov(tv5, tv4, isQR); // 16. tv4 = CMOV(tv5, tv4, isQR)
        // 17. for i in (c1, c1 - 1, ..., 2):
        for (let i = c1; i > _1n; i--) {
            let tv5 = i - _2n; // 18.    tv5 = i - 2
            tv5 = _2n << (tv5 - _1n); // 19.    tv5 = 2^tv5
            let tvv5 = Fp.pow(tv4, tv5); // 20.    tv5 = tv4^tv5
            const e1 = Fp.eql(tvv5, Fp.ONE); // 21.    e1 = tv5 == 1
            tv2 = Fp.mul(tv3, tv1); // 22.    tv2 = tv3 * tv1
            tv1 = Fp.mul(tv1, tv1); // 23.    tv1 = tv1 * tv1
            tvv5 = Fp.mul(tv4, tv1); // 24.    tv5 = tv4 * tv1
            tv3 = Fp.cmov(tv2, tv3, e1); // 25.    tv3 = CMOV(tv2, tv3, e1)
            tv4 = Fp.cmov(tvv5, tv4, e1); // 26.    tv4 = CMOV(tv5, tv4, e1)
        }
        return { isValid: isQR, value: tv3 };
    };
    if (Fp.ORDER % _4n === _3n) {
        // sqrt_ratio_3mod4(u, v)
        const c1 = (Fp.ORDER - _3n) / _4n; // 1. c1 = (q - 3) / 4     # Integer arithmetic
        const c2 = Fp.sqrt(Fp.neg(Z)); // 2. c2 = sqrt(-Z)
        sqrtRatio = (u, v) => {
            let tv1 = Fp.sqr(v); // 1. tv1 = v^2
            const tv2 = Fp.mul(u, v); // 2. tv2 = u * v
            tv1 = Fp.mul(tv1, tv2); // 3. tv1 = tv1 * tv2
            let y1 = Fp.pow(tv1, c1); // 4. y1 = tv1^c1
            y1 = Fp.mul(y1, tv2); // 5. y1 = y1 * tv2
            const y2 = Fp.mul(y1, c2); // 6. y2 = y1 * c2
            const tv3 = Fp.mul(Fp.sqr(y1), v); // 7. tv3 = y1^2; 8. tv3 = tv3 * v
            const isQR = Fp.eql(tv3, u); // 9. isQR = tv3 == u
            let y = Fp.cmov(y2, y1, isQR); // 10. y = CMOV(y2, y1, isQR)
            return { isValid: isQR, value: y }; // 11. return (isQR, y) isQR ? y : y*c2
        };
    }
    // No curves uses that
    // if (Fp.ORDER % _8n === _5n) // sqrt_ratio_5mod8
    return sqrtRatio;
}
/**
 * Simplified Shallue-van de Woestijne-Ulas Method
 * https://www.rfc-editor.org/rfc/rfc9380#section-6.6.2
 */
function mapToCurveSimpleSWU(Fp, opts) {
    mod.validateField(Fp);
    if (!Fp.isValid(opts.A) || !Fp.isValid(opts.B) || !Fp.isValid(opts.Z))
        throw new Error('mapToCurveSimpleSWU: invalid opts');
    const sqrtRatio = SWUFpSqrtRatio(Fp, opts.Z);
    if (!Fp.isOdd)
        throw new Error('Fp.isOdd is not implemented!');
    // Input: u, an element of F.
    // Output: (x, y), a point on E.
    return (u) => {
        // prettier-ignore
        let tv1, tv2, tv3, tv4, tv5, tv6, x, y;
        tv1 = Fp.sqr(u); // 1.  tv1 = u^2
        tv1 = Fp.mul(tv1, opts.Z); // 2.  tv1 = Z * tv1
        tv2 = Fp.sqr(tv1); // 3.  tv2 = tv1^2
        tv2 = Fp.add(tv2, tv1); // 4.  tv2 = tv2 + tv1
        tv3 = Fp.add(tv2, Fp.ONE); // 5.  tv3 = tv2 + 1
        tv3 = Fp.mul(tv3, opts.B); // 6.  tv3 = B * tv3
        tv4 = Fp.cmov(opts.Z, Fp.neg(tv2), !Fp.eql(tv2, Fp.ZERO)); // 7.  tv4 = CMOV(Z, -tv2, tv2 != 0)
        tv4 = Fp.mul(tv4, opts.A); // 8.  tv4 = A * tv4
        tv2 = Fp.sqr(tv3); // 9.  tv2 = tv3^2
        tv6 = Fp.sqr(tv4); // 10. tv6 = tv4^2
        tv5 = Fp.mul(tv6, opts.A); // 11. tv5 = A * tv6
        tv2 = Fp.add(tv2, tv5); // 12. tv2 = tv2 + tv5
        tv2 = Fp.mul(tv2, tv3); // 13. tv2 = tv2 * tv3
        tv6 = Fp.mul(tv6, tv4); // 14. tv6 = tv6 * tv4
        tv5 = Fp.mul(tv6, opts.B); // 15. tv5 = B * tv6
        tv2 = Fp.add(tv2, tv5); // 16. tv2 = tv2 + tv5
        x = Fp.mul(tv1, tv3); // 17.   x = tv1 * tv3
        const { isValid, value } = sqrtRatio(tv2, tv6); // 18. (is_gx1_square, y1) = sqrt_ratio(tv2, tv6)
        y = Fp.mul(tv1, u); // 19.   y = tv1 * u  -> Z * u^3 * y1
        y = Fp.mul(y, value); // 20.   y = y * y1
        x = Fp.cmov(x, tv3, isValid); // 21.   x = CMOV(x, tv3, is_gx1_square)
        y = Fp.cmov(y, value, isValid); // 22.   y = CMOV(y, y1, is_gx1_square)
        const e1 = Fp.isOdd(u) === Fp.isOdd(y); // 23.  e1 = sgn0(u) == sgn0(y)
        y = Fp.cmov(Fp.neg(y), y, e1); // 24.   y = CMOV(-y, y, e1)
        x = Fp.div(x, tv4); // 25.   x = x / tv4
        return { x, y };
    };
}
//# sourceMappingURL=weierstrass.js.map

/***/ }),

/***/ 459:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.hash_to_ristretto255 = exports.hashToRistretto255 = exports.RistrettoPoint = exports.encodeToCurve = exports.hashToCurve = exports.edwardsToMontgomery = exports.x25519 = exports.ed25519ph = exports.ed25519ctx = exports.ed25519 = exports.ED25519_TORSION_SUBGROUP = void 0;
exports.edwardsToMontgomeryPub = edwardsToMontgomeryPub;
exports.edwardsToMontgomeryPriv = edwardsToMontgomeryPriv;
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const sha512_1 = __webpack_require__(102);
const utils_1 = __webpack_require__(9175);
const edwards_js_1 = __webpack_require__(6377);
const hash_to_curve_js_1 = __webpack_require__(1761);
const modular_js_1 = __webpack_require__(4967);
const montgomery_js_1 = __webpack_require__(2854);
const utils_js_1 = __webpack_require__(1484);
/**
 * ed25519 Twisted Edwards curve with following addons:
 * - X25519 ECDH
 * - Ristretto cofactor elimination
 * - Elligator hash-to-group / point indistinguishability
 */
const ED25519_P = BigInt('57896044618658097711785492504343953926634992332820282019728792003956564819949');
// ‚àö(-1) aka ‚àö(a) aka 2^((p-1)/4)
const ED25519_SQRT_M1 = /* @__PURE__ */ BigInt('19681161376707505956807079304988542015446066515923890162744021073123829784752');
// prettier-ignore
const _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3);
// prettier-ignore
const _5n = BigInt(5), _8n = BigInt(8);
function ed25519_pow_2_252_3(x) {
    // prettier-ignore
    const _10n = BigInt(10), _20n = BigInt(20), _40n = BigInt(40), _80n = BigInt(80);
    const P = ED25519_P;
    const x2 = (x * x) % P;
    const b2 = (x2 * x) % P; // x^3, 11
    const b4 = ((0, modular_js_1.pow2)(b2, _2n, P) * b2) % P; // x^15, 1111
    const b5 = ((0, modular_js_1.pow2)(b4, _1n, P) * x) % P; // x^31
    const b10 = ((0, modular_js_1.pow2)(b5, _5n, P) * b5) % P;
    const b20 = ((0, modular_js_1.pow2)(b10, _10n, P) * b10) % P;
    const b40 = ((0, modular_js_1.pow2)(b20, _20n, P) * b20) % P;
    const b80 = ((0, modular_js_1.pow2)(b40, _40n, P) * b40) % P;
    const b160 = ((0, modular_js_1.pow2)(b80, _80n, P) * b80) % P;
    const b240 = ((0, modular_js_1.pow2)(b160, _80n, P) * b80) % P;
    const b250 = ((0, modular_js_1.pow2)(b240, _10n, P) * b10) % P;
    const pow_p_5_8 = ((0, modular_js_1.pow2)(b250, _2n, P) * x) % P;
    // ^ To pow to (p+3)/8, multiply it by x.
    return { pow_p_5_8, b2 };
}
function adjustScalarBytes(bytes) {
    // Section 5: For X25519, in order to decode 32 random bytes as an integer scalar,
    // set the three least significant bits of the first byte
    bytes[0] &= 248; // 0b1111_1000
    // and the most significant bit of the last to zero,
    bytes[31] &= 127; // 0b0111_1111
    // set the second most significant bit of the last byte to 1
    bytes[31] |= 64; // 0b0100_0000
    return bytes;
}
// sqrt(u/v)
function uvRatio(u, v) {
    const P = ED25519_P;
    const v3 = (0, modular_js_1.mod)(v * v * v, P); // v¬≥
    const v7 = (0, modular_js_1.mod)(v3 * v3 * v, P); // v‚Å∑
    // (p+3)/8 and (p-5)/8
    const pow = ed25519_pow_2_252_3(u * v7).pow_p_5_8;
    let x = (0, modular_js_1.mod)(u * v3 * pow, P); // (uv¬≥)(uv‚Å∑)^(p-5)/8
    const vx2 = (0, modular_js_1.mod)(v * x * x, P); // vx¬≤
    const root1 = x; // First root candidate
    const root2 = (0, modular_js_1.mod)(x * ED25519_SQRT_M1, P); // Second root candidate
    const useRoot1 = vx2 === u; // If vx¬≤ = u (mod p), x is a square root
    const useRoot2 = vx2 === (0, modular_js_1.mod)(-u, P); // If vx¬≤ = -u, set x <-- x * 2^((p-1)/4)
    const noRoot = vx2 === (0, modular_js_1.mod)(-u * ED25519_SQRT_M1, P); // There is no valid root, vx¬≤ = -u‚àö(-1)
    if (useRoot1)
        x = root1;
    if (useRoot2 || noRoot)
        x = root2; // We return root2 anyway, for const-time
    if ((0, modular_js_1.isNegativeLE)(x, P))
        x = (0, modular_js_1.mod)(-x, P);
    return { isValid: useRoot1 || useRoot2, value: x };
}
// Just in case
exports.ED25519_TORSION_SUBGROUP = [
    '0100000000000000000000000000000000000000000000000000000000000000',
    'c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac037a',
    '0000000000000000000000000000000000000000000000000000000000000080',
    '26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc05',
    'ecffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff7f',
    '26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc85',
    '0000000000000000000000000000000000000000000000000000000000000000',
    'c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac03fa',
];
const Fp = /* @__PURE__ */ (() => (0, modular_js_1.Field)(ED25519_P, undefined, true))();
const ed25519Defaults = /* @__PURE__ */ (() => ({
    // Param: a
    a: BigInt(-1), // Fp.create(-1) is proper; our way still works and is faster
    // d is equal to -121665/121666 over finite field.
    // Negative number is P - number, and division is invert(number, P)
    d: BigInt('37095705934669439343138083508754565189542113879843219016388785533085940283555'),
    // Finite field ùîΩp over which we'll do calculations; 2n**255n - 19n
    Fp,
    // Subgroup order: how many points curve has
    // 2n**252n + 27742317777372353535851937790883648493n;
    n: BigInt('7237005577332262213973186563042994240857116359379907606001950938285454250989'),
    // Cofactor
    h: _8n,
    // Base point (x, y) aka generator point
    Gx: BigInt('15112221349535400772501151409588531511454012693041857206046113283949847762202'),
    Gy: BigInt('46316835694926478169428394003475163141307993866256225615783033603165251855960'),
    hash: sha512_1.sha512,
    randomBytes: utils_1.randomBytes,
    adjustScalarBytes,
    // dom2
    // Ratio of u to v. Allows us to combine inversion and square root. Uses algo from RFC8032 5.1.3.
    // Constant-time, u/‚àöv
    uvRatio,
}))();
/**
 * ed25519 curve with EdDSA signatures.
 */
exports.ed25519 = (() => (0, edwards_js_1.twistedEdwards)(ed25519Defaults))();
function ed25519_domain(data, ctx, phflag) {
    if (ctx.length > 255)
        throw new Error('Context is too big');
    return (0, utils_1.concatBytes)((0, utils_1.utf8ToBytes)('SigEd25519 no Ed25519 collisions'), new Uint8Array([phflag ? 1 : 0, ctx.length]), ctx, data);
}
exports.ed25519ctx = (() => (0, edwards_js_1.twistedEdwards)({
    ...ed25519Defaults,
    domain: ed25519_domain,
}))();
exports.ed25519ph = (() => (0, edwards_js_1.twistedEdwards)(Object.assign({}, ed25519Defaults, {
    domain: ed25519_domain,
    prehash: sha512_1.sha512,
})))();
exports.x25519 = (() => (0, montgomery_js_1.montgomery)({
    P: ED25519_P,
    a: BigInt(486662),
    montgomeryBits: 255, // n is 253 bits
    nByteLength: 32,
    Gu: BigInt(9),
    powPminus2: (x) => {
        const P = ED25519_P;
        // x^(p-2) aka x^(2^255-21)
        const { pow_p_5_8, b2 } = ed25519_pow_2_252_3(x);
        return (0, modular_js_1.mod)((0, modular_js_1.pow2)(pow_p_5_8, _3n, P) * b2, P);
    },
    adjustScalarBytes,
    randomBytes: utils_1.randomBytes,
}))();
/**
 * Converts ed25519 public key to x25519 public key. Uses formula:
 * * `(u, v) = ((1+y)/(1-y), sqrt(-486664)*u/x)`
 * * `(x, y) = (sqrt(-486664)*u/v, (u-1)/(u+1))`
 * @example
 *   const someonesPub = ed25519.getPublicKey(ed25519.utils.randomPrivateKey());
 *   const aPriv = x25519.utils.randomPrivateKey();
 *   x25519.getSharedSecret(aPriv, edwardsToMontgomeryPub(someonesPub))
 */
function edwardsToMontgomeryPub(edwardsPub) {
    const { y } = exports.ed25519.ExtendedPoint.fromHex(edwardsPub);
    const _1n = BigInt(1);
    return Fp.toBytes(Fp.create((_1n + y) * Fp.inv(_1n - y)));
}
exports.edwardsToMontgomery = edwardsToMontgomeryPub; // deprecated
/**
 * Converts ed25519 secret key to x25519 secret key.
 * @example
 *   const someonesPub = x25519.getPublicKey(x25519.utils.randomPrivateKey());
 *   const aPriv = ed25519.utils.randomPrivateKey();
 *   x25519.getSharedSecret(edwardsToMontgomeryPriv(aPriv), someonesPub)
 */
function edwardsToMontgomeryPriv(edwardsPriv) {
    const hashed = ed25519Defaults.hash(edwardsPriv.subarray(0, 32));
    return ed25519Defaults.adjustScalarBytes(hashed).subarray(0, 32);
}
// Hash To Curve Elligator2 Map (NOTE: different from ristretto255 elligator)
// NOTE: very important part is usage of FpSqrtEven for ELL2_C1_EDWARDS, since
// SageMath returns different root first and everything falls apart
const ELL2_C1 = /* @__PURE__ */ (() => (Fp.ORDER + _3n) / _8n)(); // 1. c1 = (q + 3) / 8       # Integer arithmetic
const ELL2_C2 = /* @__PURE__ */ (() => Fp.pow(_2n, ELL2_C1))(); // 2. c2 = 2^c1
const ELL2_C3 = /* @__PURE__ */ (() => Fp.sqrt(Fp.neg(Fp.ONE)))(); // 3. c3 = sqrt(-1)
// prettier-ignore
function map_to_curve_elligator2_curve25519(u) {
    const ELL2_C4 = (Fp.ORDER - _5n) / _8n; // 4. c4 = (q - 5) / 8       # Integer arithmetic
    const ELL2_J = BigInt(486662);
    let tv1 = Fp.sqr(u); //  1.  tv1 = u^2
    tv1 = Fp.mul(tv1, _2n); //  2.  tv1 = 2 * tv1
    let xd = Fp.add(tv1, Fp.ONE); //  3.   xd = tv1 + 1         # Nonzero: -1 is square (mod p), tv1 is not
    let x1n = Fp.neg(ELL2_J); //  4.  x1n = -J              # x1 = x1n / xd = -J / (1 + 2 * u^2)
    let tv2 = Fp.sqr(xd); //  5.  tv2 = xd^2
    let gxd = Fp.mul(tv2, xd); //  6.  gxd = tv2 * xd        # gxd = xd^3
    let gx1 = Fp.mul(tv1, ELL2_J); //  7.  gx1 = J * tv1         # x1n + J * xd
    gx1 = Fp.mul(gx1, x1n); //  8.  gx1 = gx1 * x1n       # x1n^2 + J * x1n * xd
    gx1 = Fp.add(gx1, tv2); //  9.  gx1 = gx1 + tv2       # x1n^2 + J * x1n * xd + xd^2
    gx1 = Fp.mul(gx1, x1n); //  10. gx1 = gx1 * x1n       # x1n^3 + J * x1n^2 * xd + x1n * xd^2
    let tv3 = Fp.sqr(gxd); //  11. tv3 = gxd^2
    tv2 = Fp.sqr(tv3); //  12. tv2 = tv3^2           # gxd^4
    tv3 = Fp.mul(tv3, gxd); //  13. tv3 = tv3 * gxd       # gxd^3
    tv3 = Fp.mul(tv3, gx1); //  14. tv3 = tv3 * gx1       # gx1 * gxd^3
    tv2 = Fp.mul(tv2, tv3); //  15. tv2 = tv2 * tv3       # gx1 * gxd^7
    let y11 = Fp.pow(tv2, ELL2_C4); //  16. y11 = tv2^c4        # (gx1 * gxd^7)^((p - 5) / 8)
    y11 = Fp.mul(y11, tv3); //  17. y11 = y11 * tv3       # gx1*gxd^3*(gx1*gxd^7)^((p-5)/8)
    let y12 = Fp.mul(y11, ELL2_C3); //  18. y12 = y11 * c3
    tv2 = Fp.sqr(y11); //  19. tv2 = y11^2
    tv2 = Fp.mul(tv2, gxd); //  20. tv2 = tv2 * gxd
    let e1 = Fp.eql(tv2, gx1); //  21.  e1 = tv2 == gx1
    let y1 = Fp.cmov(y12, y11, e1); //  22.  y1 = CMOV(y12, y11, e1)  # If g(x1) is square, this is its sqrt
    let x2n = Fp.mul(x1n, tv1); //  23. x2n = x1n * tv1       # x2 = x2n / xd = 2 * u^2 * x1n / xd
    let y21 = Fp.mul(y11, u); //  24. y21 = y11 * u
    y21 = Fp.mul(y21, ELL2_C2); //  25. y21 = y21 * c2
    let y22 = Fp.mul(y21, ELL2_C3); //  26. y22 = y21 * c3
    let gx2 = Fp.mul(gx1, tv1); //  27. gx2 = gx1 * tv1       # g(x2) = gx2 / gxd = 2 * u^2 * g(x1)
    tv2 = Fp.sqr(y21); //  28. tv2 = y21^2
    tv2 = Fp.mul(tv2, gxd); //  29. tv2 = tv2 * gxd
    let e2 = Fp.eql(tv2, gx2); //  30.  e2 = tv2 == gx2
    let y2 = Fp.cmov(y22, y21, e2); //  31.  y2 = CMOV(y22, y21, e2)  # If g(x2) is square, this is its sqrt
    tv2 = Fp.sqr(y1); //  32. tv2 = y1^2
    tv2 = Fp.mul(tv2, gxd); //  33. tv2 = tv2 * gxd
    let e3 = Fp.eql(tv2, gx1); //  34.  e3 = tv2 == gx1
    let xn = Fp.cmov(x2n, x1n, e3); //  35.  xn = CMOV(x2n, x1n, e3)  # If e3, x = x1, else x = x2
    let y = Fp.cmov(y2, y1, e3); //  36.   y = CMOV(y2, y1, e3)    # If e3, y = y1, else y = y2
    let e4 = Fp.isOdd(y); //  37.  e4 = sgn0(y) == 1        # Fix sign of y
    y = Fp.cmov(y, Fp.neg(y), e3 !== e4); //  38.   y = CMOV(y, -y, e3 XOR e4)
    return { xMn: xn, xMd: xd, yMn: y, yMd: _1n }; //  39. return (xn, xd, y, 1)
}
const ELL2_C1_EDWARDS = /* @__PURE__ */ (() => (0, modular_js_1.FpSqrtEven)(Fp, Fp.neg(BigInt(486664))))(); // sgn0(c1) MUST equal 0
function map_to_curve_elligator2_edwards25519(u) {
    const { xMn, xMd, yMn, yMd } = map_to_curve_elligator2_curve25519(u); //  1.  (xMn, xMd, yMn, yMd) =
    // map_to_curve_elligator2_curve25519(u)
    let xn = Fp.mul(xMn, yMd); //  2.  xn = xMn * yMd
    xn = Fp.mul(xn, ELL2_C1_EDWARDS); //  3.  xn = xn * c1
    let xd = Fp.mul(xMd, yMn); //  4.  xd = xMd * yMn    # xn / xd = c1 * xM / yM
    let yn = Fp.sub(xMn, xMd); //  5.  yn = xMn - xMd
    let yd = Fp.add(xMn, xMd); //  6.  yd = xMn + xMd    # (n / d - 1) / (n / d + 1) = (n - d) / (n + d)
    let tv1 = Fp.mul(xd, yd); //  7. tv1 = xd * yd
    let e = Fp.eql(tv1, Fp.ZERO); //  8.   e = tv1 == 0
    xn = Fp.cmov(xn, Fp.ZERO, e); //  9.  xn = CMOV(xn, 0, e)
    xd = Fp.cmov(xd, Fp.ONE, e); //  10. xd = CMOV(xd, 1, e)
    yn = Fp.cmov(yn, Fp.ONE, e); //  11. yn = CMOV(yn, 1, e)
    yd = Fp.cmov(yd, Fp.ONE, e); //  12. yd = CMOV(yd, 1, e)
    const inv = Fp.invertBatch([xd, yd]); // batch division
    return { x: Fp.mul(xn, inv[0]), y: Fp.mul(yn, inv[1]) }; //  13. return (xn, xd, yn, yd)
}
const htf = /* @__PURE__ */ (() => (0, hash_to_curve_js_1.createHasher)(exports.ed25519.ExtendedPoint, (scalars) => map_to_curve_elligator2_edwards25519(scalars[0]), {
    DST: 'edwards25519_XMD:SHA-512_ELL2_RO_',
    encodeDST: 'edwards25519_XMD:SHA-512_ELL2_NU_',
    p: Fp.ORDER,
    m: 1,
    k: 128,
    expand: 'xmd',
    hash: sha512_1.sha512,
}))();
exports.hashToCurve = (() => htf.hashToCurve)();
exports.encodeToCurve = (() => htf.encodeToCurve)();
function assertRstPoint(other) {
    if (!(other instanceof RistPoint))
        throw new Error('RistrettoPoint expected');
}
// ‚àö(-1) aka ‚àö(a) aka 2^((p-1)/4)
const SQRT_M1 = ED25519_SQRT_M1;
// ‚àö(ad - 1)
const SQRT_AD_MINUS_ONE = /* @__PURE__ */ BigInt('25063068953384623474111414158702152701244531502492656460079210482610430750235');
// 1 / ‚àö(a-d)
const INVSQRT_A_MINUS_D = /* @__PURE__ */ BigInt('54469307008909316920995813868745141605393597292927456921205312896311721017578');
// 1-d¬≤
const ONE_MINUS_D_SQ = /* @__PURE__ */ BigInt('1159843021668779879193775521855586647937357759715417654439879720876111806838');
// (d-1)¬≤
const D_MINUS_ONE_SQ = /* @__PURE__ */ BigInt('40440834346308536858101042469323190826248399146238708352240133220865137265952');
// Calculates 1/‚àö(number)
const invertSqrt = (number) => uvRatio(_1n, number);
const MAX_255B = /* @__PURE__ */ BigInt('0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff');
const bytes255ToNumberLE = (bytes) => exports.ed25519.CURVE.Fp.create((0, utils_js_1.bytesToNumberLE)(bytes) & MAX_255B);
// Computes Elligator map for Ristretto
// https://ristretto.group/formulas/elligator.html
function calcElligatorRistrettoMap(r0) {
    const { d } = exports.ed25519.CURVE;
    const P = exports.ed25519.CURVE.Fp.ORDER;
    const mod = exports.ed25519.CURVE.Fp.create;
    const r = mod(SQRT_M1 * r0 * r0); // 1
    const Ns = mod((r + _1n) * ONE_MINUS_D_SQ); // 2
    let c = BigInt(-1); // 3
    const D = mod((c - d * r) * mod(r + d)); // 4
    let { isValid: Ns_D_is_sq, value: s } = uvRatio(Ns, D); // 5
    let s_ = mod(s * r0); // 6
    if (!(0, modular_js_1.isNegativeLE)(s_, P))
        s_ = mod(-s_);
    if (!Ns_D_is_sq)
        s = s_; // 7
    if (!Ns_D_is_sq)
        c = r; // 8
    const Nt = mod(c * (r - _1n) * D_MINUS_ONE_SQ - D); // 9
    const s2 = s * s;
    const W0 = mod((s + s) * D); // 10
    const W1 = mod(Nt * SQRT_AD_MINUS_ONE); // 11
    const W2 = mod(_1n - s2); // 12
    const W3 = mod(_1n + s2); // 13
    return new exports.ed25519.ExtendedPoint(mod(W0 * W3), mod(W2 * W1), mod(W1 * W3), mod(W0 * W2));
}
/**
 * Each ed25519/ExtendedPoint has 8 different equivalent points. This can be
 * a source of bugs for protocols like ring signatures. Ristretto was created to solve this.
 * Ristretto point operates in X:Y:Z:T extended coordinates like ExtendedPoint,
 * but it should work in its own namespace: do not combine those two.
 * https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-ristretto255-decaf448
 */
class RistPoint {
    // Private property to discourage combining ExtendedPoint + RistrettoPoint
    // Always use Ristretto encoding/decoding instead.
    constructor(ep) {
        this.ep = ep;
    }
    static fromAffine(ap) {
        return new RistPoint(exports.ed25519.ExtendedPoint.fromAffine(ap));
    }
    /**
     * Takes uniform output of 64-byte hash function like sha512 and converts it to `RistrettoPoint`.
     * The hash-to-group operation applies Elligator twice and adds the results.
     * **Note:** this is one-way map, there is no conversion from point to hash.
     * https://ristretto.group/formulas/elligator.html
     * @param hex 64-byte output of a hash function
     */
    static hashToCurve(hex) {
        hex = (0, utils_js_1.ensureBytes)('ristrettoHash', hex, 64);
        const r1 = bytes255ToNumberLE(hex.slice(0, 32));
        const R1 = calcElligatorRistrettoMap(r1);
        const r2 = bytes255ToNumberLE(hex.slice(32, 64));
        const R2 = calcElligatorRistrettoMap(r2);
        return new RistPoint(R1.add(R2));
    }
    /**
     * Converts ristretto-encoded string to ristretto point.
     * https://ristretto.group/formulas/decoding.html
     * @param hex Ristretto-encoded 32 bytes. Not every 32-byte string is valid ristretto encoding
     */
    static fromHex(hex) {
        hex = (0, utils_js_1.ensureBytes)('ristrettoHex', hex, 32);
        const { a, d } = exports.ed25519.CURVE;
        const P = exports.ed25519.CURVE.Fp.ORDER;
        const mod = exports.ed25519.CURVE.Fp.create;
        const emsg = 'RistrettoPoint.fromHex: the hex is not valid encoding of RistrettoPoint';
        const s = bytes255ToNumberLE(hex);
        // 1. Check that s_bytes is the canonical encoding of a field element, or else abort.
        // 3. Check that s is non-negative, or else abort
        if (!(0, utils_js_1.equalBytes)((0, utils_js_1.numberToBytesLE)(s, 32), hex) || (0, modular_js_1.isNegativeLE)(s, P))
            throw new Error(emsg);
        const s2 = mod(s * s);
        const u1 = mod(_1n + a * s2); // 4 (a is -1)
        const u2 = mod(_1n - a * s2); // 5
        const u1_2 = mod(u1 * u1);
        const u2_2 = mod(u2 * u2);
        const v = mod(a * d * u1_2 - u2_2); // 6
        const { isValid, value: I } = invertSqrt(mod(v * u2_2)); // 7
        const Dx = mod(I * u2); // 8
        const Dy = mod(I * Dx * v); // 9
        let x = mod((s + s) * Dx); // 10
        if ((0, modular_js_1.isNegativeLE)(x, P))
            x = mod(-x); // 10
        const y = mod(u1 * Dy); // 11
        const t = mod(x * y); // 12
        if (!isValid || (0, modular_js_1.isNegativeLE)(t, P) || y === _0n)
            throw new Error(emsg);
        return new RistPoint(new exports.ed25519.ExtendedPoint(x, y, _1n, t));
    }
    /**
     * Encodes ristretto point to Uint8Array.
     * https://ristretto.group/formulas/encoding.html
     */
    toRawBytes() {
        let { ex: x, ey: y, ez: z, et: t } = this.ep;
        const P = exports.ed25519.CURVE.Fp.ORDER;
        const mod = exports.ed25519.CURVE.Fp.create;
        const u1 = mod(mod(z + y) * mod(z - y)); // 1
        const u2 = mod(x * y); // 2
        // Square root always exists
        const u2sq = mod(u2 * u2);
        const { value: invsqrt } = invertSqrt(mod(u1 * u2sq)); // 3
        const D1 = mod(invsqrt * u1); // 4
        const D2 = mod(invsqrt * u2); // 5
        const zInv = mod(D1 * D2 * t); // 6
        let D; // 7
        if ((0, modular_js_1.isNegativeLE)(t * zInv, P)) {
            let _x = mod(y * SQRT_M1);
            let _y = mod(x * SQRT_M1);
            x = _x;
            y = _y;
            D = mod(D1 * INVSQRT_A_MINUS_D);
        }
        else {
            D = D2; // 8
        }
        if ((0, modular_js_1.isNegativeLE)(x * zInv, P))
            y = mod(-y); // 9
        let s = mod((z - y) * D); // 10 (check footer's note, no sqrt(-a))
        if ((0, modular_js_1.isNegativeLE)(s, P))
            s = mod(-s);
        return (0, utils_js_1.numberToBytesLE)(s, 32); // 11
    }
    toHex() {
        return (0, utils_js_1.bytesToHex)(this.toRawBytes());
    }
    toString() {
        return this.toHex();
    }
    // Compare one point to another.
    equals(other) {
        assertRstPoint(other);
        const { ex: X1, ey: Y1 } = this.ep;
        const { ex: X2, ey: Y2 } = other.ep;
        const mod = exports.ed25519.CURVE.Fp.create;
        // (x1 * y2 == y1 * x2) | (y1 * y2 == x1 * x2)
        const one = mod(X1 * Y2) === mod(Y1 * X2);
        const two = mod(Y1 * Y2) === mod(X1 * X2);
        return one || two;
    }
    add(other) {
        assertRstPoint(other);
        return new RistPoint(this.ep.add(other.ep));
    }
    subtract(other) {
        assertRstPoint(other);
        return new RistPoint(this.ep.subtract(other.ep));
    }
    multiply(scalar) {
        return new RistPoint(this.ep.multiply(scalar));
    }
    multiplyUnsafe(scalar) {
        return new RistPoint(this.ep.multiplyUnsafe(scalar));
    }
    double() {
        return new RistPoint(this.ep.double());
    }
    negate() {
        return new RistPoint(this.ep.negate());
    }
}
exports.RistrettoPoint = (() => {
    if (!RistPoint.BASE)
        RistPoint.BASE = new RistPoint(exports.ed25519.ExtendedPoint.BASE);
    if (!RistPoint.ZERO)
        RistPoint.ZERO = new RistPoint(exports.ed25519.ExtendedPoint.ZERO);
    return RistPoint;
})();
// Hashing to ristretto255. https://www.rfc-editor.org/rfc/rfc9380#appendix-B
const hashToRistretto255 = (msg, options) => {
    const d = options.DST;
    const DST = typeof d === 'string' ? (0, utils_1.utf8ToBytes)(d) : d;
    const uniform_bytes = (0, hash_to_curve_js_1.expand_message_xmd)(msg, DST, 64, sha512_1.sha512);
    const P = RistPoint.hashToCurve(uniform_bytes);
    return P;
};
exports.hashToRistretto255 = hashToRistretto255;
exports.hash_to_ristretto255 = exports.hashToRistretto255; // legacy
//# sourceMappingURL=ed25519.js.map

/***/ }),

/***/ 5897:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.encodeToCurve = exports.hashToCurve = exports.secp256r1 = exports.p256 = void 0;
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const sha256_1 = __webpack_require__(2623);
const _shortw_utils_js_1 = __webpack_require__(3562);
const hash_to_curve_js_1 = __webpack_require__(1761);
const modular_js_1 = __webpack_require__(4967);
const weierstrass_js_1 = __webpack_require__(1705);
// NIST secp256r1 aka p256
// https://www.secg.org/sec2-v2.pdf, https://neuromancer.sk/std/nist/P-256
const Fp = (0, modular_js_1.Field)(BigInt('0xffffffff00000001000000000000000000000000ffffffffffffffffffffffff'));
const CURVE_A = Fp.create(BigInt('-3'));
const CURVE_B = BigInt('0x5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b');
// prettier-ignore
exports.p256 = (0, _shortw_utils_js_1.createCurve)({
    a: CURVE_A, // Equation params: a, b
    b: CURVE_B,
    Fp, // Field: 2n**224n * (2n**32n-1n) + 2n**192n + 2n**96n-1n
    // Curve order, total count of valid points in the field
    n: BigInt('0xffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551'),
    // Base (generator) point (x, y)
    Gx: BigInt('0x6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296'),
    Gy: BigInt('0x4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f5'),
    h: BigInt(1),
    lowS: false,
}, sha256_1.sha256);
exports.secp256r1 = exports.p256;
const mapSWU = /* @__PURE__ */ (() => (0, weierstrass_js_1.mapToCurveSimpleSWU)(Fp, {
    A: CURVE_A,
    B: CURVE_B,
    Z: Fp.create(BigInt('-10')),
}))();
const htf = /* @__PURE__ */ (() => (0, hash_to_curve_js_1.createHasher)(exports.secp256r1.ProjectivePoint, (scalars) => mapSWU(scalars[0]), {
    DST: 'P256_XMD:SHA-256_SSWU_RO_',
    encodeDST: 'P256_XMD:SHA-256_SSWU_NU_',
    p: Fp.ORDER,
    m: 1,
    k: 128,
    expand: 'xmd',
    hash: sha256_1.sha256,
}))();
exports.hashToCurve = (() => htf.hashToCurve)();
exports.encodeToCurve = (() => htf.encodeToCurve)();
//# sourceMappingURL=p256.js.map

/***/ }),

/***/ 7557:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isBytes = isBytes;
exports.number = number;
exports.bool = bool;
exports.bytes = bytes;
exports.hash = hash;
exports.exists = exists;
exports.output = output;
function number(n) {
    if (!Number.isSafeInteger(n) || n < 0)
        throw new Error(`positive integer expected, not ${n}`);
}
function bool(b) {
    if (typeof b !== 'boolean')
        throw new Error(`boolean expected, not ${b}`);
}
// copied from utils
function isBytes(a) {
    return (a instanceof Uint8Array ||
        (a != null && typeof a === 'object' && a.constructor.name === 'Uint8Array'));
}
function bytes(b, ...lengths) {
    if (!isBytes(b))
        throw new Error('Uint8Array expected');
    if (lengths.length > 0 && !lengths.includes(b.length))
        throw new Error(`Uint8Array expected of length ${lengths}, not of length=${b.length}`);
}
function hash(h) {
    if (typeof h !== 'function' || typeof h.create !== 'function')
        throw new Error('Hash should be wrapped by utils.wrapConstructor');
    number(h.outputLen);
    number(h.blockLen);
}
function exists(instance, checkFinished = true) {
    if (instance.destroyed)
        throw new Error('Hash instance has been destroyed');
    if (checkFinished && instance.finished)
        throw new Error('Hash#digest() has already been called');
}
function output(out, instance) {
    bytes(out);
    const min = instance.outputLen;
    if (out.length < min) {
        throw new Error(`digestInto() expects output buffer of length at least ${min}`);
    }
}
const assert = { number, bool, bytes, hash, exists, output };
exports["default"] = assert;
//# sourceMappingURL=_assert.js.map

/***/ }),

/***/ 7202:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.HashMD = exports.Maj = exports.Chi = void 0;
const _assert_js_1 = __webpack_require__(7557);
const utils_js_1 = __webpack_require__(9175);
/**
 * Polyfill for Safari 14
 */
function setBigUint64(view, byteOffset, value, isLE) {
    if (typeof view.setBigUint64 === 'function')
        return view.setBigUint64(byteOffset, value, isLE);
    const _32n = BigInt(32);
    const _u32_max = BigInt(0xffffffff);
    const wh = Number((value >> _32n) & _u32_max);
    const wl = Number(value & _u32_max);
    const h = isLE ? 4 : 0;
    const l = isLE ? 0 : 4;
    view.setUint32(byteOffset + h, wh, isLE);
    view.setUint32(byteOffset + l, wl, isLE);
}
/**
 * Choice: a ? b : c
 */
const Chi = (a, b, c) => (a & b) ^ (~a & c);
exports.Chi = Chi;
/**
 * Majority function, true if any two inputs is true
 */
const Maj = (a, b, c) => (a & b) ^ (a & c) ^ (b & c);
exports.Maj = Maj;
/**
 * Merkle-Damgard hash construction base class.
 * Could be used to create MD5, RIPEMD, SHA1, SHA2.
 */
class HashMD extends utils_js_1.Hash {
    constructor(blockLen, outputLen, padOffset, isLE) {
        super();
        this.blockLen = blockLen;
        this.outputLen = outputLen;
        this.padOffset = padOffset;
        this.isLE = isLE;
        this.finished = false;
        this.length = 0;
        this.pos = 0;
        this.destroyed = false;
        this.buffer = new Uint8Array(blockLen);
        this.view = (0, utils_js_1.createView)(this.buffer);
    }
    update(data) {
        (0, _assert_js_1.exists)(this);
        const { view, buffer, blockLen } = this;
        data = (0, utils_js_1.toBytes)(data);
        const len = data.length;
        for (let pos = 0; pos < len;) {
            const take = Math.min(blockLen - this.pos, len - pos);
            // Fast path: we have at least one block in input, cast it to view and process
            if (take === blockLen) {
                const dataView = (0, utils_js_1.createView)(data);
                for (; blockLen <= len - pos; pos += blockLen)
                    this.process(dataView, pos);
                continue;
            }
            buffer.set(data.subarray(pos, pos + take), this.pos);
            this.pos += take;
            pos += take;
            if (this.pos === blockLen) {
                this.process(view, 0);
                this.pos = 0;
            }
        }
        this.length += data.length;
        this.roundClean();
        return this;
    }
    digestInto(out) {
        (0, _assert_js_1.exists)(this);
        (0, _assert_js_1.output)(out, this);
        this.finished = true;
        // Padding
        // We can avoid allocation of buffer for padding completely if it
        // was previously not allocated here. But it won't change performance.
        const { buffer, view, blockLen, isLE } = this;
        let { pos } = this;
        // append the bit '1' to the message
        buffer[pos++] = 0b10000000;
        this.buffer.subarray(pos).fill(0);
        // we have less than padOffset left in buffer, so we cannot put length in
        // current block, need process it and pad again
        if (this.padOffset > blockLen - pos) {
            this.process(view, 0);
            pos = 0;
        }
        // Pad until full block byte with zeros
        for (let i = pos; i < blockLen; i++)
            buffer[i] = 0;
        // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that
        // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.
        // So we just write lowest 64 bits of that value.
        setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);
        this.process(view, 0);
        const oview = (0, utils_js_1.createView)(out);
        const len = this.outputLen;
        // NOTE: we do division by 4 later, which should be fused in single op with modulo by JIT
        if (len % 4)
            throw new Error('_sha2: outputLen should be aligned to 32bit');
        const outLen = len / 4;
        const state = this.get();
        if (outLen > state.length)
            throw new Error('_sha2: outputLen bigger than state');
        for (let i = 0; i < outLen; i++)
            oview.setUint32(4 * i, state[i], isLE);
    }
    digest() {
        const { buffer, outputLen } = this;
        this.digestInto(buffer);
        const res = buffer.slice(0, outputLen);
        this.destroy();
        return res;
    }
    _cloneInto(to) {
        to || (to = new this.constructor());
        to.set(...this.get());
        const { blockLen, buffer, length, finished, destroyed, pos } = this;
        to.length = length;
        to.pos = pos;
        to.finished = finished;
        to.destroyed = destroyed;
        if (length % blockLen)
            to.buffer.set(buffer);
        return to;
    }
}
exports.HashMD = HashMD;
//# sourceMappingURL=_md.js.map

/***/ }),

/***/ 2318:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.add5L = exports.add5H = exports.add4H = exports.add4L = exports.add3H = exports.add3L = exports.rotlBL = exports.rotlBH = exports.rotlSL = exports.rotlSH = exports.rotr32L = exports.rotr32H = exports.rotrBL = exports.rotrBH = exports.rotrSL = exports.rotrSH = exports.shrSL = exports.shrSH = exports.toBig = void 0;
exports.fromBig = fromBig;
exports.split = split;
exports.add = add;
const U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);
const _32n = /* @__PURE__ */ BigInt(32);
// We are not using BigUint64Array, because they are extremely slow as per 2022
function fromBig(n, le = false) {
    if (le)
        return { h: Number(n & U32_MASK64), l: Number((n >> _32n) & U32_MASK64) };
    return { h: Number((n >> _32n) & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };
}
function split(lst, le = false) {
    let Ah = new Uint32Array(lst.length);
    let Al = new Uint32Array(lst.length);
    for (let i = 0; i < lst.length; i++) {
        const { h, l } = fromBig(lst[i], le);
        [Ah[i], Al[i]] = [h, l];
    }
    return [Ah, Al];
}
const toBig = (h, l) => (BigInt(h >>> 0) << _32n) | BigInt(l >>> 0);
exports.toBig = toBig;
// for Shift in [0, 32)
const shrSH = (h, _l, s) => h >>> s;
exports.shrSH = shrSH;
const shrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);
exports.shrSL = shrSL;
// Right rotate for Shift in [1, 32)
const rotrSH = (h, l, s) => (h >>> s) | (l << (32 - s));
exports.rotrSH = rotrSH;
const rotrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);
exports.rotrSL = rotrSL;
// Right rotate for Shift in (32, 64), NOTE: 32 is special case.
const rotrBH = (h, l, s) => (h << (64 - s)) | (l >>> (s - 32));
exports.rotrBH = rotrBH;
const rotrBL = (h, l, s) => (h >>> (s - 32)) | (l << (64 - s));
exports.rotrBL = rotrBL;
// Right rotate for shift===32 (just swaps l&h)
const rotr32H = (_h, l) => l;
exports.rotr32H = rotr32H;
const rotr32L = (h, _l) => h;
exports.rotr32L = rotr32L;
// Left rotate for Shift in [1, 32)
const rotlSH = (h, l, s) => (h << s) | (l >>> (32 - s));
exports.rotlSH = rotlSH;
const rotlSL = (h, l, s) => (l << s) | (h >>> (32 - s));
exports.rotlSL = rotlSL;
// Left rotate for Shift in (32, 64), NOTE: 32 is special case.
const rotlBH = (h, l, s) => (l << (s - 32)) | (h >>> (64 - s));
exports.rotlBH = rotlBH;
const rotlBL = (h, l, s) => (h << (s - 32)) | (l >>> (64 - s));
exports.rotlBL = rotlBL;
// JS uses 32-bit signed integers for bitwise operations which means we cannot
// simple take carry out of low bit sum by shift, we need to use division.
function add(Ah, Al, Bh, Bl) {
    const l = (Al >>> 0) + (Bl >>> 0);
    return { h: (Ah + Bh + ((l / 2 ** 32) | 0)) | 0, l: l | 0 };
}
// Addition with more than 2 elements
const add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);
exports.add3L = add3L;
const add3H = (low, Ah, Bh, Ch) => (Ah + Bh + Ch + ((low / 2 ** 32) | 0)) | 0;
exports.add3H = add3H;
const add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);
exports.add4L = add4L;
const add4H = (low, Ah, Bh, Ch, Dh) => (Ah + Bh + Ch + Dh + ((low / 2 ** 32) | 0)) | 0;
exports.add4H = add4H;
const add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);
exports.add5L = add5L;
const add5H = (low, Ah, Bh, Ch, Dh, Eh) => (Ah + Bh + Ch + Dh + Eh + ((low / 2 ** 32) | 0)) | 0;
exports.add5H = add5H;
// prettier-ignore
const u64 = {
    fromBig, split, toBig,
    shrSH, shrSL,
    rotrSH, rotrSL, rotrBH, rotrBL,
    rotr32H, rotr32L,
    rotlSH, rotlSL, rotlBH, rotlBL,
    add, add3L, add3H, add4L, add4H, add5H, add5L,
};
exports["default"] = u64;
//# sourceMappingURL=_u64.js.map

/***/ }),

/***/ 6125:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.crypto = void 0;
// We prefer WebCrypto aka globalThis.crypto, which exists in node.js 16+.
// Falls back to Node.js built-in crypto for Node.js <=v14
// See utils.ts for details.
// @ts-ignore
const nc = __webpack_require__(7598);
exports.crypto = nc && typeof nc === 'object' && 'webcrypto' in nc
    ? nc.webcrypto
    : nc && typeof nc === 'object' && 'randomBytes' in nc
        ? nc
        : undefined;
//# sourceMappingURL=cryptoNode.js.map

/***/ }),

/***/ 9615:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.hmac = exports.HMAC = void 0;
const _assert_js_1 = __webpack_require__(7557);
const utils_js_1 = __webpack_require__(9175);
// HMAC (RFC 2104)
class HMAC extends utils_js_1.Hash {
    constructor(hash, _key) {
        super();
        this.finished = false;
        this.destroyed = false;
        (0, _assert_js_1.hash)(hash);
        const key = (0, utils_js_1.toBytes)(_key);
        this.iHash = hash.create();
        if (typeof this.iHash.update !== 'function')
            throw new Error('Expected instance of class which extends utils.Hash');
        this.blockLen = this.iHash.blockLen;
        this.outputLen = this.iHash.outputLen;
        const blockLen = this.blockLen;
        const pad = new Uint8Array(blockLen);
        // blockLen can be bigger than outputLen
        pad.set(key.length > blockLen ? hash.create().update(key).digest() : key);
        for (let i = 0; i < pad.length; i++)
            pad[i] ^= 0x36;
        this.iHash.update(pad);
        // By doing update (processing of first block) of outer hash here we can re-use it between multiple calls via clone
        this.oHash = hash.create();
        // Undo internal XOR && apply outer XOR
        for (let i = 0; i < pad.length; i++)
            pad[i] ^= 0x36 ^ 0x5c;
        this.oHash.update(pad);
        pad.fill(0);
    }
    update(buf) {
        (0, _assert_js_1.exists)(this);
        this.iHash.update(buf);
        return this;
    }
    digestInto(out) {
        (0, _assert_js_1.exists)(this);
        (0, _assert_js_1.bytes)(out, this.outputLen);
        this.finished = true;
        this.iHash.digestInto(out);
        this.oHash.update(out);
        this.oHash.digestInto(out);
        this.destroy();
    }
    digest() {
        const out = new Uint8Array(this.oHash.outputLen);
        this.digestInto(out);
        return out;
    }
    _cloneInto(to) {
        // Create new instance without calling constructor since key already in state and we don't know it.
        to || (to = Object.create(Object.getPrototypeOf(this), {}));
        const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;
        to = to;
        to.finished = finished;
        to.destroyed = destroyed;
        to.blockLen = blockLen;
        to.outputLen = outputLen;
        to.oHash = oHash._cloneInto(to.oHash);
        to.iHash = iHash._cloneInto(to.iHash);
        return to;
    }
    destroy() {
        this.destroyed = true;
        this.oHash.destroy();
        this.iHash.destroy();
    }
}
exports.HMAC = HMAC;
/**
 * HMAC: RFC2104 message authentication code.
 * @param hash - function that would be used e.g. sha256
 * @param key - message key
 * @param message - message data
 * @example
 * import { hmac } from '@noble/hashes/hmac';
 * import { sha256 } from '@noble/hashes/sha2';
 * const mac1 = hmac(sha256, 'key', 'message');
 */
const hmac = (hash, key, message) => new HMAC(hash, key).update(message).digest();
exports.hmac = hmac;
exports.hmac.create = (hash, key) => new HMAC(hash, key);
//# sourceMappingURL=hmac.js.map

/***/ }),

/***/ 2623:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.sha224 = exports.sha256 = exports.SHA256 = void 0;
const _md_js_1 = __webpack_require__(7202);
const utils_js_1 = __webpack_require__(9175);
// SHA2-256 need to try 2^128 hashes to execute birthday attack.
// BTC network is doing 2^67 hashes/sec as per early 2023.
// Round constants:
// first 32 bits of the fractional parts of the cube roots of the first 64 primes 2..311)
// prettier-ignore
const SHA256_K = /* @__PURE__ */ new Uint32Array([
    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
    0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
    0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
    0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
    0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2
]);
// Initial state:
// first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19
// prettier-ignore
const SHA256_IV = /* @__PURE__ */ new Uint32Array([
    0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19
]);
// Temporary buffer, not used to store anything between runs
// Named this way because it matches specification.
const SHA256_W = /* @__PURE__ */ new Uint32Array(64);
class SHA256 extends _md_js_1.HashMD {
    constructor() {
        super(64, 32, 8, false);
        // We cannot use array here since array allows indexing by variable
        // which means optimizer/compiler cannot use registers.
        this.A = SHA256_IV[0] | 0;
        this.B = SHA256_IV[1] | 0;
        this.C = SHA256_IV[2] | 0;
        this.D = SHA256_IV[3] | 0;
        this.E = SHA256_IV[4] | 0;
        this.F = SHA256_IV[5] | 0;
        this.G = SHA256_IV[6] | 0;
        this.H = SHA256_IV[7] | 0;
    }
    get() {
        const { A, B, C, D, E, F, G, H } = this;
        return [A, B, C, D, E, F, G, H];
    }
    // prettier-ignore
    set(A, B, C, D, E, F, G, H) {
        this.A = A | 0;
        this.B = B | 0;
        this.C = C | 0;
        this.D = D | 0;
        this.E = E | 0;
        this.F = F | 0;
        this.G = G | 0;
        this.H = H | 0;
    }
    process(view, offset) {
        // Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array
        for (let i = 0; i < 16; i++, offset += 4)
            SHA256_W[i] = view.getUint32(offset, false);
        for (let i = 16; i < 64; i++) {
            const W15 = SHA256_W[i - 15];
            const W2 = SHA256_W[i - 2];
            const s0 = (0, utils_js_1.rotr)(W15, 7) ^ (0, utils_js_1.rotr)(W15, 18) ^ (W15 >>> 3);
            const s1 = (0, utils_js_1.rotr)(W2, 17) ^ (0, utils_js_1.rotr)(W2, 19) ^ (W2 >>> 10);
            SHA256_W[i] = (s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16]) | 0;
        }
        // Compression function main loop, 64 rounds
        let { A, B, C, D, E, F, G, H } = this;
        for (let i = 0; i < 64; i++) {
            const sigma1 = (0, utils_js_1.rotr)(E, 6) ^ (0, utils_js_1.rotr)(E, 11) ^ (0, utils_js_1.rotr)(E, 25);
            const T1 = (H + sigma1 + (0, _md_js_1.Chi)(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;
            const sigma0 = (0, utils_js_1.rotr)(A, 2) ^ (0, utils_js_1.rotr)(A, 13) ^ (0, utils_js_1.rotr)(A, 22);
            const T2 = (sigma0 + (0, _md_js_1.Maj)(A, B, C)) | 0;
            H = G;
            G = F;
            F = E;
            E = (D + T1) | 0;
            D = C;
            C = B;
            B = A;
            A = (T1 + T2) | 0;
        }
        // Add the compressed chunk to the current hash value
        A = (A + this.A) | 0;
        B = (B + this.B) | 0;
        C = (C + this.C) | 0;
        D = (D + this.D) | 0;
        E = (E + this.E) | 0;
        F = (F + this.F) | 0;
        G = (G + this.G) | 0;
        H = (H + this.H) | 0;
        this.set(A, B, C, D, E, F, G, H);
    }
    roundClean() {
        SHA256_W.fill(0);
    }
    destroy() {
        this.set(0, 0, 0, 0, 0, 0, 0, 0);
        this.buffer.fill(0);
    }
}
exports.SHA256 = SHA256;
// Constants from https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf
class SHA224 extends SHA256 {
    constructor() {
        super();
        this.A = 0xc1059ed8 | 0;
        this.B = 0x367cd507 | 0;
        this.C = 0x3070dd17 | 0;
        this.D = 0xf70e5939 | 0;
        this.E = 0xffc00b31 | 0;
        this.F = 0x68581511 | 0;
        this.G = 0x64f98fa7 | 0;
        this.H = 0xbefa4fa4 | 0;
        this.outputLen = 28;
    }
}
/**
 * SHA2-256 hash function
 * @param message - data that would be hashed
 */
exports.sha256 = (0, utils_js_1.wrapConstructor)(() => new SHA256());
/**
 * SHA2-224 hash function
 */
exports.sha224 = (0, utils_js_1.wrapConstructor)(() => new SHA224());
//# sourceMappingURL=sha256.js.map

/***/ }),

/***/ 102:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.sha384 = exports.sha512_256 = exports.sha512_224 = exports.sha512 = exports.SHA384 = exports.SHA512_256 = exports.SHA512_224 = exports.SHA512 = void 0;
const _md_js_1 = __webpack_require__(7202);
const _u64_js_1 = __webpack_require__(2318);
const utils_js_1 = __webpack_require__(9175);
// Round contants (first 32 bits of the fractional parts of the cube roots of the first 80 primes 2..409):
// prettier-ignore
const [SHA512_Kh, SHA512_Kl] = /* @__PURE__ */ (() => _u64_js_1.default.split([
    '0x428a2f98d728ae22', '0x7137449123ef65cd', '0xb5c0fbcfec4d3b2f', '0xe9b5dba58189dbbc',
    '0x3956c25bf348b538', '0x59f111f1b605d019', '0x923f82a4af194f9b', '0xab1c5ed5da6d8118',
    '0xd807aa98a3030242', '0x12835b0145706fbe', '0x243185be4ee4b28c', '0x550c7dc3d5ffb4e2',
    '0x72be5d74f27b896f', '0x80deb1fe3b1696b1', '0x9bdc06a725c71235', '0xc19bf174cf692694',
    '0xe49b69c19ef14ad2', '0xefbe4786384f25e3', '0x0fc19dc68b8cd5b5', '0x240ca1cc77ac9c65',
    '0x2de92c6f592b0275', '0x4a7484aa6ea6e483', '0x5cb0a9dcbd41fbd4', '0x76f988da831153b5',
    '0x983e5152ee66dfab', '0xa831c66d2db43210', '0xb00327c898fb213f', '0xbf597fc7beef0ee4',
    '0xc6e00bf33da88fc2', '0xd5a79147930aa725', '0x06ca6351e003826f', '0x142929670a0e6e70',
    '0x27b70a8546d22ffc', '0x2e1b21385c26c926', '0x4d2c6dfc5ac42aed', '0x53380d139d95b3df',
    '0x650a73548baf63de', '0x766a0abb3c77b2a8', '0x81c2c92e47edaee6', '0x92722c851482353b',
    '0xa2bfe8a14cf10364', '0xa81a664bbc423001', '0xc24b8b70d0f89791', '0xc76c51a30654be30',
    '0xd192e819d6ef5218', '0xd69906245565a910', '0xf40e35855771202a', '0x106aa07032bbd1b8',
    '0x19a4c116b8d2d0c8', '0x1e376c085141ab53', '0x2748774cdf8eeb99', '0x34b0bcb5e19b48a8',
    '0x391c0cb3c5c95a63', '0x4ed8aa4ae3418acb', '0x5b9cca4f7763e373', '0x682e6ff3d6b2b8a3',
    '0x748f82ee5defb2fc', '0x78a5636f43172f60', '0x84c87814a1f0ab72', '0x8cc702081a6439ec',
    '0x90befffa23631e28', '0xa4506cebde82bde9', '0xbef9a3f7b2c67915', '0xc67178f2e372532b',
    '0xca273eceea26619c', '0xd186b8c721c0c207', '0xeada7dd6cde0eb1e', '0xf57d4f7fee6ed178',
    '0x06f067aa72176fba', '0x0a637dc5a2c898a6', '0x113f9804bef90dae', '0x1b710b35131c471b',
    '0x28db77f523047d84', '0x32caab7b40c72493', '0x3c9ebe0a15c9bebc', '0x431d67c49c100d4c',
    '0x4cc5d4becb3e42b6', '0x597f299cfc657e2a', '0x5fcb6fab3ad6faec', '0x6c44198c4a475817'
].map(n => BigInt(n))))();
// Temporary buffer, not used to store anything between runs
const SHA512_W_H = /* @__PURE__ */ new Uint32Array(80);
const SHA512_W_L = /* @__PURE__ */ new Uint32Array(80);
class SHA512 extends _md_js_1.HashMD {
    constructor() {
        super(128, 64, 16, false);
        // We cannot use array here since array allows indexing by variable which means optimizer/compiler cannot use registers.
        // Also looks cleaner and easier to verify with spec.
        // Initial state (first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19):
        // h -- high 32 bits, l -- low 32 bits
        this.Ah = 0x6a09e667 | 0;
        this.Al = 0xf3bcc908 | 0;
        this.Bh = 0xbb67ae85 | 0;
        this.Bl = 0x84caa73b | 0;
        this.Ch = 0x3c6ef372 | 0;
        this.Cl = 0xfe94f82b | 0;
        this.Dh = 0xa54ff53a | 0;
        this.Dl = 0x5f1d36f1 | 0;
        this.Eh = 0x510e527f | 0;
        this.El = 0xade682d1 | 0;
        this.Fh = 0x9b05688c | 0;
        this.Fl = 0x2b3e6c1f | 0;
        this.Gh = 0x1f83d9ab | 0;
        this.Gl = 0xfb41bd6b | 0;
        this.Hh = 0x5be0cd19 | 0;
        this.Hl = 0x137e2179 | 0;
    }
    // prettier-ignore
    get() {
        const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
        return [Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];
    }
    // prettier-ignore
    set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {
        this.Ah = Ah | 0;
        this.Al = Al | 0;
        this.Bh = Bh | 0;
        this.Bl = Bl | 0;
        this.Ch = Ch | 0;
        this.Cl = Cl | 0;
        this.Dh = Dh | 0;
        this.Dl = Dl | 0;
        this.Eh = Eh | 0;
        this.El = El | 0;
        this.Fh = Fh | 0;
        this.Fl = Fl | 0;
        this.Gh = Gh | 0;
        this.Gl = Gl | 0;
        this.Hh = Hh | 0;
        this.Hl = Hl | 0;
    }
    process(view, offset) {
        // Extend the first 16 words into the remaining 64 words w[16..79] of the message schedule array
        for (let i = 0; i < 16; i++, offset += 4) {
            SHA512_W_H[i] = view.getUint32(offset);
            SHA512_W_L[i] = view.getUint32((offset += 4));
        }
        for (let i = 16; i < 80; i++) {
            // s0 := (w[i-15] rightrotate 1) xor (w[i-15] rightrotate 8) xor (w[i-15] rightshift 7)
            const W15h = SHA512_W_H[i - 15] | 0;
            const W15l = SHA512_W_L[i - 15] | 0;
            const s0h = _u64_js_1.default.rotrSH(W15h, W15l, 1) ^ _u64_js_1.default.rotrSH(W15h, W15l, 8) ^ _u64_js_1.default.shrSH(W15h, W15l, 7);
            const s0l = _u64_js_1.default.rotrSL(W15h, W15l, 1) ^ _u64_js_1.default.rotrSL(W15h, W15l, 8) ^ _u64_js_1.default.shrSL(W15h, W15l, 7);
            // s1 := (w[i-2] rightrotate 19) xor (w[i-2] rightrotate 61) xor (w[i-2] rightshift 6)
            const W2h = SHA512_W_H[i - 2] | 0;
            const W2l = SHA512_W_L[i - 2] | 0;
            const s1h = _u64_js_1.default.rotrSH(W2h, W2l, 19) ^ _u64_js_1.default.rotrBH(W2h, W2l, 61) ^ _u64_js_1.default.shrSH(W2h, W2l, 6);
            const s1l = _u64_js_1.default.rotrSL(W2h, W2l, 19) ^ _u64_js_1.default.rotrBL(W2h, W2l, 61) ^ _u64_js_1.default.shrSL(W2h, W2l, 6);
            // SHA256_W[i] = s0 + s1 + SHA256_W[i - 7] + SHA256_W[i - 16];
            const SUMl = _u64_js_1.default.add4L(s0l, s1l, SHA512_W_L[i - 7], SHA512_W_L[i - 16]);
            const SUMh = _u64_js_1.default.add4H(SUMl, s0h, s1h, SHA512_W_H[i - 7], SHA512_W_H[i - 16]);
            SHA512_W_H[i] = SUMh | 0;
            SHA512_W_L[i] = SUMl | 0;
        }
        let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
        // Compression function main loop, 80 rounds
        for (let i = 0; i < 80; i++) {
            // S1 := (e rightrotate 14) xor (e rightrotate 18) xor (e rightrotate 41)
            const sigma1h = _u64_js_1.default.rotrSH(Eh, El, 14) ^ _u64_js_1.default.rotrSH(Eh, El, 18) ^ _u64_js_1.default.rotrBH(Eh, El, 41);
            const sigma1l = _u64_js_1.default.rotrSL(Eh, El, 14) ^ _u64_js_1.default.rotrSL(Eh, El, 18) ^ _u64_js_1.default.rotrBL(Eh, El, 41);
            //const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;
            const CHIh = (Eh & Fh) ^ (~Eh & Gh);
            const CHIl = (El & Fl) ^ (~El & Gl);
            // T1 = H + sigma1 + Chi(E, F, G) + SHA512_K[i] + SHA512_W[i]
            // prettier-ignore
            const T1ll = _u64_js_1.default.add5L(Hl, sigma1l, CHIl, SHA512_Kl[i], SHA512_W_L[i]);
            const T1h = _u64_js_1.default.add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i], SHA512_W_H[i]);
            const T1l = T1ll | 0;
            // S0 := (a rightrotate 28) xor (a rightrotate 34) xor (a rightrotate 39)
            const sigma0h = _u64_js_1.default.rotrSH(Ah, Al, 28) ^ _u64_js_1.default.rotrBH(Ah, Al, 34) ^ _u64_js_1.default.rotrBH(Ah, Al, 39);
            const sigma0l = _u64_js_1.default.rotrSL(Ah, Al, 28) ^ _u64_js_1.default.rotrBL(Ah, Al, 34) ^ _u64_js_1.default.rotrBL(Ah, Al, 39);
            const MAJh = (Ah & Bh) ^ (Ah & Ch) ^ (Bh & Ch);
            const MAJl = (Al & Bl) ^ (Al & Cl) ^ (Bl & Cl);
            Hh = Gh | 0;
            Hl = Gl | 0;
            Gh = Fh | 0;
            Gl = Fl | 0;
            Fh = Eh | 0;
            Fl = El | 0;
            ({ h: Eh, l: El } = _u64_js_1.default.add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));
            Dh = Ch | 0;
            Dl = Cl | 0;
            Ch = Bh | 0;
            Cl = Bl | 0;
            Bh = Ah | 0;
            Bl = Al | 0;
            const All = _u64_js_1.default.add3L(T1l, sigma0l, MAJl);
            Ah = _u64_js_1.default.add3H(All, T1h, sigma0h, MAJh);
            Al = All | 0;
        }
        // Add the compressed chunk to the current hash value
        ({ h: Ah, l: Al } = _u64_js_1.default.add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));
        ({ h: Bh, l: Bl } = _u64_js_1.default.add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));
        ({ h: Ch, l: Cl } = _u64_js_1.default.add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));
        ({ h: Dh, l: Dl } = _u64_js_1.default.add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));
        ({ h: Eh, l: El } = _u64_js_1.default.add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));
        ({ h: Fh, l: Fl } = _u64_js_1.default.add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));
        ({ h: Gh, l: Gl } = _u64_js_1.default.add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));
        ({ h: Hh, l: Hl } = _u64_js_1.default.add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));
        this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);
    }
    roundClean() {
        SHA512_W_H.fill(0);
        SHA512_W_L.fill(0);
    }
    destroy() {
        this.buffer.fill(0);
        this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    }
}
exports.SHA512 = SHA512;
class SHA512_224 extends SHA512 {
    constructor() {
        super();
        // h -- high 32 bits, l -- low 32 bits
        this.Ah = 0x8c3d37c8 | 0;
        this.Al = 0x19544da2 | 0;
        this.Bh = 0x73e19966 | 0;
        this.Bl = 0x89dcd4d6 | 0;
        this.Ch = 0x1dfab7ae | 0;
        this.Cl = 0x32ff9c82 | 0;
        this.Dh = 0x679dd514 | 0;
        this.Dl = 0x582f9fcf | 0;
        this.Eh = 0x0f6d2b69 | 0;
        this.El = 0x7bd44da8 | 0;
        this.Fh = 0x77e36f73 | 0;
        this.Fl = 0x04c48942 | 0;
        this.Gh = 0x3f9d85a8 | 0;
        this.Gl = 0x6a1d36c8 | 0;
        this.Hh = 0x1112e6ad | 0;
        this.Hl = 0x91d692a1 | 0;
        this.outputLen = 28;
    }
}
exports.SHA512_224 = SHA512_224;
class SHA512_256 extends SHA512 {
    constructor() {
        super();
        // h -- high 32 bits, l -- low 32 bits
        this.Ah = 0x22312194 | 0;
        this.Al = 0xfc2bf72c | 0;
        this.Bh = 0x9f555fa3 | 0;
        this.Bl = 0xc84c64c2 | 0;
        this.Ch = 0x2393b86b | 0;
        this.Cl = 0x6f53b151 | 0;
        this.Dh = 0x96387719 | 0;
        this.Dl = 0x5940eabd | 0;
        this.Eh = 0x96283ee2 | 0;
        this.El = 0xa88effe3 | 0;
        this.Fh = 0xbe5e1e25 | 0;
        this.Fl = 0x53863992 | 0;
        this.Gh = 0x2b0199fc | 0;
        this.Gl = 0x2c85b8aa | 0;
        this.Hh = 0x0eb72ddc | 0;
        this.Hl = 0x81c52ca2 | 0;
        this.outputLen = 32;
    }
}
exports.SHA512_256 = SHA512_256;
class SHA384 extends SHA512 {
    constructor() {
        super();
        // h -- high 32 bits, l -- low 32 bits
        this.Ah = 0xcbbb9d5d | 0;
        this.Al = 0xc1059ed8 | 0;
        this.Bh = 0x629a292a | 0;
        this.Bl = 0x367cd507 | 0;
        this.Ch = 0x9159015a | 0;
        this.Cl = 0x3070dd17 | 0;
        this.Dh = 0x152fecd8 | 0;
        this.Dl = 0xf70e5939 | 0;
        this.Eh = 0x67332667 | 0;
        this.El = 0xffc00b31 | 0;
        this.Fh = 0x8eb44a87 | 0;
        this.Fl = 0x68581511 | 0;
        this.Gh = 0xdb0c2e0d | 0;
        this.Gl = 0x64f98fa7 | 0;
        this.Hh = 0x47b5481d | 0;
        this.Hl = 0xbefa4fa4 | 0;
        this.outputLen = 48;
    }
}
exports.SHA384 = SHA384;
exports.sha512 = (0, utils_js_1.wrapConstructor)(() => new SHA512());
exports.sha512_224 = (0, utils_js_1.wrapConstructor)(() => new SHA512_224());
exports.sha512_256 = (0, utils_js_1.wrapConstructor)(() => new SHA512_256());
exports.sha384 = (0, utils_js_1.wrapConstructor)(() => new SHA384());
//# sourceMappingURL=sha512.js.map

/***/ }),

/***/ 9175:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Hash = exports.nextTick = exports.byteSwapIfBE = exports.byteSwap = exports.isLE = exports.rotl = exports.rotr = exports.createView = exports.u32 = exports.u8 = void 0;
exports.isBytes = isBytes;
exports.byteSwap32 = byteSwap32;
exports.bytesToHex = bytesToHex;
exports.hexToBytes = hexToBytes;
exports.asyncLoop = asyncLoop;
exports.utf8ToBytes = utf8ToBytes;
exports.toBytes = toBytes;
exports.concatBytes = concatBytes;
exports.checkOpts = checkOpts;
exports.wrapConstructor = wrapConstructor;
exports.wrapConstructorWithOpts = wrapConstructorWithOpts;
exports.wrapXOFConstructorWithOpts = wrapXOFConstructorWithOpts;
exports.randomBytes = randomBytes;
// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.
// node.js versions earlier than v19 don't declare it in global scope.
// For node.js, package.json#exports field mapping rewrites import
// from `crypto` to `cryptoNode`, which imports native module.
// Makes the utils un-importable in browsers without a bundler.
// Once node.js 18 is deprecated (2025-04-30), we can just drop the import.
const crypto_1 = __webpack_require__(6125);
const _assert_js_1 = __webpack_require__(7557);
// export { isBytes } from './_assert.js';
// We can't reuse isBytes from _assert, because somehow this causes huge perf issues
function isBytes(a) {
    return (a instanceof Uint8Array ||
        (a != null && typeof a === 'object' && a.constructor.name === 'Uint8Array'));
}
// Cast array to different type
const u8 = (arr) => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);
exports.u8 = u8;
const u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
exports.u32 = u32;
// Cast array to view
const createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
exports.createView = createView;
// The rotate right (circular right shift) operation for uint32
const rotr = (word, shift) => (word << (32 - shift)) | (word >>> shift);
exports.rotr = rotr;
// The rotate left (circular left shift) operation for uint32
const rotl = (word, shift) => (word << shift) | ((word >>> (32 - shift)) >>> 0);
exports.rotl = rotl;
exports.isLE = new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44;
// The byte swap operation for uint32
const byteSwap = (word) => ((word << 24) & 0xff000000) |
    ((word << 8) & 0xff0000) |
    ((word >>> 8) & 0xff00) |
    ((word >>> 24) & 0xff);
exports.byteSwap = byteSwap;
// Conditionally byte swap if on a big-endian platform
exports.byteSwapIfBE = exports.isLE ? (n) => n : (n) => (0, exports.byteSwap)(n);
// In place byte swap for Uint32Array
function byteSwap32(arr) {
    for (let i = 0; i < arr.length; i++) {
        arr[i] = (0, exports.byteSwap)(arr[i]);
    }
}
// Array where index 0xf0 (240) is mapped to string 'f0'
const hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, '0'));
/**
 * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'
 */
function bytesToHex(bytes) {
    (0, _assert_js_1.bytes)(bytes);
    // pre-caching improves the speed 6x
    let hex = '';
    for (let i = 0; i < bytes.length; i++) {
        hex += hexes[bytes[i]];
    }
    return hex;
}
// We use optimized technique to convert hex string to byte array
const asciis = { _0: 48, _9: 57, _A: 65, _F: 70, _a: 97, _f: 102 };
function asciiToBase16(char) {
    if (char >= asciis._0 && char <= asciis._9)
        return char - asciis._0;
    if (char >= asciis._A && char <= asciis._F)
        return char - (asciis._A - 10);
    if (char >= asciis._a && char <= asciis._f)
        return char - (asciis._a - 10);
    return;
}
/**
 * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])
 */
function hexToBytes(hex) {
    if (typeof hex !== 'string')
        throw new Error('hex string expected, got ' + typeof hex);
    const hl = hex.length;
    const al = hl / 2;
    if (hl % 2)
        throw new Error('padded hex string expected, got unpadded hex of length ' + hl);
    const array = new Uint8Array(al);
    for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {
        const n1 = asciiToBase16(hex.charCodeAt(hi));
        const n2 = asciiToBase16(hex.charCodeAt(hi + 1));
        if (n1 === undefined || n2 === undefined) {
            const char = hex[hi] + hex[hi + 1];
            throw new Error('hex string expected, got non-hex character "' + char + '" at index ' + hi);
        }
        array[ai] = n1 * 16 + n2;
    }
    return array;
}
// There is no setImmediate in browser and setTimeout is slow.
// call of async fn will return Promise, which will be fullfiled only on
// next scheduler queue processing step and this is exactly what we need.
const nextTick = async () => { };
exports.nextTick = nextTick;
// Returns control to thread each 'tick' ms to avoid blocking
async function asyncLoop(iters, tick, cb) {
    let ts = Date.now();
    for (let i = 0; i < iters; i++) {
        cb(i);
        // Date.now() is not monotonic, so in case if clock goes backwards we return return control too
        const diff = Date.now() - ts;
        if (diff >= 0 && diff < tick)
            continue;
        await (0, exports.nextTick)();
        ts += diff;
    }
}
/**
 * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])
 */
function utf8ToBytes(str) {
    if (typeof str !== 'string')
        throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809
}
/**
 * Normalizes (non-hex) string or Uint8Array to Uint8Array.
 * Warning: when Uint8Array is passed, it would NOT get copied.
 * Keep in mind for future mutable operations.
 */
function toBytes(data) {
    if (typeof data === 'string')
        data = utf8ToBytes(data);
    (0, _assert_js_1.bytes)(data);
    return data;
}
/**
 * Copies several Uint8Arrays into one.
 */
function concatBytes(...arrays) {
    let sum = 0;
    for (let i = 0; i < arrays.length; i++) {
        const a = arrays[i];
        (0, _assert_js_1.bytes)(a);
        sum += a.length;
    }
    const res = new Uint8Array(sum);
    for (let i = 0, pad = 0; i < arrays.length; i++) {
        const a = arrays[i];
        res.set(a, pad);
        pad += a.length;
    }
    return res;
}
// For runtime check if class implements interface
class Hash {
    // Safe version that clones internal state
    clone() {
        return this._cloneInto();
    }
}
exports.Hash = Hash;
const toStr = {}.toString;
function checkOpts(defaults, opts) {
    if (opts !== undefined && toStr.call(opts) !== '[object Object]')
        throw new Error('Options should be object or undefined');
    const merged = Object.assign(defaults, opts);
    return merged;
}
function wrapConstructor(hashCons) {
    const hashC = (msg) => hashCons().update(toBytes(msg)).digest();
    const tmp = hashCons();
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = () => hashCons();
    return hashC;
}
function wrapConstructorWithOpts(hashCons) {
    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
    const tmp = hashCons({});
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = (opts) => hashCons(opts);
    return hashC;
}
function wrapXOFConstructorWithOpts(hashCons) {
    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
    const tmp = hashCons({});
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = (opts) => hashCons(opts);
    return hashC;
}
/**
 * Secure PRNG. Uses `crypto.getRandomValues`, which defers to OS.
 */
function randomBytes(bytesLength = 32) {
    if (crypto_1.crypto && typeof crypto_1.crypto.getRandomValues === 'function') {
        return crypto_1.crypto.getRandomValues(new Uint8Array(bytesLength));
    }
    // Legacy Node.js compatibility
    if (crypto_1.crypto && typeof crypto_1.crypto.randomBytes === 'function') {
        return crypto_1.crypto.randomBytes(bytesLength);
    }
    throw new Error('crypto.getRandomValues must be defined');
}
//# sourceMappingURL=utils.js.map

/***/ }),

/***/ 9619:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.aesCbcDecrypt = exports.aesCbcEncrypt = void 0;
const helpers_1 = __webpack_require__(6013);
function aesCbcEncrypt(iv, key, data) {
    return __awaiter(this, void 0, void 0, function* () {
        let result;
        if (helpers_1.isBrowser()) {
            result = yield helpers_1.browserAesEncrypt(iv, key, data);
        }
        else if (helpers_1.isNode()) {
            result = helpers_1.nodeAesEncrypt(iv, key, data);
        }
        else {
            result = helpers_1.fallbackAesEncrypt(iv, key, data);
        }
        return result;
    });
}
exports.aesCbcEncrypt = aesCbcEncrypt;
function aesCbcDecrypt(iv, key, data) {
    return __awaiter(this, void 0, void 0, function* () {
        let result;
        if (helpers_1.isBrowser()) {
            result = yield helpers_1.browserAesDecrypt(iv, key, data);
        }
        else if (helpers_1.isNode()) {
            result = helpers_1.nodeAesDecrypt(iv, key, data);
        }
        else {
            result = helpers_1.fallbackAesDecrypt(iv, key, data);
        }
        return result;
    });
}
exports.aesCbcDecrypt = aesCbcDecrypt;
//# sourceMappingURL=async.js.map

/***/ }),

/***/ 1963:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !exports.hasOwnProperty(p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__webpack_require__(9619), exports);
__exportStar(__webpack_require__(9200), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 9200:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.aesCbcDecryptSync = exports.aesCbcEncryptSync = void 0;
const helpers_1 = __webpack_require__(6013);
function aesCbcEncryptSync(iv, key, data) {
    let result;
    if (helpers_1.isNode()) {
        result = helpers_1.nodeAesEncrypt(iv, key, data);
    }
    else {
        result = helpers_1.fallbackAesEncrypt(iv, key, data);
    }
    return result;
}
exports.aesCbcEncryptSync = aesCbcEncryptSync;
function aesCbcDecryptSync(iv, key, data) {
    let result;
    if (helpers_1.isNode()) {
        result = helpers_1.nodeAesDecrypt(iv, key, data);
    }
    else {
        result = helpers_1.fallbackAesDecrypt(iv, key, data);
    }
    return result;
}
exports.aesCbcDecryptSync = aesCbcDecryptSync;
//# sourceMappingURL=sync.js.map

/***/ }),

/***/ 2219:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ERROR_BAD_MAC = exports.EMPTY_UINT_ARRAY = exports.MAX_MSG_LENGTH = exports.MAX_KEY_LENGTH = exports.PREFIXED_KEY_LENGTH = exports.MAC_LENGTH = exports.IV_LENGTH = exports.KEY_LENGTH = exports.PREFIX_LENGTH = exports.RIPEMD160_NODE_ALGO = exports.SHA512_NODE_ALGO = exports.SHA256_NODE_ALGO = exports.HMAC_NODE_ALGO = exports.AES_NODE_ALGO = exports.SHA512_BROWSER_ALGO = exports.SHA256_BROWSER_ALGO = exports.HMAC_BROWSER = exports.HMAC_BROWSER_ALGO = exports.AES_BROWSER_ALGO = exports.HMAC_LENGTH = exports.AES_LENGTH = exports.LENGTH_1024 = exports.LENGTH_512 = exports.LENGTH_256 = exports.LENGTH_128 = exports.LENGTH_64 = exports.LENGTH_32 = exports.LENGTH_16 = exports.LENGTH_1 = exports.LENGTH_0 = exports.VERIFY_OP = exports.SIGN_OP = exports.DECRYPT_OP = exports.ENCRYPT_OP = exports.UTF8_ENC = exports.HEX_ENC = void 0;
exports.HEX_ENC = 'hex';
exports.UTF8_ENC = 'utf8';
exports.ENCRYPT_OP = 'encrypt';
exports.DECRYPT_OP = 'decrypt';
exports.SIGN_OP = 'sign';
exports.VERIFY_OP = 'verify';
exports.LENGTH_0 = 0;
exports.LENGTH_1 = 1;
exports.LENGTH_16 = 16;
exports.LENGTH_32 = 32;
exports.LENGTH_64 = 64;
exports.LENGTH_128 = 128;
exports.LENGTH_256 = 256;
exports.LENGTH_512 = 512;
exports.LENGTH_1024 = 1024;
exports.AES_LENGTH = exports.LENGTH_256;
exports.HMAC_LENGTH = exports.LENGTH_256;
exports.AES_BROWSER_ALGO = 'AES-CBC';
exports.HMAC_BROWSER_ALGO = `SHA-${exports.AES_LENGTH}`;
exports.HMAC_BROWSER = 'HMAC';
exports.SHA256_BROWSER_ALGO = 'SHA-256';
exports.SHA512_BROWSER_ALGO = 'SHA-512';
exports.AES_NODE_ALGO = `aes-${exports.AES_LENGTH}-cbc`;
exports.HMAC_NODE_ALGO = `sha${exports.HMAC_LENGTH}`;
exports.SHA256_NODE_ALGO = 'sha256';
exports.SHA512_NODE_ALGO = 'sha512';
exports.RIPEMD160_NODE_ALGO = 'ripemd160';
exports.PREFIX_LENGTH = exports.LENGTH_1;
exports.KEY_LENGTH = exports.LENGTH_32;
exports.IV_LENGTH = exports.LENGTH_16;
exports.MAC_LENGTH = exports.LENGTH_32;
exports.PREFIXED_KEY_LENGTH = exports.KEY_LENGTH + exports.PREFIX_LENGTH;
exports.MAX_KEY_LENGTH = exports.LENGTH_1024;
exports.MAX_MSG_LENGTH = exports.LENGTH_32;
exports.EMPTY_UINT_ARRAY = new Uint8Array(exports.LENGTH_0);
exports.ERROR_BAD_MAC = 'Bad MAC';
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 8097:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.browserSha512 = exports.browserSha256 = exports.browserHmacSha512Sign = exports.browserHmacSha256Sign = exports.browserAesDecrypt = exports.browserAesEncrypt = exports.browserImportKey = exports.browserExportKey = exports.getOps = exports.getAlgo = exports.getSubtleCrypto = exports.getBrowerCrypto = void 0;
const constants_1 = __webpack_require__(2219);
function getBrowerCrypto() {
    return (global === null || global === void 0 ? void 0 : global.crypto) || (global === null || global === void 0 ? void 0 : global.msCrypto) || {};
}
exports.getBrowerCrypto = getBrowerCrypto;
function getSubtleCrypto() {
    const browserCrypto = getBrowerCrypto();
    return browserCrypto.subtle || browserCrypto.webkitSubtle;
}
exports.getSubtleCrypto = getSubtleCrypto;
function getAlgo(type) {
    return type === constants_1.AES_BROWSER_ALGO
        ? { length: constants_1.AES_LENGTH, name: constants_1.AES_BROWSER_ALGO }
        : {
            hash: { name: constants_1.HMAC_BROWSER_ALGO },
            name: constants_1.HMAC_BROWSER,
        };
}
exports.getAlgo = getAlgo;
function getOps(type) {
    return type === constants_1.AES_BROWSER_ALGO
        ? [constants_1.ENCRYPT_OP, constants_1.DECRYPT_OP]
        : [constants_1.SIGN_OP, constants_1.VERIFY_OP];
}
exports.getOps = getOps;
function browserExportKey(cryptoKey, type = constants_1.AES_BROWSER_ALGO) {
    return __awaiter(this, void 0, void 0, function* () {
        const subtle = getSubtleCrypto();
        return new Uint8Array(yield subtle.exportKey('raw', cryptoKey));
    });
}
exports.browserExportKey = browserExportKey;
function browserImportKey(buffer, type = constants_1.AES_BROWSER_ALGO) {
    return __awaiter(this, void 0, void 0, function* () {
        return getSubtleCrypto().importKey('raw', buffer, getAlgo(type), true, getOps(type));
    });
}
exports.browserImportKey = browserImportKey;
function browserAesEncrypt(iv, key, data) {
    return __awaiter(this, void 0, void 0, function* () {
        const subtle = getSubtleCrypto();
        const cryptoKey = yield browserImportKey(key, constants_1.AES_BROWSER_ALGO);
        const result = yield subtle.encrypt({
            iv,
            name: constants_1.AES_BROWSER_ALGO,
        }, cryptoKey, data);
        return new Uint8Array(result);
    });
}
exports.browserAesEncrypt = browserAesEncrypt;
function browserAesDecrypt(iv, key, data) {
    return __awaiter(this, void 0, void 0, function* () {
        const subtle = getSubtleCrypto();
        const cryptoKey = yield browserImportKey(key, constants_1.AES_BROWSER_ALGO);
        const result = yield subtle.decrypt({
            iv,
            name: constants_1.AES_BROWSER_ALGO,
        }, cryptoKey, data);
        return new Uint8Array(result);
    });
}
exports.browserAesDecrypt = browserAesDecrypt;
function browserHmacSha256Sign(key, data) {
    return __awaiter(this, void 0, void 0, function* () {
        const subtle = getSubtleCrypto();
        const cryptoKey = yield browserImportKey(key, constants_1.HMAC_BROWSER);
        const signature = yield subtle.sign({
            length: constants_1.HMAC_LENGTH,
            name: constants_1.HMAC_BROWSER,
        }, cryptoKey, data);
        return new Uint8Array(signature);
    });
}
exports.browserHmacSha256Sign = browserHmacSha256Sign;
function browserHmacSha512Sign(key, data) {
    return __awaiter(this, void 0, void 0, function* () {
        const subtle = getSubtleCrypto();
        const cryptoKey = yield browserImportKey(key, constants_1.HMAC_BROWSER);
        const signature = yield subtle.sign({
            length: constants_1.LENGTH_512,
            name: constants_1.HMAC_BROWSER,
        }, cryptoKey, data);
        return new Uint8Array(signature);
    });
}
exports.browserHmacSha512Sign = browserHmacSha512Sign;
function browserSha256(data) {
    return __awaiter(this, void 0, void 0, function* () {
        const subtle = getSubtleCrypto();
        const result = yield subtle.digest({
            name: constants_1.SHA256_BROWSER_ALGO,
        }, data);
        return new Uint8Array(result);
    });
}
exports.browserSha256 = browserSha256;
function browserSha512(data) {
    return __awaiter(this, void 0, void 0, function* () {
        const subtle = getSubtleCrypto();
        const result = yield subtle.digest({
            name: constants_1.SHA512_BROWSER_ALGO,
        }, data);
        return new Uint8Array(result);
    });
}
exports.browserSha512 = browserSha512;
//# sourceMappingURL=browser.js.map

/***/ }),

/***/ 775:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.fallbackRipemd160 = exports.fallbackSha512 = exports.fallbackSha256 = exports.fallbackHmacSha512Sign = exports.fallbackHmacSha256Sign = exports.fallbackAesDecrypt = exports.fallbackAesEncrypt = void 0;
const aes_js_1 = __importDefault(__webpack_require__(3836));
const hash = __importStar(__webpack_require__(7952));
const enc_utils_1 = __webpack_require__(9561);
const constants_1 = __webpack_require__(2219);
const index_1 = __webpack_require__(6013);
function fallbackAesEncrypt(iv, key, data) {
    const aesCbc = new aes_js_1.default.ModeOfOperation.cbc(key, iv);
    const padded = index_1.pkcs7.pad(data);
    const encryptedBytes = aesCbc.encrypt(padded);
    return new Uint8Array(encryptedBytes);
}
exports.fallbackAesEncrypt = fallbackAesEncrypt;
function fallbackAesDecrypt(iv, key, data) {
    const aesCbc = new aes_js_1.default.ModeOfOperation.cbc(key, iv);
    const encryptedBytes = aesCbc.decrypt(data);
    const padded = new Uint8Array(encryptedBytes);
    const result = index_1.pkcs7.unpad(padded);
    return result;
}
exports.fallbackAesDecrypt = fallbackAesDecrypt;
function fallbackHmacSha256Sign(key, data) {
    const result = hash
        .hmac(hash[constants_1.SHA256_NODE_ALGO], key)
        .update(data)
        .digest(constants_1.HEX_ENC);
    return enc_utils_1.hexToArray(result);
}
exports.fallbackHmacSha256Sign = fallbackHmacSha256Sign;
function fallbackHmacSha512Sign(key, data) {
    const result = hash
        .hmac(hash[constants_1.SHA512_NODE_ALGO], key)
        .update(data)
        .digest(constants_1.HEX_ENC);
    return enc_utils_1.hexToArray(result);
}
exports.fallbackHmacSha512Sign = fallbackHmacSha512Sign;
function fallbackSha256(msg) {
    const result = hash
        .sha256()
        .update(msg)
        .digest(constants_1.HEX_ENC);
    return enc_utils_1.hexToArray(result);
}
exports.fallbackSha256 = fallbackSha256;
function fallbackSha512(msg) {
    const result = hash
        .sha512()
        .update(msg)
        .digest(constants_1.HEX_ENC);
    return enc_utils_1.hexToArray(result);
}
exports.fallbackSha512 = fallbackSha512;
function fallbackRipemd160(msg) {
    const result = hash
        .ripemd160()
        .update(msg)
        .digest(constants_1.HEX_ENC);
    return enc_utils_1.hexToArray(result);
}
exports.fallbackRipemd160 = fallbackRipemd160;
//# sourceMappingURL=fallback.js.map

/***/ }),

/***/ 4625:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !exports.hasOwnProperty(p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__webpack_require__(8097), exports);
__exportStar(__webpack_require__(775), exports);
__exportStar(__webpack_require__(3977), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 3977:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.nodeRipemd160 = exports.nodeSha512 = exports.nodeSha256 = exports.nodeHmacSha512Sign = exports.nodeHmacSha256Sign = exports.nodeAesDecrypt = exports.nodeAesEncrypt = void 0;
const crypto_1 = __importDefault(__webpack_require__(6982));
const enc_utils_1 = __webpack_require__(9561);
const constants_1 = __webpack_require__(2219);
function nodeAesEncrypt(iv, key, data) {
    const cipher = crypto_1.default.createCipheriv(constants_1.AES_NODE_ALGO, key, iv);
    return enc_utils_1.bufferToArray(enc_utils_1.concatBuffers(cipher.update(data), cipher.final()));
}
exports.nodeAesEncrypt = nodeAesEncrypt;
function nodeAesDecrypt(iv, key, data) {
    const decipher = crypto_1.default.createDecipheriv(constants_1.AES_NODE_ALGO, key, iv);
    return enc_utils_1.bufferToArray(enc_utils_1.concatBuffers(decipher.update(data), decipher.final()));
}
exports.nodeAesDecrypt = nodeAesDecrypt;
function nodeHmacSha256Sign(key, data) {
    const buf = crypto_1.default
        .createHmac(constants_1.HMAC_NODE_ALGO, new Uint8Array(key))
        .update(data)
        .digest();
    return enc_utils_1.bufferToArray(buf);
}
exports.nodeHmacSha256Sign = nodeHmacSha256Sign;
function nodeHmacSha512Sign(key, data) {
    const buf = crypto_1.default
        .createHmac(constants_1.SHA512_NODE_ALGO, new Uint8Array(key))
        .update(data)
        .digest();
    return enc_utils_1.bufferToArray(buf);
}
exports.nodeHmacSha512Sign = nodeHmacSha512Sign;
function nodeSha256(data) {
    const buf = crypto_1.default
        .createHash(constants_1.SHA256_NODE_ALGO)
        .update(data)
        .digest();
    return enc_utils_1.bufferToArray(buf);
}
exports.nodeSha256 = nodeSha256;
function nodeSha512(data) {
    const buf = crypto_1.default
        .createHash(constants_1.SHA512_NODE_ALGO)
        .update(data)
        .digest();
    return enc_utils_1.bufferToArray(buf);
}
exports.nodeSha512 = nodeSha512;
function nodeRipemd160(data) {
    const buf = crypto_1.default
        .createHash(constants_1.RIPEMD160_NODE_ALGO)
        .update(data)
        .digest();
    return enc_utils_1.bufferToArray(buf);
}
exports.nodeRipemd160 = nodeRipemd160;
//# sourceMappingURL=node.js.map

/***/ }),

/***/ 6013:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !exports.hasOwnProperty(p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__webpack_require__(2219), exports);
__exportStar(__webpack_require__(4625), exports);
__exportStar(__webpack_require__(9141), exports);
__exportStar(__webpack_require__(2916), exports);
__exportStar(__webpack_require__(8918), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 9141:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.pkcs7 = void 0;
let PADDING = [
    [16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16],
    [15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15],
    [14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14],
    [13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13],
    [12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12],
    [11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11],
    [10, 10, 10, 10, 10, 10, 10, 10, 10, 10],
    [9, 9, 9, 9, 9, 9, 9, 9, 9],
    [8, 8, 8, 8, 8, 8, 8, 8],
    [7, 7, 7, 7, 7, 7, 7],
    [6, 6, 6, 6, 6, 6],
    [5, 5, 5, 5, 5],
    [4, 4, 4, 4],
    [3, 3, 3],
    [2, 2],
    [1],
];
exports.pkcs7 = {
    pad(plaintext) {
        const padding = PADDING[plaintext.byteLength % 16 || 0];
        const result = new Uint8Array(plaintext.byteLength + padding.length);
        result.set(plaintext);
        result.set(padding, plaintext.byteLength);
        return result;
    },
    unpad(padded) {
        return padded.subarray(0, padded.byteLength - padded[padded.byteLength - 1]);
    },
};
//# sourceMappingURL=pkcs7.js.map

/***/ }),

/***/ 2916:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
//# sourceMappingURL=types.js.map

/***/ }),

/***/ 8918:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isConstantTime = exports.isNode = exports.isBrowser = exports.assert = void 0;
const env_1 = __webpack_require__(4625);
function assert(condition, message) {
    if (!condition) {
        throw new Error(message || 'Assertion failed');
    }
}
exports.assert = assert;
function isBrowser() {
    return !!env_1.getBrowerCrypto() && !!env_1.getSubtleCrypto();
}
exports.isBrowser = isBrowser;
function isNode() {
    return (typeof process !== 'undefined' &&
        typeof process.versions !== 'undefined' &&
        typeof process.versions.node !== 'undefined');
}
exports.isNode = isNode;
function isConstantTime(arr1, arr2) {
    if (arr1.length !== arr2.length) {
        return false;
    }
    let res = 0;
    for (let i = 0; i < arr1.length; i++) {
        res |= arr1[i] ^ arr2[i];
    }
    return res === 0;
}
exports.isConstantTime = isConstantTime;
//# sourceMappingURL=validators.js.map

/***/ }),

/***/ 3467:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.hmacSha512Verify = exports.hmacSha512Sign = exports.hmacSha256Verify = exports.hmacSha256Sign = void 0;
const helpers_1 = __webpack_require__(6013);
function hmacSha256Sign(key, msg) {
    return __awaiter(this, void 0, void 0, function* () {
        let result;
        if (helpers_1.isBrowser()) {
            result = yield helpers_1.browserHmacSha256Sign(key, msg);
        }
        else if (helpers_1.isNode()) {
            result = helpers_1.nodeHmacSha256Sign(key, msg);
        }
        else {
            result = helpers_1.fallbackHmacSha256Sign(key, msg);
        }
        return result;
    });
}
exports.hmacSha256Sign = hmacSha256Sign;
function hmacSha256Verify(key, msg, sig) {
    return __awaiter(this, void 0, void 0, function* () {
        let result;
        if (helpers_1.isBrowser()) {
            const expectedSig = yield helpers_1.browserHmacSha256Sign(key, msg);
            result = helpers_1.isConstantTime(expectedSig, sig);
        }
        else if (helpers_1.isNode()) {
            const expectedSig = helpers_1.nodeHmacSha256Sign(key, msg);
            result = helpers_1.isConstantTime(expectedSig, sig);
        }
        else {
            const expectedSig = helpers_1.fallbackHmacSha256Sign(key, msg);
            result = helpers_1.isConstantTime(expectedSig, sig);
        }
        return result;
    });
}
exports.hmacSha256Verify = hmacSha256Verify;
function hmacSha512Sign(key, msg) {
    return __awaiter(this, void 0, void 0, function* () {
        let result;
        if (helpers_1.isBrowser()) {
            result = yield helpers_1.browserHmacSha512Sign(key, msg);
        }
        else if (helpers_1.isNode()) {
            result = helpers_1.nodeHmacSha512Sign(key, msg);
        }
        else {
            result = helpers_1.fallbackHmacSha512Sign(key, msg);
        }
        return result;
    });
}
exports.hmacSha512Sign = hmacSha512Sign;
function hmacSha512Verify(key, msg, sig) {
    return __awaiter(this, void 0, void 0, function* () {
        let result;
        if (helpers_1.isNode()) {
            const expectedSig = helpers_1.nodeHmacSha512Sign(key, msg);
            result = helpers_1.isConstantTime(expectedSig, sig);
        }
        else {
            const expectedSig = helpers_1.fallbackHmacSha512Sign(key, msg);
            result = helpers_1.isConstantTime(expectedSig, sig);
        }
        return result;
    });
}
exports.hmacSha512Verify = hmacSha512Verify;
//# sourceMappingURL=async.js.map

/***/ }),

/***/ 2307:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !exports.hasOwnProperty(p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__webpack_require__(3467), exports);
__exportStar(__webpack_require__(280), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 280:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.hmacSha512VerifySync = exports.hmacSha512SignSync = exports.hmacSha256VerifySync = exports.hmacSha256SignSync = void 0;
const helpers_1 = __webpack_require__(6013);
function hmacSha256SignSync(key, msg) {
    let result;
    if (helpers_1.isNode()) {
        result = helpers_1.nodeHmacSha256Sign(key, msg);
    }
    else {
        result = helpers_1.fallbackHmacSha256Sign(key, msg);
    }
    return result;
}
exports.hmacSha256SignSync = hmacSha256SignSync;
function hmacSha256VerifySync(key, msg, sig) {
    let result;
    if (helpers_1.isNode()) {
        const expectedSig = helpers_1.nodeHmacSha256Sign(key, msg);
        result = helpers_1.isConstantTime(expectedSig, sig);
    }
    else {
        const expectedSig = helpers_1.fallbackHmacSha256Sign(key, msg);
        result = helpers_1.isConstantTime(expectedSig, sig);
    }
    return result;
}
exports.hmacSha256VerifySync = hmacSha256VerifySync;
function hmacSha512SignSync(key, msg) {
    let result;
    if (helpers_1.isNode()) {
        result = helpers_1.nodeHmacSha512Sign(key, msg);
    }
    else {
        result = helpers_1.fallbackHmacSha512Sign(key, msg);
    }
    return result;
}
exports.hmacSha512SignSync = hmacSha512SignSync;
function hmacSha512VerifySync(key, msg, sig) {
    let result;
    if (helpers_1.isNode()) {
        const expectedSig = helpers_1.nodeHmacSha512Sign(key, msg);
        result = helpers_1.isConstantTime(expectedSig, sig);
    }
    else {
        const expectedSig = helpers_1.fallbackHmacSha512Sign(key, msg);
        result = helpers_1.isConstantTime(expectedSig, sig);
    }
    return result;
}
exports.hmacSha512VerifySync = hmacSha512VerifySync;
//# sourceMappingURL=sync.js.map

/***/ }),

/***/ 9071:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !exports.hasOwnProperty(p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__webpack_require__(1963), exports);
__exportStar(__webpack_require__(6013), exports);
__exportStar(__webpack_require__(2307), exports);
__exportStar(__webpack_require__(503), exports);
__exportStar(__webpack_require__(6088), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 503:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.randomBytes = void 0;
const isoRandom = __importStar(__webpack_require__(4526));
function randomBytes(length) {
    return isoRandom.randomBytes(length);
}
exports.randomBytes = randomBytes;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 1956:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ripemd160 = exports.sha512 = exports.sha256 = void 0;
const helpers_1 = __webpack_require__(6013);
function sha256(msg) {
    return __awaiter(this, void 0, void 0, function* () {
        let result = helpers_1.EMPTY_UINT_ARRAY;
        if (helpers_1.isBrowser()) {
            result = yield helpers_1.browserSha256(msg);
        }
        else if (helpers_1.isNode()) {
            result = helpers_1.nodeSha256(msg);
        }
        else {
            result = helpers_1.fallbackSha256(msg);
        }
        return result;
    });
}
exports.sha256 = sha256;
function sha512(msg) {
    return __awaiter(this, void 0, void 0, function* () {
        let result = helpers_1.EMPTY_UINT_ARRAY;
        if (helpers_1.isBrowser()) {
            result = yield helpers_1.browserSha512(msg);
        }
        else if (helpers_1.isNode()) {
            result = helpers_1.nodeSha512(msg);
        }
        else {
            result = helpers_1.fallbackSha512(msg);
        }
        return result;
    });
}
exports.sha512 = sha512;
function ripemd160(msg) {
    return __awaiter(this, void 0, void 0, function* () {
        let result = helpers_1.EMPTY_UINT_ARRAY;
        if (helpers_1.isNode()) {
            result = helpers_1.nodeRipemd160(msg);
        }
        else {
            result = helpers_1.fallbackRipemd160(msg);
        }
        return result;
    });
}
exports.ripemd160 = ripemd160;
//# sourceMappingURL=async.js.map

/***/ }),

/***/ 6088:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !exports.hasOwnProperty(p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__webpack_require__(1956), exports);
__exportStar(__webpack_require__(6253), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 6253:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ripemd160Sync = exports.sha512Sync = exports.sha256Sync = void 0;
const helpers_1 = __webpack_require__(6013);
function sha256Sync(msg) {
    let result = helpers_1.EMPTY_UINT_ARRAY;
    if (helpers_1.isNode()) {
        result = helpers_1.nodeSha256(msg);
    }
    else {
        result = helpers_1.fallbackSha256(msg);
    }
    return result;
}
exports.sha256Sync = sha256Sync;
function sha512Sync(msg) {
    let result = helpers_1.EMPTY_UINT_ARRAY;
    if (helpers_1.isNode()) {
        result = helpers_1.nodeSha512(msg);
    }
    else {
        result = helpers_1.fallbackSha512(msg);
    }
    return result;
}
exports.sha512Sync = sha512Sync;
function ripemd160Sync(msg) {
    let result = helpers_1.EMPTY_UINT_ARRAY;
    if (helpers_1.isNode()) {
        result = helpers_1.nodeRipemd160(msg);
    }
    else {
        result = helpers_1.fallbackRipemd160(msg);
    }
    return result;
}
exports.ripemd160Sync = ripemd160Sync;
//# sourceMappingURL=sync.js.map

/***/ }),

/***/ 4526:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.randomBytes = void 0;
const crypto_1 = __importDefault(__webpack_require__(6982));
const enc_utils_1 = __webpack_require__(9561);
function randomBytes(length) {
    const buf = crypto_1.default.randomBytes(length);
    return enc_utils_1.bufferToArray(buf);
}
exports.randomBytes = randomBytes;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 9303:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Authorize = exports.AuthEnc = exports.ECIES = void 0;
const ecies_1 = __webpack_require__(5008);
Object.defineProperty(exports, "ECIES", ({ enumerable: true, get: function () { return ecies_1.ECIES; } }));
const authEnc_1 = __webpack_require__(7457);
Object.defineProperty(exports, "AuthEnc", ({ enumerable: true, get: function () { return authEnc_1.AuthEnc; } }));
const authorize_1 = __webpack_require__(1732);
Object.defineProperty(exports, "Authorize", ({ enumerable: true, get: function () { return authorize_1.Authorize; } }));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 7457:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AuthEnc = void 0;
const BN = __webpack_require__(9404);
const cryptoJS = __webpack_require__(1396);
const elliptic = __webpack_require__(6729);
const P256 = elliptic.ec('p256');
const crypto_utils_1 = __webpack_require__(5573);
const ecies_1 = __webpack_require__(5008);
const assert = __webpack_require__(2613);
var AuthEnc;
(function (AuthEnc) {
    /**
     * Authenticate and encrypt the data.
     * @param localAuthPriv
     * @param remoteAuthPub
     * @param plain
     * @returns Promise<string> A string encoded in base64
     */
    function _encrypt(localAuthPriv, remoteAuthPub, plain) {
        return __awaiter(this, void 0, void 0, function* () {
            let plainBytes;
            if (typeof plain === 'string') {
                plainBytes = cryptoJS.enc.Utf8.parse(plain);
            }
            else if (plain instanceof Uint8Array) {
                plainBytes = crypto_utils_1.Hex.toCryptoJSBytes(crypto_utils_1.Hex.fromBytes(plain));
            }
            else {
                // CryptoJSBytes
                plainBytes = plain;
            }
            const sha256 = cryptoJS.algo.SHA256.create();
            sha256.update(plainBytes);
            let digest = sha256.finalize();
            let hash = new BN(digest.toString(cryptoJS.enc.Hex), 16);
            //let ecdsa = new elliptic.ec(P256)
            let priv = P256.keyFromPrivate(localAuthPriv);
            let signature = P256.sign(hash, priv);
            let signatureBytes = cryptoJS.enc.Hex.parse(crypto_utils_1.Hex.pad64(signature.r.toString(16)));
            signatureBytes.concat(cryptoJS.enc.Hex.parse(crypto_utils_1.Hex.pad64(signature.s.toString(16))));
            let sigPlain = plainBytes.concat(signatureBytes);
            let cypherBytes = yield ecies_1.ECIES.encryptCryptoJSBytes(remoteAuthPub, sigPlain);
            return crypto_utils_1.UrlBase64.fromCryptoJSBytes(cypherBytes);
        });
    }
    AuthEnc._encrypt = _encrypt;
    /**
     * Verify the signatures and decrypt the data.
     * @param localAuthPriv
     * @param remoteAuthPub
     * @param cypher = Base64(cypherBytes + signature(64 byte))
     * @returns [boolean, CryptoJSBytes]
     */
    function _decrypt(localAuthPriv, remoteAuthPub, cypher) {
        let cypherBytes = crypto_utils_1.UrlBase64.toCryptoJSBytes(cypher);
        //Decrypt
        let sigPlain = ecies_1.ECIES.decryptCryptoJSBytes(localAuthPriv, cypherBytes);
        let sigPlainHex = cryptoJS.enc.Hex.stringify(sigPlain);
        //signature(64 byte)
        assert(sigPlainHex.length > 128);
        let r = new BN(sigPlainHex.substring(sigPlainHex.length - 128, sigPlainHex.length - 64), 16);
        let s = new BN(sigPlainHex.substring(sigPlainHex.length - 64), 16);
        let signature = { r: r, s: s };
        let plainBytes = cryptoJS.enc.Hex.parse(sigPlainHex.substring(0, sigPlainHex.length - 128));
        const sha256 = cryptoJS.algo.SHA256.create();
        sha256.update(plainBytes);
        const dig = sha256.finalize();
        let hash = new BN(cryptoJS.enc.Hex.stringify(dig), 16);
        // Verify signature
        // let ecdsa = new elliptic.ec(P256)
        if (!P256.verify(hash, signature, remoteAuthPub)) {
            return [false, undefined];
        }
        return [true, plainBytes];
    }
    AuthEnc._decrypt = _decrypt;
    /**
     * Encrypt a string to a cypher string.
     * @param localAuthPriv
     * @param remoteAuthPub
     * @param plain
     * @return {Promise<string>} cypher data is a string encoded in base64.
     */
    function encryptString(localAuthPriv, remoteAuthPub, plain) {
        return __awaiter(this, void 0, void 0, function* () {
            return _encrypt(localAuthPriv, remoteAuthPub, plain);
        });
    }
    AuthEnc.encryptString = encryptString;
    /**
     * Decrypt cypher data to a string.
     * @param localAuthPriv
     * @param remoteAuthPub
     * @param cypher
     * @return {[boolean, string]} [ok, plain]
     */
    function decryptString(localAuthPriv, remoteAuthPub, cypher) {
        let [ok, cjsBytes] = _decrypt(localAuthPriv, remoteAuthPub, cypher);
        if (ok) {
            return [true, cryptoJS.enc.Utf8.stringify(cjsBytes)];
        }
        else {
            return [false, null];
        }
    }
    AuthEnc.decryptString = decryptString;
    /**
     * Encrypt the CryptoJSBytes to a cypher string.
     * @param localAuthPriv
     * @param remoteAuthPub
     * @param plain
     * @return {Promise<string>} cypher
     */
    function encryptCryptoJSBytes(localAuthPriv, remoteAuthPub, plain) {
        return __awaiter(this, void 0, void 0, function* () {
            return _encrypt(localAuthPriv, remoteAuthPub, plain);
        });
    }
    AuthEnc.encryptCryptoJSBytes = encryptCryptoJSBytes;
    /**
     * Decrypt a cypher string to plain CryptoJSBytes.
     * @param localAuthPriv
     * @param remoteAuthPub
     * @param cypher
     * @return {[boolean, CryptoJSBytes]} [ok, plain]
     */
    function decryptCryptoJSBytes(localAuthPriv, remoteAuthPub, cypher) {
        return _decrypt(localAuthPriv, remoteAuthPub, cypher);
    }
    AuthEnc.decryptCryptoJSBytes = decryptCryptoJSBytes;
    /**
     * Encrypt the Bytes to a cypher string.
     * @param localAuthPriv
     * @param remoteAuthPub
     * @param plain
     * @return {Promise<string>} cypher
     */
    function encryptBytes(localAuthPriv, remoteAuthPub, plain) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield _encrypt(localAuthPriv, remoteAuthPub, plain);
        });
    }
    AuthEnc.encryptBytes = encryptBytes;
    /**
     * Decrypt a cypher string to plain bytes.
     * @param localAuthPriv
     * @param remoteAuthPub
     * @param cypher
     * @return {[boolean, Uint8Array]} [ok, plain]
     */
    function decryptBytes(localAuthPriv, remoteAuthPub, cypher) {
        let [ok, cjsBytes] = _decrypt(localAuthPriv, remoteAuthPub, cypher);
        if (ok) {
            return [true, crypto_utils_1.Hex.toBytes(crypto_utils_1.Hex.fromCryptoJSBytes(cjsBytes))];
        }
        else {
            return [false, null];
        }
    }
    AuthEnc.decryptBytes = decryptBytes;
})(AuthEnc = exports.AuthEnc || (exports.AuthEnc = {}));
//# sourceMappingURL=authEnc.js.map

/***/ }),

/***/ 1732:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Authorize = void 0;
const BN = __webpack_require__(9404);
const cryptoJS = __webpack_require__(1396);
const elliptic = __webpack_require__(6729);
const P256 = elliptic.ec('p256');
const crypto_utils_1 = __webpack_require__(5573);
const assert = __webpack_require__(2613);
var Authorize;
(function (Authorize) {
    /**
     * Sign a message
     * @param localAuthPriv
     * @param data
     * @return Promise<string>  Hex(r) + Hex(s)
     */
    function sign(localAuthPriv, data) {
        return __awaiter(this, void 0, void 0, function* () {
            if (typeof data === 'string') {
                data = cryptoJS.enc.Utf8.parse(data);
            }
            else if (data instanceof Uint8Array) {
                data = crypto_utils_1.Hex.toCryptoJSBytes(crypto_utils_1.Hex.fromBytes(data));
            }
            else {
                // CryptoJSBytes, do nothing
            }
            // Get hash of cypher text
            const sha256 = cryptoJS.algo.SHA256.create();
            sha256.update(data);
            const dig = sha256.finalize();
            let hash = new BN(cryptoJS.enc.Hex.stringify(dig), 16);
            // Get signature
            //let ecdsa = new elliptic.ec(P256)
            let priv = P256.keyFromPrivate(localAuthPriv);
            let signature = P256.sign(hash, priv);
            return crypto_utils_1.Hex.pad64(signature.r.toString(16))
                + crypto_utils_1.Hex.pad64(signature.s.toString(16));
        });
    }
    Authorize.sign = sign;
    /**
     * Verify the signatures.
     * @returns boolean
     * @param authPub
     * @param data
     * @param sig
     */
    function verify(authPub, data, sig) {
        // Get r,s
        assert(sig.length === 128);
        const r = new BN(sig.substring(0, 64), 16);
        const s = new BN(sig.substring(64), 16);
        let signature = { r: r, s: s };
        if (typeof data === 'string') {
            data = cryptoJS.enc.Utf8.parse(data);
        }
        else if (data instanceof Uint8Array) {
            data = crypto_utils_1.Hex.toCryptoJSBytes(crypto_utils_1.Hex.fromBytes(data));
        }
        else {
            // CryptoJSBytes, do nothing
        }
        // Get hash of cypher text
        const sha256 = cryptoJS.algo.SHA256.create();
        sha256.update(data);
        const dig = sha256.finalize();
        let hash = new BN(dig.toString(cryptoJS.enc.Hex), 16);
        // Verify signature
        return P256.verify(hash, signature, authPub);
    }
    Authorize.verify = verify;
})(Authorize = exports.Authorize || (exports.Authorize = {}));
//# sourceMappingURL=authorize.js.map

/***/ }),

/***/ 5008:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ECIES = void 0;
const cryptoJS = __webpack_require__(1396);
const elliptic = __webpack_require__(6729);
const crypto_rand_1 = __webpack_require__(6493);
const crypto_utils_1 = __webpack_require__(5573);
const P256 = elliptic.ec('p256');
var ECIES;
(function (ECIES) {
    /**
     * Encryption.
     * @param pub. ECC Public Key
     * @param plainBytes
     * @param r The private key
     * @param ivWordArray AES encrypt iv
     * @returns {CryptoJSBytes}: [gR.encode()||aesCypher||macCypher||ivWordArray]
     * @private
     */
    function _encryptCryptoJSBytesWithRIV(pub, plainBytes, r, ivWordArray) {
        // get share Key
        let gR = P256.g.mul(r);
        let keyPoint = pub.mul(r);
        //generate seed
        let seed = cryptoJS.lib.WordArray.create();
        let keyPointX = keyPoint.getX();
        let gREncode = gR.encode();
        seed.concat(cryptoJS.enc.Hex.parse(crypto_utils_1.Hex.padLength(crypto_utils_1.Hex.fromBytes(gREncode), 65 * 2)));
        seed.concat(cryptoJS.enc.Hex.parse(crypto_utils_1.Hex.pad64(keyPointX.toString(16))));
        //generate derivation key
        let symmKeyBytes = 256 / 8;
        let macKeyBytes = 1024 / 8;
        let digestBytes = 512 / 8;
        let derivationKey = '';
        let totalBytes = symmKeyBytes + macKeyBytes;
        for (let i = 1; i <= (totalBytes + digestBytes - 1) / digestBytes; i++) {
            let sha512 = cryptoJS.algo.SHA512.create();
            let iWordArray = cryptoJS.enc.Hex.parse(crypto_utils_1.Hex.pad8(i.toString(16)));
            sha512.update(seed);
            sha512.update(iWordArray);
            let digest = sha512.finalize();
            derivationKey += crypto_utils_1.Hex.padLength(digest.toString(cryptoJS.enc.Hex), 128);
        }
        derivationKey = derivationKey.substring(0, totalBytes * 2);
        let symmKey = derivationKey.substring(0, symmKeyBytes * 2);
        let macKey = derivationKey.substring(symmKeyBytes * 2, derivationKey.length);
        // encrypt, AES256, CBC default
        let aesEncryptor = cryptoJS.algo.AES.createEncryptor(cryptoJS.enc.Hex.parse(symmKey), { iv: ivWordArray });
        let cypher1 = aesEncryptor.process(plainBytes);
        let cypher2 = aesEncryptor.finalize();
        let aesCypher = cypher1.concat(cypher2);
        //cal mac for cypher
        let macIVLen = "0";
        let hmac_sha512 = cryptoJS.algo.HMAC.create(cryptoJS.algo.SHA512, cryptoJS.enc.Hex.parse(macKey));
        hmac_sha512.update(aesCypher);
        hmac_sha512.update(cryptoJS.enc.Hex.parse(crypto_utils_1.Hex.pad16(macIVLen)));
        let macCypher = hmac_sha512.finalize();
        let gREncodeWordArray = cryptoJS.enc.Hex.parse(crypto_utils_1.Hex.padLength(crypto_utils_1.Hex.fromBytes(gREncode), 65 * 2));
        return gREncodeWordArray.concat(aesCypher).concat(macCypher).concat(ivWordArray);
    }
    /**
     * Decryption
     * @param gR. Curve.g^R
     * @param priv.
     * @param ivWordArray AES encrypt iv
     * @param aesCypher
     * @param macCypher
     * @returns {CryptoJSBytes} PLain
     * @private
     */
    function _decryptCryptoJSBytes(gR, priv, ivWordArray, aesCypher, macCypher) {
        // get share key
        let keyPoint = gR.mul(priv);
        //generate seed
        let keyPointX = keyPoint.getX();
        let gREncode = gR.encode();
        let seed = cryptoJS.lib.WordArray.create();
        seed.concat(cryptoJS.enc.Hex.parse(crypto_utils_1.Hex.padLength(crypto_utils_1.Hex.fromBytes(gREncode), 65 * 2)));
        seed.concat(cryptoJS.enc.Hex.parse(crypto_utils_1.Hex.pad64(keyPointX.toString(16))));
        //generate derivation key
        let symmKeyBytes = 256 / 8;
        let macKeyBytes = 1024 / 8;
        let digestBytes = 512 / 8;
        let derivationKey = '';
        let totalBytes = symmKeyBytes + macKeyBytes;
        for (let i = 1; i <= (totalBytes + digestBytes - 1) / digestBytes; i++) {
            let sha512 = cryptoJS.algo.SHA512.create();
            let iWordArray = cryptoJS.enc.Hex.parse(crypto_utils_1.Hex.pad8(i.toString(16)));
            sha512.update(seed);
            sha512.update(iWordArray);
            let digest = sha512.finalize();
            derivationKey += crypto_utils_1.Hex.padLength(digest.toString(cryptoJS.enc.Hex), 128);
        }
        derivationKey = derivationKey.substring(0, totalBytes * 2);
        let symmKey = derivationKey.substring(0, symmKeyBytes * 2);
        let macKey = derivationKey.substring(symmKeyBytes * 2, derivationKey.length);
        //cal mac for cypher
        let macIVLen = "0";
        let hmac_sha512 = cryptoJS.algo.HMAC.create(cryptoJS.algo.SHA512, cryptoJS.enc.Hex.parse(macKey));
        hmac_sha512.update(aesCypher);
        hmac_sha512.update(cryptoJS.enc.Hex.parse(crypto_utils_1.Hex.pad16(macIVLen)));
        let verifyMacCypher = hmac_sha512.finalize();
        if (verifyMacCypher.toString(cryptoJS.enc.Hex) != macCypher.toString(cryptoJS.enc.Hex)) {
            throw 'Mac verify error: verifyMacCypher != macCypher';
        }
        // decrypt
        let aesDecryptor = cryptoJS.algo.AES.createDecryptor(cryptoJS.enc.Hex.parse(symmKey), { iv: ivWordArray });
        let plainPart1 = aesDecryptor.process(aesCypher);
        let plainPart2 = aesDecryptor.finalize();
        return plainPart1.concat(plainPart2);
    }
    /**
     * Encrypt CryptoJSBytes to cypher CryptoJSBytes.
     * @param pub. ECC Public Key
     * @param plainCryptoJSBytes.
     * @returns {Promise<CryptoJSBytes>}
     */
    function encryptCryptoJSBytes(pub, plainCryptoJSBytes) {
        return __awaiter(this, void 0, void 0, function* () {
            const r = yield crypto_rand_1.Rand.randomBNLt(P256.n);
            let iv = yield crypto_rand_1.Rand.randomBytes(16);
            const ivCryptoJSBytes = crypto_utils_1.Hex.toCryptoJSBytes(crypto_utils_1.Hex.fromBytes(iv));
            return yield _encryptCryptoJSBytesWithRIV(pub, plainCryptoJSBytes, r, ivCryptoJSBytes);
        });
    }
    ECIES.encryptCryptoJSBytes = encryptCryptoJSBytes;
    /**
     * Encrypt CryptoJSBytes to cypher CryptoJSBytes with specified random IV.
     * @param pub. ECC Public Key
     * @param plainCryptoJSBytes.
     * @param r. BN
     * @param iv. Uint8Array
     * @returns {Promise<CryptoJSBytes>}
     */
    function encryptCryptoJSBytesWithRIV(pub, plainCryptoJSBytes, r, iv) {
        return __awaiter(this, void 0, void 0, function* () {
            const ivCryptoJSBytes = crypto_utils_1.Hex.toCryptoJSBytes(crypto_utils_1.Hex.fromBytes(iv));
            return yield _encryptCryptoJSBytesWithRIV(pub, plainCryptoJSBytes, r, ivCryptoJSBytes);
        });
    }
    ECIES.encryptCryptoJSBytesWithRIV = encryptCryptoJSBytesWithRIV;
    /**
     * Decrypt CryptoJSBytes to plain CryptoBytes.
     * @param priv. Private Key.
     * @param cypherCryptoJSBytes
     * @returns {CryptoJSBytes} Plain
     */
    function decryptCryptoJSBytes(priv, cypherCryptoJSBytes) {
        // Split cypher data
        let cypherStr = cryptoJS.enc.Hex.stringify(cypherCryptoJSBytes);
        let start = 0;
        let prefix = cypherStr.substring(start, start + 2);
        if (prefix != "04") {
            throw 'prefix error';
        }
        start += 2;
        let gR_x = cypherStr.substring(start, start + 64);
        start += 64;
        let gR_y = cypherStr.substring(start, start + 64);
        start += 64;
        let aesCypher = cypherStr.substring(start, cypherStr.length - 128 - 32);
        let macCypher = cypherStr.substring(cypherStr.length - 128 - 32, cypherStr.length - 32);
        let iv = cypherStr.substring(cypherStr.length - 32, cypherStr.length);
        let gR = P256.curve.point(gR_x, gR_y);
        let ivWordArray = cryptoJS.enc.Hex.parse(iv);
        aesCypher = cryptoJS.enc.Hex.parse(aesCypher);
        macCypher = cryptoJS.enc.Hex.parse(macCypher);
        return _decryptCryptoJSBytes(gR, priv, ivWordArray, aesCypher, macCypher);
    }
    ECIES.decryptCryptoJSBytes = decryptCryptoJSBytes;
    /**
     * Encrypt bytes to cypher bytes.
     * @param pub. ECC Public Key
     * @param plainBytes.
     * @returns {Promise<Uint8Array>} cypher bytes.
     */
    function encryptBytes(pub, plainBytes) {
        return __awaiter(this, void 0, void 0, function* () {
            let plainCryptoJSBytes = crypto_utils_1.Hex.toCryptoJSBytes(crypto_utils_1.Hex.fromBytes(plainBytes));
            let cypherCryptoJSBytes = yield encryptCryptoJSBytes(pub, plainCryptoJSBytes);
            return crypto_utils_1.Hex.toBytes(crypto_utils_1.Hex.fromCryptoJSBytes(cypherCryptoJSBytes));
        });
    }
    ECIES.encryptBytes = encryptBytes;
    /**
     * Decrypt cypher bytes to plain bytes.
     * @param priv. Private Key.
     * @param cypherBytes
     * @returns {Uint8Array}
     */
    function decryptBytes(priv, cypherBytes) {
        let cypherCryptoJSBytes = crypto_utils_1.Hex.toCryptoJSBytes(crypto_utils_1.Hex.fromBytes(cypherBytes));
        let plainCryptoJSBytes = decryptCryptoJSBytes(priv, cypherCryptoJSBytes);
        return crypto_utils_1.Hex.toBytes(crypto_utils_1.Hex.fromCryptoJSBytes(plainCryptoJSBytes));
    }
    ECIES.decryptBytes = decryptBytes;
    /**
     * Encrypt a string to cypher bytes.
     * @param pub. ECC Public Key
     * @param plainStr
     * @returns {Promise<Uint8Array>}
     */
    function encryptString(pub, plainStr) {
        return __awaiter(this, void 0, void 0, function* () {
            let plainCryptoJSBytes = cryptoJS.enc.Utf8.parse(plainStr);
            let cypherCryptoJSBytes = yield encryptCryptoJSBytes(pub, plainCryptoJSBytes);
            return crypto_utils_1.Hex.toBytes(crypto_utils_1.Hex.fromCryptoJSBytes(cypherCryptoJSBytes));
        });
    }
    ECIES.encryptString = encryptString;
    /**
     * Decrypt bytes to plain bytes.
     * @param priv. Private Key.
     * @param cypherBytes
     * @returns {string} plain
     */
    function decryptString(priv, cypherBytes) {
        let cypherCryptoJSBytes = crypto_utils_1.Hex.toCryptoJSBytes(crypto_utils_1.Hex.fromBytes(cypherBytes));
        let plainCryptoJSBytes = decryptCryptoJSBytes(priv, cypherCryptoJSBytes);
        return cryptoJS.enc.Utf8.stringify(plainCryptoJSBytes);
    }
    ECIES.decryptString = decryptString;
})(ECIES = exports.ECIES || (exports.ECIES = {}));
//# sourceMappingURL=ecies.js.map

/***/ }),

/***/ 6493:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Prime = exports.Rand = void 0;
const rand_1 = __webpack_require__(3254);
Object.defineProperty(exports, "Rand", ({ enumerable: true, get: function () { return rand_1.Rand; } }));
const prime_1 = __webpack_require__(3446);
Object.defineProperty(exports, "Prime", ({ enumerable: true, get: function () { return prime_1.Prime; } }));
rand_1.Rand.config_randomBytesImp(function (byteSize) {
    const crypto = __webpack_require__(6982);
    return crypto.randomBytes(byteSize);
});
rand_1.Rand.config_randomPrimeImp(function (byteSize) {
    return __awaiter(this, void 0, void 0, function* () {
        while (true) {
            let r = yield rand_1.Rand.randomBN(byteSize);
            if (prime_1.Prime.isProbablyPrime(r)) {
                return r;
            }
        }
    });
});
rand_1.Rand.config_randomSafePrimeImp(function (byteSize) {
    return __awaiter(this, void 0, void 0, function* () {
        throw "no implementation for randomSafePrime";
    });
});
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 3446:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Prime = void 0;
const BN = __webpack_require__(9404);
var Prime;
(function (Prime) {
    const smallPrimes = [
        2,
        3,
        5,
        7,
        11,
        13,
        17,
        19,
        23,
        29,
        31,
        37,
        41,
        43,
        47,
        53,
        59,
        61,
        67,
        71,
        73,
        79,
        83,
        89,
        97,
        101,
        103,
        107,
        109,
        113,
        127,
        131,
        137,
        139,
        149,
        151,
        157,
        163,
        167,
        173,
        179,
        181,
        191,
        193,
        197,
        199,
        211,
        223,
        227,
        229,
        233,
        239,
        241,
        251,
        257,
        263,
        269,
        271,
        277,
        281,
        283,
        293,
        307,
        311,
        313,
        317,
        331,
        337,
        347,
        349,
        353,
        359,
        367,
        373,
        379,
        383,
        389,
        397,
        401,
        409,
        419,
        421,
        431,
        433,
        439,
        443,
        449,
        457,
        461,
        463,
        467,
        479,
        487,
        491,
        499,
        503,
        509,
        521,
        523,
        541,
        547,
        557,
        563,
        569,
        571,
        577,
        587,
        593,
        599,
        601,
        607,
        613,
        617,
        619,
        631,
        641,
        643,
        647,
        653,
        659,
        661,
        673,
        677,
        683,
        691,
        701,
        709,
        719,
        727,
        733,
        739,
        743,
        751,
        757,
        761,
        769,
        773,
        787,
        797,
        809,
        811,
        821,
        823,
        827,
        829,
        839,
        853,
        857,
        859,
        863,
        877,
        881,
        883,
        887,
        907,
        911,
        919,
        929,
        937,
        941,
        947,
        953,
        967,
        971,
        977,
        983,
        991,
        997,
        1009,
        1013,
        1019,
        1021,
        1031,
        1033,
        1039,
        1049,
        1051,
        1061,
        1063,
        1069,
        1087,
        1091,
        1093,
        1097,
        1103,
        1109,
        1117,
        1123,
        1129,
        1151,
        1153,
        1163,
        1171,
        1181,
        1187,
        1193,
        1201,
        1213,
        1217,
        1223,
        1229
    ];
    function defaultTrial(n) {
        // choose a number of iterations sufficient to reduce the
        // probability of accepting a composite below 2**-80
        // (from menezes et al. table 4.4):
        let t = 40;
        const nBit = Math.log2(n);
        for (let pair of [
            [100, 27],
            [150, 18],
            [200, 15],
            [250, 12],
            [300, 9],
            [350, 8],
            [400, 7],
            [450, 6],
            [550, 5],
            [650, 4],
            [850, 3],
            [1300, 2]
        ]) {
            if (nBit < pair[0]) {
                break;
            }
            t = pair[1];
        }
        return t;
    }
    function isPrime(n) {
        /**
         * for small prime
         */
        if (n > 0 && n < 10000)
            throw "Input number must be in fields [0, 10000]: " + n;
        if (n === 1) {
            return false;
        }
        let r = Math.floor(Math.sqrt(n));
        for (let i = 2; i <= r; i++) {
            if (n % i === 0)
                return false;
        }
        return true;
    }
    function isProbablyPrime(n) {
        /**
         * return true if x is prime, false otherwise.
         *
         * We use the Miller‚ÄìRabin primality test, as given in: https://en.wikipedia.org/wiki/Miller%E2%80%93Rabin_primality_test.
         * This test is not exact:
         * there are composite values n for which it returns True.
         * in testing the odd numbers from 10000001 to 19999999,
         * about 66 composites got past the first test, 5 got past the second test, and none got past the third.
         * Since factors of 2, 3, 5, 7, and 11 were detected during preliminary screening,
         * the number of numbers tested by miller-rabin was (19999999 - 10000001)*(2/3)*(4/5)*(6/7) = 4.57 million.
         */
        // if n < 1000, try simple test
        if (n.ltn(10000)) {
            return isPrime(n.toNumber());
        }
        // const
        const one = new BN('1', 10);
        const two = new BN('2', 10);
        const nSub1 = n.subn(1);
        // try gcd,  and remain 1/2 * 2/3 * 4/5 * 6/7 = 0.2286
        const m = 2 * 3 * 5 * 7 * 11;
        if (!n.gcd(new BN(m.toString(), 10)).eqn(1)) {
            return false;
        }
        // get d, s
        let d = n.subn(1);
        let s = new BN('0', 10);
        while (d.modn(2) === 0) {
            d.idivn(2);
            s.iaddn(1);
        }
        // try Miller-Rabbin test
        const ctx = BN.red(n);
        let nNumber = Infinity;
        try {
            nNumber = n.toNumber();
        }
        catch (err) {
            // when n bits > 53, set number to Infinity
        }
        const t = defaultTrial(nNumber);
        let k = 0;
        while (k < t) {
            let a = new BN(smallPrimes[k].toString(), 10);
            k = k + 1;
            if (!a.gcd(n).eqn(1)) {
                return false;
            }
            a = a.toRed(ctx);
            // @ts-ignore
            let x = a.redPow(d);
            if (x.eq(one) || x.eq(nSub1)) {
                continue;
            }
            let r = 1;
            const sInt = s.toNumber();
            for (; r < sInt; r++) {
                x = x.redPow(two);
                if (x.eq(nSub1)) {
                    // continue " while(k < t) "
                    break;
                }
            }
            if (r >= sInt) {
                return false;
            }
        }
        return true;
    }
    Prime.isProbablyPrime = isProbablyPrime;
})(Prime = exports.Prime || (exports.Prime = {}));
//# sourceMappingURL=prime.js.map

/***/ }),

/***/ 3254:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Rand = void 0;
const BN = __webpack_require__(9404);
var Rand;
(function (Rand) {
    // Custom random bytes generator.
    let randomBytesImp = null;
    let randomPrimeImp = null;
    let randomSafePrimeImp = null;
    /**
     * Set your randomBytes generator.
     * @param _randomBytesImp
     */
    function config_randomBytesImp(_randomBytesImp) {
        randomBytesImp = _randomBytesImp;
    }
    Rand.config_randomBytesImp = config_randomBytesImp;
    function config_randomPrimeImp(_randomPrimeImp) {
        randomPrimeImp = _randomPrimeImp;
    }
    Rand.config_randomPrimeImp = config_randomPrimeImp;
    function config_randomSafePrimeImp(_randomSafePrimeImp) {
        randomSafePrimeImp = _randomSafePrimeImp;
    }
    Rand.config_randomSafePrimeImp = config_randomSafePrimeImp;
    function randomBytes(byteSize) {
        return __awaiter(this, void 0, void 0, function* () {
            return randomBytesImp(byteSize);
        });
    }
    Rand.randomBytes = randomBytes;
    function randomBN(byteSize) {
        return __awaiter(this, void 0, void 0, function* () {
            const buf = yield randomBytes(byteSize);
            return new BN(buf.toString('hex'), 16);
        });
    }
    Rand.randomBN = randomBN;
    function randomBNStrict(byteSize) {
        return __awaiter(this, void 0, void 0, function* () {
            while (true) {
                let buf = yield randomBytes(byteSize);
                let hByte = buf.readUInt8(0);
                if (hByte >= 127) {
                    return new BN(buf.toString('hex'), 16);
                }
            }
        });
    }
    Rand.randomBNStrict = randomBNStrict;
    function randomPrime(byteSize) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield randomPrimeImp(byteSize);
        });
    }
    Rand.randomPrime = randomPrime;
    function randomPrimeStrict(byteSize) {
        return __awaiter(this, void 0, void 0, function* () {
            while (true) {
                let r = yield Rand.randomPrime(byteSize);
                if (r.bitLength() === (byteSize * 8)) {
                    return r;
                }
            }
        });
    }
    Rand.randomPrimeStrict = randomPrimeStrict;
    function randomSafePrime(byteSize) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield randomSafePrimeImp(byteSize);
        });
    }
    Rand.randomSafePrime = randomSafePrime;
    function randomSafePrimeStrict(byteSize) {
        return __awaiter(this, void 0, void 0, function* () {
            while (true) {
                let r = yield Rand.randomSafePrime(byteSize);
                if (r.bitLength() === (byteSize * 8)) {
                    return r;
                }
            }
        });
    }
    Rand.randomSafePrimeStrict = randomSafePrimeStrict;
    function randomPrime256Bit() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield randomPrime(32);
        });
    }
    Rand.randomPrime256Bit = randomPrime256Bit;
    function randomPrimeStrict256Bit() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield randomPrimeStrict(32);
        });
    }
    Rand.randomPrimeStrict256Bit = randomPrimeStrict256Bit;
    function randomBNLt(max) {
        return __awaiter(this, void 0, void 0, function* () {
            let byteLen = 1;
            if (max.bitLength() % 8 === 0) {
                byteLen = max.bitLength() / 8;
            }
            else {
                byteLen = Math.floor(max.bitLength() / 8) + 1;
            }
            let r = yield randomBN(byteLen);
            r = r.mod(max);
            // to fix the bug in lib "bn.js" while byteLen === 1
            // @ts-ignore
            if (r.red) {
                // @ts-ignore
                return r.fromRed();
            }
            else {
                return r;
            }
        });
    }
    Rand.randomBNLt = randomBNLt;
    // for pailliar cryptosystem
    // Deprecated
    function randomBNLtGCD(max) {
        return __awaiter(this, void 0, void 0, function* () {
            while (true) {
                let r = yield randomBNLt(max);
                if (r.gcd(max).eqn(1)) {
                    return r;
                }
            }
        });
    }
    Rand.randomBNLtGCD = randomBNLtGCD;
    function randomBNLtCoPrime(max) {
        return __awaiter(this, void 0, void 0, function* () {
            while (true) {
                let r = yield randomBNLt(max);
                if (r.gcd(max).eqn(1)) {
                    return r;
                }
            }
        });
    }
    Rand.randomBNLtCoPrime = randomBNLtCoPrime;
})(Rand = exports.Rand || (exports.Rand = {}));
//# sourceMappingURL=rand.js.map

/***/ }),

/***/ 5573:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UrlBase64 = exports.Hex = void 0;
const hex_1 = __webpack_require__(8140);
Object.defineProperty(exports, "Hex", ({ enumerable: true, get: function () { return hex_1.Hex; } }));
const urlBase64_1 = __webpack_require__(351);
Object.defineProperty(exports, "UrlBase64", ({ enumerable: true, get: function () { return urlBase64_1.UrlBase64; } }));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 8140:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Hex = void 0;
const CryptoJS = __webpack_require__(1396);
/**
 * @brief: pad with "0" if the hex.length === 1; no change otherwise.
 *    - situation 1:
 *        "1" => "01"
 *        "f" => "0f"
 *
 *    - situation 1:
 *        "12" => "12"
 *        "ff" => "ff"
 * @param hex
 */
function zero2(hex) {
    if (hex.length === 1) {
        return '0' + hex;
    }
    else if (hex.length === 2) {
        return hex;
    }
    else {
        throw "Invalid hex length: " + hex.length;
    }
}
class Hex {
    /**
     * Hex ===> Bytes:
     *      "0100ff" => [0x01, 0x00, 0xff]
     *
     * @param hex
     */
    static toBytes(hex) {
        let msg = hex.replace(/[^a-z0-9]+/ig, '');
        msg = Hex.padEven(msg);
        let res = new Uint8Array(msg.length / 2);
        for (let i = 0; i < msg.length; i += 2) {
            res[i / 2] = parseInt(msg.slice(i, i + 2), 16);
        }
        return res;
    }
    /**
     * Bytes(Uint8Array) ===> Hex:
     *      [0x01, 0x00, 0xff] => "0100ff"
     *
     * @param bytes
     */
    static fromBytes(bytes) {
        var res = '';
        if (bytes.length == 0)
            return res;
        for (var i = 0; i < bytes.length; i++) {
            res += zero2(bytes[i].toString(16));
        }
        return res;
    }
    /**
     * Hex ===> CryptoJSBytes
     *
     * "1234"     ===> 0x1234
     *  "123"     ===> 0x0123
     *  "120"     ===> 0x0120
     *
     * Use the function to avoid the bugs in "crypto-js"
     *  "123"     ===> 0x1203
     *  "120"     ===> 0x1200
     *
     * More details for the bugs in "crypto-js":
     * - Problem 1
     *   const a = CryptoJS.enc.Hex.parse('d6021ef5d7cccd55cda318fe2bd47334bac0b699e4a6676f8d941f7706d3820')
     *   const expected_a = a.toString(CryptoJS.enc.Hex)
     *   console.log('expected_a:', expected_a)
     *
     *   The result is:
     *   expected_a: d6021ef5d7cccd55cda318fe2bd47334bac0b699e4a6676f8d941f7706d38200
     *
     * - Problem 2
     *   const a = CryptoJS.enc.Hex.parse('d6021ef5d7cccd55cda318fe2bd47334bac0b699e4a6676f8d941f7706d3821')
     *   const expected_a = a.toString(CryptoJS.enc.Hex)
     *   console.log('expected_a:', expected_a)
     *
     *   The result is:
     *   expected_a: d6021ef5d7cccd55cda318fe2bd47334bac0b699e4a6676f8d941f7706d38201
     * @param hex
     */
    static toCryptoJSBytes(hex) {
        return CryptoJS.enc.Hex.parse(Hex.padEven(hex));
    }
    /**
     * Bytes ===> Hex
     * @param bytes
     */
    static fromCryptoJSBytes(bytes) {
        return CryptoJS.enc.Hex.stringify(bytes);
    }
    /**
     * Reverse hex string byte by byte.
     *     "01234567" ===> "67452301"
     * @param hex
     */
    static reverseHex(hex) {
        if (hex.length % 2 !== 0) {
            throw "Invalid hex: " + hex.length + ". Length of input hex must be even!";
        }
        let bytes = Hex.toBytes(hex);
        var res = '';
        for (let i = bytes.length - 1; i >= 0; i--)
            res += zero2(bytes[i].toString(16));
        return res;
    }
    /**
     * Pad the hex string to the specified length
     * @param hex. For example "01020304"
     * @param expectedLen. For example 16
     * @returns {*} For example "0000000001020304"
     */
    static padLength(hex, expectedLen) {
        if (hex.length > expectedLen) {
            throw "Input hex is too long(" + hex.length + " chars). It should be no more than " + expectedLen + " chars according to specified expectedLen.";
        }
        while (expectedLen > hex.length) {
            hex = '0' + hex;
        }
        return hex;
    }
    /**
     * Pad to 64 chars long
     * @param hex
     * @returns {*}
     */
    static pad64(hex) {
        return Hex.padLength(hex, 64);
    }
    /**
     * Pad to 32 chars long
     * @param hex
     * @returns {*}
     */
    static pad32(hex) {
        return Hex.padLength(hex, 32);
    }
    /**
     * Pad to 16 chars long
     * "12345678" => "0000000012345678"
     * @param hex
     * @returns {*}
     */
    static pad16(hex) {
        return Hex.padLength(hex, 16);
    }
    /**
     * Pad to 8 chars long
     * "1234567" => "01234567"
     * @param hex
     * @returns {*}
     */
    static pad8(hex) {
        return Hex.padLength(hex, 8);
    }
    /**
     * Pad to 4 chars long
     * "1" => "0001"
     * @param hex
     * @returns {*}
     */
    static pad4(hex) {
        return Hex.padLength(hex, 4);
    }
    /**
     * Pad to 2 chars long
     * "1" => "01"
     * @param hex
     * @returns {*}
     */
    static pad2(hex) {
        return Hex.padLength(hex, 2);
    }
    /**
     * Pad to even chars.
     * "123" => "0123"
     * @param hex
     * @returns {*}
     */
    static padEven(hex) {
        if (hex.length % 2 !== 0) {
            hex = '0' + hex;
        }
        return hex;
    }
}
exports.Hex = Hex;
//# sourceMappingURL=hex.js.map

/***/ }),

/***/ 351:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/**
 * Convert binary data to and from UrlBase64 encoding.
 * This is identical to Base64 encoding, except that the padding character is "." and the other
 * non-alphanumeric characters are "-" and "_" instead of "+" and "/".
 * The purpose of UrlBase64 encoding is to provide a compact encoding of binary data that is safe
 * for use as an URL parameter. Base64 encoding does not produce encoded values that are safe for
 * use in URLs, since "/" can be interpreted as a path delimiter; "+" is the encoded form of a space;
 * and "=" is used to separate a name from the corresponding value in an URL parameter.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UrlBase64 = void 0;
const CryptoJS = __webpack_require__(1396);
const hex_1 = __webpack_require__(8140);
class UrlBase64 {
    /**
     * UrlBase64 ===> Bytes:
     * @param urlBase64
     */
    static toBytes(urlBase64) {
        // UrlBase64 ==> CryptoJSBytes ==> Hex ==> Bytes: Uint8Array
        return hex_1.Hex.toBytes(hex_1.Hex.fromCryptoJSBytes(UrlBase64.toCryptoJSBytes(urlBase64)));
    }
    /**
     * Bytes(Uint8Array) ===> UrlBase64:
     * @param bytes
     */
    static fromBytes(bytes) {
        // Bytes: Uint8Array ==> Hex ==> CryptoJSBytes ==> UrlBase64
        return UrlBase64.fromCryptoJSBytes(hex_1.Hex.toCryptoJSBytes(hex_1.Hex.fromBytes(bytes)));
    }
    /**
     * UrlBase64 ===> CryptoJSBytes:
     * @param urlBase64
     */
    static toCryptoJSBytes(urlBase64) {
        let base64 = urlBase64.replace(/\./g, '=').replace(/-/g, '+').replace(/_/g, '/');
        return CryptoJS.enc.Base64.parse(base64);
    }
    /**
     * CryptoJSBytes ===> UrlBase64:
     * @param bytes
     */
    static fromCryptoJSBytes(bytes) {
        let base64 = CryptoJS.enc.Base64.stringify(bytes);
        return base64.replace(/=/g, '.').replace(/\+/g, '-').replace(/\//g, '_');
    }
}
exports.UrlBase64 = UrlBase64;
//# sourceMappingURL=urlBase64.js.map

/***/ }),

/***/ 972:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Copyright (C) 2016 Dmitry Chestnykh
// MIT License. See LICENSE file for details.
Object.defineProperty(exports, "__esModule", ({ value: true }));
/**
 * Package binary provides functions for encoding and decoding numbers in byte arrays.
 */
var int_1 = __webpack_require__(4512);
// TODO(dchest): add asserts for correct value ranges and array offsets.
/**
 * Reads 2 bytes from array starting at offset as big-endian
 * signed 16-bit integer and returns it.
 */
function readInt16BE(array, offset) {
    if (offset === void 0) { offset = 0; }
    return (((array[offset + 0] << 8) | array[offset + 1]) << 16) >> 16;
}
exports.readInt16BE = readInt16BE;
/**
 * Reads 2 bytes from array starting at offset as big-endian
 * unsigned 16-bit integer and returns it.
 */
function readUint16BE(array, offset) {
    if (offset === void 0) { offset = 0; }
    return ((array[offset + 0] << 8) | array[offset + 1]) >>> 0;
}
exports.readUint16BE = readUint16BE;
/**
 * Reads 2 bytes from array starting at offset as little-endian
 * signed 16-bit integer and returns it.
 */
function readInt16LE(array, offset) {
    if (offset === void 0) { offset = 0; }
    return (((array[offset + 1] << 8) | array[offset]) << 16) >> 16;
}
exports.readInt16LE = readInt16LE;
/**
 * Reads 2 bytes from array starting at offset as little-endian
 * unsigned 16-bit integer and returns it.
 */
function readUint16LE(array, offset) {
    if (offset === void 0) { offset = 0; }
    return ((array[offset + 1] << 8) | array[offset]) >>> 0;
}
exports.readUint16LE = readUint16LE;
/**
 * Writes 2-byte big-endian representation of 16-bit unsigned
 * value to byte array starting at offset.
 *
 * If byte array is not given, creates a new 2-byte one.
 *
 * Returns the output byte array.
 */
function writeUint16BE(value, out, offset) {
    if (out === void 0) { out = new Uint8Array(2); }
    if (offset === void 0) { offset = 0; }
    out[offset + 0] = value >>> 8;
    out[offset + 1] = value >>> 0;
    return out;
}
exports.writeUint16BE = writeUint16BE;
exports.writeInt16BE = writeUint16BE;
/**
 * Writes 2-byte little-endian representation of 16-bit unsigned
 * value to array starting at offset.
 *
 * If byte array is not given, creates a new 2-byte one.
 *
 * Returns the output byte array.
 */
function writeUint16LE(value, out, offset) {
    if (out === void 0) { out = new Uint8Array(2); }
    if (offset === void 0) { offset = 0; }
    out[offset + 0] = value >>> 0;
    out[offset + 1] = value >>> 8;
    return out;
}
exports.writeUint16LE = writeUint16LE;
exports.writeInt16LE = writeUint16LE;
/**
 * Reads 4 bytes from array starting at offset as big-endian
 * signed 32-bit integer and returns it.
 */
function readInt32BE(array, offset) {
    if (offset === void 0) { offset = 0; }
    return (array[offset] << 24) |
        (array[offset + 1] << 16) |
        (array[offset + 2] << 8) |
        array[offset + 3];
}
exports.readInt32BE = readInt32BE;
/**
 * Reads 4 bytes from array starting at offset as big-endian
 * unsigned 32-bit integer and returns it.
 */
function readUint32BE(array, offset) {
    if (offset === void 0) { offset = 0; }
    return ((array[offset] << 24) |
        (array[offset + 1] << 16) |
        (array[offset + 2] << 8) |
        array[offset + 3]) >>> 0;
}
exports.readUint32BE = readUint32BE;
/**
 * Reads 4 bytes from array starting at offset as little-endian
 * signed 32-bit integer and returns it.
 */
function readInt32LE(array, offset) {
    if (offset === void 0) { offset = 0; }
    return (array[offset + 3] << 24) |
        (array[offset + 2] << 16) |
        (array[offset + 1] << 8) |
        array[offset];
}
exports.readInt32LE = readInt32LE;
/**
 * Reads 4 bytes from array starting at offset as little-endian
 * unsigned 32-bit integer and returns it.
 */
function readUint32LE(array, offset) {
    if (offset === void 0) { offset = 0; }
    return ((array[offset + 3] << 24) |
        (array[offset + 2] << 16) |
        (array[offset + 1] << 8) |
        array[offset]) >>> 0;
}
exports.readUint32LE = readUint32LE;
/**
 * Writes 4-byte big-endian representation of 32-bit unsigned
 * value to byte array starting at offset.
 *
 * If byte array is not given, creates a new 4-byte one.
 *
 * Returns the output byte array.
 */
function writeUint32BE(value, out, offset) {
    if (out === void 0) { out = new Uint8Array(4); }
    if (offset === void 0) { offset = 0; }
    out[offset + 0] = value >>> 24;
    out[offset + 1] = value >>> 16;
    out[offset + 2] = value >>> 8;
    out[offset + 3] = value >>> 0;
    return out;
}
exports.writeUint32BE = writeUint32BE;
exports.writeInt32BE = writeUint32BE;
/**
 * Writes 4-byte little-endian representation of 32-bit unsigned
 * value to array starting at offset.
 *
 * If byte array is not given, creates a new 4-byte one.
 *
 * Returns the output byte array.
 */
function writeUint32LE(value, out, offset) {
    if (out === void 0) { out = new Uint8Array(4); }
    if (offset === void 0) { offset = 0; }
    out[offset + 0] = value >>> 0;
    out[offset + 1] = value >>> 8;
    out[offset + 2] = value >>> 16;
    out[offset + 3] = value >>> 24;
    return out;
}
exports.writeUint32LE = writeUint32LE;
exports.writeInt32LE = writeUint32LE;
/**
 * Reads 8 bytes from array starting at offset as big-endian
 * signed 64-bit integer and returns it.
 *
 * IMPORTANT: due to JavaScript limitation, supports exact
 * numbers in range -9007199254740991 to 9007199254740991.
 * If the number stored in the byte array is outside this range,
 * the result is not exact.
 */
function readInt64BE(array, offset) {
    if (offset === void 0) { offset = 0; }
    var hi = readInt32BE(array, offset);
    var lo = readInt32BE(array, offset + 4);
    return hi * 0x100000000 + lo - ((lo >> 31) * 0x100000000);
}
exports.readInt64BE = readInt64BE;
/**
 * Reads 8 bytes from array starting at offset as big-endian
 * unsigned 64-bit integer and returns it.
 *
 * IMPORTANT: due to JavaScript limitation, supports values up to 2^53-1.
 */
function readUint64BE(array, offset) {
    if (offset === void 0) { offset = 0; }
    var hi = readUint32BE(array, offset);
    var lo = readUint32BE(array, offset + 4);
    return hi * 0x100000000 + lo;
}
exports.readUint64BE = readUint64BE;
/**
 * Reads 8 bytes from array starting at offset as little-endian
 * signed 64-bit integer and returns it.
 *
 * IMPORTANT: due to JavaScript limitation, supports exact
 * numbers in range -9007199254740991 to 9007199254740991.
 * If the number stored in the byte array is outside this range,
 * the result is not exact.
 */
function readInt64LE(array, offset) {
    if (offset === void 0) { offset = 0; }
    var lo = readInt32LE(array, offset);
    var hi = readInt32LE(array, offset + 4);
    return hi * 0x100000000 + lo - ((lo >> 31) * 0x100000000);
}
exports.readInt64LE = readInt64LE;
/**
 * Reads 8 bytes from array starting at offset as little-endian
 * unsigned 64-bit integer and returns it.
 *
 * IMPORTANT: due to JavaScript limitation, supports values up to 2^53-1.
 */
function readUint64LE(array, offset) {
    if (offset === void 0) { offset = 0; }
    var lo = readUint32LE(array, offset);
    var hi = readUint32LE(array, offset + 4);
    return hi * 0x100000000 + lo;
}
exports.readUint64LE = readUint64LE;
/**
 * Writes 8-byte big-endian representation of 64-bit unsigned
 * value to byte array starting at offset.
 *
 * Due to JavaScript limitation, supports values up to 2^53-1.
 *
 * If byte array is not given, creates a new 8-byte one.
 *
 * Returns the output byte array.
 */
function writeUint64BE(value, out, offset) {
    if (out === void 0) { out = new Uint8Array(8); }
    if (offset === void 0) { offset = 0; }
    writeUint32BE(value / 0x100000000 >>> 0, out, offset);
    writeUint32BE(value >>> 0, out, offset + 4);
    return out;
}
exports.writeUint64BE = writeUint64BE;
exports.writeInt64BE = writeUint64BE;
/**
 * Writes 8-byte little-endian representation of 64-bit unsigned
 * value to byte array starting at offset.
 *
 * Due to JavaScript limitation, supports values up to 2^53-1.
 *
 * If byte array is not given, creates a new 8-byte one.
 *
 * Returns the output byte array.
 */
function writeUint64LE(value, out, offset) {
    if (out === void 0) { out = new Uint8Array(8); }
    if (offset === void 0) { offset = 0; }
    writeUint32LE(value >>> 0, out, offset);
    writeUint32LE(value / 0x100000000 >>> 0, out, offset + 4);
    return out;
}
exports.writeUint64LE = writeUint64LE;
exports.writeInt64LE = writeUint64LE;
/**
 * Reads bytes from array starting at offset as big-endian
 * unsigned bitLen-bit integer and returns it.
 *
 * Supports bit lengths divisible by 8, up to 48.
 */
function readUintBE(bitLength, array, offset) {
    if (offset === void 0) { offset = 0; }
    // TODO(dchest): implement support for bitLengths non-divisible by 8
    if (bitLength % 8 !== 0) {
        throw new Error("readUintBE supports only bitLengths divisible by 8");
    }
    if (bitLength / 8 > array.length - offset) {
        throw new Error("readUintBE: array is too short for the given bitLength");
    }
    var result = 0;
    var mul = 1;
    for (var i = bitLength / 8 + offset - 1; i >= offset; i--) {
        result += array[i] * mul;
        mul *= 256;
    }
    return result;
}
exports.readUintBE = readUintBE;
/**
 * Reads bytes from array starting at offset as little-endian
 * unsigned bitLen-bit integer and returns it.
 *
 * Supports bit lengths divisible by 8, up to 48.
 */
function readUintLE(bitLength, array, offset) {
    if (offset === void 0) { offset = 0; }
    // TODO(dchest): implement support for bitLengths non-divisible by 8
    if (bitLength % 8 !== 0) {
        throw new Error("readUintLE supports only bitLengths divisible by 8");
    }
    if (bitLength / 8 > array.length - offset) {
        throw new Error("readUintLE: array is too short for the given bitLength");
    }
    var result = 0;
    var mul = 1;
    for (var i = offset; i < offset + bitLength / 8; i++) {
        result += array[i] * mul;
        mul *= 256;
    }
    return result;
}
exports.readUintLE = readUintLE;
/**
 * Writes a big-endian representation of bitLen-bit unsigned
 * value to array starting at offset.
 *
 * Supports bit lengths divisible by 8, up to 48.
 *
 * If byte array is not given, creates a new one.
 *
 * Returns the output byte array.
 */
function writeUintBE(bitLength, value, out, offset) {
    if (out === void 0) { out = new Uint8Array(bitLength / 8); }
    if (offset === void 0) { offset = 0; }
    // TODO(dchest): implement support for bitLengths non-divisible by 8
    if (bitLength % 8 !== 0) {
        throw new Error("writeUintBE supports only bitLengths divisible by 8");
    }
    if (!int_1.isSafeInteger(value)) {
        throw new Error("writeUintBE value must be an integer");
    }
    var div = 1;
    for (var i = bitLength / 8 + offset - 1; i >= offset; i--) {
        out[i] = (value / div) & 0xff;
        div *= 256;
    }
    return out;
}
exports.writeUintBE = writeUintBE;
/**
 * Writes a little-endian representation of bitLen-bit unsigned
 * value to array starting at offset.
 *
 * Supports bit lengths divisible by 8, up to 48.
 *
 * If byte array is not given, creates a new one.
 *
 * Returns the output byte array.
 */
function writeUintLE(bitLength, value, out, offset) {
    if (out === void 0) { out = new Uint8Array(bitLength / 8); }
    if (offset === void 0) { offset = 0; }
    // TODO(dchest): implement support for bitLengths non-divisible by 8
    if (bitLength % 8 !== 0) {
        throw new Error("writeUintLE supports only bitLengths divisible by 8");
    }
    if (!int_1.isSafeInteger(value)) {
        throw new Error("writeUintLE value must be an integer");
    }
    var div = 1;
    for (var i = offset; i < offset + bitLength / 8; i++) {
        out[i] = (value / div) & 0xff;
        div *= 256;
    }
    return out;
}
exports.writeUintLE = writeUintLE;
/**
 * Reads 4 bytes from array starting at offset as big-endian
 * 32-bit floating-point number and returns it.
 */
function readFloat32BE(array, offset) {
    if (offset === void 0) { offset = 0; }
    var view = new DataView(array.buffer, array.byteOffset, array.byteLength);
    return view.getFloat32(offset);
}
exports.readFloat32BE = readFloat32BE;
/**
 * Reads 4 bytes from array starting at offset as little-endian
 * 32-bit floating-point number and returns it.
 */
function readFloat32LE(array, offset) {
    if (offset === void 0) { offset = 0; }
    var view = new DataView(array.buffer, array.byteOffset, array.byteLength);
    return view.getFloat32(offset, true);
}
exports.readFloat32LE = readFloat32LE;
/**
 * Reads 8 bytes from array starting at offset as big-endian
 * 64-bit floating-point number ("double") and returns it.
 */
function readFloat64BE(array, offset) {
    if (offset === void 0) { offset = 0; }
    var view = new DataView(array.buffer, array.byteOffset, array.byteLength);
    return view.getFloat64(offset);
}
exports.readFloat64BE = readFloat64BE;
/**
 * Reads 8 bytes from array starting at offset as little-endian
 * 64-bit floating-point number ("double") and returns it.
 */
function readFloat64LE(array, offset) {
    if (offset === void 0) { offset = 0; }
    var view = new DataView(array.buffer, array.byteOffset, array.byteLength);
    return view.getFloat64(offset, true);
}
exports.readFloat64LE = readFloat64LE;
/**
 * Writes 4-byte big-endian floating-point representation of value
 * to byte array starting at offset.
 *
 * If byte array is not given, creates a new 4-byte one.
 *
 * Returns the output byte array.
 */
function writeFloat32BE(value, out, offset) {
    if (out === void 0) { out = new Uint8Array(4); }
    if (offset === void 0) { offset = 0; }
    var view = new DataView(out.buffer, out.byteOffset, out.byteLength);
    view.setFloat32(offset, value);
    return out;
}
exports.writeFloat32BE = writeFloat32BE;
/**
 * Writes 4-byte little-endian floating-point representation of value
 * to byte array starting at offset.
 *
 * If byte array is not given, creates a new 4-byte one.
 *
 * Returns the output byte array.
 */
function writeFloat32LE(value, out, offset) {
    if (out === void 0) { out = new Uint8Array(4); }
    if (offset === void 0) { offset = 0; }
    var view = new DataView(out.buffer, out.byteOffset, out.byteLength);
    view.setFloat32(offset, value, true);
    return out;
}
exports.writeFloat32LE = writeFloat32LE;
/**
 * Writes 8-byte big-endian floating-point representation of value
 * to byte array starting at offset.
 *
 * If byte array is not given, creates a new 8-byte one.
 *
 * Returns the output byte array.
 */
function writeFloat64BE(value, out, offset) {
    if (out === void 0) { out = new Uint8Array(8); }
    if (offset === void 0) { offset = 0; }
    var view = new DataView(out.buffer, out.byteOffset, out.byteLength);
    view.setFloat64(offset, value);
    return out;
}
exports.writeFloat64BE = writeFloat64BE;
/**
 * Writes 8-byte little-endian floating-point representation of value
 * to byte array starting at offset.
 *
 * If byte array is not given, creates a new 8-byte one.
 *
 * Returns the output byte array.
 */
function writeFloat64LE(value, out, offset) {
    if (out === void 0) { out = new Uint8Array(8); }
    if (offset === void 0) { offset = 0; }
    var view = new DataView(out.buffer, out.byteOffset, out.byteLength);
    view.setFloat64(offset, value, true);
    return out;
}
exports.writeFloat64LE = writeFloat64LE;
//# sourceMappingURL=binary.js.map

/***/ }),

/***/ 4512:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// Copyright (C) 2016 Dmitry Chestnykh
// MIT License. See LICENSE file for details.
Object.defineProperty(exports, "__esModule", ({ value: true }));
/**
 * Package int provides helper functions for integerss.
 */
// Shim using 16-bit pieces.
function imulShim(a, b) {
    var ah = (a >>> 16) & 0xffff, al = a & 0xffff;
    var bh = (b >>> 16) & 0xffff, bl = b & 0xffff;
    return ((al * bl) + (((ah * bl + al * bh) << 16) >>> 0) | 0);
}
/** 32-bit integer multiplication.  */
// Use system Math.imul if available, otherwise use our shim.
exports.mul = Math.imul || imulShim;
/** 32-bit integer addition.  */
function add(a, b) {
    return (a + b) | 0;
}
exports.add = add;
/**  32-bit integer subtraction.  */
function sub(a, b) {
    return (a - b) | 0;
}
exports.sub = sub;
/** 32-bit integer left rotation */
function rotl(x, n) {
    return x << n | x >>> (32 - n);
}
exports.rotl = rotl;
/** 32-bit integer left rotation */
function rotr(x, n) {
    return x << (32 - n) | x >>> n;
}
exports.rotr = rotr;
function isIntegerShim(n) {
    return typeof n === "number" && isFinite(n) && Math.floor(n) === n;
}
/**
 * Returns true if the argument is an integer number.
 *
 * In ES2015, Number.isInteger.
 */
exports.isInteger = Number.isInteger || isIntegerShim;
/**
 *  Math.pow(2, 53) - 1
 *
 *  In ES2015 Number.MAX_SAFE_INTEGER.
 */
exports.MAX_SAFE_INTEGER = 9007199254740991;
/**
 * Returns true if the argument is a safe integer number
 * (-MIN_SAFE_INTEGER < number <= MAX_SAFE_INTEGER)
 *
 * In ES2015, Number.isSafeInteger.
 */
exports.isSafeInteger = function (n) {
    return exports.isInteger(n) && (n >= -exports.MAX_SAFE_INTEGER && n <= exports.MAX_SAFE_INTEGER);
};
//# sourceMappingURL=int.js.map

/***/ }),

/***/ 7052:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Copyright (C) 2016 Dmitry Chestnykh
// MIT License. See LICENSE file for details.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.randomStringForEntropy = exports.randomString = exports.randomUint32 = exports.randomBytes = exports.defaultRandomSource = void 0;
const system_1 = __webpack_require__(5492);
const binary_1 = __webpack_require__(972);
const wipe_1 = __webpack_require__(6228);
exports.defaultRandomSource = new system_1.SystemRandomSource();
function randomBytes(length, prng = exports.defaultRandomSource) {
    return prng.randomBytes(length);
}
exports.randomBytes = randomBytes;
/**
 * Returns a uniformly random unsigned 32-bit integer.
 */
function randomUint32(prng = exports.defaultRandomSource) {
    // Generate 4-byte random buffer.
    const buf = randomBytes(4, prng);
    // Convert bytes from buffer into a 32-bit integer.
    // It's not important which byte order to use, since
    // the result is random.
    const result = (0, binary_1.readUint32LE)(buf);
    // Clean the buffer.
    (0, wipe_1.wipe)(buf);
    return result;
}
exports.randomUint32 = randomUint32;
/** 62 alphanumeric characters for default charset of randomString() */
const ALPHANUMERIC = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
/**
 * Returns a uniform random string of the given length
 * with characters from the given charset.
 *
 * Charset must not have more than 256 characters.
 *
 * Default charset generates case-sensitive alphanumeric
 * strings (0-9, A-Z, a-z).
 */
function randomString(length, charset = ALPHANUMERIC, prng = exports.defaultRandomSource) {
    if (charset.length < 2) {
        throw new Error("randomString charset is too short");
    }
    if (charset.length > 256) {
        throw new Error("randomString charset is too long");
    }
    let out = '';
    const charsLen = charset.length;
    const maxByte = 256 - (256 % charsLen);
    while (length > 0) {
        const buf = randomBytes(Math.ceil(length * 256 / maxByte), prng);
        for (let i = 0; i < buf.length && length > 0; i++) {
            const randomByte = buf[i];
            if (randomByte < maxByte) {
                out += charset.charAt(randomByte % charsLen);
                length--;
            }
        }
        (0, wipe_1.wipe)(buf);
    }
    return out;
}
exports.randomString = randomString;
/**
 * Returns uniform random string containing at least the given
 * number of bits of entropy.
 *
 * For example, randomStringForEntropy(128) will return a 22-character
 * alphanumeric string, while randomStringForEntropy(128, "0123456789")
 * will return a 39-character numeric string, both will contain at
 * least 128 bits of entropy.
 *
 * Default charset generates case-sensitive alphanumeric
 * strings (0-9, A-Z, a-z).
 */
function randomStringForEntropy(bits, charset = ALPHANUMERIC, prng = exports.defaultRandomSource) {
    const length = Math.ceil(bits / (Math.log(charset.length) / Math.LN2));
    return randomString(length, charset, prng);
}
exports.randomStringForEntropy = randomStringForEntropy;
//# sourceMappingURL=random.js.map

/***/ }),

/***/ 7029:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// Copyright (C) 2016 Dmitry Chestnykh
// MIT License. See LICENSE file for details.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BrowserRandomSource = void 0;
const QUOTA = 65536;
class BrowserRandomSource {
    constructor() {
        this.isAvailable = false;
        this.isInstantiated = false;
        const browserCrypto = typeof self !== 'undefined'
            ? (self.crypto || self.msCrypto) // IE11 has msCrypto
            : null;
        if (browserCrypto && browserCrypto.getRandomValues !== undefined) {
            this._crypto = browserCrypto;
            this.isAvailable = true;
            this.isInstantiated = true;
        }
    }
    randomBytes(length) {
        if (!this.isAvailable || !this._crypto) {
            throw new Error("Browser random byte generator is not available.");
        }
        const out = new Uint8Array(length);
        for (let i = 0; i < out.length; i += QUOTA) {
            this._crypto.getRandomValues(out.subarray(i, i + Math.min(out.length - i, QUOTA)));
        }
        return out;
    }
}
exports.BrowserRandomSource = BrowserRandomSource;
//# sourceMappingURL=browser.js.map

/***/ }),

/***/ 5821:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Copyright (C) 2016 Dmitry Chestnykh
// MIT License. See LICENSE file for details.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NodeRandomSource = void 0;
const wipe_1 = __webpack_require__(6228);
class NodeRandomSource {
    constructor() {
        this.isAvailable = false;
        this.isInstantiated = false;
        if (true) {
            const nodeCrypto = __webpack_require__(6982);
            if (nodeCrypto && nodeCrypto.randomBytes) {
                this._crypto = nodeCrypto;
                this.isAvailable = true;
                this.isInstantiated = true;
            }
        }
    }
    randomBytes(length) {
        if (!this.isAvailable || !this._crypto) {
            throw new Error("Node.js random byte generator is not available.");
        }
        // Get random bytes (result is Buffer).
        let buffer = this._crypto.randomBytes(length);
        // Make sure we got the length that we requested.
        if (buffer.length !== length) {
            throw new Error("NodeRandomSource: got fewer bytes than requested");
        }
        // Allocate output array.
        const out = new Uint8Array(length);
        // Copy bytes from buffer to output.
        for (let i = 0; i < out.length; i++) {
            out[i] = buffer[i];
        }
        // Cleanup.
        (0, wipe_1.wipe)(buffer);
        return out;
    }
}
exports.NodeRandomSource = NodeRandomSource;
//# sourceMappingURL=node.js.map

/***/ }),

/***/ 5492:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Copyright (C) 2016 Dmitry Chestnykh
// MIT License. See LICENSE file for details.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SystemRandomSource = void 0;
const browser_1 = __webpack_require__(7029);
const node_1 = __webpack_require__(5821);
class SystemRandomSource {
    constructor() {
        this.isAvailable = false;
        this.name = "";
        // Try browser.
        this._source = new browser_1.BrowserRandomSource();
        if (this._source.isAvailable) {
            this.isAvailable = true;
            this.name = "Browser";
            return;
        }
        // If no browser source, try Node.
        this._source = new node_1.NodeRandomSource();
        if (this._source.isAvailable) {
            this.isAvailable = true;
            this.name = "Node";
            return;
        }
        // No sources, we're out of options.
    }
    randomBytes(length) {
        if (!this.isAvailable) {
            throw new Error("System random byte generator is not available.");
        }
        return this._source.randomBytes(length);
    }
}
exports.SystemRandomSource = SystemRandomSource;
//# sourceMappingURL=system.js.map

/***/ }),

/***/ 6228:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// Copyright (C) 2016 Dmitry Chestnykh
// MIT License. See LICENSE file for details.
Object.defineProperty(exports, "__esModule", ({ value: true }));
/**
 * Sets all values in the given array to zero and returns it.
 *
 * The fact that it sets bytes to zero can be relied on.
 *
 * There is no guarantee that this function makes data disappear from memory,
 * as runtime implementation can, for example, have copying garbage collector
 * that will make copies of sensitive data before we wipe it. Or that an
 * operating system will write our data to swap or sleep image. Another thing
 * is that an optimizing compiler can remove calls to this function or make it
 * no-op. There's nothing we can do with it, so we just do our best and hope
 * that everything will be okay and good will triumph over evil.
 */
function wipe(array) {
    // Right now it's similar to array.fill(0). If it turns
    // out that runtimes optimize this call away, maybe
    // we can try something else.
    for (var i = 0; i < array.length; i++) {
        array[i] = 0;
    }
    return array;
}
exports.wipe = wipe;
//# sourceMappingURL=wipe.js.map

/***/ }),

/***/ 774:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Copyright (C) 2016 Dmitry Chestnykh
// MIT License. See LICENSE file for details.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.sharedKey = exports.generateKeyPair = exports.generateKeyPairFromSeed = exports.scalarMultBase = exports.scalarMult = exports.SHARED_KEY_LENGTH = exports.SECRET_KEY_LENGTH = exports.PUBLIC_KEY_LENGTH = void 0;
/**
 * Package x25519 implements X25519 key agreement.
 */
const random_1 = __webpack_require__(7052);
const wipe_1 = __webpack_require__(6228);
exports.PUBLIC_KEY_LENGTH = 32;
exports.SECRET_KEY_LENGTH = 32;
exports.SHARED_KEY_LENGTH = 32;
// Returns new zero-filled 16-element GF (Float64Array).
// If passed an array of numbers, prefills the returned
// array with them.
//
// We use Float64Array, because we need 48-bit numbers
// for this implementation.
function gf(init) {
    const r = new Float64Array(16);
    if (init) {
        for (let i = 0; i < init.length; i++) {
            r[i] = init[i];
        }
    }
    return r;
}
// Base point.
const _9 = new Uint8Array(32);
_9[0] = 9;
const _121665 = gf([0xdb41, 1]);
function car25519(o) {
    let c = 1;
    for (let i = 0; i < 16; i++) {
        let v = o[i] + c + 65535;
        c = Math.floor(v / 65536);
        o[i] = v - c * 65536;
    }
    o[0] += c - 1 + 37 * (c - 1);
}
function sel25519(p, q, b) {
    const c = ~(b - 1);
    for (let i = 0; i < 16; i++) {
        const t = c & (p[i] ^ q[i]);
        p[i] ^= t;
        q[i] ^= t;
    }
}
function pack25519(o, n) {
    const m = gf();
    const t = gf();
    for (let i = 0; i < 16; i++) {
        t[i] = n[i];
    }
    car25519(t);
    car25519(t);
    car25519(t);
    for (let j = 0; j < 2; j++) {
        m[0] = t[0] - 0xffed;
        for (let i = 1; i < 15; i++) {
            m[i] = t[i] - 0xffff - ((m[i - 1] >> 16) & 1);
            m[i - 1] &= 0xffff;
        }
        m[15] = t[15] - 0x7fff - ((m[14] >> 16) & 1);
        const b = (m[15] >> 16) & 1;
        m[14] &= 0xffff;
        sel25519(t, m, 1 - b);
    }
    for (let i = 0; i < 16; i++) {
        o[2 * i] = t[i] & 0xff;
        o[2 * i + 1] = t[i] >> 8;
    }
}
function unpack25519(o, n) {
    for (let i = 0; i < 16; i++) {
        o[i] = n[2 * i] + (n[2 * i + 1] << 8);
    }
    o[15] &= 0x7fff;
}
function add(o, a, b) {
    for (let i = 0; i < 16; i++) {
        o[i] = a[i] + b[i];
    }
}
function sub(o, a, b) {
    for (let i = 0; i < 16; i++) {
        o[i] = a[i] - b[i];
    }
}
function mul(o, a, b) {
    let v, c, t0 = 0, t1 = 0, t2 = 0, t3 = 0, t4 = 0, t5 = 0, t6 = 0, t7 = 0, t8 = 0, t9 = 0, t10 = 0, t11 = 0, t12 = 0, t13 = 0, t14 = 0, t15 = 0, t16 = 0, t17 = 0, t18 = 0, t19 = 0, t20 = 0, t21 = 0, t22 = 0, t23 = 0, t24 = 0, t25 = 0, t26 = 0, t27 = 0, t28 = 0, t29 = 0, t30 = 0, b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3], b4 = b[4], b5 = b[5], b6 = b[6], b7 = b[7], b8 = b[8], b9 = b[9], b10 = b[10], b11 = b[11], b12 = b[12], b13 = b[13], b14 = b[14], b15 = b[15];
    v = a[0];
    t0 += v * b0;
    t1 += v * b1;
    t2 += v * b2;
    t3 += v * b3;
    t4 += v * b4;
    t5 += v * b5;
    t6 += v * b6;
    t7 += v * b7;
    t8 += v * b8;
    t9 += v * b9;
    t10 += v * b10;
    t11 += v * b11;
    t12 += v * b12;
    t13 += v * b13;
    t14 += v * b14;
    t15 += v * b15;
    v = a[1];
    t1 += v * b0;
    t2 += v * b1;
    t3 += v * b2;
    t4 += v * b3;
    t5 += v * b4;
    t6 += v * b5;
    t7 += v * b6;
    t8 += v * b7;
    t9 += v * b8;
    t10 += v * b9;
    t11 += v * b10;
    t12 += v * b11;
    t13 += v * b12;
    t14 += v * b13;
    t15 += v * b14;
    t16 += v * b15;
    v = a[2];
    t2 += v * b0;
    t3 += v * b1;
    t4 += v * b2;
    t5 += v * b3;
    t6 += v * b4;
    t7 += v * b5;
    t8 += v * b6;
    t9 += v * b7;
    t10 += v * b8;
    t11 += v * b9;
    t12 += v * b10;
    t13 += v * b11;
    t14 += v * b12;
    t15 += v * b13;
    t16 += v * b14;
    t17 += v * b15;
    v = a[3];
    t3 += v * b0;
    t4 += v * b1;
    t5 += v * b2;
    t6 += v * b3;
    t7 += v * b4;
    t8 += v * b5;
    t9 += v * b6;
    t10 += v * b7;
    t11 += v * b8;
    t12 += v * b9;
    t13 += v * b10;
    t14 += v * b11;
    t15 += v * b12;
    t16 += v * b13;
    t17 += v * b14;
    t18 += v * b15;
    v = a[4];
    t4 += v * b0;
    t5 += v * b1;
    t6 += v * b2;
    t7 += v * b3;
    t8 += v * b4;
    t9 += v * b5;
    t10 += v * b6;
    t11 += v * b7;
    t12 += v * b8;
    t13 += v * b9;
    t14 += v * b10;
    t15 += v * b11;
    t16 += v * b12;
    t17 += v * b13;
    t18 += v * b14;
    t19 += v * b15;
    v = a[5];
    t5 += v * b0;
    t6 += v * b1;
    t7 += v * b2;
    t8 += v * b3;
    t9 += v * b4;
    t10 += v * b5;
    t11 += v * b6;
    t12 += v * b7;
    t13 += v * b8;
    t14 += v * b9;
    t15 += v * b10;
    t16 += v * b11;
    t17 += v * b12;
    t18 += v * b13;
    t19 += v * b14;
    t20 += v * b15;
    v = a[6];
    t6 += v * b0;
    t7 += v * b1;
    t8 += v * b2;
    t9 += v * b3;
    t10 += v * b4;
    t11 += v * b5;
    t12 += v * b6;
    t13 += v * b7;
    t14 += v * b8;
    t15 += v * b9;
    t16 += v * b10;
    t17 += v * b11;
    t18 += v * b12;
    t19 += v * b13;
    t20 += v * b14;
    t21 += v * b15;
    v = a[7];
    t7 += v * b0;
    t8 += v * b1;
    t9 += v * b2;
    t10 += v * b3;
    t11 += v * b4;
    t12 += v * b5;
    t13 += v * b6;
    t14 += v * b7;
    t15 += v * b8;
    t16 += v * b9;
    t17 += v * b10;
    t18 += v * b11;
    t19 += v * b12;
    t20 += v * b13;
    t21 += v * b14;
    t22 += v * b15;
    v = a[8];
    t8 += v * b0;
    t9 += v * b1;
    t10 += v * b2;
    t11 += v * b3;
    t12 += v * b4;
    t13 += v * b5;
    t14 += v * b6;
    t15 += v * b7;
    t16 += v * b8;
    t17 += v * b9;
    t18 += v * b10;
    t19 += v * b11;
    t20 += v * b12;
    t21 += v * b13;
    t22 += v * b14;
    t23 += v * b15;
    v = a[9];
    t9 += v * b0;
    t10 += v * b1;
    t11 += v * b2;
    t12 += v * b3;
    t13 += v * b4;
    t14 += v * b5;
    t15 += v * b6;
    t16 += v * b7;
    t17 += v * b8;
    t18 += v * b9;
    t19 += v * b10;
    t20 += v * b11;
    t21 += v * b12;
    t22 += v * b13;
    t23 += v * b14;
    t24 += v * b15;
    v = a[10];
    t10 += v * b0;
    t11 += v * b1;
    t12 += v * b2;
    t13 += v * b3;
    t14 += v * b4;
    t15 += v * b5;
    t16 += v * b6;
    t17 += v * b7;
    t18 += v * b8;
    t19 += v * b9;
    t20 += v * b10;
    t21 += v * b11;
    t22 += v * b12;
    t23 += v * b13;
    t24 += v * b14;
    t25 += v * b15;
    v = a[11];
    t11 += v * b0;
    t12 += v * b1;
    t13 += v * b2;
    t14 += v * b3;
    t15 += v * b4;
    t16 += v * b5;
    t17 += v * b6;
    t18 += v * b7;
    t19 += v * b8;
    t20 += v * b9;
    t21 += v * b10;
    t22 += v * b11;
    t23 += v * b12;
    t24 += v * b13;
    t25 += v * b14;
    t26 += v * b15;
    v = a[12];
    t12 += v * b0;
    t13 += v * b1;
    t14 += v * b2;
    t15 += v * b3;
    t16 += v * b4;
    t17 += v * b5;
    t18 += v * b6;
    t19 += v * b7;
    t20 += v * b8;
    t21 += v * b9;
    t22 += v * b10;
    t23 += v * b11;
    t24 += v * b12;
    t25 += v * b13;
    t26 += v * b14;
    t27 += v * b15;
    v = a[13];
    t13 += v * b0;
    t14 += v * b1;
    t15 += v * b2;
    t16 += v * b3;
    t17 += v * b4;
    t18 += v * b5;
    t19 += v * b6;
    t20 += v * b7;
    t21 += v * b8;
    t22 += v * b9;
    t23 += v * b10;
    t24 += v * b11;
    t25 += v * b12;
    t26 += v * b13;
    t27 += v * b14;
    t28 += v * b15;
    v = a[14];
    t14 += v * b0;
    t15 += v * b1;
    t16 += v * b2;
    t17 += v * b3;
    t18 += v * b4;
    t19 += v * b5;
    t20 += v * b6;
    t21 += v * b7;
    t22 += v * b8;
    t23 += v * b9;
    t24 += v * b10;
    t25 += v * b11;
    t26 += v * b12;
    t27 += v * b13;
    t28 += v * b14;
    t29 += v * b15;
    v = a[15];
    t15 += v * b0;
    t16 += v * b1;
    t17 += v * b2;
    t18 += v * b3;
    t19 += v * b4;
    t20 += v * b5;
    t21 += v * b6;
    t22 += v * b7;
    t23 += v * b8;
    t24 += v * b9;
    t25 += v * b10;
    t26 += v * b11;
    t27 += v * b12;
    t28 += v * b13;
    t29 += v * b14;
    t30 += v * b15;
    t0 += 38 * t16;
    t1 += 38 * t17;
    t2 += 38 * t18;
    t3 += 38 * t19;
    t4 += 38 * t20;
    t5 += 38 * t21;
    t6 += 38 * t22;
    t7 += 38 * t23;
    t8 += 38 * t24;
    t9 += 38 * t25;
    t10 += 38 * t26;
    t11 += 38 * t27;
    t12 += 38 * t28;
    t13 += 38 * t29;
    t14 += 38 * t30;
    // t15 left as is
    // first car
    c = 1;
    v = t0 + c + 65535;
    c = Math.floor(v / 65536);
    t0 = v - c * 65536;
    v = t1 + c + 65535;
    c = Math.floor(v / 65536);
    t1 = v - c * 65536;
    v = t2 + c + 65535;
    c = Math.floor(v / 65536);
    t2 = v - c * 65536;
    v = t3 + c + 65535;
    c = Math.floor(v / 65536);
    t3 = v - c * 65536;
    v = t4 + c + 65535;
    c = Math.floor(v / 65536);
    t4 = v - c * 65536;
    v = t5 + c + 65535;
    c = Math.floor(v / 65536);
    t5 = v - c * 65536;
    v = t6 + c + 65535;
    c = Math.floor(v / 65536);
    t6 = v - c * 65536;
    v = t7 + c + 65535;
    c = Math.floor(v / 65536);
    t7 = v - c * 65536;
    v = t8 + c + 65535;
    c = Math.floor(v / 65536);
    t8 = v - c * 65536;
    v = t9 + c + 65535;
    c = Math.floor(v / 65536);
    t9 = v - c * 65536;
    v = t10 + c + 65535;
    c = Math.floor(v / 65536);
    t10 = v - c * 65536;
    v = t11 + c + 65535;
    c = Math.floor(v / 65536);
    t11 = v - c * 65536;
    v = t12 + c + 65535;
    c = Math.floor(v / 65536);
    t12 = v - c * 65536;
    v = t13 + c + 65535;
    c = Math.floor(v / 65536);
    t13 = v - c * 65536;
    v = t14 + c + 65535;
    c = Math.floor(v / 65536);
    t14 = v - c * 65536;
    v = t15 + c + 65535;
    c = Math.floor(v / 65536);
    t15 = v - c * 65536;
    t0 += c - 1 + 37 * (c - 1);
    // second car
    c = 1;
    v = t0 + c + 65535;
    c = Math.floor(v / 65536);
    t0 = v - c * 65536;
    v = t1 + c + 65535;
    c = Math.floor(v / 65536);
    t1 = v - c * 65536;
    v = t2 + c + 65535;
    c = Math.floor(v / 65536);
    t2 = v - c * 65536;
    v = t3 + c + 65535;
    c = Math.floor(v / 65536);
    t3 = v - c * 65536;
    v = t4 + c + 65535;
    c = Math.floor(v / 65536);
    t4 = v - c * 65536;
    v = t5 + c + 65535;
    c = Math.floor(v / 65536);
    t5 = v - c * 65536;
    v = t6 + c + 65535;
    c = Math.floor(v / 65536);
    t6 = v - c * 65536;
    v = t7 + c + 65535;
    c = Math.floor(v / 65536);
    t7 = v - c * 65536;
    v = t8 + c + 65535;
    c = Math.floor(v / 65536);
    t8 = v - c * 65536;
    v = t9 + c + 65535;
    c = Math.floor(v / 65536);
    t9 = v - c * 65536;
    v = t10 + c + 65535;
    c = Math.floor(v / 65536);
    t10 = v - c * 65536;
    v = t11 + c + 65535;
    c = Math.floor(v / 65536);
    t11 = v - c * 65536;
    v = t12 + c + 65535;
    c = Math.floor(v / 65536);
    t12 = v - c * 65536;
    v = t13 + c + 65535;
    c = Math.floor(v / 65536);
    t13 = v - c * 65536;
    v = t14 + c + 65535;
    c = Math.floor(v / 65536);
    t14 = v - c * 65536;
    v = t15 + c + 65535;
    c = Math.floor(v / 65536);
    t15 = v - c * 65536;
    t0 += c - 1 + 37 * (c - 1);
    o[0] = t0;
    o[1] = t1;
    o[2] = t2;
    o[3] = t3;
    o[4] = t4;
    o[5] = t5;
    o[6] = t6;
    o[7] = t7;
    o[8] = t8;
    o[9] = t9;
    o[10] = t10;
    o[11] = t11;
    o[12] = t12;
    o[13] = t13;
    o[14] = t14;
    o[15] = t15;
}
function square(o, a) {
    mul(o, a, a);
}
function inv25519(o, inp) {
    const c = gf();
    for (let i = 0; i < 16; i++) {
        c[i] = inp[i];
    }
    for (let i = 253; i >= 0; i--) {
        square(c, c);
        if (i !== 2 && i !== 4) {
            mul(c, c, inp);
        }
    }
    for (let i = 0; i < 16; i++) {
        o[i] = c[i];
    }
}
function scalarMult(n, p) {
    const z = new Uint8Array(32);
    const x = new Float64Array(80);
    const a = gf(), b = gf(), c = gf(), d = gf(), e = gf(), f = gf();
    for (let i = 0; i < 31; i++) {
        z[i] = n[i];
    }
    z[31] = (n[31] & 127) | 64;
    z[0] &= 248;
    unpack25519(x, p);
    for (let i = 0; i < 16; i++) {
        b[i] = x[i];
    }
    a[0] = d[0] = 1;
    for (let i = 254; i >= 0; --i) {
        const r = (z[i >>> 3] >>> (i & 7)) & 1;
        sel25519(a, b, r);
        sel25519(c, d, r);
        add(e, a, c);
        sub(a, a, c);
        add(c, b, d);
        sub(b, b, d);
        square(d, e);
        square(f, a);
        mul(a, c, a);
        mul(c, b, e);
        add(e, a, c);
        sub(a, a, c);
        square(b, a);
        sub(c, d, f);
        mul(a, c, _121665);
        add(a, a, d);
        mul(c, c, a);
        mul(a, d, f);
        mul(d, b, x);
        square(b, e);
        sel25519(a, b, r);
        sel25519(c, d, r);
    }
    for (let i = 0; i < 16; i++) {
        x[i + 16] = a[i];
        x[i + 32] = c[i];
        x[i + 48] = b[i];
        x[i + 64] = d[i];
    }
    const x32 = x.subarray(32);
    const x16 = x.subarray(16);
    inv25519(x32, x32);
    mul(x16, x16, x32);
    const q = new Uint8Array(32);
    pack25519(q, x16);
    return q;
}
exports.scalarMult = scalarMult;
function scalarMultBase(n) {
    return scalarMult(n, _9);
}
exports.scalarMultBase = scalarMultBase;
function generateKeyPairFromSeed(seed) {
    if (seed.length !== exports.SECRET_KEY_LENGTH) {
        throw new Error(`x25519: seed must be ${exports.SECRET_KEY_LENGTH} bytes`);
    }
    const secretKey = new Uint8Array(seed);
    const publicKey = scalarMultBase(secretKey);
    return {
        publicKey,
        secretKey
    };
}
exports.generateKeyPairFromSeed = generateKeyPairFromSeed;
function generateKeyPair(prng) {
    const seed = (0, random_1.randomBytes)(32, prng);
    const result = generateKeyPairFromSeed(seed);
    (0, wipe_1.wipe)(seed);
    return result;
}
exports.generateKeyPair = generateKeyPair;
/**
 * Returns a shared key between our secret key and a peer's public key.
 *
 * Throws an error if the given keys are of wrong length.
 *
 * If rejectZero is true throws if the calculated shared key is all-zero.
 * From RFC 7748:
 *
 * > Protocol designers using Diffie-Hellman over the curves defined in
 * > this document must not assume "contributory behavior".  Specially,
 * > contributory behavior means that both parties' private keys
 * > contribute to the resulting shared key.  Since curve25519 and
 * > curve448 have cofactors of 8 and 4 (respectively), an input point of
 * > small order will eliminate any contribution from the other party's
 * > private key.  This situation can be detected by checking for the all-
 * > zero output, which implementations MAY do, as specified in Section 6.
 * > However, a large number of existing implementations do not do this.
 *
 * IMPORTANT: the returned key is a raw result of scalar multiplication.
 * To use it as a key material, hash it with a cryptographic hash function.
 */
function sharedKey(mySecretKey, theirPublicKey, rejectZero = false) {
    if (mySecretKey.length !== exports.PUBLIC_KEY_LENGTH) {
        throw new Error("X25519: incorrect secret key length");
    }
    if (theirPublicKey.length !== exports.PUBLIC_KEY_LENGTH) {
        throw new Error("X25519: incorrect public key length");
    }
    const result = scalarMult(mySecretKey, theirPublicKey);
    if (rejectZero) {
        let zeros = 0;
        for (let i = 0; i < result.length; i++) {
            zeros |= result[i];
        }
        if (zeros === 0) {
            throw new Error("X25519: invalid shared key");
        }
    }
    return result;
}
exports.sharedKey = sharedKey;
//# sourceMappingURL=x25519.js.map

/***/ }),

/***/ 3836:
/***/ (function(module) {

/*! MIT License. Copyright 2015-2018 Richard Moore <me@ricmoo.com>. See LICENSE.txt. */
(function(root) {
    "use strict";

    function checkInt(value) {
        return (parseInt(value) === value);
    }

    function checkInts(arrayish) {
        if (!checkInt(arrayish.length)) { return false; }

        for (var i = 0; i < arrayish.length; i++) {
            if (!checkInt(arrayish[i]) || arrayish[i] < 0 || arrayish[i] > 255) {
                return false;
            }
        }

        return true;
    }

    function coerceArray(arg, copy) {

        // ArrayBuffer view
        if (arg.buffer && arg.name === 'Uint8Array') {

            if (copy) {
                if (arg.slice) {
                    arg = arg.slice();
                } else {
                    arg = Array.prototype.slice.call(arg);
                }
            }

            return arg;
        }

        // It's an array; check it is a valid representation of a byte
        if (Array.isArray(arg)) {
            if (!checkInts(arg)) {
                throw new Error('Array contains invalid value: ' + arg);
            }

            return new Uint8Array(arg);
        }

        // Something else, but behaves like an array (maybe a Buffer? Arguments?)
        if (checkInt(arg.length) && checkInts(arg)) {
            return new Uint8Array(arg);
        }

        throw new Error('unsupported array-like object');
    }

    function createArray(length) {
        return new Uint8Array(length);
    }

    function copyArray(sourceArray, targetArray, targetStart, sourceStart, sourceEnd) {
        if (sourceStart != null || sourceEnd != null) {
            if (sourceArray.slice) {
                sourceArray = sourceArray.slice(sourceStart, sourceEnd);
            } else {
                sourceArray = Array.prototype.slice.call(sourceArray, sourceStart, sourceEnd);
            }
        }
        targetArray.set(sourceArray, targetStart);
    }



    var convertUtf8 = (function() {
        function toBytes(text) {
            var result = [], i = 0;
            text = encodeURI(text);
            while (i < text.length) {
                var c = text.charCodeAt(i++);

                // if it is a % sign, encode the following 2 bytes as a hex value
                if (c === 37) {
                    result.push(parseInt(text.substr(i, 2), 16))
                    i += 2;

                // otherwise, just the actual byte
                } else {
                    result.push(c)
                }
            }

            return coerceArray(result);
        }

        function fromBytes(bytes) {
            var result = [], i = 0;

            while (i < bytes.length) {
                var c = bytes[i];

                if (c < 128) {
                    result.push(String.fromCharCode(c));
                    i++;
                } else if (c > 191 && c < 224) {
                    result.push(String.fromCharCode(((c & 0x1f) << 6) | (bytes[i + 1] & 0x3f)));
                    i += 2;
                } else {
                    result.push(String.fromCharCode(((c & 0x0f) << 12) | ((bytes[i + 1] & 0x3f) << 6) | (bytes[i + 2] & 0x3f)));
                    i += 3;
                }
            }

            return result.join('');
        }

        return {
            toBytes: toBytes,
            fromBytes: fromBytes,
        }
    })();

    var convertHex = (function() {
        function toBytes(text) {
            var result = [];
            for (var i = 0; i < text.length; i += 2) {
                result.push(parseInt(text.substr(i, 2), 16));
            }

            return result;
        }

        // http://ixti.net/development/javascript/2011/11/11/base64-encodedecode-of-utf8-in-browser-with-js.html
        var Hex = '0123456789abcdef';

        function fromBytes(bytes) {
                var result = [];
                for (var i = 0; i < bytes.length; i++) {
                    var v = bytes[i];
                    result.push(Hex[(v & 0xf0) >> 4] + Hex[v & 0x0f]);
                }
                return result.join('');
        }

        return {
            toBytes: toBytes,
            fromBytes: fromBytes,
        }
    })();


    // Number of rounds by keysize
    var numberOfRounds = {16: 10, 24: 12, 32: 14}

    // Round constant words
    var rcon = [0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91];

    // S-box and Inverse S-box (S is for Substitution)
    var S = [0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76, 0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0, 0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15, 0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75, 0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84, 0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf, 0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8, 0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2, 0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73, 0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb, 0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79, 0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08, 0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a, 0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e, 0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf, 0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16];
    var Si =[0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb, 0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb, 0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e, 0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25, 0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92, 0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84, 0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06, 0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b, 0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73, 0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e, 0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b, 0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4, 0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f, 0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef, 0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61, 0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d];

    // Transformations for encryption
    var T1 = [0xc66363a5, 0xf87c7c84, 0xee777799, 0xf67b7b8d, 0xfff2f20d, 0xd66b6bbd, 0xde6f6fb1, 0x91c5c554, 0x60303050, 0x02010103, 0xce6767a9, 0x562b2b7d, 0xe7fefe19, 0xb5d7d762, 0x4dababe6, 0xec76769a, 0x8fcaca45, 0x1f82829d, 0x89c9c940, 0xfa7d7d87, 0xeffafa15, 0xb25959eb, 0x8e4747c9, 0xfbf0f00b, 0x41adadec, 0xb3d4d467, 0x5fa2a2fd, 0x45afafea, 0x239c9cbf, 0x53a4a4f7, 0xe4727296, 0x9bc0c05b, 0x75b7b7c2, 0xe1fdfd1c, 0x3d9393ae, 0x4c26266a, 0x6c36365a, 0x7e3f3f41, 0xf5f7f702, 0x83cccc4f, 0x6834345c, 0x51a5a5f4, 0xd1e5e534, 0xf9f1f108, 0xe2717193, 0xabd8d873, 0x62313153, 0x2a15153f, 0x0804040c, 0x95c7c752, 0x46232365, 0x9dc3c35e, 0x30181828, 0x379696a1, 0x0a05050f, 0x2f9a9ab5, 0x0e070709, 0x24121236, 0x1b80809b, 0xdfe2e23d, 0xcdebeb26, 0x4e272769, 0x7fb2b2cd, 0xea75759f, 0x1209091b, 0x1d83839e, 0x582c2c74, 0x341a1a2e, 0x361b1b2d, 0xdc6e6eb2, 0xb45a5aee, 0x5ba0a0fb, 0xa45252f6, 0x763b3b4d, 0xb7d6d661, 0x7db3b3ce, 0x5229297b, 0xdde3e33e, 0x5e2f2f71, 0x13848497, 0xa65353f5, 0xb9d1d168, 0x00000000, 0xc1eded2c, 0x40202060, 0xe3fcfc1f, 0x79b1b1c8, 0xb65b5bed, 0xd46a6abe, 0x8dcbcb46, 0x67bebed9, 0x7239394b, 0x944a4ade, 0x984c4cd4, 0xb05858e8, 0x85cfcf4a, 0xbbd0d06b, 0xc5efef2a, 0x4faaaae5, 0xedfbfb16, 0x864343c5, 0x9a4d4dd7, 0x66333355, 0x11858594, 0x8a4545cf, 0xe9f9f910, 0x04020206, 0xfe7f7f81, 0xa05050f0, 0x783c3c44, 0x259f9fba, 0x4ba8a8e3, 0xa25151f3, 0x5da3a3fe, 0x804040c0, 0x058f8f8a, 0x3f9292ad, 0x219d9dbc, 0x70383848, 0xf1f5f504, 0x63bcbcdf, 0x77b6b6c1, 0xafdada75, 0x42212163, 0x20101030, 0xe5ffff1a, 0xfdf3f30e, 0xbfd2d26d, 0x81cdcd4c, 0x180c0c14, 0x26131335, 0xc3ecec2f, 0xbe5f5fe1, 0x359797a2, 0x884444cc, 0x2e171739, 0x93c4c457, 0x55a7a7f2, 0xfc7e7e82, 0x7a3d3d47, 0xc86464ac, 0xba5d5de7, 0x3219192b, 0xe6737395, 0xc06060a0, 0x19818198, 0x9e4f4fd1, 0xa3dcdc7f, 0x44222266, 0x542a2a7e, 0x3b9090ab, 0x0b888883, 0x8c4646ca, 0xc7eeee29, 0x6bb8b8d3, 0x2814143c, 0xa7dede79, 0xbc5e5ee2, 0x160b0b1d, 0xaddbdb76, 0xdbe0e03b, 0x64323256, 0x743a3a4e, 0x140a0a1e, 0x924949db, 0x0c06060a, 0x4824246c, 0xb85c5ce4, 0x9fc2c25d, 0xbdd3d36e, 0x43acacef, 0xc46262a6, 0x399191a8, 0x319595a4, 0xd3e4e437, 0xf279798b, 0xd5e7e732, 0x8bc8c843, 0x6e373759, 0xda6d6db7, 0x018d8d8c, 0xb1d5d564, 0x9c4e4ed2, 0x49a9a9e0, 0xd86c6cb4, 0xac5656fa, 0xf3f4f407, 0xcfeaea25, 0xca6565af, 0xf47a7a8e, 0x47aeaee9, 0x10080818, 0x6fbabad5, 0xf0787888, 0x4a25256f, 0x5c2e2e72, 0x381c1c24, 0x57a6a6f1, 0x73b4b4c7, 0x97c6c651, 0xcbe8e823, 0xa1dddd7c, 0xe874749c, 0x3e1f1f21, 0x964b4bdd, 0x61bdbddc, 0x0d8b8b86, 0x0f8a8a85, 0xe0707090, 0x7c3e3e42, 0x71b5b5c4, 0xcc6666aa, 0x904848d8, 0x06030305, 0xf7f6f601, 0x1c0e0e12, 0xc26161a3, 0x6a35355f, 0xae5757f9, 0x69b9b9d0, 0x17868691, 0x99c1c158, 0x3a1d1d27, 0x279e9eb9, 0xd9e1e138, 0xebf8f813, 0x2b9898b3, 0x22111133, 0xd26969bb, 0xa9d9d970, 0x078e8e89, 0x339494a7, 0x2d9b9bb6, 0x3c1e1e22, 0x15878792, 0xc9e9e920, 0x87cece49, 0xaa5555ff, 0x50282878, 0xa5dfdf7a, 0x038c8c8f, 0x59a1a1f8, 0x09898980, 0x1a0d0d17, 0x65bfbfda, 0xd7e6e631, 0x844242c6, 0xd06868b8, 0x824141c3, 0x299999b0, 0x5a2d2d77, 0x1e0f0f11, 0x7bb0b0cb, 0xa85454fc, 0x6dbbbbd6, 0x2c16163a];
    var T2 = [0xa5c66363, 0x84f87c7c, 0x99ee7777, 0x8df67b7b, 0x0dfff2f2, 0xbdd66b6b, 0xb1de6f6f, 0x5491c5c5, 0x50603030, 0x03020101, 0xa9ce6767, 0x7d562b2b, 0x19e7fefe, 0x62b5d7d7, 0xe64dabab, 0x9aec7676, 0x458fcaca, 0x9d1f8282, 0x4089c9c9, 0x87fa7d7d, 0x15effafa, 0xebb25959, 0xc98e4747, 0x0bfbf0f0, 0xec41adad, 0x67b3d4d4, 0xfd5fa2a2, 0xea45afaf, 0xbf239c9c, 0xf753a4a4, 0x96e47272, 0x5b9bc0c0, 0xc275b7b7, 0x1ce1fdfd, 0xae3d9393, 0x6a4c2626, 0x5a6c3636, 0x417e3f3f, 0x02f5f7f7, 0x4f83cccc, 0x5c683434, 0xf451a5a5, 0x34d1e5e5, 0x08f9f1f1, 0x93e27171, 0x73abd8d8, 0x53623131, 0x3f2a1515, 0x0c080404, 0x5295c7c7, 0x65462323, 0x5e9dc3c3, 0x28301818, 0xa1379696, 0x0f0a0505, 0xb52f9a9a, 0x090e0707, 0x36241212, 0x9b1b8080, 0x3ddfe2e2, 0x26cdebeb, 0x694e2727, 0xcd7fb2b2, 0x9fea7575, 0x1b120909, 0x9e1d8383, 0x74582c2c, 0x2e341a1a, 0x2d361b1b, 0xb2dc6e6e, 0xeeb45a5a, 0xfb5ba0a0, 0xf6a45252, 0x4d763b3b, 0x61b7d6d6, 0xce7db3b3, 0x7b522929, 0x3edde3e3, 0x715e2f2f, 0x97138484, 0xf5a65353, 0x68b9d1d1, 0x00000000, 0x2cc1eded, 0x60402020, 0x1fe3fcfc, 0xc879b1b1, 0xedb65b5b, 0xbed46a6a, 0x468dcbcb, 0xd967bebe, 0x4b723939, 0xde944a4a, 0xd4984c4c, 0xe8b05858, 0x4a85cfcf, 0x6bbbd0d0, 0x2ac5efef, 0xe54faaaa, 0x16edfbfb, 0xc5864343, 0xd79a4d4d, 0x55663333, 0x94118585, 0xcf8a4545, 0x10e9f9f9, 0x06040202, 0x81fe7f7f, 0xf0a05050, 0x44783c3c, 0xba259f9f, 0xe34ba8a8, 0xf3a25151, 0xfe5da3a3, 0xc0804040, 0x8a058f8f, 0xad3f9292, 0xbc219d9d, 0x48703838, 0x04f1f5f5, 0xdf63bcbc, 0xc177b6b6, 0x75afdada, 0x63422121, 0x30201010, 0x1ae5ffff, 0x0efdf3f3, 0x6dbfd2d2, 0x4c81cdcd, 0x14180c0c, 0x35261313, 0x2fc3ecec, 0xe1be5f5f, 0xa2359797, 0xcc884444, 0x392e1717, 0x5793c4c4, 0xf255a7a7, 0x82fc7e7e, 0x477a3d3d, 0xacc86464, 0xe7ba5d5d, 0x2b321919, 0x95e67373, 0xa0c06060, 0x98198181, 0xd19e4f4f, 0x7fa3dcdc, 0x66442222, 0x7e542a2a, 0xab3b9090, 0x830b8888, 0xca8c4646, 0x29c7eeee, 0xd36bb8b8, 0x3c281414, 0x79a7dede, 0xe2bc5e5e, 0x1d160b0b, 0x76addbdb, 0x3bdbe0e0, 0x56643232, 0x4e743a3a, 0x1e140a0a, 0xdb924949, 0x0a0c0606, 0x6c482424, 0xe4b85c5c, 0x5d9fc2c2, 0x6ebdd3d3, 0xef43acac, 0xa6c46262, 0xa8399191, 0xa4319595, 0x37d3e4e4, 0x8bf27979, 0x32d5e7e7, 0x438bc8c8, 0x596e3737, 0xb7da6d6d, 0x8c018d8d, 0x64b1d5d5, 0xd29c4e4e, 0xe049a9a9, 0xb4d86c6c, 0xfaac5656, 0x07f3f4f4, 0x25cfeaea, 0xafca6565, 0x8ef47a7a, 0xe947aeae, 0x18100808, 0xd56fbaba, 0x88f07878, 0x6f4a2525, 0x725c2e2e, 0x24381c1c, 0xf157a6a6, 0xc773b4b4, 0x5197c6c6, 0x23cbe8e8, 0x7ca1dddd, 0x9ce87474, 0x213e1f1f, 0xdd964b4b, 0xdc61bdbd, 0x860d8b8b, 0x850f8a8a, 0x90e07070, 0x427c3e3e, 0xc471b5b5, 0xaacc6666, 0xd8904848, 0x05060303, 0x01f7f6f6, 0x121c0e0e, 0xa3c26161, 0x5f6a3535, 0xf9ae5757, 0xd069b9b9, 0x91178686, 0x5899c1c1, 0x273a1d1d, 0xb9279e9e, 0x38d9e1e1, 0x13ebf8f8, 0xb32b9898, 0x33221111, 0xbbd26969, 0x70a9d9d9, 0x89078e8e, 0xa7339494, 0xb62d9b9b, 0x223c1e1e, 0x92158787, 0x20c9e9e9, 0x4987cece, 0xffaa5555, 0x78502828, 0x7aa5dfdf, 0x8f038c8c, 0xf859a1a1, 0x80098989, 0x171a0d0d, 0xda65bfbf, 0x31d7e6e6, 0xc6844242, 0xb8d06868, 0xc3824141, 0xb0299999, 0x775a2d2d, 0x111e0f0f, 0xcb7bb0b0, 0xfca85454, 0xd66dbbbb, 0x3a2c1616];
    var T3 = [0x63a5c663, 0x7c84f87c, 0x7799ee77, 0x7b8df67b, 0xf20dfff2, 0x6bbdd66b, 0x6fb1de6f, 0xc55491c5, 0x30506030, 0x01030201, 0x67a9ce67, 0x2b7d562b, 0xfe19e7fe, 0xd762b5d7, 0xabe64dab, 0x769aec76, 0xca458fca, 0x829d1f82, 0xc94089c9, 0x7d87fa7d, 0xfa15effa, 0x59ebb259, 0x47c98e47, 0xf00bfbf0, 0xadec41ad, 0xd467b3d4, 0xa2fd5fa2, 0xafea45af, 0x9cbf239c, 0xa4f753a4, 0x7296e472, 0xc05b9bc0, 0xb7c275b7, 0xfd1ce1fd, 0x93ae3d93, 0x266a4c26, 0x365a6c36, 0x3f417e3f, 0xf702f5f7, 0xcc4f83cc, 0x345c6834, 0xa5f451a5, 0xe534d1e5, 0xf108f9f1, 0x7193e271, 0xd873abd8, 0x31536231, 0x153f2a15, 0x040c0804, 0xc75295c7, 0x23654623, 0xc35e9dc3, 0x18283018, 0x96a13796, 0x050f0a05, 0x9ab52f9a, 0x07090e07, 0x12362412, 0x809b1b80, 0xe23ddfe2, 0xeb26cdeb, 0x27694e27, 0xb2cd7fb2, 0x759fea75, 0x091b1209, 0x839e1d83, 0x2c74582c, 0x1a2e341a, 0x1b2d361b, 0x6eb2dc6e, 0x5aeeb45a, 0xa0fb5ba0, 0x52f6a452, 0x3b4d763b, 0xd661b7d6, 0xb3ce7db3, 0x297b5229, 0xe33edde3, 0x2f715e2f, 0x84971384, 0x53f5a653, 0xd168b9d1, 0x00000000, 0xed2cc1ed, 0x20604020, 0xfc1fe3fc, 0xb1c879b1, 0x5bedb65b, 0x6abed46a, 0xcb468dcb, 0xbed967be, 0x394b7239, 0x4ade944a, 0x4cd4984c, 0x58e8b058, 0xcf4a85cf, 0xd06bbbd0, 0xef2ac5ef, 0xaae54faa, 0xfb16edfb, 0x43c58643, 0x4dd79a4d, 0x33556633, 0x85941185, 0x45cf8a45, 0xf910e9f9, 0x02060402, 0x7f81fe7f, 0x50f0a050, 0x3c44783c, 0x9fba259f, 0xa8e34ba8, 0x51f3a251, 0xa3fe5da3, 0x40c08040, 0x8f8a058f, 0x92ad3f92, 0x9dbc219d, 0x38487038, 0xf504f1f5, 0xbcdf63bc, 0xb6c177b6, 0xda75afda, 0x21634221, 0x10302010, 0xff1ae5ff, 0xf30efdf3, 0xd26dbfd2, 0xcd4c81cd, 0x0c14180c, 0x13352613, 0xec2fc3ec, 0x5fe1be5f, 0x97a23597, 0x44cc8844, 0x17392e17, 0xc45793c4, 0xa7f255a7, 0x7e82fc7e, 0x3d477a3d, 0x64acc864, 0x5de7ba5d, 0x192b3219, 0x7395e673, 0x60a0c060, 0x81981981, 0x4fd19e4f, 0xdc7fa3dc, 0x22664422, 0x2a7e542a, 0x90ab3b90, 0x88830b88, 0x46ca8c46, 0xee29c7ee, 0xb8d36bb8, 0x143c2814, 0xde79a7de, 0x5ee2bc5e, 0x0b1d160b, 0xdb76addb, 0xe03bdbe0, 0x32566432, 0x3a4e743a, 0x0a1e140a, 0x49db9249, 0x060a0c06, 0x246c4824, 0x5ce4b85c, 0xc25d9fc2, 0xd36ebdd3, 0xacef43ac, 0x62a6c462, 0x91a83991, 0x95a43195, 0xe437d3e4, 0x798bf279, 0xe732d5e7, 0xc8438bc8, 0x37596e37, 0x6db7da6d, 0x8d8c018d, 0xd564b1d5, 0x4ed29c4e, 0xa9e049a9, 0x6cb4d86c, 0x56faac56, 0xf407f3f4, 0xea25cfea, 0x65afca65, 0x7a8ef47a, 0xaee947ae, 0x08181008, 0xbad56fba, 0x7888f078, 0x256f4a25, 0x2e725c2e, 0x1c24381c, 0xa6f157a6, 0xb4c773b4, 0xc65197c6, 0xe823cbe8, 0xdd7ca1dd, 0x749ce874, 0x1f213e1f, 0x4bdd964b, 0xbddc61bd, 0x8b860d8b, 0x8a850f8a, 0x7090e070, 0x3e427c3e, 0xb5c471b5, 0x66aacc66, 0x48d89048, 0x03050603, 0xf601f7f6, 0x0e121c0e, 0x61a3c261, 0x355f6a35, 0x57f9ae57, 0xb9d069b9, 0x86911786, 0xc15899c1, 0x1d273a1d, 0x9eb9279e, 0xe138d9e1, 0xf813ebf8, 0x98b32b98, 0x11332211, 0x69bbd269, 0xd970a9d9, 0x8e89078e, 0x94a73394, 0x9bb62d9b, 0x1e223c1e, 0x87921587, 0xe920c9e9, 0xce4987ce, 0x55ffaa55, 0x28785028, 0xdf7aa5df, 0x8c8f038c, 0xa1f859a1, 0x89800989, 0x0d171a0d, 0xbfda65bf, 0xe631d7e6, 0x42c68442, 0x68b8d068, 0x41c38241, 0x99b02999, 0x2d775a2d, 0x0f111e0f, 0xb0cb7bb0, 0x54fca854, 0xbbd66dbb, 0x163a2c16];
    var T4 = [0x6363a5c6, 0x7c7c84f8, 0x777799ee, 0x7b7b8df6, 0xf2f20dff, 0x6b6bbdd6, 0x6f6fb1de, 0xc5c55491, 0x30305060, 0x01010302, 0x6767a9ce, 0x2b2b7d56, 0xfefe19e7, 0xd7d762b5, 0xababe64d, 0x76769aec, 0xcaca458f, 0x82829d1f, 0xc9c94089, 0x7d7d87fa, 0xfafa15ef, 0x5959ebb2, 0x4747c98e, 0xf0f00bfb, 0xadadec41, 0xd4d467b3, 0xa2a2fd5f, 0xafafea45, 0x9c9cbf23, 0xa4a4f753, 0x727296e4, 0xc0c05b9b, 0xb7b7c275, 0xfdfd1ce1, 0x9393ae3d, 0x26266a4c, 0x36365a6c, 0x3f3f417e, 0xf7f702f5, 0xcccc4f83, 0x34345c68, 0xa5a5f451, 0xe5e534d1, 0xf1f108f9, 0x717193e2, 0xd8d873ab, 0x31315362, 0x15153f2a, 0x04040c08, 0xc7c75295, 0x23236546, 0xc3c35e9d, 0x18182830, 0x9696a137, 0x05050f0a, 0x9a9ab52f, 0x0707090e, 0x12123624, 0x80809b1b, 0xe2e23ddf, 0xebeb26cd, 0x2727694e, 0xb2b2cd7f, 0x75759fea, 0x09091b12, 0x83839e1d, 0x2c2c7458, 0x1a1a2e34, 0x1b1b2d36, 0x6e6eb2dc, 0x5a5aeeb4, 0xa0a0fb5b, 0x5252f6a4, 0x3b3b4d76, 0xd6d661b7, 0xb3b3ce7d, 0x29297b52, 0xe3e33edd, 0x2f2f715e, 0x84849713, 0x5353f5a6, 0xd1d168b9, 0x00000000, 0xeded2cc1, 0x20206040, 0xfcfc1fe3, 0xb1b1c879, 0x5b5bedb6, 0x6a6abed4, 0xcbcb468d, 0xbebed967, 0x39394b72, 0x4a4ade94, 0x4c4cd498, 0x5858e8b0, 0xcfcf4a85, 0xd0d06bbb, 0xefef2ac5, 0xaaaae54f, 0xfbfb16ed, 0x4343c586, 0x4d4dd79a, 0x33335566, 0x85859411, 0x4545cf8a, 0xf9f910e9, 0x02020604, 0x7f7f81fe, 0x5050f0a0, 0x3c3c4478, 0x9f9fba25, 0xa8a8e34b, 0x5151f3a2, 0xa3a3fe5d, 0x4040c080, 0x8f8f8a05, 0x9292ad3f, 0x9d9dbc21, 0x38384870, 0xf5f504f1, 0xbcbcdf63, 0xb6b6c177, 0xdada75af, 0x21216342, 0x10103020, 0xffff1ae5, 0xf3f30efd, 0xd2d26dbf, 0xcdcd4c81, 0x0c0c1418, 0x13133526, 0xecec2fc3, 0x5f5fe1be, 0x9797a235, 0x4444cc88, 0x1717392e, 0xc4c45793, 0xa7a7f255, 0x7e7e82fc, 0x3d3d477a, 0x6464acc8, 0x5d5de7ba, 0x19192b32, 0x737395e6, 0x6060a0c0, 0x81819819, 0x4f4fd19e, 0xdcdc7fa3, 0x22226644, 0x2a2a7e54, 0x9090ab3b, 0x8888830b, 0x4646ca8c, 0xeeee29c7, 0xb8b8d36b, 0x14143c28, 0xdede79a7, 0x5e5ee2bc, 0x0b0b1d16, 0xdbdb76ad, 0xe0e03bdb, 0x32325664, 0x3a3a4e74, 0x0a0a1e14, 0x4949db92, 0x06060a0c, 0x24246c48, 0x5c5ce4b8, 0xc2c25d9f, 0xd3d36ebd, 0xacacef43, 0x6262a6c4, 0x9191a839, 0x9595a431, 0xe4e437d3, 0x79798bf2, 0xe7e732d5, 0xc8c8438b, 0x3737596e, 0x6d6db7da, 0x8d8d8c01, 0xd5d564b1, 0x4e4ed29c, 0xa9a9e049, 0x6c6cb4d8, 0x5656faac, 0xf4f407f3, 0xeaea25cf, 0x6565afca, 0x7a7a8ef4, 0xaeaee947, 0x08081810, 0xbabad56f, 0x787888f0, 0x25256f4a, 0x2e2e725c, 0x1c1c2438, 0xa6a6f157, 0xb4b4c773, 0xc6c65197, 0xe8e823cb, 0xdddd7ca1, 0x74749ce8, 0x1f1f213e, 0x4b4bdd96, 0xbdbddc61, 0x8b8b860d, 0x8a8a850f, 0x707090e0, 0x3e3e427c, 0xb5b5c471, 0x6666aacc, 0x4848d890, 0x03030506, 0xf6f601f7, 0x0e0e121c, 0x6161a3c2, 0x35355f6a, 0x5757f9ae, 0xb9b9d069, 0x86869117, 0xc1c15899, 0x1d1d273a, 0x9e9eb927, 0xe1e138d9, 0xf8f813eb, 0x9898b32b, 0x11113322, 0x6969bbd2, 0xd9d970a9, 0x8e8e8907, 0x9494a733, 0x9b9bb62d, 0x1e1e223c, 0x87879215, 0xe9e920c9, 0xcece4987, 0x5555ffaa, 0x28287850, 0xdfdf7aa5, 0x8c8c8f03, 0xa1a1f859, 0x89898009, 0x0d0d171a, 0xbfbfda65, 0xe6e631d7, 0x4242c684, 0x6868b8d0, 0x4141c382, 0x9999b029, 0x2d2d775a, 0x0f0f111e, 0xb0b0cb7b, 0x5454fca8, 0xbbbbd66d, 0x16163a2c];

    // Transformations for decryption
    var T5 = [0x51f4a750, 0x7e416553, 0x1a17a4c3, 0x3a275e96, 0x3bab6bcb, 0x1f9d45f1, 0xacfa58ab, 0x4be30393, 0x2030fa55, 0xad766df6, 0x88cc7691, 0xf5024c25, 0x4fe5d7fc, 0xc52acbd7, 0x26354480, 0xb562a38f, 0xdeb15a49, 0x25ba1b67, 0x45ea0e98, 0x5dfec0e1, 0xc32f7502, 0x814cf012, 0x8d4697a3, 0x6bd3f9c6, 0x038f5fe7, 0x15929c95, 0xbf6d7aeb, 0x955259da, 0xd4be832d, 0x587421d3, 0x49e06929, 0x8ec9c844, 0x75c2896a, 0xf48e7978, 0x99583e6b, 0x27b971dd, 0xbee14fb6, 0xf088ad17, 0xc920ac66, 0x7dce3ab4, 0x63df4a18, 0xe51a3182, 0x97513360, 0x62537f45, 0xb16477e0, 0xbb6bae84, 0xfe81a01c, 0xf9082b94, 0x70486858, 0x8f45fd19, 0x94de6c87, 0x527bf8b7, 0xab73d323, 0x724b02e2, 0xe31f8f57, 0x6655ab2a, 0xb2eb2807, 0x2fb5c203, 0x86c57b9a, 0xd33708a5, 0x302887f2, 0x23bfa5b2, 0x02036aba, 0xed16825c, 0x8acf1c2b, 0xa779b492, 0xf307f2f0, 0x4e69e2a1, 0x65daf4cd, 0x0605bed5, 0xd134621f, 0xc4a6fe8a, 0x342e539d, 0xa2f355a0, 0x058ae132, 0xa4f6eb75, 0x0b83ec39, 0x4060efaa, 0x5e719f06, 0xbd6e1051, 0x3e218af9, 0x96dd063d, 0xdd3e05ae, 0x4de6bd46, 0x91548db5, 0x71c45d05, 0x0406d46f, 0x605015ff, 0x1998fb24, 0xd6bde997, 0x894043cc, 0x67d99e77, 0xb0e842bd, 0x07898b88, 0xe7195b38, 0x79c8eedb, 0xa17c0a47, 0x7c420fe9, 0xf8841ec9, 0x00000000, 0x09808683, 0x322bed48, 0x1e1170ac, 0x6c5a724e, 0xfd0efffb, 0x0f853856, 0x3daed51e, 0x362d3927, 0x0a0fd964, 0x685ca621, 0x9b5b54d1, 0x24362e3a, 0x0c0a67b1, 0x9357e70f, 0xb4ee96d2, 0x1b9b919e, 0x80c0c54f, 0x61dc20a2, 0x5a774b69, 0x1c121a16, 0xe293ba0a, 0xc0a02ae5, 0x3c22e043, 0x121b171d, 0x0e090d0b, 0xf28bc7ad, 0x2db6a8b9, 0x141ea9c8, 0x57f11985, 0xaf75074c, 0xee99ddbb, 0xa37f60fd, 0xf701269f, 0x5c72f5bc, 0x44663bc5, 0x5bfb7e34, 0x8b432976, 0xcb23c6dc, 0xb6edfc68, 0xb8e4f163, 0xd731dcca, 0x42638510, 0x13972240, 0x84c61120, 0x854a247d, 0xd2bb3df8, 0xaef93211, 0xc729a16d, 0x1d9e2f4b, 0xdcb230f3, 0x0d8652ec, 0x77c1e3d0, 0x2bb3166c, 0xa970b999, 0x119448fa, 0x47e96422, 0xa8fc8cc4, 0xa0f03f1a, 0x567d2cd8, 0x223390ef, 0x87494ec7, 0xd938d1c1, 0x8ccaa2fe, 0x98d40b36, 0xa6f581cf, 0xa57ade28, 0xdab78e26, 0x3fadbfa4, 0x2c3a9de4, 0x5078920d, 0x6a5fcc9b, 0x547e4662, 0xf68d13c2, 0x90d8b8e8, 0x2e39f75e, 0x82c3aff5, 0x9f5d80be, 0x69d0937c, 0x6fd52da9, 0xcf2512b3, 0xc8ac993b, 0x10187da7, 0xe89c636e, 0xdb3bbb7b, 0xcd267809, 0x6e5918f4, 0xec9ab701, 0x834f9aa8, 0xe6956e65, 0xaaffe67e, 0x21bccf08, 0xef15e8e6, 0xbae79bd9, 0x4a6f36ce, 0xea9f09d4, 0x29b07cd6, 0x31a4b2af, 0x2a3f2331, 0xc6a59430, 0x35a266c0, 0x744ebc37, 0xfc82caa6, 0xe090d0b0, 0x33a7d815, 0xf104984a, 0x41ecdaf7, 0x7fcd500e, 0x1791f62f, 0x764dd68d, 0x43efb04d, 0xccaa4d54, 0xe49604df, 0x9ed1b5e3, 0x4c6a881b, 0xc12c1fb8, 0x4665517f, 0x9d5eea04, 0x018c355d, 0xfa877473, 0xfb0b412e, 0xb3671d5a, 0x92dbd252, 0xe9105633, 0x6dd64713, 0x9ad7618c, 0x37a10c7a, 0x59f8148e, 0xeb133c89, 0xcea927ee, 0xb761c935, 0xe11ce5ed, 0x7a47b13c, 0x9cd2df59, 0x55f2733f, 0x1814ce79, 0x73c737bf, 0x53f7cdea, 0x5ffdaa5b, 0xdf3d6f14, 0x7844db86, 0xcaaff381, 0xb968c43e, 0x3824342c, 0xc2a3405f, 0x161dc372, 0xbce2250c, 0x283c498b, 0xff0d9541, 0x39a80171, 0x080cb3de, 0xd8b4e49c, 0x6456c190, 0x7bcb8461, 0xd532b670, 0x486c5c74, 0xd0b85742];
    var T6 = [0x5051f4a7, 0x537e4165, 0xc31a17a4, 0x963a275e, 0xcb3bab6b, 0xf11f9d45, 0xabacfa58, 0x934be303, 0x552030fa, 0xf6ad766d, 0x9188cc76, 0x25f5024c, 0xfc4fe5d7, 0xd7c52acb, 0x80263544, 0x8fb562a3, 0x49deb15a, 0x6725ba1b, 0x9845ea0e, 0xe15dfec0, 0x02c32f75, 0x12814cf0, 0xa38d4697, 0xc66bd3f9, 0xe7038f5f, 0x9515929c, 0xebbf6d7a, 0xda955259, 0x2dd4be83, 0xd3587421, 0x2949e069, 0x448ec9c8, 0x6a75c289, 0x78f48e79, 0x6b99583e, 0xdd27b971, 0xb6bee14f, 0x17f088ad, 0x66c920ac, 0xb47dce3a, 0x1863df4a, 0x82e51a31, 0x60975133, 0x4562537f, 0xe0b16477, 0x84bb6bae, 0x1cfe81a0, 0x94f9082b, 0x58704868, 0x198f45fd, 0x8794de6c, 0xb7527bf8, 0x23ab73d3, 0xe2724b02, 0x57e31f8f, 0x2a6655ab, 0x07b2eb28, 0x032fb5c2, 0x9a86c57b, 0xa5d33708, 0xf2302887, 0xb223bfa5, 0xba02036a, 0x5ced1682, 0x2b8acf1c, 0x92a779b4, 0xf0f307f2, 0xa14e69e2, 0xcd65daf4, 0xd50605be, 0x1fd13462, 0x8ac4a6fe, 0x9d342e53, 0xa0a2f355, 0x32058ae1, 0x75a4f6eb, 0x390b83ec, 0xaa4060ef, 0x065e719f, 0x51bd6e10, 0xf93e218a, 0x3d96dd06, 0xaedd3e05, 0x464de6bd, 0xb591548d, 0x0571c45d, 0x6f0406d4, 0xff605015, 0x241998fb, 0x97d6bde9, 0xcc894043, 0x7767d99e, 0xbdb0e842, 0x8807898b, 0x38e7195b, 0xdb79c8ee, 0x47a17c0a, 0xe97c420f, 0xc9f8841e, 0x00000000, 0x83098086, 0x48322bed, 0xac1e1170, 0x4e6c5a72, 0xfbfd0eff, 0x560f8538, 0x1e3daed5, 0x27362d39, 0x640a0fd9, 0x21685ca6, 0xd19b5b54, 0x3a24362e, 0xb10c0a67, 0x0f9357e7, 0xd2b4ee96, 0x9e1b9b91, 0x4f80c0c5, 0xa261dc20, 0x695a774b, 0x161c121a, 0x0ae293ba, 0xe5c0a02a, 0x433c22e0, 0x1d121b17, 0x0b0e090d, 0xadf28bc7, 0xb92db6a8, 0xc8141ea9, 0x8557f119, 0x4caf7507, 0xbbee99dd, 0xfda37f60, 0x9ff70126, 0xbc5c72f5, 0xc544663b, 0x345bfb7e, 0x768b4329, 0xdccb23c6, 0x68b6edfc, 0x63b8e4f1, 0xcad731dc, 0x10426385, 0x40139722, 0x2084c611, 0x7d854a24, 0xf8d2bb3d, 0x11aef932, 0x6dc729a1, 0x4b1d9e2f, 0xf3dcb230, 0xec0d8652, 0xd077c1e3, 0x6c2bb316, 0x99a970b9, 0xfa119448, 0x2247e964, 0xc4a8fc8c, 0x1aa0f03f, 0xd8567d2c, 0xef223390, 0xc787494e, 0xc1d938d1, 0xfe8ccaa2, 0x3698d40b, 0xcfa6f581, 0x28a57ade, 0x26dab78e, 0xa43fadbf, 0xe42c3a9d, 0x0d507892, 0x9b6a5fcc, 0x62547e46, 0xc2f68d13, 0xe890d8b8, 0x5e2e39f7, 0xf582c3af, 0xbe9f5d80, 0x7c69d093, 0xa96fd52d, 0xb3cf2512, 0x3bc8ac99, 0xa710187d, 0x6ee89c63, 0x7bdb3bbb, 0x09cd2678, 0xf46e5918, 0x01ec9ab7, 0xa8834f9a, 0x65e6956e, 0x7eaaffe6, 0x0821bccf, 0xe6ef15e8, 0xd9bae79b, 0xce4a6f36, 0xd4ea9f09, 0xd629b07c, 0xaf31a4b2, 0x312a3f23, 0x30c6a594, 0xc035a266, 0x37744ebc, 0xa6fc82ca, 0xb0e090d0, 0x1533a7d8, 0x4af10498, 0xf741ecda, 0x0e7fcd50, 0x2f1791f6, 0x8d764dd6, 0x4d43efb0, 0x54ccaa4d, 0xdfe49604, 0xe39ed1b5, 0x1b4c6a88, 0xb8c12c1f, 0x7f466551, 0x049d5eea, 0x5d018c35, 0x73fa8774, 0x2efb0b41, 0x5ab3671d, 0x5292dbd2, 0x33e91056, 0x136dd647, 0x8c9ad761, 0x7a37a10c, 0x8e59f814, 0x89eb133c, 0xeecea927, 0x35b761c9, 0xede11ce5, 0x3c7a47b1, 0x599cd2df, 0x3f55f273, 0x791814ce, 0xbf73c737, 0xea53f7cd, 0x5b5ffdaa, 0x14df3d6f, 0x867844db, 0x81caaff3, 0x3eb968c4, 0x2c382434, 0x5fc2a340, 0x72161dc3, 0x0cbce225, 0x8b283c49, 0x41ff0d95, 0x7139a801, 0xde080cb3, 0x9cd8b4e4, 0x906456c1, 0x617bcb84, 0x70d532b6, 0x74486c5c, 0x42d0b857];
    var T7 = [0xa75051f4, 0x65537e41, 0xa4c31a17, 0x5e963a27, 0x6bcb3bab, 0x45f11f9d, 0x58abacfa, 0x03934be3, 0xfa552030, 0x6df6ad76, 0x769188cc, 0x4c25f502, 0xd7fc4fe5, 0xcbd7c52a, 0x44802635, 0xa38fb562, 0x5a49deb1, 0x1b6725ba, 0x0e9845ea, 0xc0e15dfe, 0x7502c32f, 0xf012814c, 0x97a38d46, 0xf9c66bd3, 0x5fe7038f, 0x9c951592, 0x7aebbf6d, 0x59da9552, 0x832dd4be, 0x21d35874, 0x692949e0, 0xc8448ec9, 0x896a75c2, 0x7978f48e, 0x3e6b9958, 0x71dd27b9, 0x4fb6bee1, 0xad17f088, 0xac66c920, 0x3ab47dce, 0x4a1863df, 0x3182e51a, 0x33609751, 0x7f456253, 0x77e0b164, 0xae84bb6b, 0xa01cfe81, 0x2b94f908, 0x68587048, 0xfd198f45, 0x6c8794de, 0xf8b7527b, 0xd323ab73, 0x02e2724b, 0x8f57e31f, 0xab2a6655, 0x2807b2eb, 0xc2032fb5, 0x7b9a86c5, 0x08a5d337, 0x87f23028, 0xa5b223bf, 0x6aba0203, 0x825ced16, 0x1c2b8acf, 0xb492a779, 0xf2f0f307, 0xe2a14e69, 0xf4cd65da, 0xbed50605, 0x621fd134, 0xfe8ac4a6, 0x539d342e, 0x55a0a2f3, 0xe132058a, 0xeb75a4f6, 0xec390b83, 0xefaa4060, 0x9f065e71, 0x1051bd6e, 0x8af93e21, 0x063d96dd, 0x05aedd3e, 0xbd464de6, 0x8db59154, 0x5d0571c4, 0xd46f0406, 0x15ff6050, 0xfb241998, 0xe997d6bd, 0x43cc8940, 0x9e7767d9, 0x42bdb0e8, 0x8b880789, 0x5b38e719, 0xeedb79c8, 0x0a47a17c, 0x0fe97c42, 0x1ec9f884, 0x00000000, 0x86830980, 0xed48322b, 0x70ac1e11, 0x724e6c5a, 0xfffbfd0e, 0x38560f85, 0xd51e3dae, 0x3927362d, 0xd9640a0f, 0xa621685c, 0x54d19b5b, 0x2e3a2436, 0x67b10c0a, 0xe70f9357, 0x96d2b4ee, 0x919e1b9b, 0xc54f80c0, 0x20a261dc, 0x4b695a77, 0x1a161c12, 0xba0ae293, 0x2ae5c0a0, 0xe0433c22, 0x171d121b, 0x0d0b0e09, 0xc7adf28b, 0xa8b92db6, 0xa9c8141e, 0x198557f1, 0x074caf75, 0xddbbee99, 0x60fda37f, 0x269ff701, 0xf5bc5c72, 0x3bc54466, 0x7e345bfb, 0x29768b43, 0xc6dccb23, 0xfc68b6ed, 0xf163b8e4, 0xdccad731, 0x85104263, 0x22401397, 0x112084c6, 0x247d854a, 0x3df8d2bb, 0x3211aef9, 0xa16dc729, 0x2f4b1d9e, 0x30f3dcb2, 0x52ec0d86, 0xe3d077c1, 0x166c2bb3, 0xb999a970, 0x48fa1194, 0x642247e9, 0x8cc4a8fc, 0x3f1aa0f0, 0x2cd8567d, 0x90ef2233, 0x4ec78749, 0xd1c1d938, 0xa2fe8cca, 0x0b3698d4, 0x81cfa6f5, 0xde28a57a, 0x8e26dab7, 0xbfa43fad, 0x9de42c3a, 0x920d5078, 0xcc9b6a5f, 0x4662547e, 0x13c2f68d, 0xb8e890d8, 0xf75e2e39, 0xaff582c3, 0x80be9f5d, 0x937c69d0, 0x2da96fd5, 0x12b3cf25, 0x993bc8ac, 0x7da71018, 0x636ee89c, 0xbb7bdb3b, 0x7809cd26, 0x18f46e59, 0xb701ec9a, 0x9aa8834f, 0x6e65e695, 0xe67eaaff, 0xcf0821bc, 0xe8e6ef15, 0x9bd9bae7, 0x36ce4a6f, 0x09d4ea9f, 0x7cd629b0, 0xb2af31a4, 0x23312a3f, 0x9430c6a5, 0x66c035a2, 0xbc37744e, 0xcaa6fc82, 0xd0b0e090, 0xd81533a7, 0x984af104, 0xdaf741ec, 0x500e7fcd, 0xf62f1791, 0xd68d764d, 0xb04d43ef, 0x4d54ccaa, 0x04dfe496, 0xb5e39ed1, 0x881b4c6a, 0x1fb8c12c, 0x517f4665, 0xea049d5e, 0x355d018c, 0x7473fa87, 0x412efb0b, 0x1d5ab367, 0xd25292db, 0x5633e910, 0x47136dd6, 0x618c9ad7, 0x0c7a37a1, 0x148e59f8, 0x3c89eb13, 0x27eecea9, 0xc935b761, 0xe5ede11c, 0xb13c7a47, 0xdf599cd2, 0x733f55f2, 0xce791814, 0x37bf73c7, 0xcdea53f7, 0xaa5b5ffd, 0x6f14df3d, 0xdb867844, 0xf381caaf, 0xc43eb968, 0x342c3824, 0x405fc2a3, 0xc372161d, 0x250cbce2, 0x498b283c, 0x9541ff0d, 0x017139a8, 0xb3de080c, 0xe49cd8b4, 0xc1906456, 0x84617bcb, 0xb670d532, 0x5c74486c, 0x5742d0b8];
    var T8 = [0xf4a75051, 0x4165537e, 0x17a4c31a, 0x275e963a, 0xab6bcb3b, 0x9d45f11f, 0xfa58abac, 0xe303934b, 0x30fa5520, 0x766df6ad, 0xcc769188, 0x024c25f5, 0xe5d7fc4f, 0x2acbd7c5, 0x35448026, 0x62a38fb5, 0xb15a49de, 0xba1b6725, 0xea0e9845, 0xfec0e15d, 0x2f7502c3, 0x4cf01281, 0x4697a38d, 0xd3f9c66b, 0x8f5fe703, 0x929c9515, 0x6d7aebbf, 0x5259da95, 0xbe832dd4, 0x7421d358, 0xe0692949, 0xc9c8448e, 0xc2896a75, 0x8e7978f4, 0x583e6b99, 0xb971dd27, 0xe14fb6be, 0x88ad17f0, 0x20ac66c9, 0xce3ab47d, 0xdf4a1863, 0x1a3182e5, 0x51336097, 0x537f4562, 0x6477e0b1, 0x6bae84bb, 0x81a01cfe, 0x082b94f9, 0x48685870, 0x45fd198f, 0xde6c8794, 0x7bf8b752, 0x73d323ab, 0x4b02e272, 0x1f8f57e3, 0x55ab2a66, 0xeb2807b2, 0xb5c2032f, 0xc57b9a86, 0x3708a5d3, 0x2887f230, 0xbfa5b223, 0x036aba02, 0x16825ced, 0xcf1c2b8a, 0x79b492a7, 0x07f2f0f3, 0x69e2a14e, 0xdaf4cd65, 0x05bed506, 0x34621fd1, 0xa6fe8ac4, 0x2e539d34, 0xf355a0a2, 0x8ae13205, 0xf6eb75a4, 0x83ec390b, 0x60efaa40, 0x719f065e, 0x6e1051bd, 0x218af93e, 0xdd063d96, 0x3e05aedd, 0xe6bd464d, 0x548db591, 0xc45d0571, 0x06d46f04, 0x5015ff60, 0x98fb2419, 0xbde997d6, 0x4043cc89, 0xd99e7767, 0xe842bdb0, 0x898b8807, 0x195b38e7, 0xc8eedb79, 0x7c0a47a1, 0x420fe97c, 0x841ec9f8, 0x00000000, 0x80868309, 0x2bed4832, 0x1170ac1e, 0x5a724e6c, 0x0efffbfd, 0x8538560f, 0xaed51e3d, 0x2d392736, 0x0fd9640a, 0x5ca62168, 0x5b54d19b, 0x362e3a24, 0x0a67b10c, 0x57e70f93, 0xee96d2b4, 0x9b919e1b, 0xc0c54f80, 0xdc20a261, 0x774b695a, 0x121a161c, 0x93ba0ae2, 0xa02ae5c0, 0x22e0433c, 0x1b171d12, 0x090d0b0e, 0x8bc7adf2, 0xb6a8b92d, 0x1ea9c814, 0xf1198557, 0x75074caf, 0x99ddbbee, 0x7f60fda3, 0x01269ff7, 0x72f5bc5c, 0x663bc544, 0xfb7e345b, 0x4329768b, 0x23c6dccb, 0xedfc68b6, 0xe4f163b8, 0x31dccad7, 0x63851042, 0x97224013, 0xc6112084, 0x4a247d85, 0xbb3df8d2, 0xf93211ae, 0x29a16dc7, 0x9e2f4b1d, 0xb230f3dc, 0x8652ec0d, 0xc1e3d077, 0xb3166c2b, 0x70b999a9, 0x9448fa11, 0xe9642247, 0xfc8cc4a8, 0xf03f1aa0, 0x7d2cd856, 0x3390ef22, 0x494ec787, 0x38d1c1d9, 0xcaa2fe8c, 0xd40b3698, 0xf581cfa6, 0x7ade28a5, 0xb78e26da, 0xadbfa43f, 0x3a9de42c, 0x78920d50, 0x5fcc9b6a, 0x7e466254, 0x8d13c2f6, 0xd8b8e890, 0x39f75e2e, 0xc3aff582, 0x5d80be9f, 0xd0937c69, 0xd52da96f, 0x2512b3cf, 0xac993bc8, 0x187da710, 0x9c636ee8, 0x3bbb7bdb, 0x267809cd, 0x5918f46e, 0x9ab701ec, 0x4f9aa883, 0x956e65e6, 0xffe67eaa, 0xbccf0821, 0x15e8e6ef, 0xe79bd9ba, 0x6f36ce4a, 0x9f09d4ea, 0xb07cd629, 0xa4b2af31, 0x3f23312a, 0xa59430c6, 0xa266c035, 0x4ebc3774, 0x82caa6fc, 0x90d0b0e0, 0xa7d81533, 0x04984af1, 0xecdaf741, 0xcd500e7f, 0x91f62f17, 0x4dd68d76, 0xefb04d43, 0xaa4d54cc, 0x9604dfe4, 0xd1b5e39e, 0x6a881b4c, 0x2c1fb8c1, 0x65517f46, 0x5eea049d, 0x8c355d01, 0x877473fa, 0x0b412efb, 0x671d5ab3, 0xdbd25292, 0x105633e9, 0xd647136d, 0xd7618c9a, 0xa10c7a37, 0xf8148e59, 0x133c89eb, 0xa927eece, 0x61c935b7, 0x1ce5ede1, 0x47b13c7a, 0xd2df599c, 0xf2733f55, 0x14ce7918, 0xc737bf73, 0xf7cdea53, 0xfdaa5b5f, 0x3d6f14df, 0x44db8678, 0xaff381ca, 0x68c43eb9, 0x24342c38, 0xa3405fc2, 0x1dc37216, 0xe2250cbc, 0x3c498b28, 0x0d9541ff, 0xa8017139, 0x0cb3de08, 0xb4e49cd8, 0x56c19064, 0xcb84617b, 0x32b670d5, 0x6c5c7448, 0xb85742d0];

    // Transformations for decryption key expansion
    var U1 = [0x00000000, 0x0e090d0b, 0x1c121a16, 0x121b171d, 0x3824342c, 0x362d3927, 0x24362e3a, 0x2a3f2331, 0x70486858, 0x7e416553, 0x6c5a724e, 0x62537f45, 0x486c5c74, 0x4665517f, 0x547e4662, 0x5a774b69, 0xe090d0b0, 0xee99ddbb, 0xfc82caa6, 0xf28bc7ad, 0xd8b4e49c, 0xd6bde997, 0xc4a6fe8a, 0xcaaff381, 0x90d8b8e8, 0x9ed1b5e3, 0x8ccaa2fe, 0x82c3aff5, 0xa8fc8cc4, 0xa6f581cf, 0xb4ee96d2, 0xbae79bd9, 0xdb3bbb7b, 0xd532b670, 0xc729a16d, 0xc920ac66, 0xe31f8f57, 0xed16825c, 0xff0d9541, 0xf104984a, 0xab73d323, 0xa57ade28, 0xb761c935, 0xb968c43e, 0x9357e70f, 0x9d5eea04, 0x8f45fd19, 0x814cf012, 0x3bab6bcb, 0x35a266c0, 0x27b971dd, 0x29b07cd6, 0x038f5fe7, 0x0d8652ec, 0x1f9d45f1, 0x119448fa, 0x4be30393, 0x45ea0e98, 0x57f11985, 0x59f8148e, 0x73c737bf, 0x7dce3ab4, 0x6fd52da9, 0x61dc20a2, 0xad766df6, 0xa37f60fd, 0xb16477e0, 0xbf6d7aeb, 0x955259da, 0x9b5b54d1, 0x894043cc, 0x87494ec7, 0xdd3e05ae, 0xd33708a5, 0xc12c1fb8, 0xcf2512b3, 0xe51a3182, 0xeb133c89, 0xf9082b94, 0xf701269f, 0x4de6bd46, 0x43efb04d, 0x51f4a750, 0x5ffdaa5b, 0x75c2896a, 0x7bcb8461, 0x69d0937c, 0x67d99e77, 0x3daed51e, 0x33a7d815, 0x21bccf08, 0x2fb5c203, 0x058ae132, 0x0b83ec39, 0x1998fb24, 0x1791f62f, 0x764dd68d, 0x7844db86, 0x6a5fcc9b, 0x6456c190, 0x4e69e2a1, 0x4060efaa, 0x527bf8b7, 0x5c72f5bc, 0x0605bed5, 0x080cb3de, 0x1a17a4c3, 0x141ea9c8, 0x3e218af9, 0x302887f2, 0x223390ef, 0x2c3a9de4, 0x96dd063d, 0x98d40b36, 0x8acf1c2b, 0x84c61120, 0xaef93211, 0xa0f03f1a, 0xb2eb2807, 0xbce2250c, 0xe6956e65, 0xe89c636e, 0xfa877473, 0xf48e7978, 0xdeb15a49, 0xd0b85742, 0xc2a3405f, 0xccaa4d54, 0x41ecdaf7, 0x4fe5d7fc, 0x5dfec0e1, 0x53f7cdea, 0x79c8eedb, 0x77c1e3d0, 0x65daf4cd, 0x6bd3f9c6, 0x31a4b2af, 0x3fadbfa4, 0x2db6a8b9, 0x23bfa5b2, 0x09808683, 0x07898b88, 0x15929c95, 0x1b9b919e, 0xa17c0a47, 0xaf75074c, 0xbd6e1051, 0xb3671d5a, 0x99583e6b, 0x97513360, 0x854a247d, 0x8b432976, 0xd134621f, 0xdf3d6f14, 0xcd267809, 0xc32f7502, 0xe9105633, 0xe7195b38, 0xf5024c25, 0xfb0b412e, 0x9ad7618c, 0x94de6c87, 0x86c57b9a, 0x88cc7691, 0xa2f355a0, 0xacfa58ab, 0xbee14fb6, 0xb0e842bd, 0xea9f09d4, 0xe49604df, 0xf68d13c2, 0xf8841ec9, 0xd2bb3df8, 0xdcb230f3, 0xcea927ee, 0xc0a02ae5, 0x7a47b13c, 0x744ebc37, 0x6655ab2a, 0x685ca621, 0x42638510, 0x4c6a881b, 0x5e719f06, 0x5078920d, 0x0a0fd964, 0x0406d46f, 0x161dc372, 0x1814ce79, 0x322bed48, 0x3c22e043, 0x2e39f75e, 0x2030fa55, 0xec9ab701, 0xe293ba0a, 0xf088ad17, 0xfe81a01c, 0xd4be832d, 0xdab78e26, 0xc8ac993b, 0xc6a59430, 0x9cd2df59, 0x92dbd252, 0x80c0c54f, 0x8ec9c844, 0xa4f6eb75, 0xaaffe67e, 0xb8e4f163, 0xb6edfc68, 0x0c0a67b1, 0x02036aba, 0x10187da7, 0x1e1170ac, 0x342e539d, 0x3a275e96, 0x283c498b, 0x26354480, 0x7c420fe9, 0x724b02e2, 0x605015ff, 0x6e5918f4, 0x44663bc5, 0x4a6f36ce, 0x587421d3, 0x567d2cd8, 0x37a10c7a, 0x39a80171, 0x2bb3166c, 0x25ba1b67, 0x0f853856, 0x018c355d, 0x13972240, 0x1d9e2f4b, 0x47e96422, 0x49e06929, 0x5bfb7e34, 0x55f2733f, 0x7fcd500e, 0x71c45d05, 0x63df4a18, 0x6dd64713, 0xd731dcca, 0xd938d1c1, 0xcb23c6dc, 0xc52acbd7, 0xef15e8e6, 0xe11ce5ed, 0xf307f2f0, 0xfd0efffb, 0xa779b492, 0xa970b999, 0xbb6bae84, 0xb562a38f, 0x9f5d80be, 0x91548db5, 0x834f9aa8, 0x8d4697a3];
    var U2 = [0x00000000, 0x0b0e090d, 0x161c121a, 0x1d121b17, 0x2c382434, 0x27362d39, 0x3a24362e, 0x312a3f23, 0x58704868, 0x537e4165, 0x4e6c5a72, 0x4562537f, 0x74486c5c, 0x7f466551, 0x62547e46, 0x695a774b, 0xb0e090d0, 0xbbee99dd, 0xa6fc82ca, 0xadf28bc7, 0x9cd8b4e4, 0x97d6bde9, 0x8ac4a6fe, 0x81caaff3, 0xe890d8b8, 0xe39ed1b5, 0xfe8ccaa2, 0xf582c3af, 0xc4a8fc8c, 0xcfa6f581, 0xd2b4ee96, 0xd9bae79b, 0x7bdb3bbb, 0x70d532b6, 0x6dc729a1, 0x66c920ac, 0x57e31f8f, 0x5ced1682, 0x41ff0d95, 0x4af10498, 0x23ab73d3, 0x28a57ade, 0x35b761c9, 0x3eb968c4, 0x0f9357e7, 0x049d5eea, 0x198f45fd, 0x12814cf0, 0xcb3bab6b, 0xc035a266, 0xdd27b971, 0xd629b07c, 0xe7038f5f, 0xec0d8652, 0xf11f9d45, 0xfa119448, 0x934be303, 0x9845ea0e, 0x8557f119, 0x8e59f814, 0xbf73c737, 0xb47dce3a, 0xa96fd52d, 0xa261dc20, 0xf6ad766d, 0xfda37f60, 0xe0b16477, 0xebbf6d7a, 0xda955259, 0xd19b5b54, 0xcc894043, 0xc787494e, 0xaedd3e05, 0xa5d33708, 0xb8c12c1f, 0xb3cf2512, 0x82e51a31, 0x89eb133c, 0x94f9082b, 0x9ff70126, 0x464de6bd, 0x4d43efb0, 0x5051f4a7, 0x5b5ffdaa, 0x6a75c289, 0x617bcb84, 0x7c69d093, 0x7767d99e, 0x1e3daed5, 0x1533a7d8, 0x0821bccf, 0x032fb5c2, 0x32058ae1, 0x390b83ec, 0x241998fb, 0x2f1791f6, 0x8d764dd6, 0x867844db, 0x9b6a5fcc, 0x906456c1, 0xa14e69e2, 0xaa4060ef, 0xb7527bf8, 0xbc5c72f5, 0xd50605be, 0xde080cb3, 0xc31a17a4, 0xc8141ea9, 0xf93e218a, 0xf2302887, 0xef223390, 0xe42c3a9d, 0x3d96dd06, 0x3698d40b, 0x2b8acf1c, 0x2084c611, 0x11aef932, 0x1aa0f03f, 0x07b2eb28, 0x0cbce225, 0x65e6956e, 0x6ee89c63, 0x73fa8774, 0x78f48e79, 0x49deb15a, 0x42d0b857, 0x5fc2a340, 0x54ccaa4d, 0xf741ecda, 0xfc4fe5d7, 0xe15dfec0, 0xea53f7cd, 0xdb79c8ee, 0xd077c1e3, 0xcd65daf4, 0xc66bd3f9, 0xaf31a4b2, 0xa43fadbf, 0xb92db6a8, 0xb223bfa5, 0x83098086, 0x8807898b, 0x9515929c, 0x9e1b9b91, 0x47a17c0a, 0x4caf7507, 0x51bd6e10, 0x5ab3671d, 0x6b99583e, 0x60975133, 0x7d854a24, 0x768b4329, 0x1fd13462, 0x14df3d6f, 0x09cd2678, 0x02c32f75, 0x33e91056, 0x38e7195b, 0x25f5024c, 0x2efb0b41, 0x8c9ad761, 0x8794de6c, 0x9a86c57b, 0x9188cc76, 0xa0a2f355, 0xabacfa58, 0xb6bee14f, 0xbdb0e842, 0xd4ea9f09, 0xdfe49604, 0xc2f68d13, 0xc9f8841e, 0xf8d2bb3d, 0xf3dcb230, 0xeecea927, 0xe5c0a02a, 0x3c7a47b1, 0x37744ebc, 0x2a6655ab, 0x21685ca6, 0x10426385, 0x1b4c6a88, 0x065e719f, 0x0d507892, 0x640a0fd9, 0x6f0406d4, 0x72161dc3, 0x791814ce, 0x48322bed, 0x433c22e0, 0x5e2e39f7, 0x552030fa, 0x01ec9ab7, 0x0ae293ba, 0x17f088ad, 0x1cfe81a0, 0x2dd4be83, 0x26dab78e, 0x3bc8ac99, 0x30c6a594, 0x599cd2df, 0x5292dbd2, 0x4f80c0c5, 0x448ec9c8, 0x75a4f6eb, 0x7eaaffe6, 0x63b8e4f1, 0x68b6edfc, 0xb10c0a67, 0xba02036a, 0xa710187d, 0xac1e1170, 0x9d342e53, 0x963a275e, 0x8b283c49, 0x80263544, 0xe97c420f, 0xe2724b02, 0xff605015, 0xf46e5918, 0xc544663b, 0xce4a6f36, 0xd3587421, 0xd8567d2c, 0x7a37a10c, 0x7139a801, 0x6c2bb316, 0x6725ba1b, 0x560f8538, 0x5d018c35, 0x40139722, 0x4b1d9e2f, 0x2247e964, 0x2949e069, 0x345bfb7e, 0x3f55f273, 0x0e7fcd50, 0x0571c45d, 0x1863df4a, 0x136dd647, 0xcad731dc, 0xc1d938d1, 0xdccb23c6, 0xd7c52acb, 0xe6ef15e8, 0xede11ce5, 0xf0f307f2, 0xfbfd0eff, 0x92a779b4, 0x99a970b9, 0x84bb6bae, 0x8fb562a3, 0xbe9f5d80, 0xb591548d, 0xa8834f9a, 0xa38d4697];
    var U3 = [0x00000000, 0x0d0b0e09, 0x1a161c12, 0x171d121b, 0x342c3824, 0x3927362d, 0x2e3a2436, 0x23312a3f, 0x68587048, 0x65537e41, 0x724e6c5a, 0x7f456253, 0x5c74486c, 0x517f4665, 0x4662547e, 0x4b695a77, 0xd0b0e090, 0xddbbee99, 0xcaa6fc82, 0xc7adf28b, 0xe49cd8b4, 0xe997d6bd, 0xfe8ac4a6, 0xf381caaf, 0xb8e890d8, 0xb5e39ed1, 0xa2fe8cca, 0xaff582c3, 0x8cc4a8fc, 0x81cfa6f5, 0x96d2b4ee, 0x9bd9bae7, 0xbb7bdb3b, 0xb670d532, 0xa16dc729, 0xac66c920, 0x8f57e31f, 0x825ced16, 0x9541ff0d, 0x984af104, 0xd323ab73, 0xde28a57a, 0xc935b761, 0xc43eb968, 0xe70f9357, 0xea049d5e, 0xfd198f45, 0xf012814c, 0x6bcb3bab, 0x66c035a2, 0x71dd27b9, 0x7cd629b0, 0x5fe7038f, 0x52ec0d86, 0x45f11f9d, 0x48fa1194, 0x03934be3, 0x0e9845ea, 0x198557f1, 0x148e59f8, 0x37bf73c7, 0x3ab47dce, 0x2da96fd5, 0x20a261dc, 0x6df6ad76, 0x60fda37f, 0x77e0b164, 0x7aebbf6d, 0x59da9552, 0x54d19b5b, 0x43cc8940, 0x4ec78749, 0x05aedd3e, 0x08a5d337, 0x1fb8c12c, 0x12b3cf25, 0x3182e51a, 0x3c89eb13, 0x2b94f908, 0x269ff701, 0xbd464de6, 0xb04d43ef, 0xa75051f4, 0xaa5b5ffd, 0x896a75c2, 0x84617bcb, 0x937c69d0, 0x9e7767d9, 0xd51e3dae, 0xd81533a7, 0xcf0821bc, 0xc2032fb5, 0xe132058a, 0xec390b83, 0xfb241998, 0xf62f1791, 0xd68d764d, 0xdb867844, 0xcc9b6a5f, 0xc1906456, 0xe2a14e69, 0xefaa4060, 0xf8b7527b, 0xf5bc5c72, 0xbed50605, 0xb3de080c, 0xa4c31a17, 0xa9c8141e, 0x8af93e21, 0x87f23028, 0x90ef2233, 0x9de42c3a, 0x063d96dd, 0x0b3698d4, 0x1c2b8acf, 0x112084c6, 0x3211aef9, 0x3f1aa0f0, 0x2807b2eb, 0x250cbce2, 0x6e65e695, 0x636ee89c, 0x7473fa87, 0x7978f48e, 0x5a49deb1, 0x5742d0b8, 0x405fc2a3, 0x4d54ccaa, 0xdaf741ec, 0xd7fc4fe5, 0xc0e15dfe, 0xcdea53f7, 0xeedb79c8, 0xe3d077c1, 0xf4cd65da, 0xf9c66bd3, 0xb2af31a4, 0xbfa43fad, 0xa8b92db6, 0xa5b223bf, 0x86830980, 0x8b880789, 0x9c951592, 0x919e1b9b, 0x0a47a17c, 0x074caf75, 0x1051bd6e, 0x1d5ab367, 0x3e6b9958, 0x33609751, 0x247d854a, 0x29768b43, 0x621fd134, 0x6f14df3d, 0x7809cd26, 0x7502c32f, 0x5633e910, 0x5b38e719, 0x4c25f502, 0x412efb0b, 0x618c9ad7, 0x6c8794de, 0x7b9a86c5, 0x769188cc, 0x55a0a2f3, 0x58abacfa, 0x4fb6bee1, 0x42bdb0e8, 0x09d4ea9f, 0x04dfe496, 0x13c2f68d, 0x1ec9f884, 0x3df8d2bb, 0x30f3dcb2, 0x27eecea9, 0x2ae5c0a0, 0xb13c7a47, 0xbc37744e, 0xab2a6655, 0xa621685c, 0x85104263, 0x881b4c6a, 0x9f065e71, 0x920d5078, 0xd9640a0f, 0xd46f0406, 0xc372161d, 0xce791814, 0xed48322b, 0xe0433c22, 0xf75e2e39, 0xfa552030, 0xb701ec9a, 0xba0ae293, 0xad17f088, 0xa01cfe81, 0x832dd4be, 0x8e26dab7, 0x993bc8ac, 0x9430c6a5, 0xdf599cd2, 0xd25292db, 0xc54f80c0, 0xc8448ec9, 0xeb75a4f6, 0xe67eaaff, 0xf163b8e4, 0xfc68b6ed, 0x67b10c0a, 0x6aba0203, 0x7da71018, 0x70ac1e11, 0x539d342e, 0x5e963a27, 0x498b283c, 0x44802635, 0x0fe97c42, 0x02e2724b, 0x15ff6050, 0x18f46e59, 0x3bc54466, 0x36ce4a6f, 0x21d35874, 0x2cd8567d, 0x0c7a37a1, 0x017139a8, 0x166c2bb3, 0x1b6725ba, 0x38560f85, 0x355d018c, 0x22401397, 0x2f4b1d9e, 0x642247e9, 0x692949e0, 0x7e345bfb, 0x733f55f2, 0x500e7fcd, 0x5d0571c4, 0x4a1863df, 0x47136dd6, 0xdccad731, 0xd1c1d938, 0xc6dccb23, 0xcbd7c52a, 0xe8e6ef15, 0xe5ede11c, 0xf2f0f307, 0xfffbfd0e, 0xb492a779, 0xb999a970, 0xae84bb6b, 0xa38fb562, 0x80be9f5d, 0x8db59154, 0x9aa8834f, 0x97a38d46];
    var U4 = [0x00000000, 0x090d0b0e, 0x121a161c, 0x1b171d12, 0x24342c38, 0x2d392736, 0x362e3a24, 0x3f23312a, 0x48685870, 0x4165537e, 0x5a724e6c, 0x537f4562, 0x6c5c7448, 0x65517f46, 0x7e466254, 0x774b695a, 0x90d0b0e0, 0x99ddbbee, 0x82caa6fc, 0x8bc7adf2, 0xb4e49cd8, 0xbde997d6, 0xa6fe8ac4, 0xaff381ca, 0xd8b8e890, 0xd1b5e39e, 0xcaa2fe8c, 0xc3aff582, 0xfc8cc4a8, 0xf581cfa6, 0xee96d2b4, 0xe79bd9ba, 0x3bbb7bdb, 0x32b670d5, 0x29a16dc7, 0x20ac66c9, 0x1f8f57e3, 0x16825ced, 0x0d9541ff, 0x04984af1, 0x73d323ab, 0x7ade28a5, 0x61c935b7, 0x68c43eb9, 0x57e70f93, 0x5eea049d, 0x45fd198f, 0x4cf01281, 0xab6bcb3b, 0xa266c035, 0xb971dd27, 0xb07cd629, 0x8f5fe703, 0x8652ec0d, 0x9d45f11f, 0x9448fa11, 0xe303934b, 0xea0e9845, 0xf1198557, 0xf8148e59, 0xc737bf73, 0xce3ab47d, 0xd52da96f, 0xdc20a261, 0x766df6ad, 0x7f60fda3, 0x6477e0b1, 0x6d7aebbf, 0x5259da95, 0x5b54d19b, 0x4043cc89, 0x494ec787, 0x3e05aedd, 0x3708a5d3, 0x2c1fb8c1, 0x2512b3cf, 0x1a3182e5, 0x133c89eb, 0x082b94f9, 0x01269ff7, 0xe6bd464d, 0xefb04d43, 0xf4a75051, 0xfdaa5b5f, 0xc2896a75, 0xcb84617b, 0xd0937c69, 0xd99e7767, 0xaed51e3d, 0xa7d81533, 0xbccf0821, 0xb5c2032f, 0x8ae13205, 0x83ec390b, 0x98fb2419, 0x91f62f17, 0x4dd68d76, 0x44db8678, 0x5fcc9b6a, 0x56c19064, 0x69e2a14e, 0x60efaa40, 0x7bf8b752, 0x72f5bc5c, 0x05bed506, 0x0cb3de08, 0x17a4c31a, 0x1ea9c814, 0x218af93e, 0x2887f230, 0x3390ef22, 0x3a9de42c, 0xdd063d96, 0xd40b3698, 0xcf1c2b8a, 0xc6112084, 0xf93211ae, 0xf03f1aa0, 0xeb2807b2, 0xe2250cbc, 0x956e65e6, 0x9c636ee8, 0x877473fa, 0x8e7978f4, 0xb15a49de, 0xb85742d0, 0xa3405fc2, 0xaa4d54cc, 0xecdaf741, 0xe5d7fc4f, 0xfec0e15d, 0xf7cdea53, 0xc8eedb79, 0xc1e3d077, 0xdaf4cd65, 0xd3f9c66b, 0xa4b2af31, 0xadbfa43f, 0xb6a8b92d, 0xbfa5b223, 0x80868309, 0x898b8807, 0x929c9515, 0x9b919e1b, 0x7c0a47a1, 0x75074caf, 0x6e1051bd, 0x671d5ab3, 0x583e6b99, 0x51336097, 0x4a247d85, 0x4329768b, 0x34621fd1, 0x3d6f14df, 0x267809cd, 0x2f7502c3, 0x105633e9, 0x195b38e7, 0x024c25f5, 0x0b412efb, 0xd7618c9a, 0xde6c8794, 0xc57b9a86, 0xcc769188, 0xf355a0a2, 0xfa58abac, 0xe14fb6be, 0xe842bdb0, 0x9f09d4ea, 0x9604dfe4, 0x8d13c2f6, 0x841ec9f8, 0xbb3df8d2, 0xb230f3dc, 0xa927eece, 0xa02ae5c0, 0x47b13c7a, 0x4ebc3774, 0x55ab2a66, 0x5ca62168, 0x63851042, 0x6a881b4c, 0x719f065e, 0x78920d50, 0x0fd9640a, 0x06d46f04, 0x1dc37216, 0x14ce7918, 0x2bed4832, 0x22e0433c, 0x39f75e2e, 0x30fa5520, 0x9ab701ec, 0x93ba0ae2, 0x88ad17f0, 0x81a01cfe, 0xbe832dd4, 0xb78e26da, 0xac993bc8, 0xa59430c6, 0xd2df599c, 0xdbd25292, 0xc0c54f80, 0xc9c8448e, 0xf6eb75a4, 0xffe67eaa, 0xe4f163b8, 0xedfc68b6, 0x0a67b10c, 0x036aba02, 0x187da710, 0x1170ac1e, 0x2e539d34, 0x275e963a, 0x3c498b28, 0x35448026, 0x420fe97c, 0x4b02e272, 0x5015ff60, 0x5918f46e, 0x663bc544, 0x6f36ce4a, 0x7421d358, 0x7d2cd856, 0xa10c7a37, 0xa8017139, 0xb3166c2b, 0xba1b6725, 0x8538560f, 0x8c355d01, 0x97224013, 0x9e2f4b1d, 0xe9642247, 0xe0692949, 0xfb7e345b, 0xf2733f55, 0xcd500e7f, 0xc45d0571, 0xdf4a1863, 0xd647136d, 0x31dccad7, 0x38d1c1d9, 0x23c6dccb, 0x2acbd7c5, 0x15e8e6ef, 0x1ce5ede1, 0x07f2f0f3, 0x0efffbfd, 0x79b492a7, 0x70b999a9, 0x6bae84bb, 0x62a38fb5, 0x5d80be9f, 0x548db591, 0x4f9aa883, 0x4697a38d];

    function convertToInt32(bytes) {
        var result = [];
        for (var i = 0; i < bytes.length; i += 4) {
            result.push(
                (bytes[i    ] << 24) |
                (bytes[i + 1] << 16) |
                (bytes[i + 2] <<  8) |
                 bytes[i + 3]
            );
        }
        return result;
    }

    var AES = function(key) {
        if (!(this instanceof AES)) {
            throw Error('AES must be instanitated with `new`');
        }

        Object.defineProperty(this, 'key', {
            value: coerceArray(key, true)
        });

        this._prepare();
    }


    AES.prototype._prepare = function() {

        var rounds = numberOfRounds[this.key.length];
        if (rounds == null) {
            throw new Error('invalid key size (must be 16, 24 or 32 bytes)');
        }

        // encryption round keys
        this._Ke = [];

        // decryption round keys
        this._Kd = [];

        for (var i = 0; i <= rounds; i++) {
            this._Ke.push([0, 0, 0, 0]);
            this._Kd.push([0, 0, 0, 0]);
        }

        var roundKeyCount = (rounds + 1) * 4;
        var KC = this.key.length / 4;

        // convert the key into ints
        var tk = convertToInt32(this.key);

        // copy values into round key arrays
        var index;
        for (var i = 0; i < KC; i++) {
            index = i >> 2;
            this._Ke[index][i % 4] = tk[i];
            this._Kd[rounds - index][i % 4] = tk[i];
        }

        // key expansion (fips-197 section 5.2)
        var rconpointer = 0;
        var t = KC, tt;
        while (t < roundKeyCount) {
            tt = tk[KC - 1];
            tk[0] ^= ((S[(tt >> 16) & 0xFF] << 24) ^
                      (S[(tt >>  8) & 0xFF] << 16) ^
                      (S[ tt        & 0xFF] <<  8) ^
                       S[(tt >> 24) & 0xFF]        ^
                      (rcon[rconpointer] << 24));
            rconpointer += 1;

            // key expansion (for non-256 bit)
            if (KC != 8) {
                for (var i = 1; i < KC; i++) {
                    tk[i] ^= tk[i - 1];
                }

            // key expansion for 256-bit keys is "slightly different" (fips-197)
            } else {
                for (var i = 1; i < (KC / 2); i++) {
                    tk[i] ^= tk[i - 1];
                }
                tt = tk[(KC / 2) - 1];

                tk[KC / 2] ^= (S[ tt        & 0xFF]        ^
                              (S[(tt >>  8) & 0xFF] <<  8) ^
                              (S[(tt >> 16) & 0xFF] << 16) ^
                              (S[(tt >> 24) & 0xFF] << 24));

                for (var i = (KC / 2) + 1; i < KC; i++) {
                    tk[i] ^= tk[i - 1];
                }
            }

            // copy values into round key arrays
            var i = 0, r, c;
            while (i < KC && t < roundKeyCount) {
                r = t >> 2;
                c = t % 4;
                this._Ke[r][c] = tk[i];
                this._Kd[rounds - r][c] = tk[i++];
                t++;
            }
        }

        // inverse-cipher-ify the decryption round key (fips-197 section 5.3)
        for (var r = 1; r < rounds; r++) {
            for (var c = 0; c < 4; c++) {
                tt = this._Kd[r][c];
                this._Kd[r][c] = (U1[(tt >> 24) & 0xFF] ^
                                  U2[(tt >> 16) & 0xFF] ^
                                  U3[(tt >>  8) & 0xFF] ^
                                  U4[ tt        & 0xFF]);
            }
        }
    }

    AES.prototype.encrypt = function(plaintext) {
        if (plaintext.length != 16) {
            throw new Error('invalid plaintext size (must be 16 bytes)');
        }

        var rounds = this._Ke.length - 1;
        var a = [0, 0, 0, 0];

        // convert plaintext to (ints ^ key)
        var t = convertToInt32(plaintext);
        for (var i = 0; i < 4; i++) {
            t[i] ^= this._Ke[0][i];
        }

        // apply round transforms
        for (var r = 1; r < rounds; r++) {
            for (var i = 0; i < 4; i++) {
                a[i] = (T1[(t[ i         ] >> 24) & 0xff] ^
                        T2[(t[(i + 1) % 4] >> 16) & 0xff] ^
                        T3[(t[(i + 2) % 4] >>  8) & 0xff] ^
                        T4[ t[(i + 3) % 4]        & 0xff] ^
                        this._Ke[r][i]);
            }
            t = a.slice();
        }

        // the last round is special
        var result = createArray(16), tt;
        for (var i = 0; i < 4; i++) {
            tt = this._Ke[rounds][i];
            result[4 * i    ] = (S[(t[ i         ] >> 24) & 0xff] ^ (tt >> 24)) & 0xff;
            result[4 * i + 1] = (S[(t[(i + 1) % 4] >> 16) & 0xff] ^ (tt >> 16)) & 0xff;
            result[4 * i + 2] = (S[(t[(i + 2) % 4] >>  8) & 0xff] ^ (tt >>  8)) & 0xff;
            result[4 * i + 3] = (S[ t[(i + 3) % 4]        & 0xff] ^  tt       ) & 0xff;
        }

        return result;
    }

    AES.prototype.decrypt = function(ciphertext) {
        if (ciphertext.length != 16) {
            throw new Error('invalid ciphertext size (must be 16 bytes)');
        }

        var rounds = this._Kd.length - 1;
        var a = [0, 0, 0, 0];

        // convert plaintext to (ints ^ key)
        var t = convertToInt32(ciphertext);
        for (var i = 0; i < 4; i++) {
            t[i] ^= this._Kd[0][i];
        }

        // apply round transforms
        for (var r = 1; r < rounds; r++) {
            for (var i = 0; i < 4; i++) {
                a[i] = (T5[(t[ i          ] >> 24) & 0xff] ^
                        T6[(t[(i + 3) % 4] >> 16) & 0xff] ^
                        T7[(t[(i + 2) % 4] >>  8) & 0xff] ^
                        T8[ t[(i + 1) % 4]        & 0xff] ^
                        this._Kd[r][i]);
            }
            t = a.slice();
        }

        // the last round is special
        var result = createArray(16), tt;
        for (var i = 0; i < 4; i++) {
            tt = this._Kd[rounds][i];
            result[4 * i    ] = (Si[(t[ i         ] >> 24) & 0xff] ^ (tt >> 24)) & 0xff;
            result[4 * i + 1] = (Si[(t[(i + 3) % 4] >> 16) & 0xff] ^ (tt >> 16)) & 0xff;
            result[4 * i + 2] = (Si[(t[(i + 2) % 4] >>  8) & 0xff] ^ (tt >>  8)) & 0xff;
            result[4 * i + 3] = (Si[ t[(i + 1) % 4]        & 0xff] ^  tt       ) & 0xff;
        }

        return result;
    }


    /**
     *  Mode Of Operation - Electonic Codebook (ECB)
     */
    var ModeOfOperationECB = function(key) {
        if (!(this instanceof ModeOfOperationECB)) {
            throw Error('AES must be instanitated with `new`');
        }

        this.description = "Electronic Code Block";
        this.name = "ecb";

        this._aes = new AES(key);
    }

    ModeOfOperationECB.prototype.encrypt = function(plaintext) {
        plaintext = coerceArray(plaintext);

        if ((plaintext.length % 16) !== 0) {
            throw new Error('invalid plaintext size (must be multiple of 16 bytes)');
        }

        var ciphertext = createArray(plaintext.length);
        var block = createArray(16);

        for (var i = 0; i < plaintext.length; i += 16) {
            copyArray(plaintext, block, 0, i, i + 16);
            block = this._aes.encrypt(block);
            copyArray(block, ciphertext, i);
        }

        return ciphertext;
    }

    ModeOfOperationECB.prototype.decrypt = function(ciphertext) {
        ciphertext = coerceArray(ciphertext);

        if ((ciphertext.length % 16) !== 0) {
            throw new Error('invalid ciphertext size (must be multiple of 16 bytes)');
        }

        var plaintext = createArray(ciphertext.length);
        var block = createArray(16);

        for (var i = 0; i < ciphertext.length; i += 16) {
            copyArray(ciphertext, block, 0, i, i + 16);
            block = this._aes.decrypt(block);
            copyArray(block, plaintext, i);
        }

        return plaintext;
    }


    /**
     *  Mode Of Operation - Cipher Block Chaining (CBC)
     */
    var ModeOfOperationCBC = function(key, iv) {
        if (!(this instanceof ModeOfOperationCBC)) {
            throw Error('AES must be instanitated with `new`');
        }

        this.description = "Cipher Block Chaining";
        this.name = "cbc";

        if (!iv) {
            iv = createArray(16);

        } else if (iv.length != 16) {
            throw new Error('invalid initialation vector size (must be 16 bytes)');
        }

        this._lastCipherblock = coerceArray(iv, true);

        this._aes = new AES(key);
    }

    ModeOfOperationCBC.prototype.encrypt = function(plaintext) {
        plaintext = coerceArray(plaintext);

        if ((plaintext.length % 16) !== 0) {
            throw new Error('invalid plaintext size (must be multiple of 16 bytes)');
        }

        var ciphertext = createArray(plaintext.length);
        var block = createArray(16);

        for (var i = 0; i < plaintext.length; i += 16) {
            copyArray(plaintext, block, 0, i, i + 16);

            for (var j = 0; j < 16; j++) {
                block[j] ^= this._lastCipherblock[j];
            }

            this._lastCipherblock = this._aes.encrypt(block);
            copyArray(this._lastCipherblock, ciphertext, i);
        }

        return ciphertext;
    }

    ModeOfOperationCBC.prototype.decrypt = function(ciphertext) {
        ciphertext = coerceArray(ciphertext);

        if ((ciphertext.length % 16) !== 0) {
            throw new Error('invalid ciphertext size (must be multiple of 16 bytes)');
        }

        var plaintext = createArray(ciphertext.length);
        var block = createArray(16);

        for (var i = 0; i < ciphertext.length; i += 16) {
            copyArray(ciphertext, block, 0, i, i + 16);
            block = this._aes.decrypt(block);

            for (var j = 0; j < 16; j++) {
                plaintext[i + j] = block[j] ^ this._lastCipherblock[j];
            }

            copyArray(ciphertext, this._lastCipherblock, 0, i, i + 16);
        }

        return plaintext;
    }


    /**
     *  Mode Of Operation - Cipher Feedback (CFB)
     */
    var ModeOfOperationCFB = function(key, iv, segmentSize) {
        if (!(this instanceof ModeOfOperationCFB)) {
            throw Error('AES must be instanitated with `new`');
        }

        this.description = "Cipher Feedback";
        this.name = "cfb";

        if (!iv) {
            iv = createArray(16);

        } else if (iv.length != 16) {
            throw new Error('invalid initialation vector size (must be 16 size)');
        }

        if (!segmentSize) { segmentSize = 1; }

        this.segmentSize = segmentSize;

        this._shiftRegister = coerceArray(iv, true);

        this._aes = new AES(key);
    }

    ModeOfOperationCFB.prototype.encrypt = function(plaintext) {
        if ((plaintext.length % this.segmentSize) != 0) {
            throw new Error('invalid plaintext size (must be segmentSize bytes)');
        }

        var encrypted = coerceArray(plaintext, true);

        var xorSegment;
        for (var i = 0; i < encrypted.length; i += this.segmentSize) {
            xorSegment = this._aes.encrypt(this._shiftRegister);
            for (var j = 0; j < this.segmentSize; j++) {
                encrypted[i + j] ^= xorSegment[j];
            }

            // Shift the register
            copyArray(this._shiftRegister, this._shiftRegister, 0, this.segmentSize);
            copyArray(encrypted, this._shiftRegister, 16 - this.segmentSize, i, i + this.segmentSize);
        }

        return encrypted;
    }

    ModeOfOperationCFB.prototype.decrypt = function(ciphertext) {
        if ((ciphertext.length % this.segmentSize) != 0) {
            throw new Error('invalid ciphertext size (must be segmentSize bytes)');
        }

        var plaintext = coerceArray(ciphertext, true);

        var xorSegment;
        for (var i = 0; i < plaintext.length; i += this.segmentSize) {
            xorSegment = this._aes.encrypt(this._shiftRegister);

            for (var j = 0; j < this.segmentSize; j++) {
                plaintext[i + j] ^= xorSegment[j];
            }

            // Shift the register
            copyArray(this._shiftRegister, this._shiftRegister, 0, this.segmentSize);
            copyArray(ciphertext, this._shiftRegister, 16 - this.segmentSize, i, i + this.segmentSize);
        }

        return plaintext;
    }

    /**
     *  Mode Of Operation - Output Feedback (OFB)
     */
    var ModeOfOperationOFB = function(key, iv) {
        if (!(this instanceof ModeOfOperationOFB)) {
            throw Error('AES must be instanitated with `new`');
        }

        this.description = "Output Feedback";
        this.name = "ofb";

        if (!iv) {
            iv = createArray(16);

        } else if (iv.length != 16) {
            throw new Error('invalid initialation vector size (must be 16 bytes)');
        }

        this._lastPrecipher = coerceArray(iv, true);
        this._lastPrecipherIndex = 16;

        this._aes = new AES(key);
    }

    ModeOfOperationOFB.prototype.encrypt = function(plaintext) {
        var encrypted = coerceArray(plaintext, true);

        for (var i = 0; i < encrypted.length; i++) {
            if (this._lastPrecipherIndex === 16) {
                this._lastPrecipher = this._aes.encrypt(this._lastPrecipher);
                this._lastPrecipherIndex = 0;
            }
            encrypted[i] ^= this._lastPrecipher[this._lastPrecipherIndex++];
        }

        return encrypted;
    }

    // Decryption is symetric
    ModeOfOperationOFB.prototype.decrypt = ModeOfOperationOFB.prototype.encrypt;


    /**
     *  Counter object for CTR common mode of operation
     */
    var Counter = function(initialValue) {
        if (!(this instanceof Counter)) {
            throw Error('Counter must be instanitated with `new`');
        }

        // We allow 0, but anything false-ish uses the default 1
        if (initialValue !== 0 && !initialValue) { initialValue = 1; }

        if (typeof(initialValue) === 'number') {
            this._counter = createArray(16);
            this.setValue(initialValue);

        } else {
            this.setBytes(initialValue);
        }
    }

    Counter.prototype.setValue = function(value) {
        if (typeof(value) !== 'number' || parseInt(value) != value) {
            throw new Error('invalid counter value (must be an integer)');
        }

        // We cannot safely handle numbers beyond the safe range for integers
        if (value > Number.MAX_SAFE_INTEGER) {
            throw new Error('integer value out of safe range');
        }

        for (var index = 15; index >= 0; --index) {
            this._counter[index] = value % 256;
            value = parseInt(value / 256);
        }
    }

    Counter.prototype.setBytes = function(bytes) {
        bytes = coerceArray(bytes, true);

        if (bytes.length != 16) {
            throw new Error('invalid counter bytes size (must be 16 bytes)');
        }

        this._counter = bytes;
    };

    Counter.prototype.increment = function() {
        for (var i = 15; i >= 0; i--) {
            if (this._counter[i] === 255) {
                this._counter[i] = 0;
            } else {
                this._counter[i]++;
                break;
            }
        }
    }


    /**
     *  Mode Of Operation - Counter (CTR)
     */
    var ModeOfOperationCTR = function(key, counter) {
        if (!(this instanceof ModeOfOperationCTR)) {
            throw Error('AES must be instanitated with `new`');
        }

        this.description = "Counter";
        this.name = "ctr";

        if (!(counter instanceof Counter)) {
            counter = new Counter(counter)
        }

        this._counter = counter;

        this._remainingCounter = null;
        this._remainingCounterIndex = 16;

        this._aes = new AES(key);
    }

    ModeOfOperationCTR.prototype.encrypt = function(plaintext) {
        var encrypted = coerceArray(plaintext, true);

        for (var i = 0; i < encrypted.length; i++) {
            if (this._remainingCounterIndex === 16) {
                this._remainingCounter = this._aes.encrypt(this._counter._counter);
                this._remainingCounterIndex = 0;
                this._counter.increment();
            }
            encrypted[i] ^= this._remainingCounter[this._remainingCounterIndex++];
        }

        return encrypted;
    }

    // Decryption is symetric
    ModeOfOperationCTR.prototype.decrypt = ModeOfOperationCTR.prototype.encrypt;


    ///////////////////////
    // Padding

    // See:https://tools.ietf.org/html/rfc2315
    function pkcs7pad(data) {
        data = coerceArray(data, true);
        var padder = 16 - (data.length % 16);
        var result = createArray(data.length + padder);
        copyArray(data, result);
        for (var i = data.length; i < result.length; i++) {
            result[i] = padder;
        }
        return result;
    }

    function pkcs7strip(data) {
        data = coerceArray(data, true);
        if (data.length < 16) { throw new Error('PKCS#7 invalid length'); }

        var padder = data[data.length - 1];
        if (padder > 16) { throw new Error('PKCS#7 padding byte out of range'); }

        var length = data.length - padder;
        for (var i = 0; i < padder; i++) {
            if (data[length + i] !== padder) {
                throw new Error('PKCS#7 invalid padding byte');
            }
        }

        var result = createArray(length);
        copyArray(data, result, 0, 0, length);
        return result;
    }

    ///////////////////////
    // Exporting


    // The block cipher
    var aesjs = {
        AES: AES,
        Counter: Counter,

        ModeOfOperation: {
            ecb: ModeOfOperationECB,
            cbc: ModeOfOperationCBC,
            cfb: ModeOfOperationCFB,
            ofb: ModeOfOperationOFB,
            ctr: ModeOfOperationCTR
        },

        utils: {
            hex: convertHex,
            utf8: convertUtf8
        },

        padding: {
            pkcs7: {
                pad: pkcs7pad,
                strip: pkcs7strip
            }
        },

        _arrayTest: {
            coerceArray: coerceArray,
            createArray: createArray,
            copyArray: copyArray,
        }
    };


    // node.js
    if (true) {
        module.exports = aesjs

    // RequireJS/AMD
    // http://www.requirejs.org/docs/api.html
    // https://github.com/amdjs/amdjs-api/wiki/AMD
    } else {}


})(this);


/***/ }),

/***/ 7813:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  Any: () => (/* binding */ Any),
  BaseBlock: () => (/* binding */ BaseBlock),
  BitString: () => (/* binding */ BitString),
  BmpString: () => (/* binding */ BmpString),
  Boolean: () => (/* binding */ Boolean),
  CharacterString: () => (/* binding */ CharacterString),
  Choice: () => (/* binding */ Choice),
  Constructed: () => (/* binding */ Constructed),
  DATE: () => (/* binding */ DATE),
  DateTime: () => (/* binding */ DateTime),
  Duration: () => (/* binding */ Duration),
  EndOfContent: () => (/* binding */ EndOfContent),
  Enumerated: () => (/* binding */ Enumerated),
  GeneralString: () => (/* binding */ GeneralString),
  GeneralizedTime: () => (/* binding */ GeneralizedTime),
  GraphicString: () => (/* binding */ GraphicString),
  HexBlock: () => (/* binding */ HexBlock),
  IA5String: () => (/* binding */ IA5String),
  Integer: () => (/* binding */ Integer),
  Null: () => (/* binding */ Null),
  NumericString: () => (/* binding */ NumericString),
  ObjectIdentifier: () => (/* binding */ ObjectIdentifier),
  OctetString: () => (/* binding */ OctetString),
  Primitive: () => (/* binding */ Primitive),
  PrintableString: () => (/* binding */ PrintableString),
  RawData: () => (/* binding */ RawData),
  RelativeObjectIdentifier: () => (/* binding */ RelativeObjectIdentifier),
  Repeated: () => (/* binding */ Repeated),
  Sequence: () => (/* binding */ Sequence),
  Set: () => (/* binding */ Set),
  TIME: () => (/* binding */ TIME),
  TeletexString: () => (/* binding */ TeletexString),
  TimeOfDay: () => (/* binding */ TimeOfDay),
  UTCTime: () => (/* binding */ UTCTime),
  UniversalString: () => (/* binding */ UniversalString),
  Utf8String: () => (/* binding */ Utf8String),
  ValueBlock: () => (/* binding */ ValueBlock),
  VideotexString: () => (/* binding */ VideotexString),
  VisibleString: () => (/* binding */ VisibleString),
  compareSchema: () => (/* binding */ compareSchema),
  fromBER: () => (/* binding */ fromBER),
  fromJSON: () => (/* binding */ fromJSON),
  verifySchema: () => (/* binding */ verifySchema)
});

;// ./node_modules/pvutils/build/utils.es.js
/*!
 Copyright (c) Peculiar Ventures, LLC
*/

function getUTCDate(date) {
    return new Date(date.getTime() + (date.getTimezoneOffset() * 60000));
}
function getParametersValue(parameters, name, defaultValue) {
    var _a;
    if ((parameters instanceof Object) === false) {
        return defaultValue;
    }
    return (_a = parameters[name]) !== null && _a !== void 0 ? _a : defaultValue;
}
function bufferToHexCodes(inputBuffer, inputOffset = 0, inputLength = (inputBuffer.byteLength - inputOffset), insertSpace = false) {
    let result = "";
    for (const item of (new Uint8Array(inputBuffer, inputOffset, inputLength))) {
        const str = item.toString(16).toUpperCase();
        if (str.length === 1) {
            result += "0";
        }
        result += str;
        if (insertSpace) {
            result += " ";
        }
    }
    return result.trim();
}
function checkBufferParams(baseBlock, inputBuffer, inputOffset, inputLength) {
    if (!(inputBuffer instanceof ArrayBuffer)) {
        baseBlock.error = "Wrong parameter: inputBuffer must be \"ArrayBuffer\"";
        return false;
    }
    if (!inputBuffer.byteLength) {
        baseBlock.error = "Wrong parameter: inputBuffer has zero length";
        return false;
    }
    if (inputOffset < 0) {
        baseBlock.error = "Wrong parameter: inputOffset less than zero";
        return false;
    }
    if (inputLength < 0) {
        baseBlock.error = "Wrong parameter: inputLength less than zero";
        return false;
    }
    if ((inputBuffer.byteLength - inputOffset - inputLength) < 0) {
        baseBlock.error = "End of input reached before message was fully decoded (inconsistent offset and length values)";
        return false;
    }
    return true;
}
function utilFromBase(inputBuffer, inputBase) {
    let result = 0;
    if (inputBuffer.length === 1) {
        return inputBuffer[0];
    }
    for (let i = (inputBuffer.length - 1); i >= 0; i--) {
        result += inputBuffer[(inputBuffer.length - 1) - i] * Math.pow(2, inputBase * i);
    }
    return result;
}
function utilToBase(value, base, reserved = (-1)) {
    const internalReserved = reserved;
    let internalValue = value;
    let result = 0;
    let biggest = Math.pow(2, base);
    for (let i = 1; i < 8; i++) {
        if (value < biggest) {
            let retBuf;
            if (internalReserved < 0) {
                retBuf = new ArrayBuffer(i);
                result = i;
            }
            else {
                if (internalReserved < i) {
                    return (new ArrayBuffer(0));
                }
                retBuf = new ArrayBuffer(internalReserved);
                result = internalReserved;
            }
            const retView = new Uint8Array(retBuf);
            for (let j = (i - 1); j >= 0; j--) {
                const basis = Math.pow(2, j * base);
                retView[result - j - 1] = Math.floor(internalValue / basis);
                internalValue -= (retView[result - j - 1]) * basis;
            }
            return retBuf;
        }
        biggest *= Math.pow(2, base);
    }
    return new ArrayBuffer(0);
}
function utilConcatBuf(...buffers) {
    let outputLength = 0;
    let prevLength = 0;
    for (const buffer of buffers) {
        outputLength += buffer.byteLength;
    }
    const retBuf = new ArrayBuffer(outputLength);
    const retView = new Uint8Array(retBuf);
    for (const buffer of buffers) {
        retView.set(new Uint8Array(buffer), prevLength);
        prevLength += buffer.byteLength;
    }
    return retBuf;
}
function utilConcatView(...views) {
    let outputLength = 0;
    let prevLength = 0;
    for (const view of views) {
        outputLength += view.length;
    }
    const retBuf = new ArrayBuffer(outputLength);
    const retView = new Uint8Array(retBuf);
    for (const view of views) {
        retView.set(view, prevLength);
        prevLength += view.length;
    }
    return retView;
}
function utilDecodeTC() {
    const buf = new Uint8Array(this.valueHex);
    if (this.valueHex.byteLength >= 2) {
        const condition1 = (buf[0] === 0xFF) && (buf[1] & 0x80);
        const condition2 = (buf[0] === 0x00) && ((buf[1] & 0x80) === 0x00);
        if (condition1 || condition2) {
            this.warnings.push("Needlessly long format");
        }
    }
    const bigIntBuffer = new ArrayBuffer(this.valueHex.byteLength);
    const bigIntView = new Uint8Array(bigIntBuffer);
    for (let i = 0; i < this.valueHex.byteLength; i++) {
        bigIntView[i] = 0;
    }
    bigIntView[0] = (buf[0] & 0x80);
    const bigInt = utilFromBase(bigIntView, 8);
    const smallIntBuffer = new ArrayBuffer(this.valueHex.byteLength);
    const smallIntView = new Uint8Array(smallIntBuffer);
    for (let j = 0; j < this.valueHex.byteLength; j++) {
        smallIntView[j] = buf[j];
    }
    smallIntView[0] &= 0x7F;
    const smallInt = utilFromBase(smallIntView, 8);
    return (smallInt - bigInt);
}
function utilEncodeTC(value) {
    const modValue = (value < 0) ? (value * (-1)) : value;
    let bigInt = 128;
    for (let i = 1; i < 8; i++) {
        if (modValue <= bigInt) {
            if (value < 0) {
                const smallInt = bigInt - modValue;
                const retBuf = utilToBase(smallInt, 8, i);
                const retView = new Uint8Array(retBuf);
                retView[0] |= 0x80;
                return retBuf;
            }
            let retBuf = utilToBase(modValue, 8, i);
            let retView = new Uint8Array(retBuf);
            if (retView[0] & 0x80) {
                const tempBuf = retBuf.slice(0);
                const tempView = new Uint8Array(tempBuf);
                retBuf = new ArrayBuffer(retBuf.byteLength + 1);
                retView = new Uint8Array(retBuf);
                for (let k = 0; k < tempBuf.byteLength; k++) {
                    retView[k + 1] = tempView[k];
                }
                retView[0] = 0x00;
            }
            return retBuf;
        }
        bigInt *= Math.pow(2, 8);
    }
    return (new ArrayBuffer(0));
}
function isEqualBuffer(inputBuffer1, inputBuffer2) {
    if (inputBuffer1.byteLength !== inputBuffer2.byteLength) {
        return false;
    }
    const view1 = new Uint8Array(inputBuffer1);
    const view2 = new Uint8Array(inputBuffer2);
    for (let i = 0; i < view1.length; i++) {
        if (view1[i] !== view2[i]) {
            return false;
        }
    }
    return true;
}
function padNumber(inputNumber, fullLength) {
    const str = inputNumber.toString(10);
    if (fullLength < str.length) {
        return "";
    }
    const dif = fullLength - str.length;
    const padding = new Array(dif);
    for (let i = 0; i < dif; i++) {
        padding[i] = "0";
    }
    const paddingString = padding.join("");
    return paddingString.concat(str);
}
const base64Template = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
const base64UrlTemplate = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=";
function toBase64(input, useUrlTemplate = false, skipPadding = false, skipLeadingZeros = false) {
    let i = 0;
    let flag1 = 0;
    let flag2 = 0;
    let output = "";
    const template = (useUrlTemplate) ? base64UrlTemplate : base64Template;
    if (skipLeadingZeros) {
        let nonZeroPosition = 0;
        for (let i = 0; i < input.length; i++) {
            if (input.charCodeAt(i) !== 0) {
                nonZeroPosition = i;
                break;
            }
        }
        input = input.slice(nonZeroPosition);
    }
    while (i < input.length) {
        const chr1 = input.charCodeAt(i++);
        if (i >= input.length) {
            flag1 = 1;
        }
        const chr2 = input.charCodeAt(i++);
        if (i >= input.length) {
            flag2 = 1;
        }
        const chr3 = input.charCodeAt(i++);
        const enc1 = chr1 >> 2;
        const enc2 = ((chr1 & 0x03) << 4) | (chr2 >> 4);
        let enc3 = ((chr2 & 0x0F) << 2) | (chr3 >> 6);
        let enc4 = chr3 & 0x3F;
        if (flag1 === 1) {
            enc3 = enc4 = 64;
        }
        else {
            if (flag2 === 1) {
                enc4 = 64;
            }
        }
        if (skipPadding) {
            if (enc3 === 64) {
                output += `${template.charAt(enc1)}${template.charAt(enc2)}`;
            }
            else {
                if (enc4 === 64) {
                    output += `${template.charAt(enc1)}${template.charAt(enc2)}${template.charAt(enc3)}`;
                }
                else {
                    output += `${template.charAt(enc1)}${template.charAt(enc2)}${template.charAt(enc3)}${template.charAt(enc4)}`;
                }
            }
        }
        else {
            output += `${template.charAt(enc1)}${template.charAt(enc2)}${template.charAt(enc3)}${template.charAt(enc4)}`;
        }
    }
    return output;
}
function fromBase64(input, useUrlTemplate = false, cutTailZeros = false) {
    const template = (useUrlTemplate) ? base64UrlTemplate : base64Template;
    function indexOf(toSearch) {
        for (let i = 0; i < 64; i++) {
            if (template.charAt(i) === toSearch)
                return i;
        }
        return 64;
    }
    function test(incoming) {
        return ((incoming === 64) ? 0x00 : incoming);
    }
    let i = 0;
    let output = "";
    while (i < input.length) {
        const enc1 = indexOf(input.charAt(i++));
        const enc2 = (i >= input.length) ? 0x00 : indexOf(input.charAt(i++));
        const enc3 = (i >= input.length) ? 0x00 : indexOf(input.charAt(i++));
        const enc4 = (i >= input.length) ? 0x00 : indexOf(input.charAt(i++));
        const chr1 = (test(enc1) << 2) | (test(enc2) >> 4);
        const chr2 = ((test(enc2) & 0x0F) << 4) | (test(enc3) >> 2);
        const chr3 = ((test(enc3) & 0x03) << 6) | test(enc4);
        output += String.fromCharCode(chr1);
        if (enc3 !== 64) {
            output += String.fromCharCode(chr2);
        }
        if (enc4 !== 64) {
            output += String.fromCharCode(chr3);
        }
    }
    if (cutTailZeros) {
        const outputLength = output.length;
        let nonZeroStart = (-1);
        for (let i = (outputLength - 1); i >= 0; i--) {
            if (output.charCodeAt(i) !== 0) {
                nonZeroStart = i;
                break;
            }
        }
        if (nonZeroStart !== (-1)) {
            output = output.slice(0, nonZeroStart + 1);
        }
        else {
            output = "";
        }
    }
    return output;
}
function arrayBufferToString(buffer) {
    let resultString = "";
    const view = new Uint8Array(buffer);
    for (const element of view) {
        resultString += String.fromCharCode(element);
    }
    return resultString;
}
function stringToArrayBuffer(str) {
    const stringLength = str.length;
    const resultBuffer = new ArrayBuffer(stringLength);
    const resultView = new Uint8Array(resultBuffer);
    for (let i = 0; i < stringLength; i++) {
        resultView[i] = str.charCodeAt(i);
    }
    return resultBuffer;
}
const log2 = Math.log(2);
function nearestPowerOf2(length) {
    const base = (Math.log(length) / log2);
    const floor = Math.floor(base);
    const round = Math.round(base);
    return ((floor === round) ? floor : round);
}
function clearProps(object, propsArray) {
    for (const prop of propsArray) {
        delete object[prop];
    }
}



;// ./node_modules/asn1js/src/asn1.js
/* eslint-disable indent */
/*
 * Copyright (c) 2016-2018, Peculiar Ventures
 * All rights reserved.
 *
 * Author 2016-2018, Yury Strozhevsky <www.strozhevsky.com>.
 *
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice,
 *    this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the copyright holder nor the names of its contributors
 *    may be used to endorse or promote products derived from this software without
 *    specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
 * OF SUCH DAMAGE.
 *
 */
//**************************************************************************************

//**************************************************************************************
//#region Other utility functions
//**************************************************************************************
function assertBigInt()
{
	if(typeof BigInt === "undefined")
	{
		throw new Error("BigInt is not defined. Your environment doesn't implement BigInt.");
	}
}

/**
 * Recursive function which checks and enables isIndefiniteForm flag for constructed blocks if any child has that flag enabled
 * @param {BaseBlock} baseBlock Base ASN.1 block
 * @returns Returns `true` if incoming block is `indefinite form`
 */
function prepareIndefiniteForm(baseBlock)
{
	if(baseBlock.idBlock.isConstructed)
	{
		for(let i = 0; i < baseBlock.valueBlock.value.length; i++)
		{
			if(prepareIndefiniteForm(baseBlock.valueBlock.value[i]))
			{
				baseBlock.lenBlock.isIndefiniteForm = true;
			}
		}
	}

	return !!baseBlock.lenBlock.isIndefiniteForm;
}

/**
 * Concatenates buffers from the list
 * @param {Array.<ArrayBuffer>} buffers List of buffers
 * @returns Concatenated buffer
 */
function concat(buffers) 
{
	//#region Initial variables
	let outputLength = 0;
	let prevLength = 0;
	//#endregion

	//#region Calculate output length
	for(let i = 0; i < buffers.length; i++)
	{
		const buffer = buffers[i];
		outputLength += buffer.byteLength;
	}
	//#endregion

	const retBuf = new ArrayBuffer(outputLength);
	const retView = new Uint8Array(retBuf);

	for(let i = 0; i < buffers.length; i++)
	{
		const buffer = buffers[i];
		retView.set(new Uint8Array(buffer), prevLength);
		prevLength += buffer.byteLength;
	}

	return retBuf;
}
//**************************************************************************************
//#endregion
//**************************************************************************************
//#region Declaration of global variables
//**************************************************************************************
const powers2 = [new Uint8Array([1])];
const digitsString = "0123456789";
const NAME = "name";
const VALUE_BEFORE_DECODE = "valueBeforeDecode";
const BLOCK_LENGTH = "blockLength";
const ERROR = "error";
const WARNINGS = "warnings";
const VALUE_HEX = "valueHex";
const IS_HEX_ONLY = "isHexOnly";
const ID_BLOCK = "idBlock";
const TAG_CLASS = "tagClass";
const TAG_NUMBER = "tagNumber";
const IS_CONSTRUCTED = "isConstructed";
const LEN_BLOCK = "lenBlock";
const IS_INDEFINITE_FORM = "isIndefiniteForm";
const LONG_FORM_USED = "longFormUsed";
const LENGTH = "length";
const OPTIONAL = "optional";
const PRIMITIVE_SCHEMA = "primitiveSchema";
const VALUE = "value";
const VALUE_DATE = "valueDate";
const FROM_BER = "fromBER";
const TO_BER = "toBER";
const LOCAL = "local";
const UNUSED_BITS = "unusedBits";
const VALUE_DEC = "valueDec";
const IS_FIRST_SID = "isFirstSid";
const DATA = "data";
const EMPTY_STRING = "";
const EMPTY_BUFFER = new ArrayBuffer(0);
//**************************************************************************************
//#endregion
//**************************************************************************************
//#region Declaration for "ViewWriter"
//**************************************************************************************
class ViewWriter
{
	constructor()
	{
		/**
		 * @type {Array.<ArrayBuffer>}
		 */
		this.items = [];
	}

	/**
	 * Writes buffer
	 * @param {ArrayBuffer} buf 
	 */
	write(buf)
	{
		this.items.push(buf);
	}

	/**
	 * Concatenates all buffers
	 * @returns {ArrayBuffer}
	 */
	final()
	{
		return concat(this.items);
	}
}
//**************************************************************************************
//#endregion
//**************************************************************************************
//#region Declaration for "LocalBaseBlock" class
//**************************************************************************************
/**
 * Class used as a base block for all remaining ASN.1 classes
 * @typedef LocalBaseBlock
 * @interface
 * @property {number} blockLength
 * @property {string} error
 * @property {Array.<string>} warnings
 * @property {ArrayBuffer} valueBeforeDecode
 */
class LocalBaseBlock
{
	//**********************************************************************************
	/**
	 * Constructor for "LocalBaseBlock" class
	 * @param {Object} [parameters={}]
	 * @property {ArrayBuffer} [valueBeforeDecode]
	 */
	constructor(parameters = {})
	{
		/**
		 * @type {number} blockLength
		 */
		this.blockLength = getParametersValue(parameters, BLOCK_LENGTH, 0);
		/**
		 * @type {string} error
		 */
		this.error = getParametersValue(parameters, ERROR, EMPTY_STRING);
		/**
		 * @type {Array.<string>} warnings
		 */
		this.warnings = getParametersValue(parameters, WARNINGS, []);
		//noinspection JSCheckFunctionSignatures
		/**
		 * @type {ArrayBuffer} valueBeforeDecode
		 */
		if(VALUE_BEFORE_DECODE in parameters)
			this.valueBeforeDecode = parameters.valueBeforeDecode.slice(0);
		else
			this.valueBeforeDecode = EMPTY_BUFFER;
	}
	//**********************************************************************************
	/**
	 * Aux function, need to get a block name. Need to have it here for inheritance
	 * @returns {string}
	 */
	static blockName()
	{
		return "baseBlock";
	}
	//**********************************************************************************
	/**
	 * Conversion for the block to JSON object
	 * @returns {{blockName: string, blockLength: number, error: string, warnings: Array.<string>, valueBeforeDecode: string}}
	 */
	toJSON()
	{
		return {
			blockName: this.constructor.blockName(),
			blockLength: this.blockLength,
			error: this.error,
			warnings: this.warnings,
			valueBeforeDecode: bufferToHexCodes(this.valueBeforeDecode, 0, this.valueBeforeDecode.byteLength)
		};
	}
	//**********************************************************************************
}
//**************************************************************************************
//#endregion
//**************************************************************************************
//#region Description for "HexBlock" class
//**************************************************************************************
/**
 * Class used as a base block for all remaining ASN.1 classes
 * @extends LocalBaseBlock
 * @typedef HexBlock
 * @property {number} blockLength
 * @property {string} error
 * @property {Array.<string>} warnings
 * @property {ArrayBuffer} valueBeforeDecode
 * @property {boolean} isHexOnly
 * @property {ArrayBuffer} valueHex
 */
//noinspection JSUnusedLocalSymbols
const HexBlock = BaseClass => class LocalHexBlockMixin extends BaseClass
{
	//**********************************************************************************
	//noinspection JSUnusedGlobalSymbols
	/**
	 * Constructor for "HexBlock" class
	 * @param {Object} [parameters={}]
	 * @property {ArrayBuffer} [valueHex]
	 */
	constructor(parameters = {})
	{
		super(parameters);

		/**
		 * @type {boolean}
		 */
		this.isHexOnly = getParametersValue(parameters, IS_HEX_ONLY, false);
		/**
		 * @type {ArrayBuffer}
		 */
		if(VALUE_HEX in parameters)
			this.valueHex = parameters.valueHex.slice(0);
		else
			this.valueHex = EMPTY_BUFFER;
	}
	//**********************************************************************************
	/**
	 * Aux function, need to get a block name. Need to have it here for inheritance
	 * @returns {string}
	 */
	static blockName()
	{
		return "hexBlock";
	}
	//**********************************************************************************
	/**
	 * Base function for converting block from BER encoded array of bytes
	 * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array
	 * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started
	 * @param {!number} inputLength Maximum length of array of bytes which can be using in this function
	 * @returns {number} Offset after least decoded byte
	 */
	fromBER(inputBuffer, inputOffset, inputLength)
	{
		//#region Basic check for parameters
		//noinspection JSCheckFunctionSignatures
		if(checkBufferParams(this, inputBuffer, inputOffset, inputLength) === false)
			return (-1);
		//#endregion

		//#region Getting Uint8Array from ArrayBuffer
		const intBuffer = new Uint8Array(inputBuffer, inputOffset, inputLength);
		//#endregion

		//#region Initial checks
		if(intBuffer.length === 0)
		{
			this.warnings.push("Zero buffer length");
			return inputOffset;
		}
		//#endregion

		//#region Copy input buffer to internal buffer
		this.valueHex = inputBuffer.slice(inputOffset, inputOffset + inputLength);
		//#endregion

		this.blockLength = inputLength;

		return (inputOffset + inputLength);
	}
	//**********************************************************************************
	/**
	 * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)
	 * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes
	 * @returns {ArrayBuffer}
	 */
	toBER(sizeOnly = false)
	{
		if(this.isHexOnly !== true)
		{
			this.error = "Flag \"isHexOnly\" is not set, abort";
			return EMPTY_BUFFER;
		}

		if(sizeOnly === true)
			return new ArrayBuffer(this.valueHex.byteLength);

		//noinspection JSCheckFunctionSignatures
		return this.valueHex.slice(0);
	}
	//**********************************************************************************
	/**
	 * Conversion for the block to JSON object
	 * @returns {Object}
	 */
	toJSON()
	{
		let object = {};

		//#region Seems at the moment (Sep 2016) there is no way how to check method is supported in "super" object
		try
		{
			object = super.toJSON();
		}
		catch(ex) { }
		//#endregion

		object.blockName = this.constructor.blockName();
		object.isHexOnly = this.isHexOnly;
		object.valueHex = bufferToHexCodes(this.valueHex, 0, this.valueHex.byteLength);

		return object;
	}
	//**********************************************************************************
};
//**************************************************************************************
//#endregion
//**************************************************************************************
//#region Declaration of identification block class
//**************************************************************************************
class LocalIdentificationBlock extends HexBlock(LocalBaseBlock)
{
	//**********************************************************************************
	/**
	 * Constructor for "LocalBaseBlock" class
	 * @param {Object} [parameters={}]
	 * @property {Object} [idBlock]
	 */
	constructor(parameters = {})
	{
		super();

		if(ID_BLOCK in parameters)
		{
			//#region Properties from hexBlock class
			this.isHexOnly = getParametersValue(parameters.idBlock, IS_HEX_ONLY, false);
			this.valueHex = getParametersValue(parameters.idBlock, VALUE_HEX, EMPTY_BUFFER);
			//#endregion

			this.tagClass = getParametersValue(parameters.idBlock, TAG_CLASS, (-1));
			this.tagNumber = getParametersValue(parameters.idBlock, TAG_NUMBER, (-1));
			this.isConstructed = getParametersValue(parameters.idBlock, IS_CONSTRUCTED, false);
		}
		else
		{
			this.tagClass = (-1);
			this.tagNumber = (-1);
			this.isConstructed = false;
		}
	}
	//**********************************************************************************
	/**
	 * Aux function, need to get a block name. Need to have it here for inheritance
	 * @returns {string}
	 */
	static blockName()
	{
		return "identificationBlock";
	}
	//**********************************************************************************
	/**
	 * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)
	 * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes
	 * @returns {ArrayBuffer}
	 */
	toBER(sizeOnly = false)
	{
		//#region Initial variables
		let firstOctet = 0;
		let retBuf;
		let retView;
		//#endregion

		switch(this.tagClass)
		{
			case 1:
				firstOctet |= 0x00; // UNIVERSAL
				break;
			case 2:
				firstOctet |= 0x40; // APPLICATION
				break;
			case 3:
				firstOctet |= 0x80; // CONTEXT-SPECIFIC
				break;
			case 4:
				firstOctet |= 0xC0; // PRIVATE
				break;
			default:
				this.error = "Unknown tag class";
				return (EMPTY_BUFFER);
		}

		if(this.isConstructed)
			firstOctet |= 0x20;

		if((this.tagNumber < 31) && (!this.isHexOnly))
		{
			retBuf = new ArrayBuffer(1);
			retView = new Uint8Array(retBuf);

			if(!sizeOnly)
			{
				let number = this.tagNumber;
				number &= 0x1F;
				firstOctet |= number;

				retView[0] = firstOctet;
			}

			return retBuf;
		}

		if(this.isHexOnly === false)
		{
			const encodedBuf = utilToBase(this.tagNumber, 7);
			const encodedView = new Uint8Array(encodedBuf);
			const size = encodedBuf.byteLength;

			retBuf = new ArrayBuffer(size + 1);
			retView = new Uint8Array(retBuf);
			retView[0] = (firstOctet | 0x1F);

			if(!sizeOnly)
			{
				for(let i = 0; i < (size - 1); i++)
					retView[i + 1] = encodedView[i] | 0x80;

				retView[size] = encodedView[size - 1];
			}

			return retBuf;
		}

		retBuf = new ArrayBuffer(this.valueHex.byteLength + 1);
		retView = new Uint8Array(retBuf);

		retView[0] = (firstOctet | 0x1F);

		if(sizeOnly === false)
		{
			const curView = new Uint8Array(this.valueHex);

			for(let i = 0; i < (curView.length - 1); i++)
				retView[i + 1] = curView[i] | 0x80;

			retView[this.valueHex.byteLength] = curView[curView.length - 1];
		}

		return retBuf;
	}
	//**********************************************************************************
	/**
	 * Base function for converting block from BER encoded array of bytes
	 * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array
	 * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started
	 * @param {!number} inputLength Maximum length of array of bytes which can be using in this function
	 * @returns {number}
	 */
	fromBER(inputBuffer, inputOffset, inputLength)
	{
		//#region Basic check for parameters
		//noinspection JSCheckFunctionSignatures
		if(checkBufferParams(this, inputBuffer, inputOffset, inputLength) === false)
			return (-1);
		//#endregion

		//#region Getting Uint8Array from ArrayBuffer
		const intBuffer = new Uint8Array(inputBuffer, inputOffset, inputLength);
		//#endregion

		//#region Initial checks
		if(intBuffer.length === 0)
		{
			this.error = "Zero buffer length";
			return (-1);
		}
		//#endregion

		//#region Find tag class
		const tagClassMask = intBuffer[0] & 0xC0;

		switch(tagClassMask)
		{
			case 0x00:
				this.tagClass = (1); // UNIVERSAL
				break;
			case 0x40:
				this.tagClass = (2); // APPLICATION
				break;
			case 0x80:
				this.tagClass = (3); // CONTEXT-SPECIFIC
				break;
			case 0xC0:
				this.tagClass = (4); // PRIVATE
				break;
			default:
				this.error = "Unknown tag class";
				return (-1);
		}
		//#endregion

		//#region Find it's constructed or not
		this.isConstructed = (intBuffer[0] & 0x20) === 0x20;
		//#endregion

		//#region Find tag number
		this.isHexOnly = false;

		const tagNumberMask = intBuffer[0] & 0x1F;

		//#region Simple case (tag number < 31)
		if(tagNumberMask !== 0x1F)
		{
			this.tagNumber = (tagNumberMask);
			this.blockLength = 1;
		}
		//#endregion
		//#region Tag number bigger or equal to 31
		else
		{
			let count = 1;

			this.valueHex = new ArrayBuffer(255);
			let tagNumberBufferMaxLength = 255;
			let intTagNumberBuffer = new Uint8Array(this.valueHex);

			//noinspection JSBitwiseOperatorUsage
			while(intBuffer[count] & 0x80)
			{
				intTagNumberBuffer[count - 1] = intBuffer[count] & 0x7F;
				count++;

				if(count >= intBuffer.length)
				{
					this.error = "End of input reached before message was fully decoded";
					return (-1);
				}

				//#region In case if tag number length is greater than 255 bytes (rare but possible case)
				if(count === tagNumberBufferMaxLength)
				{
					tagNumberBufferMaxLength += 255;

					const tempBuffer = new ArrayBuffer(tagNumberBufferMaxLength);
					const tempBufferView = new Uint8Array(tempBuffer);

					for(let i = 0; i < intTagNumberBuffer.length; i++)
						tempBufferView[i] = intTagNumberBuffer[i];

					this.valueHex = new ArrayBuffer(tagNumberBufferMaxLength);
					intTagNumberBuffer = new Uint8Array(this.valueHex);
				}
				//#endregion
			}

			this.blockLength = (count + 1);
			intTagNumberBuffer[count - 1] = intBuffer[count] & 0x7F; // Write last byte to buffer

			//#region Cut buffer
			const tempBuffer = new ArrayBuffer(count);
			const tempBufferView = new Uint8Array(tempBuffer);

			for(let i = 0; i < count; i++)
				tempBufferView[i] = intTagNumberBuffer[i];

			this.valueHex = new ArrayBuffer(count);
			intTagNumberBuffer = new Uint8Array(this.valueHex);
			intTagNumberBuffer.set(tempBufferView);
			//#endregion

			//#region Try to convert long tag number to short form
			if(this.blockLength <= 9)
				this.tagNumber = utilFromBase(intTagNumberBuffer, 7);
			else
			{
				this.isHexOnly = true;
				this.warnings.push("Tag too long, represented as hex-coded");
			}
			//#endregion
		}
		//#endregion
		//#endregion

		//#region Check if constructed encoding was using for primitive type
		if(((this.tagClass === 1)) &&
			(this.isConstructed))
		{
			switch(this.tagNumber)
			{
				case 1:  // Boolean
				case 2:  // REAL
				case 5:  // Null
				case 6:  // OBJECT IDENTIFIER
				case 9:  // REAL
				case 13: // RELATIVE OBJECT IDENTIFIER
				case 14: // Time
				case 23:
				case 24:
				case 31:
				case 32:
				case 33:
				case 34:
					this.error = "Constructed encoding used for primitive type";
					return (-1);
				default:
			}
		}
		//#endregion

		return (inputOffset + this.blockLength); // Return current offset in input buffer
	}
	//**********************************************************************************
	/**
	 * Conversion for the block to JSON object
	 * @returns {{blockName: string,
	 *  tagClass: number,
	 *  tagNumber: number,
	 *  isConstructed: boolean,
	 *  isHexOnly: boolean,
	 *  valueHex: ArrayBuffer,
	 *  blockLength: number,
	 *  error: string, warnings: Array.<string>,
	 *  valueBeforeDecode: string}}
	 */
	toJSON()
	{
		let object = {};

		//#region Seems at the moment (Sep 2016) there is no way how to check method is supported in "super" object
		try
		{
			object = super.toJSON();
		}
		catch(ex) { }
		//#endregion

		object.blockName = this.constructor.blockName();
		object.tagClass = this.tagClass;
		object.tagNumber = this.tagNumber;
		object.isConstructed = this.isConstructed;

		return object;
	}
	//**********************************************************************************
}
//**************************************************************************************
//#endregion
//**************************************************************************************
//#region Declaration of length block class
//**************************************************************************************
class LocalLengthBlock extends LocalBaseBlock
{
	//**********************************************************************************
	/**
	 * Constructor for "LocalLengthBlock" class
	 * @param {Object} [parameters={}]
	 * @property {Object} [lenBlock]
	 */
	constructor(parameters = {})
	{
		super();

		if(LEN_BLOCK in parameters)
		{
			this.isIndefiniteForm = getParametersValue(parameters.lenBlock, IS_INDEFINITE_FORM, false);
			this.longFormUsed = getParametersValue(parameters.lenBlock, LONG_FORM_USED, false);
			this.length = getParametersValue(parameters.lenBlock, LENGTH, 0);
		}
		else
		{
			this.isIndefiniteForm = false;
			this.longFormUsed = false;
			this.length = 0;
		}
	}
	//**********************************************************************************
	/**
	 * Aux function, need to get a block name. Need to have it here for inheritance
	 * @returns {string}
	 */
	static blockName()
	{
		return "lengthBlock";
	}
	//**********************************************************************************
	/**
	 * Base function for converting block from BER encoded array of bytes
	 * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array
	 * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started
	 * @param {!number} inputLength Maximum length of array of bytes which can be using in this function
	 * @returns {number}
	 */
	fromBER(inputBuffer, inputOffset, inputLength)
	{
		//#region Basic check for parameters
		//noinspection JSCheckFunctionSignatures
		if(checkBufferParams(this, inputBuffer, inputOffset, inputLength) === false)
			return (-1);
		//#endregion

		//#region Getting Uint8Array from ArrayBuffer
		const intBuffer = new Uint8Array(inputBuffer, inputOffset, inputLength);
		//#endregion

		//#region Initial checks
		if(intBuffer.length === 0)
		{
			this.error = "Zero buffer length";
			return (-1);
		}

		if(intBuffer[0] === 0xFF)
		{
			this.error = "Length block 0xFF is reserved by standard";
			return (-1);
		}
		//#endregion

		//#region Check for length form type
		this.isIndefiniteForm = intBuffer[0] === 0x80;
		//#endregion

		//#region Stop working in case of indefinite length form
		if(this.isIndefiniteForm === true)
		{
			this.blockLength = 1;
			return (inputOffset + this.blockLength);
		}
		//#endregion

		//#region Check is long form of length encoding using
		this.longFormUsed = !!(intBuffer[0] & 0x80);
		//#endregion

		//#region Stop working in case of short form of length value
		if(this.longFormUsed === false)
		{
			this.length = (intBuffer[0]);
			this.blockLength = 1;
			return (inputOffset + this.blockLength);
		}
		//#endregion

		//#region Calculate length value in case of long form
		const count = intBuffer[0] & 0x7F;

		if(count > 8) // Too big length value
		{
			this.error = "Too big integer";
			return (-1);
		}

		if((count + 1) > intBuffer.length)
		{
			this.error = "End of input reached before message was fully decoded";
			return (-1);
		}

		const lengthBufferView = new Uint8Array(count);

		for(let i = 0; i < count; i++)
			lengthBufferView[i] = intBuffer[i + 1];

		if(lengthBufferView[count - 1] === 0x00)
			this.warnings.push("Needlessly long encoded length");

		this.length = utilFromBase(lengthBufferView, 8);

		if(this.longFormUsed && (this.length <= 127))
			this.warnings.push("Unnecessary usage of long length form");

		this.blockLength = count + 1;
		//#endregion

		return (inputOffset + this.blockLength); // Return current offset in input buffer
	}
	//**********************************************************************************
	/**
	 * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)
	 * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes
	 * @returns {ArrayBuffer}
	 */
	toBER(sizeOnly = false)
	{
		//#region Initial variables
		let retBuf;
		let retView;
		//#endregion

		if(this.length > 127)
			this.longFormUsed = true;

		if(this.isIndefiniteForm)
		{
			retBuf = new ArrayBuffer(1);

			if(sizeOnly === false)
			{
				retView = new Uint8Array(retBuf);
				retView[0] = 0x80;
			}

			return retBuf;
		}

		if(this.longFormUsed === true)
		{
			const encodedBuf = utilToBase(this.length, 8);

			if(encodedBuf.byteLength > 127)
			{
				this.error = "Too big length";
				return (EMPTY_BUFFER);
			}

			retBuf = new ArrayBuffer(encodedBuf.byteLength + 1);

			if(sizeOnly === true)
				return retBuf;

			const encodedView = new Uint8Array(encodedBuf);
			retView = new Uint8Array(retBuf);

			retView[0] = encodedBuf.byteLength | 0x80;

			for(let i = 0; i < encodedBuf.byteLength; i++)
				retView[i + 1] = encodedView[i];

			return retBuf;
		}

		retBuf = new ArrayBuffer(1);

		if(sizeOnly === false)
		{
			retView = new Uint8Array(retBuf);

			retView[0] = this.length;
		}

		return retBuf;
	}
	//**********************************************************************************
	/**
	 * Conversion for the block to JSON object
	 * @returns {{blockName, blockLength, error, warnings, valueBeforeDecode}|{blockName: string, blockLength: number, error: string, warnings: Array.<string>, valueBeforeDecode: string}}
	 */
	toJSON()
	{
		let object = {};

		//#region Seems at the moment (Sep 2016) there is no way how to check method is supported in "super" object
		try
		{
			object = super.toJSON();
		}
		catch(ex) { }
		//#endregion

		object.blockName = this.constructor.blockName();
		object.isIndefiniteForm = this.isIndefiniteForm;
		object.longFormUsed = this.longFormUsed;
		object.length = this.length;

		return object;
	}
	//**********************************************************************************
}
//**************************************************************************************
//#endregion
//**************************************************************************************
//#region Declaration of value block class
//**************************************************************************************
class ValueBlock extends LocalBaseBlock
{
	//**********************************************************************************
	/**
	 * Constructor for "ValueBlock" class
	 * @param {Object} [parameters={}]
	 */
	constructor(parameters = {})
	{
		super(parameters);
	}
	//**********************************************************************************
	/**
	 * Aux function, need to get a block name. Need to have it here for inheritance
	 * @returns {string}
	 */
	static blockName()
	{
		return "valueBlock";
	}
	//**********************************************************************************
	//noinspection JSUnusedLocalSymbols,JSUnusedLocalSymbols,JSUnusedLocalSymbols
	/**
	 * Base function for converting block from BER encoded array of bytes
	 * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array
	 * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started
	 * @param {!number} inputLength Maximum length of array of bytes which can be using in this function
	 * @returns {number}
	 */
	fromBER(inputBuffer, inputOffset, inputLength)
	{
		//#region Throw an exception for a function which needs to be specified in extended classes
		throw TypeError("User need to make a specific function in a class which extends \"ValueBlock\"");
		//#endregion
	}
	//**********************************************************************************
	//noinspection JSUnusedLocalSymbols
	/**
	 * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)
	 * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes
	 * @returns {ArrayBuffer}
	 */
	toBER(sizeOnly = false)
	{
		//#region Throw an exception for a function which needs to be specified in extended classes
		throw TypeError("User need to make a specific function in a class which extends \"ValueBlock\"");
		//#endregion
	}
	//**********************************************************************************
}
//**************************************************************************************
//#endregion
//**************************************************************************************
//#region Declaration of basic ASN.1 block class
//**************************************************************************************
class BaseBlock extends LocalBaseBlock
{
	//**********************************************************************************
	/**
	 * Constructor for "BaseBlock" class
	 * @param {Object} [parameters={}]
	 * @property {Object} [primitiveSchema]
	 * @property {string} [name]
	 * @property {boolean} [optional]
	 * @param valueBlockType Type of value block
	 */
	constructor(parameters = {}, valueBlockType = ValueBlock)
	{
		super(parameters);

		if(NAME in parameters)
			this.name = parameters.name;
		if(OPTIONAL in parameters)
			this.optional = parameters.optional;
		if(PRIMITIVE_SCHEMA in parameters)
			this.primitiveSchema = parameters.primitiveSchema;

		this.idBlock = new LocalIdentificationBlock(parameters);
		this.lenBlock = new LocalLengthBlock(parameters);
		this.valueBlock = new valueBlockType(parameters);
	}
	//**********************************************************************************
	/**
	 * Aux function, need to get a block name. Need to have it here for inheritance
	 * @returns {string}
	 */
	static blockName()
	{
		return "BaseBlock";
	}
	//**********************************************************************************
	/**
	 * Base function for converting block from BER encoded array of bytes
	 * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array
	 * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started
	 * @param {!number} inputLength Maximum length of array of bytes which can be using in this function
	 * @returns {number}
	 */
	fromBER(inputBuffer, inputOffset, inputLength)
	{
		const resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, (this.lenBlock.isIndefiniteForm === true) ? inputLength : this.lenBlock.length);
		if(resultOffset === (-1))
		{
			this.error = this.valueBlock.error;
			return resultOffset;
		}

		if(this.idBlock.error.length === 0)
			this.blockLength += this.idBlock.blockLength;

		if(this.lenBlock.error.length === 0)
			this.blockLength += this.lenBlock.blockLength;

		if(this.valueBlock.error.length === 0)
			this.blockLength += this.valueBlock.blockLength;

		return resultOffset;
	}
	//**********************************************************************************
	/**
	 * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)
	 * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes
	 * @returns {ArrayBuffer}
	 */
	toBER(sizeOnly = false, writer)
	{
		const _writer = writer || new ViewWriter();

		if(!writer)
		{
			prepareIndefiniteForm(this);
		}

		const idBlockBuf = this.idBlock.toBER(sizeOnly);

		_writer.write(idBlockBuf);

		if(this.lenBlock.isIndefiniteForm)
		{
			_writer.write(new Uint8Array([0x80]).buffer);

			this.valueBlock.toBER(sizeOnly, _writer);

			_writer.write(new ArrayBuffer(2));
		}
		else
		{
			const valueBlockSizeBuf = this.valueBlock.toBER(true);
			this.lenBlock.length = valueBlockSizeBuf.byteLength;
			const lenBlockBuf = this.lenBlock.toBER(sizeOnly);

			_writer.write(lenBlockBuf);

			const valueBlockBuf = sizeOnly
				? new ArrayBuffer(this.lenBlock.length)
				: this.valueBlock.toBER(sizeOnly);

			_writer.write(valueBlockBuf, _writer);
		}

		if(!writer)
		{
			return _writer.final();
		}
	}
	//**********************************************************************************
	/**
	 * Conversion for the block to JSON object
	 * @returns {{blockName, blockLength, error, warnings, valueBeforeDecode}|{blockName: string, blockLength: number, error: string, warnings: Array.<string>, valueBeforeDecode: string}}
	 */
	toJSON()
	{
		let object = {};

		//#region Seems at the moment (Sep 2016) there is no way how to check method is supported in "super" object
		try
		{
			object = super.toJSON();
		}
		catch(ex) { }
		//#endregion

		object.idBlock = this.idBlock.toJSON();
		object.lenBlock = this.lenBlock.toJSON();
		object.valueBlock = this.valueBlock.toJSON();

		if(NAME in this)
			object.name = this.name;
		if(OPTIONAL in this)
			object.optional = this.optional;
		if(PRIMITIVE_SCHEMA in this)
			object.primitiveSchema = this.primitiveSchema.toJSON();

		return object;
	}
	//**********************************************************************************
	toString()
	{
		return `${this.constructor.blockName()} : ${bufferToHexCodes(this.valueBlock.valueHex)}`;
	}
	//**********************************************************************************
}
//**************************************************************************************
//#endregion
//**************************************************************************************
//#region Declaration of basic block for all PRIMITIVE types
//**************************************************************************************
class LocalPrimitiveValueBlock extends ValueBlock
{
	//**********************************************************************************
	/**
	 * Constructor for "LocalPrimitiveValueBlock" class
	 * @param {Object} [parameters={}]
	 * @property {ArrayBuffer} [valueBeforeDecode]
	 */
	constructor(parameters = {})
	{
		super(parameters);

		//#region Variables from "hexBlock" class
		if(VALUE_HEX in parameters)
			this.valueHex = parameters.valueHex.slice(0);
		else
			this.valueHex = EMPTY_BUFFER;

		this.isHexOnly = getParametersValue(parameters, IS_HEX_ONLY, true);
		//#endregion
	}
	//**********************************************************************************
	/**
	 * Base function for converting block from BER encoded array of bytes
	 * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array
	 * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started
	 * @param {!number} inputLength Maximum length of array of bytes which can be using in this function
	 * @returns {number}
	 */
	fromBER(inputBuffer, inputOffset, inputLength)
	{
		//#region Basic check for parameters
		//noinspection JSCheckFunctionSignatures
		if(checkBufferParams(this, inputBuffer, inputOffset, inputLength) === false)
			return (-1);
		//#endregion

		//#region Getting Uint8Array from ArrayBuffer
		const intBuffer = new Uint8Array(inputBuffer, inputOffset, inputLength);
		//#endregion

		//#region Initial checks
		if(intBuffer.length === 0)
		{
			this.warnings.push("Zero buffer length");
			return inputOffset;
		}
		//#endregion

		//#region Copy input buffer into internal buffer
		this.valueHex = new ArrayBuffer(intBuffer.length);
		const valueHexView = new Uint8Array(this.valueHex);

		for(let i = 0; i < intBuffer.length; i++)
			valueHexView[i] = intBuffer[i];
		//#endregion

		this.blockLength = inputLength;

		return (inputOffset + inputLength);
	}
	//**********************************************************************************
	//noinspection JSUnusedLocalSymbols
	/**
	 * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)
	 * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes
	 * @returns {ArrayBuffer}
	 */
	toBER(sizeOnly = false)
	{
		return this.valueHex.slice(0);
	}
	//**********************************************************************************
	/**
	 * Aux function, need to get a block name. Need to have it here for inheritance
	 * @returns {string}
	 */
	static blockName()
	{
		return "PrimitiveValueBlock";
	}
	//**********************************************************************************
	/**
	 * Conversion for the block to JSON object
	 * @returns {{blockName, blockLength, error, warnings, valueBeforeDecode}|{blockName: string, blockLength: number, error: string, warnings: Array.<string>, valueBeforeDecode: string}}
	 */
	toJSON()
	{
		let object = {};

		//#region Seems at the moment (Sep 2016) there is no way how to check method is supported in "super" object
		try
		{
			object = super.toJSON();
		}
		catch(ex) { }
		//#endregion

		object.valueHex = bufferToHexCodes(this.valueHex, 0, this.valueHex.byteLength);
		object.isHexOnly = this.isHexOnly;

		return object;
	}
	//**********************************************************************************
}
//**************************************************************************************
class Primitive extends BaseBlock
{
	//**********************************************************************************
	/**
	 * Constructor for "Primitive" class
	 * @param {Object} [parameters={}]
	 * @property {ArrayBuffer} [valueHex]
	 */
	constructor(parameters = {})
	{
		super(parameters, LocalPrimitiveValueBlock);

		this.idBlock.isConstructed = false;
	}
	//**********************************************************************************
	/**
	 * Aux function, need to get a block name. Need to have it here for inheritance
	 * @returns {string}
	 */
	static blockName()
	{
		return "PRIMITIVE";
	}
	//**********************************************************************************
}
//**************************************************************************************
//#endregion
//**************************************************************************************
//#region Declaration of basic block for all CONSTRUCTED types
//**************************************************************************************
class LocalConstructedValueBlock extends ValueBlock
{
	//**********************************************************************************
	/**
	 * Constructor for "LocalConstructedValueBlock" class
	 * @param {Object} [parameters={}]
	 */
	constructor(parameters = {})
	{
		super(parameters);

		this.value = getParametersValue(parameters, VALUE, []);
		this.isIndefiniteForm = getParametersValue(parameters, IS_INDEFINITE_FORM, false);
	}
	//**********************************************************************************
	/**
	 * Base function for converting block from BER encoded array of bytes
	 * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array
	 * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started
	 * @param {!number} inputLength Maximum length of array of bytes which can be using in this function
	 * @returns {number}
	 */
	fromBER(inputBuffer, inputOffset, inputLength)
	{
		//#region Store initial offset and length
		const initialOffset = inputOffset;
		const initialLength = inputLength;
		//#endregion

		//#region Basic check for parameters
		//noinspection JSCheckFunctionSignatures
		if(checkBufferParams(this, inputBuffer, inputOffset, inputLength) === false)
			return (-1);
		//#endregion

		//#region Getting Uint8Array from ArrayBuffer
		const intBuffer = new Uint8Array(inputBuffer, inputOffset, inputLength);
		//#endregion

		//#region Initial checks
		if(intBuffer.length === 0)
		{
			this.warnings.push("Zero buffer length");
			return inputOffset;
		}
		//#endregion

		//#region Aux function
		function checkLen(indefiniteLength, length)
		{
			if(indefiniteLength === true)
				return 1;

			return length;
		}
		//#endregion

		let currentOffset = inputOffset;

		while(checkLen(this.isIndefiniteForm, inputLength) > 0)
		{
			const returnObject = LocalFromBER(inputBuffer, currentOffset, inputLength);
			if(returnObject.offset === (-1))
			{
				this.error = returnObject.result.error;
				this.warnings.concat(returnObject.result.warnings);
				return (-1);
			}

			currentOffset = returnObject.offset;

			this.blockLength += returnObject.result.blockLength;
			inputLength -= returnObject.result.blockLength;

			this.value.push(returnObject.result);

			if((this.isIndefiniteForm === true) && (returnObject.result.constructor.blockName() === EndOfContent.blockName()))
				break;
		}

		if(this.isIndefiniteForm === true)
		{
			if(this.value[this.value.length - 1].constructor.blockName() === EndOfContent.blockName())
				this.value.pop();
			else
				this.warnings.push("No EndOfContent block encoded");
		}

		//#region Copy "inputBuffer" to VALUE_BEFORE_DECODE
		this.valueBeforeDecode = inputBuffer.slice(initialOffset, initialOffset + initialLength);
		//#endregion

		return currentOffset;
	}
	//**********************************************************************************
	/**
	 * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)
	 * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes
	 * @returns {ArrayBuffer}
	 */
	toBER(sizeOnly = false, writer)
	{
		const _writer = writer || new ViewWriter();

		for(let i = 0; i < this.value.length; i++)
		{
			this.value[i].toBER(sizeOnly, _writer);
		}

		if(!writer)
		{
			return _writer.final();
		}
	}
	//**********************************************************************************
	/**
	 * Aux function, need to get a block name. Need to have it here for inheritance
	 * @returns {string}
	 */
	static blockName()
	{
		return "ConstructedValueBlock";
	}
	//**********************************************************************************
	/**
	 * Conversion for the block to JSON object
	 * @returns {{blockName, blockLength, error, warnings, valueBeforeDecode}|{blockName: string, blockLength: number, error: string, warnings: Array.<string>, valueBeforeDecode: string}}
	 */
	toJSON()
	{
		let object = {};

		//#region Seems at the moment (Sep 2016) there is no way how to check method is supported in "super" object
		try
		{
			object = super.toJSON();
		}
		catch(ex) { }
		//#endregion

		object.isIndefiniteForm = this.isIndefiniteForm;
		object.value = [];
		for(let i = 0; i < this.value.length; i++)
			object.value.push(this.value[i].toJSON());

		return object;
	}
	//**********************************************************************************
}
//**************************************************************************************
class Constructed extends BaseBlock
{
	//**********************************************************************************
	/**
	 * Constructor for "Constructed" class
	 * @param {Object} [parameters={}]
	 */
	constructor(parameters = {})
	{
		super(parameters, LocalConstructedValueBlock);

		this.idBlock.isConstructed = true;
	}
	//**********************************************************************************
	/**
	 * Aux function, need to get a block name. Need to have it here for inheritance
	 * @returns {string}
	 */
	static blockName()
	{
		return "CONSTRUCTED";
	}
	//**********************************************************************************
	/**
	 * Base function for converting block from BER encoded array of bytes
	 * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array
	 * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started
	 * @param {!number} inputLength Maximum length of array of bytes which can be using in this function
	 * @returns {number}
	 */
	fromBER(inputBuffer, inputOffset, inputLength)
	{
		this.valueBlock.isIndefiniteForm = this.lenBlock.isIndefiniteForm;

		const resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, (this.lenBlock.isIndefiniteForm === true) ? inputLength : this.lenBlock.length);
		if(resultOffset === (-1))
		{
			this.error = this.valueBlock.error;
			return resultOffset;
		}

		if(this.idBlock.error.length === 0)
			this.blockLength += this.idBlock.blockLength;

		if(this.lenBlock.error.length === 0)
			this.blockLength += this.lenBlock.blockLength;

		if(this.valueBlock.error.length === 0)
			this.blockLength += this.valueBlock.blockLength;

		return resultOffset;
	}
	//**********************************************************************************
	toString()
	{
		const values = [];
		for(const value of this.valueBlock.value)
		{
			values.push(value.toString().split("\n").map(o => `  ${o}`).join("\n"));
		}
		const blockName = this.idBlock.tagClass === 3
			? `[${this.idBlock.tagNumber}]`
			: this.constructor.blockName();
		return values.length
			? `${blockName} :\n${values.join("\n")}` // items
			: `${blockName} :`; // empty
	}
	//**********************************************************************************
}
//**************************************************************************************
//#endregion
//**************************************************************************************
//#region Declaration of ASN.1 EndOfContent type class
//**************************************************************************************
class LocalEndOfContentValueBlock extends ValueBlock
{
	//**********************************************************************************
	/**
	 * Constructor for "LocalEndOfContentValueBlock" class
	 * @param {Object} [parameters={}]
	 */
	constructor(parameters = {})
	{
		super(parameters);
	}
	//**********************************************************************************
	//noinspection JSUnusedLocalSymbols,JSUnusedLocalSymbols
	/**
	 * Base function for converting block from BER encoded array of bytes
	 * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array
	 * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started
	 * @param {!number} inputLength Maximum length of array of bytes which can be using in this function
	 * @returns {number}
	 */
	fromBER(inputBuffer, inputOffset, inputLength)
	{
		//#region There is no "value block" for EndOfContent type and we need to return the same offset
		return inputOffset;
		//#endregion
	}
	//**********************************************************************************
	//noinspection JSUnusedLocalSymbols
	/**
	 * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)
	 * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes
	 * @returns {ArrayBuffer}
	 */
	toBER(sizeOnly = false)
	{
		return EMPTY_BUFFER;
	}
	//**********************************************************************************
	/**
	 * Aux function, need to get a block name. Need to have it here for inheritance
	 * @returns {string}
	 */
	static blockName()
	{
		return "EndOfContentValueBlock";
	}
	//**********************************************************************************
}
//**************************************************************************************
class EndOfContent extends BaseBlock
{
	//**********************************************************************************
	constructor(parameters = {})
	{
		super(parameters, LocalEndOfContentValueBlock);

		this.idBlock.tagClass = 1; // UNIVERSAL
		this.idBlock.tagNumber = 0; // EndOfContent
	}
	//**********************************************************************************
	/**
	 * Aux function, need to get a block name. Need to have it here for inheritance
	 * @returns {string}
	 */
	static blockName()
	{
		return "EndOfContent";
	}
	//**********************************************************************************
}
//**************************************************************************************
//#endregion
//**************************************************************************************
//#region Declaration of ASN.1 Boolean type class
//**************************************************************************************
class LocalBooleanValueBlock extends ValueBlock
{
	//**********************************************************************************
	/**
	 * Constructor for "LocalBooleanValueBlock" class
	 * @param {Object} [parameters={}]
	 */
	constructor(parameters = {})
	{
		super(parameters);

		this.value = getParametersValue(parameters, VALUE, false);
		this.isHexOnly = getParametersValue(parameters, IS_HEX_ONLY, false);

		if(VALUE_HEX in parameters)
			this.valueHex = parameters.valueHex.slice(0);
		else
		{
			this.valueHex = new ArrayBuffer(1);
			if(this.value === true)
			{
				const view = new Uint8Array(this.valueHex);
				view[0] = 0xFF;
			}
		}
	}
	//**********************************************************************************
	/**
	 * Base function for converting block from BER encoded array of bytes
	 * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array
	 * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started
	 * @param {!number} inputLength Maximum length of array of bytes which can be using in this function
	 * @returns {number} Offset after least decoded byte
	 */
	fromBER(inputBuffer, inputOffset, inputLength)
	{
		//#region Basic check for parameters
		//noinspection JSCheckFunctionSignatures
		if(checkBufferParams(this, inputBuffer, inputOffset, inputLength) === false)
			return (-1);
		//#endregion

		//#region Getting Uint8Array from ArrayBuffer
		const intBuffer = new Uint8Array(inputBuffer, inputOffset, inputLength);
		//#endregion

		if(inputLength > 1)
			this.warnings.push("Boolean value encoded in more then 1 octet");

		this.isHexOnly = true;

		//#region Copy input buffer to internal array
		this.valueHex = new ArrayBuffer(intBuffer.length);
		const view = new Uint8Array(this.valueHex);

		for(let i = 0; i < intBuffer.length; i++)
			view[i] = intBuffer[i];
		//#endregion

		if(utilDecodeTC.call(this) !== 0)
			this.value = true;
		else
			this.value = false;

		this.blockLength = inputLength;

		return (inputOffset + inputLength);
	}
	//**********************************************************************************
	//noinspection JSUnusedLocalSymbols
	/**
	 * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)
	 * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes
	 * @returns {ArrayBuffer}
	 */
	toBER(sizeOnly = false)
	{
		return this.valueHex;
	}
	//**********************************************************************************
	/**
	 * Aux function, need to get a block name. Need to have it here for inheritance
	 * @returns {string}
	 */
	static blockName()
	{
		return "BooleanValueBlock";
	}
	//**********************************************************************************
	/**
	 * Conversion for the block to JSON object
	 * @returns {{blockName, blockLength, error, warnings, valueBeforeDecode}|{blockName: string, blockLength: number, error: string, warnings: Array.<string>, valueBeforeDecode: string}}
	 */
	toJSON()
	{
		let object = {};

		//#region Seems at the moment (Sep 2016) there is no way how to check method is supported in "super" object
		try
		{
			object = super.toJSON();
		}
		catch(ex) { }
		//#endregion

		object.value = this.value;
		object.isHexOnly = this.isHexOnly;
		object.valueHex = bufferToHexCodes(this.valueHex, 0, this.valueHex.byteLength);

		return object;
	}
	//**********************************************************************************
}
//**************************************************************************************
class Boolean extends BaseBlock
{
	//**********************************************************************************
	/**
	 * Constructor for "Boolean" class
	 * @param {Object} [parameters={}]
	 */
	constructor(parameters = {})
	{
		super(parameters, LocalBooleanValueBlock);

		this.idBlock.tagClass = 1; // UNIVERSAL
		this.idBlock.tagNumber = 1; // Boolean
	}
	//**********************************************************************************
	/**
	 * Aux function, need to get a block name. Need to have it here for inheritance
	 * @returns {string}
	 */
	static blockName()
	{
		return "BOOLEAN";
	}
	//**********************************************************************************
	toString()
	{
		return `${this.constructor.blockName()} : ${this.valueBlock.value}`;
	}
	//**********************************************************************************
}
//**************************************************************************************
//#endregion
//**************************************************************************************
//#region Declaration of ASN.1 Sequence and Set type classes
//**************************************************************************************
class Sequence extends Constructed
{
	//**********************************************************************************
	/**
	 * Constructor for "Sequence" class
	 * @param {Object} [parameters={}]
	 */
	constructor(parameters = {})
	{
		super(parameters);

		this.idBlock.tagClass = 1; // UNIVERSAL
		this.idBlock.tagNumber = 16; // Sequence
	}
	//**********************************************************************************
	/**
	 * Aux function, need to get a block name. Need to have it here for inheritance
	 * @returns {string}
	 */
	static blockName()
	{
		return "SEQUENCE";
	}
	//**********************************************************************************
}
//**************************************************************************************
class Set extends Constructed
{
	//**********************************************************************************
	/**
	 * Constructor for "Set" class
	 * @param {Object} [parameters={}]
	 */
	constructor(parameters = {})
	{
		super(parameters);

		this.idBlock.tagClass = 1; // UNIVERSAL
		this.idBlock.tagNumber = 17; // Set
	}
	//**********************************************************************************
	/**
	 * Aux function, need to get a block name. Need to have it here for inheritance
	 * @returns {string}
	 */
	static blockName()
	{
		return "SET";
	}
	//**********************************************************************************
}
//**************************************************************************************
//#endregion
//**************************************************************************************
//#region Declaration of ASN.1 Null type class
//**************************************************************************************
class Null extends BaseBlock
{
	//**********************************************************************************
	/**
	 * Constructor for "Null" class
	 * @param {Object} [parameters={}]
	 */
	constructor(parameters = {})
	{
		super(parameters, LocalBaseBlock); // We will not have a call to "Null value block" because of specified FROM_BER and TO_BER functions

		this.idBlock.tagClass = 1; // UNIVERSAL
		this.idBlock.tagNumber = 5; // Null
	}
	//**********************************************************************************
	/**
	 * Aux function, need to get a block name. Need to have it here for inheritance
	 * @returns {string}
	 */
	static blockName()
	{
		return "NULL";
	}
	//**********************************************************************************
	//noinspection JSUnusedLocalSymbols
	/**
	 * Base function for converting block from BER encoded array of bytes
	 * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array
	 * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started
	 * @param {!number} inputLength Maximum length of array of bytes which can be using in this function
	 * @returns {number} Offset after least decoded byte
	 */
	fromBER(inputBuffer, inputOffset, inputLength)
	{
		if(this.lenBlock.length > 0)
			this.warnings.push("Non-zero length of value block for Null type");

		if(this.idBlock.error.length === 0)
			this.blockLength += this.idBlock.blockLength;

		if(this.lenBlock.error.length === 0)
			this.blockLength += this.lenBlock.blockLength;

		this.blockLength += inputLength;

		if((inputOffset + inputLength) > inputBuffer.byteLength)
		{
			this.error = "End of input reached before message was fully decoded (inconsistent offset and length values)";
			return (-1);
		}

		return (inputOffset + inputLength);
	}
	//**********************************************************************************
	/**
	 * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)
	 * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes
	 * @returns {ArrayBuffer}
	 */
	toBER(sizeOnly = false, writer)
	{
		const retBuf = new ArrayBuffer(2);

		if(!sizeOnly)
		{
			const retView = new Uint8Array(retBuf);
			retView[0] = 0x05;
			retView[1] = 0x00;
		}

		if(writer)
		{
			writer.write(retBuf);
		}

		return retBuf;
	}
	//**********************************************************************************
	toString()
	{
		return `${this.constructor.blockName()}`;
	}
	//**********************************************************************************
}
//**************************************************************************************
//#endregion
//**************************************************************************************
//#region Declaration of ASN.1 OctetString type class
//**************************************************************************************
class LocalOctetStringValueBlock extends HexBlock(LocalConstructedValueBlock)
{
	//**********************************************************************************
	/**
	 * Constructor for "LocalOctetStringValueBlock" class
	 * @param {Object} [parameters={}]
	 * @property {ArrayBuffer} [valueHex]
	 */
	constructor(parameters = {})
	{
		super(parameters);

		this.isConstructed = getParametersValue(parameters, IS_CONSTRUCTED, false);
	}
	//**********************************************************************************
	/**
	 * Base function for converting block from BER encoded array of bytes
	 * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array
	 * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started
	 * @param {!number} inputLength Maximum length of array of bytes which can be using in this function
	 * @returns {number} Offset after least decoded byte
	 */
	fromBER(inputBuffer, inputOffset, inputLength)
	{
		let resultOffset = 0;

		if(this.isConstructed === true)
		{
			this.isHexOnly = false;

			resultOffset = LocalConstructedValueBlock.prototype.fromBER.call(this, inputBuffer, inputOffset, inputLength);
			if(resultOffset === (-1))
				return resultOffset;

			for(let i = 0; i < this.value.length; i++)
			{
				const currentBlockName = this.value[i].constructor.blockName();

				if(currentBlockName === EndOfContent.blockName())
				{
					if(this.isIndefiniteForm === true)
						break;
					else
					{
						this.error = "EndOfContent is unexpected, OCTET STRING may consists of OCTET STRINGs only";
						return (-1);
					}
				}

				if(currentBlockName !== OctetString.blockName())
				{
					this.error = "OCTET STRING may consists of OCTET STRINGs only";
					return (-1);
				}
			}
		}
		else
		{
			this.isHexOnly = true;

			resultOffset = super.fromBER(inputBuffer, inputOffset, inputLength);
			this.blockLength = inputLength;
		}

		return resultOffset;
	}
	//**********************************************************************************
	/**
	 * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)
	 * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes
	 * @returns {ArrayBuffer}
	 */
	toBER(sizeOnly = false, writer)
	{
		if(this.isConstructed === true)
			return LocalConstructedValueBlock.prototype.toBER.call(this, sizeOnly, writer);

		let retBuf = new ArrayBuffer(this.valueHex.byteLength);

		if(sizeOnly === true)
			return retBuf;

		if(this.valueHex.byteLength === 0)
			return retBuf;

		retBuf = this.valueHex.slice(0);

		return retBuf;
	}
	//**********************************************************************************
	/**
	 * Aux function, need to get a block name. Need to have it here for inheritance
	 * @returns {string}
	 */
	static blockName()
	{
		return "OctetStringValueBlock";
	}
	//**********************************************************************************
	toJSON()
	{
		let object = {};

		//#region Seems at the moment (Sep 2016) there is no way how to check method is supported in "super" object
		try
		{
			object = super.toJSON();
		}
		catch(ex) { }
		//#endregion

		object.isConstructed = this.isConstructed;
		object.isHexOnly = this.isHexOnly;
		object.valueHex = bufferToHexCodes(this.valueHex, 0, this.valueHex.byteLength);

		return object;
	}
	//**********************************************************************************
}
//**************************************************************************************
class OctetString extends BaseBlock
{
	//**********************************************************************************
	/**
	 * Constructor for "OctetString" class
	 * @param {Object} [parameters={}]
	 */
	constructor(parameters = {})
	{
		super(parameters, LocalOctetStringValueBlock);

		this.idBlock.tagClass = 1; // UNIVERSAL
		this.idBlock.tagNumber = 4; // OctetString
	}
	//**********************************************************************************
	/**
	 * Base function for converting block from BER encoded array of bytes
	 * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array
	 * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started
	 * @param {!number} inputLength Maximum length of array of bytes which can be using in this function
	 * @returns {number} Offset after least decoded byte
	 */
	fromBER(inputBuffer, inputOffset, inputLength)
	{
		this.valueBlock.isConstructed = this.idBlock.isConstructed;
		this.valueBlock.isIndefiniteForm = this.lenBlock.isIndefiniteForm;

		//#region Ability to encode empty OCTET STRING
		if(inputLength === 0)
		{
			if(this.idBlock.error.length === 0)
				this.blockLength += this.idBlock.blockLength;

			if(this.lenBlock.error.length === 0)
				this.blockLength += this.lenBlock.blockLength;

			return inputOffset;
		}
		//#endregion

		if(!this.valueBlock.isConstructed)
		{
			const buf = inputBuffer.slice(inputOffset, inputOffset + inputLength);
			try
			{
				const asn = fromBER(buf);
				if(asn.offset !== -1 && asn.offset === inputLength)
				{
					this.valueBlock.value = [asn.result];
				}
			} catch(e)
			{
				// nothing
			}
		}

		return super.fromBER(inputBuffer, inputOffset, inputLength);
	}
	//**********************************************************************************
	/**
	 * Aux function, need to get a block name. Need to have it here for inheritance
	 * @returns {string}
	 */
	static blockName()
	{
		return "OCTET STRING";
	}
	//**********************************************************************************
	//noinspection JSUnusedGlobalSymbols
	/**
	 * Checking that two OCTETSTRINGs are equal
	 * @param {OctetString} octetString
	 */
	isEqual(octetString)
	{
		//#region Check input type
		if((octetString instanceof OctetString) === false)
			return false;
		//#endregion

		//#region Compare two JSON strings
		if(JSON.stringify(this) !== JSON.stringify(octetString))
			return false;
		//#endregion

		return true;
	}
	//**********************************************************************************
	toString()
	{
		if(this.valueBlock.isConstructed || (this.valueBlock.value && this.valueBlock.value.length))
		{
			return Constructed.prototype.toString.call(this);
		} else
		{
			return `${this.constructor.blockName()} : ${bufferToHexCodes(this.valueBlock.valueHex)}`;
		}
	}
	//**********************************************************************************
}
//**************************************************************************************
//#endregion
//**************************************************************************************
//#region Declaration of ASN.1 BitString type class
//**************************************************************************************
class LocalBitStringValueBlock extends HexBlock(LocalConstructedValueBlock)
{
	//**********************************************************************************
	/**
	 * Constructor for "LocalBitStringValueBlock" class
	 * @param {Object} [parameters={}]
	 * @property {ArrayBuffer} [valueHex]
	 */
	constructor(parameters = {})
	{
		super(parameters);

		this.unusedBits = getParametersValue(parameters, UNUSED_BITS, 0);
		this.isConstructed = getParametersValue(parameters, IS_CONSTRUCTED, false);
		this.blockLength = this.valueHex.byteLength;
	}
	//**********************************************************************************
	/**
	 * Base function for converting block from BER encoded array of bytes
	 * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array
	 * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started
	 * @param {!number} inputLength Maximum length of array of bytes which can be using in this function
	 * @returns {number} Offset after least decoded byte
	 */
	fromBER(inputBuffer, inputOffset, inputLength)
	{
		//#region Ability to decode zero-length BitString value
		if(inputLength === 0)
			return inputOffset;
		//#endregion

		let resultOffset = (-1);

		//#region If the BISTRING supposed to be a constructed value
		if(this.isConstructed === true)
		{
			resultOffset = LocalConstructedValueBlock.prototype.fromBER.call(this, inputBuffer, inputOffset, inputLength);
			if(resultOffset === (-1))
				return resultOffset;

			for(let i = 0; i < this.value.length; i++)
			{
				const currentBlockName = this.value[i].constructor.blockName();

				if(currentBlockName === EndOfContent.blockName())
				{
					if(this.isIndefiniteForm === true)
						break;
					else
					{
						this.error = "EndOfContent is unexpected, BIT STRING may consists of BIT STRINGs only";
						return (-1);
					}
				}

				if(currentBlockName !== BitString.blockName())
				{
					this.error = "BIT STRING may consists of BIT STRINGs only";
					return (-1);
				}

				if((this.unusedBits > 0) && (this.value[i].valueBlock.unusedBits > 0))
				{
					this.error = "Using of \"unused bits\" inside constructive BIT STRING allowed for least one only";
					return (-1);
				}

				this.unusedBits = this.value[i].valueBlock.unusedBits;
				if(this.unusedBits > 7)
				{
					this.error = "Unused bits for BitString must be in range 0-7";
					return (-1);
				}
			}

			return resultOffset;
		}
		//#endregion
		//#region If the BitString supposed to be a primitive value
		//#region Basic check for parameters
		//noinspection JSCheckFunctionSignatures
		if(checkBufferParams(this, inputBuffer, inputOffset, inputLength) === false)
			return (-1);
		//#endregion

		const intBuffer = new Uint8Array(inputBuffer, inputOffset, inputLength);

		this.unusedBits = intBuffer[0];

		if(this.unusedBits > 7)
		{
			this.error = "Unused bits for BitString must be in range 0-7";
			return (-1);
		}

		if(!this.unusedBits)
		{
			const buf = inputBuffer.slice(inputOffset + 1, inputOffset + inputLength);
			try
			{
				const asn = fromBER(buf);
				if(asn.offset !== -1 && asn.offset === (inputLength - 1))
				{
					this.value = [asn.result];
				}
			} catch(e)
			{
				// nothing
			}
		}

		//#region Copy input buffer to internal buffer
		this.valueHex = new ArrayBuffer(intBuffer.length - 1);
		const view = new Uint8Array(this.valueHex);
		for(let i = 0; i < (inputLength - 1); i++)
			view[i] = intBuffer[i + 1];
		//#endregion

		this.blockLength = intBuffer.length;

		return (inputOffset + inputLength);
		//#endregion
	}
	//**********************************************************************************
	/**
	 * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)
	 * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes
	 * @returns {ArrayBuffer}
	 */
	toBER(sizeOnly = false, writer)
	{
		if(this.isConstructed === true)
			return LocalConstructedValueBlock.prototype.toBER.call(this, sizeOnly, writer);

		if(sizeOnly === true)
			return (new ArrayBuffer(this.valueHex.byteLength + 1));

		if(this.valueHex.byteLength === 0)
			return (EMPTY_BUFFER);

		const curView = new Uint8Array(this.valueHex);

		const retBuf = new ArrayBuffer(this.valueHex.byteLength + 1);
		const retView = new Uint8Array(retBuf);

		retView[0] = this.unusedBits;

		for(let i = 0; i < this.valueHex.byteLength; i++)
			retView[i + 1] = curView[i];

		return retBuf;
	}
	//**********************************************************************************
	/**
	 * Aux function, need to get a block name. Need to have it here for inheritance
	 * @returns {string}
	 */
	static blockName()
	{
		return "BitStringValueBlock";
	}
	//**********************************************************************************
	/**
	 * Conversion for the block to JSON object
	 * @returns {{blockName, blockLength, error, warnings, valueBeforeDecode}|{blockName: string, blockLength: number, error: string, warnings: Array.<string>, valueBeforeDecode: string}}
	 */
	toJSON()
	{
		let object = {};

		//#region Seems at the moment (Sep 2016) there is no way how to check method is supported in "super" object
		try
		{
			object = super.toJSON();
		}
		catch(ex) { }
		//#endregion

		object.unusedBits = this.unusedBits;
		object.isConstructed = this.isConstructed;
		object.isHexOnly = this.isHexOnly;
		object.valueHex = bufferToHexCodes(this.valueHex, 0, this.valueHex.byteLength);

		return object;
	}
	//**********************************************************************************
}
//**************************************************************************************
class BitString extends BaseBlock
{
	//**********************************************************************************
	/**
	 * Constructor for "BitString" class
	 * @param {Object} [parameters={}]
	 */
	constructor(parameters = {})
	{
		super(parameters, LocalBitStringValueBlock);

		this.idBlock.tagClass = 1; // UNIVERSAL
		this.idBlock.tagNumber = 3; // BitString
	}
	//**********************************************************************************
	/**
	 * Aux function, need to get a block name. Need to have it here for inheritance
	 * @returns {string}
	 */
	static blockName()
	{
		return "BIT STRING";
	}
	//**********************************************************************************
	/**
	 * Base function for converting block from BER encoded array of bytes
	 * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array
	 * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started
	 * @param {!number} inputLength Maximum length of array of bytes which can be using in this function
	 * @returns {number} Offset after least decoded byte
	 */
	fromBER(inputBuffer, inputOffset, inputLength)
	{
		//#region Ability to encode empty BitString
		if(inputLength === 0)
			return inputOffset;
		//#endregion

		this.valueBlock.isConstructed = this.idBlock.isConstructed;
		this.valueBlock.isIndefiniteForm = this.lenBlock.isIndefiniteForm;

		return super.fromBER(inputBuffer, inputOffset, inputLength);
	}
	//**********************************************************************************
	/**
	 * Checking that two BITSTRINGs are equal
	 * @param {BitString} bitString
	 */
	isEqual(bitString)
	{
		//#region Check input type
		if((bitString instanceof BitString) === false)
			return false;
		//#endregion

		//#region Compare two JSON strings
		if(JSON.stringify(this) !== JSON.stringify(bitString))
			return false;
		//#endregion

		return true;
	}
	//**********************************************************************************
	toString()
	{
		if(this.valueBlock.isConstructed || (this.valueBlock.value && this.valueBlock.value.length))
		{
			return Constructed.prototype.toString.call(this);
		} else
		{
			// convert bytes to bits
			const bits = [];
			const valueHex = new Uint8Array(this.valueBlock.valueHex);
			for(const byte of valueHex)
			{
				bits.push(byte.toString(2).padStart(8, "0"));
			}
			return `${this.constructor.blockName()} : ${bits.join("")}`;
		}
	}
	//**********************************************************************************
}
//**************************************************************************************
//#endregion
//**************************************************************************************
//#region Declaration of ASN.1 Integer type class
//**************************************************************************************
/**
 * @extends ValueBlock
 */
class LocalIntegerValueBlock extends HexBlock(ValueBlock)
{
	//**********************************************************************************
	/**
	 * Constructor for "LocalIntegerValueBlock" class
	 * @param {Object} [parameters={}]
	 * @property {ArrayBuffer} [valueHex]
	 */
	constructor(parameters = {})
	{
		super(parameters);

		if(VALUE in parameters)
			this.valueDec = parameters.value;
	}
	//**********************************************************************************
	/**
	 * Setter for VALUE_HEX
	 * @param {ArrayBuffer} _value
	 */
	set valueHex(_value)
	{
		this._valueHex = _value.slice(0);

		if(_value.byteLength >= 4)
		{
			this.warnings.push("Too big Integer for decoding, hex only");
			this.isHexOnly = true;
			this._valueDec = 0;
		}
		else
		{
			this.isHexOnly = false;

			if(_value.byteLength > 0)
				this._valueDec = utilDecodeTC.call(this);
		}
	}
	//**********************************************************************************
	/**
	 * Getter for VALUE_HEX
	 * @returns {ArrayBuffer}
	 */
	get valueHex()
	{
		return this._valueHex;
	}
	//**********************************************************************************
	/**
	 * Getter for VALUE_DEC
	 * @param {number} _value
	 */
	set valueDec(_value)
	{
		this._valueDec = _value;

		this.isHexOnly = false;
		this._valueHex = utilEncodeTC(_value);
	}
	//**********************************************************************************
	/**
	 * Getter for VALUE_DEC
	 * @returns {number}
	 */
	get valueDec()
	{
		return this._valueDec;
	}
	//**********************************************************************************
	/**
	 * Base function for converting block from DER encoded array of bytes
	 * @param {!ArrayBuffer} inputBuffer ASN.1 DER encoded array
	 * @param {!number} inputOffset Offset in ASN.1 DER encoded array where decoding should be started
	 * @param {!number} inputLength Maximum length of array of bytes which can be using in this function
	 * @param {number} [expectedLength=0] Expected length of converted VALUE_HEX buffer
	 * @returns {number} Offset after least decoded byte
	 */
	fromDER(inputBuffer, inputOffset, inputLength, expectedLength = 0)
	{
		const offset = this.fromBER(inputBuffer, inputOffset, inputLength);
		if(offset === (-1))
			return offset;

		const view = new Uint8Array(this._valueHex);

		if((view[0] === 0x00) && ((view[1] & 0x80) !== 0))
		{
			const updatedValueHex = new ArrayBuffer(this._valueHex.byteLength - 1);
			const updatedView = new Uint8Array(updatedValueHex);

			updatedView.set(new Uint8Array(this._valueHex, 1, this._valueHex.byteLength - 1));

			this._valueHex = updatedValueHex.slice(0);
		}
		else
		{
			if(expectedLength !== 0)
			{
				if(this._valueHex.byteLength < expectedLength)
				{
					if((expectedLength - this._valueHex.byteLength) > 1)
						expectedLength = this._valueHex.byteLength + 1;

					const updatedValueHex = new ArrayBuffer(expectedLength);
					const updatedView = new Uint8Array(updatedValueHex);

					updatedView.set(view, expectedLength - this._valueHex.byteLength);

					this._valueHex = updatedValueHex.slice(0);
				}
			}
		}

		return offset;
	}
	//**********************************************************************************
	/**
	 * Encoding of current ASN.1 block into ASN.1 encoded array (DER rules)
	 * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes
	 * @returns {ArrayBuffer}
	 */
	toDER(sizeOnly = false)
	{
		const view = new Uint8Array(this._valueHex);

		switch(true)
		{
			case ((view[0] & 0x80) !== 0):
				{
					const updatedValueHex = new ArrayBuffer(this._valueHex.byteLength + 1);
					const updatedView = new Uint8Array(updatedValueHex);

					updatedView[0] = 0x00;
					updatedView.set(view, 1);

					this._valueHex = updatedValueHex.slice(0);
				}
				break;
			case ((view[0] === 0x00) && ((view[1] & 0x80) === 0)):
				{
					const updatedValueHex = new ArrayBuffer(this._valueHex.byteLength - 1);
					const updatedView = new Uint8Array(updatedValueHex);

					updatedView.set(new Uint8Array(this._valueHex, 1, this._valueHex.byteLength - 1));

					this._valueHex = updatedValueHex.slice(0);
				}
				break;
			default:
		}

		return this.toBER(sizeOnly);
	}
	//**********************************************************************************
	/**
	 * Base function for converting block from BER encoded array of bytes
	 * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array
	 * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started
	 * @param {!number} inputLength Maximum length of array of bytes which can be using in this function
	 * @returns {number} Offset after least decoded byte
	 */
	fromBER(inputBuffer, inputOffset, inputLength)
	{
		const resultOffset = super.fromBER(inputBuffer, inputOffset, inputLength);
		if(resultOffset === (-1))
			return resultOffset;

		this.blockLength = inputLength;

		return (inputOffset + inputLength);
	}
	//**********************************************************************************
	/**
	 * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)
	 * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes
	 * @returns {ArrayBuffer}
	 */
	toBER(sizeOnly = false)
	{
		//noinspection JSCheckFunctionSignatures
		return this.valueHex.slice(0);
	}
	//**********************************************************************************
	/**
	 * Aux function, need to get a block name. Need to have it here for inheritance
	 * @returns {string}
	 */
	static blockName()
	{
		return "IntegerValueBlock";
	}
	//**********************************************************************************
	//noinspection JSUnusedGlobalSymbols
	/**
	 * Conversion for the block to JSON object
	 * @returns {Object}
	 */
	toJSON()
	{
		let object = {};

		//#region Seems at the moment (Sep 2016) there is no way how to check method is supported in "super" object
		try
		{
			object = super.toJSON();
		}
		catch(ex) { }
		//#endregion

		object.valueDec = this.valueDec;

		return object;
	}
	//**********************************************************************************
	/**
	 * Convert current value to decimal string representation
	 */
	toString()
	{
		//#region Aux functions
		function viewAdd(first, second)
		{
			//#region Initial variables
			const c = new Uint8Array([0]);

			let firstView = new Uint8Array(first);
			let secondView = new Uint8Array(second);

			let firstViewCopy = firstView.slice(0);
			const firstViewCopyLength = firstViewCopy.length - 1;
			let secondViewCopy = secondView.slice(0);
			const secondViewCopyLength = secondViewCopy.length - 1;

			let value = 0;

			const max = (secondViewCopyLength < firstViewCopyLength) ? firstViewCopyLength : secondViewCopyLength;

			let counter = 0;
			//#endregion

			for(let i = max; i >= 0; i--, counter++)
			{
				switch(true)
				{
					case (counter < secondViewCopy.length):
						value = firstViewCopy[firstViewCopyLength - counter] + secondViewCopy[secondViewCopyLength - counter] + c[0];
						break;
					default:
						value = firstViewCopy[firstViewCopyLength - counter] + c[0];
				}

				c[0] = value / 10;

				switch(true)
				{
					case (counter >= firstViewCopy.length):
						firstViewCopy = utilConcatView(new Uint8Array([value % 10]), firstViewCopy);
						break;
					default:
						firstViewCopy[firstViewCopyLength - counter] = value % 10;
				}
			}

			if(c[0] > 0)
				firstViewCopy = utilConcatView(c, firstViewCopy);

			return firstViewCopy.slice(0);
		}

		function power2(n)
		{
			if(n >= powers2.length)
			{
				for(let p = powers2.length; p <= n; p++)
				{
					const c = new Uint8Array([0]);
					let digits = (powers2[p - 1]).slice(0);

					for(let i = (digits.length - 1); i >= 0; i--)
					{
						const newValue = new Uint8Array([(digits[i] << 1) + c[0]]);
						c[0] = newValue[0] / 10;
						digits[i] = newValue[0] % 10;
					}

					if(c[0] > 0)
						digits = utilConcatView(c, digits);

					powers2.push(digits);
				}
			}

			return powers2[n];
		}

		function viewSub(first, second)
		{
			//#region Initial variables
			let b = 0;

			let firstView = new Uint8Array(first);
			let secondView = new Uint8Array(second);

			let firstViewCopy = firstView.slice(0);
			const firstViewCopyLength = firstViewCopy.length - 1;
			let secondViewCopy = secondView.slice(0);
			const secondViewCopyLength = secondViewCopy.length - 1;

			let value;

			let counter = 0;
			//#endregion

			for(let i = secondViewCopyLength; i >= 0; i--, counter++)
			{
				value = firstViewCopy[firstViewCopyLength - counter] - secondViewCopy[secondViewCopyLength - counter] - b;

				switch(true)
				{
					case (value < 0):
						b = 1;
						firstViewCopy[firstViewCopyLength - counter] = value + 10;
						break;
					default:
						b = 0;
						firstViewCopy[firstViewCopyLength - counter] = value;
				}
			}

			if(b > 0)
			{
				for(let i = (firstViewCopyLength - secondViewCopyLength + 1); i >= 0; i--, counter++)
				{
					value = firstViewCopy[firstViewCopyLength - counter] - b;

					if(value < 0)
					{
						b = 1;
						firstViewCopy[firstViewCopyLength - counter] = value + 10;
					}
					else
					{
						b = 0;
						firstViewCopy[firstViewCopyLength - counter] = value;
						break;
					}
				}
			}

			return firstViewCopy.slice();
		}
		//#endregion

		//#region Initial variables
		const firstBit = (this._valueHex.byteLength * 8) - 1;

		let digits = new Uint8Array((this._valueHex.byteLength * 8) / 3);
		let bitNumber = 0;
		let currentByte;

		const asn1View = new Uint8Array(this._valueHex);

		let result = "";

		let flag = false;
		//#endregion

		//#region Calculate number
		for(let byteNumber = (this._valueHex.byteLength - 1); byteNumber >= 0; byteNumber--)
		{
			currentByte = asn1View[byteNumber];

			for(let i = 0; i < 8; i++)
			{
				if((currentByte & 1) === 1)
				{
					switch(bitNumber)
					{
						case firstBit:
							digits = viewSub(power2(bitNumber), digits);
							result = "-";
							break;
						default:
							digits = viewAdd(digits, power2(bitNumber));
					}
				}

				bitNumber++;
				currentByte >>= 1;
			}
		}
		//#endregion

		//#region Print number
		for(let i = 0; i < digits.length; i++)
		{
			if(digits[i])
				flag = true;

			if(flag)
				result += digitsString.charAt(digits[i]);
		}

		if(flag === false)
			result += digitsString.charAt(0);
		//#endregion

		return result;
	}
	//**********************************************************************************
}
//**************************************************************************************
class Integer extends BaseBlock
{
	//**********************************************************************************
	/**
	 * Constructor for "Integer" class
	 * @param {Object} [parameters={}]
	 */
	constructor(parameters = {})
	{
		super(parameters, LocalIntegerValueBlock);

		this.idBlock.tagClass = 1; // UNIVERSAL
		this.idBlock.tagNumber = 2; // Integer
	}
	//**********************************************************************************
	/**
	 * Aux function, need to get a block name. Need to have it here for inheritance
	 * @returns {string}
	 */
	static blockName()
	{
		return "INTEGER";
	}
	//**********************************************************************************
	//noinspection JSUnusedGlobalSymbols
	/**
	 * Compare two Integer object, or Integer and ArrayBuffer objects
	 * @param {!Integer|ArrayBuffer} otherValue
	 * @returns {boolean}
	 */
	isEqual(otherValue)
	{
		if(otherValue instanceof Integer)
		{
			if(this.valueBlock.isHexOnly && otherValue.valueBlock.isHexOnly) // Compare two ArrayBuffers
				return isEqualBuffer(this.valueBlock.valueHex, otherValue.valueBlock.valueHex);

			if(this.valueBlock.isHexOnly === otherValue.valueBlock.isHexOnly)
				return (this.valueBlock.valueDec === otherValue.valueBlock.valueDec);

			return false;
		}

		if(otherValue instanceof ArrayBuffer)
			return isEqualBuffer(this.valueBlock.valueHex, otherValue);

		return false;
	}
	//**********************************************************************************
	/**
	 * Convert current Integer value from BER into DER format
	 * @returns {Integer}
	 */
	convertToDER()
	{
		const integer = new Integer({ valueHex: this.valueBlock.valueHex });
		integer.valueBlock.toDER();

		return integer;
	}
	//**********************************************************************************
	/**
	 * Convert current Integer value from DER to BER format
	 * @returns {Integer}
	 */
	convertFromDER()
	{
		const expectedLength = (this.valueBlock.valueHex.byteLength % 2) ? (this.valueBlock.valueHex.byteLength + 1) : this.valueBlock.valueHex.byteLength;
		const integer = new Integer({ valueHex: this.valueBlock.valueHex });
		integer.valueBlock.fromDER(integer.valueBlock.valueHex, 0, integer.valueBlock.valueHex.byteLength, expectedLength);

		return integer;
	}
	//**********************************************************************************
	toString()
	{
		assertBigInt();
		const hex = bufferToHexCodes(this.valueBlock.valueHex);
		const bigInt = BigInt(`0x${hex}`);
		return `${this.constructor.blockName()} : ${bigInt.toString()}`;
	}
}
//**************************************************************************************
//#endregion
//**************************************************************************************
//#region Declaration of ASN.1 Enumerated type class
//**************************************************************************************
class Enumerated extends Integer
{
	//**********************************************************************************
	/**
	 * Constructor for "Enumerated" class
	 * @param {Object} [parameters={}]
	 */
	constructor(parameters = {})
	{
		super(parameters);

		this.idBlock.tagClass = 1; // UNIVERSAL
		this.idBlock.tagNumber = 10; // Enumerated
	}
	//**********************************************************************************
	/**
	 * Aux function, need to get a block name. Need to have it here for inheritance
	 * @returns {string}
	 */
	static blockName()
	{
		return "ENUMERATED";
	}
	//**********************************************************************************
}
//**************************************************************************************
//#endregion
//**************************************************************************************
//#region Declaration of ASN.1 ObjectIdentifier type class
//**************************************************************************************
class LocalSidValueBlock extends HexBlock(LocalBaseBlock)
{
	//**********************************************************************************
	/**
	 * Constructor for "LocalSidValueBlock" class
	 * @param {Object} [parameters={}]
	 * @property {number} [valueDec]
	 * @property {boolean} [isFirstSid]
	 */
	constructor(parameters = {})
	{
		super(parameters);

		this.valueDec = getParametersValue(parameters, VALUE_DEC, -1);
		this.isFirstSid = getParametersValue(parameters, IS_FIRST_SID, false);
	}
	//**********************************************************************************
	/**
	 * Aux function, need to get a block name. Need to have it here for inheritance
	 * @returns {string}
	 */
	static blockName()
	{
		return "sidBlock";
	}
	//**********************************************************************************
	/**
	 * Base function for converting block from BER encoded array of bytes
	 * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array
	 * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started
	 * @param {!number} inputLength Maximum length of array of bytes which can be using in this function
	 * @returns {number} Offset after least decoded byte
	 */
	fromBER(inputBuffer, inputOffset, inputLength)
	{
		if(inputLength === 0)
			return inputOffset;

		//#region Basic check for parameters
		//noinspection JSCheckFunctionSignatures
		if(checkBufferParams(this, inputBuffer, inputOffset, inputLength) === false)
			return (-1);
		//#endregion

		const intBuffer = new Uint8Array(inputBuffer, inputOffset, inputLength);

		this.valueHex = new ArrayBuffer(inputLength);
		let view = new Uint8Array(this.valueHex);

		for(let i = 0; i < inputLength; i++)
		{
			view[i] = intBuffer[i] & 0x7F;

			this.blockLength++;

			if((intBuffer[i] & 0x80) === 0x00)
				break;
		}

		//#region Adjust size of valueHex buffer
		const tempValueHex = new ArrayBuffer(this.blockLength);
		const tempView = new Uint8Array(tempValueHex);

		for(let i = 0; i < this.blockLength; i++)
			tempView[i] = view[i];

		//noinspection JSCheckFunctionSignatures
		this.valueHex = tempValueHex.slice(0);
		view = new Uint8Array(this.valueHex);
		//#endregion

		if((intBuffer[this.blockLength - 1] & 0x80) !== 0x00)
		{
			this.error = "End of input reached before message was fully decoded";
			return (-1);
		}

		if(view[0] === 0x00)
			this.warnings.push("Needlessly long format of SID encoding");

		if(this.blockLength <= 8)
			this.valueDec = utilFromBase(view, 7);
		else
		{
			this.isHexOnly = true;
			this.warnings.push("Too big SID for decoding, hex only");
		}

		return (inputOffset + this.blockLength);
	}
	//**********************************************************************************
	/**
	 * Save a BigInt value immediately as an array of octects.
	 */
	set valueBigInt(value)
	{

		assertBigInt();

		let bits = BigInt(value).toString(2);
		while(bits.length % 7)
		{
			bits = "0" + bits;
		}
		const bytes = new Uint8Array(bits.length / 7);
		for(let i = 0; i < bytes.length; i++)
		{
			bytes[i] = parseInt(bits.slice(i * 7, i * 7 + 7), 2) + (i + 1 < bytes.length ? 0x80 : 0);
		}
		this.fromBER(bytes.buffer, 0, bytes.length);
	}
	//**********************************************************************************
	/**
	 * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)
	 * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes
	 * @returns {ArrayBuffer}
	 */
	toBER(sizeOnly = false)
	{
		//#region Initial variables
		let retBuf;
		let retView;
		//#endregion

		if(this.isHexOnly)
		{
			if(sizeOnly === true)
				return (new ArrayBuffer(this.valueHex.byteLength));

			const curView = new Uint8Array(this.valueHex);

			retBuf = new ArrayBuffer(this.blockLength);
			retView = new Uint8Array(retBuf);

			for(let i = 0; i < (this.blockLength - 1); i++)
				retView[i] = curView[i] | 0x80;

			retView[this.blockLength - 1] = curView[this.blockLength - 1];

			return retBuf;
		}

		const encodedBuf = utilToBase(this.valueDec, 7);
		if(encodedBuf.byteLength === 0)
		{
			this.error = "Error during encoding SID value";
			return (EMPTY_BUFFER);
		}

		retBuf = new ArrayBuffer(encodedBuf.byteLength);

		if(sizeOnly === false)
		{
			const encodedView = new Uint8Array(encodedBuf);
			retView = new Uint8Array(retBuf);

			for(let i = 0; i < (encodedBuf.byteLength - 1); i++)
				retView[i] = encodedView[i] | 0x80;

			retView[encodedBuf.byteLength - 1] = encodedView[encodedBuf.byteLength - 1];
		}

		return retBuf;
	}
	//**********************************************************************************
	/**
	 * Create string representation of current SID block
	 * @returns {string}
	 */
	toString()
	{
		let result = "";

		if(this.isHexOnly === true)
			result = bufferToHexCodes(this.valueHex, 0, this.valueHex.byteLength);
		else
		{
			if(this.isFirstSid)
			{
				let sidValue = this.valueDec;

				if(this.valueDec <= 39)
					result = "0.";
				else
				{
					if(this.valueDec <= 79)
					{
						result = "1.";
						sidValue -= 40;
					}
					else
					{
						result = "2.";
						sidValue -= 80;
					}
				}

				result += sidValue.toString();
			}
			else
				result = this.valueDec.toString();
		}

		return result;
	}
	//**********************************************************************************
	//noinspection JSUnusedGlobalSymbols
	/**
	 * Conversion for the block to JSON object
	 * @returns {Object}
	 */
	toJSON()
	{
		let object = {};

		//#region Seems at the moment (Sep 2016) there is no way how to check method is supported in "super" object
		try
		{
			object = super.toJSON();
		}
		catch(ex) { }
		//#endregion

		object.valueDec = this.valueDec;
		object.isFirstSid = this.isFirstSid;

		return object;
	}
	//**********************************************************************************
}
//**************************************************************************************
class LocalObjectIdentifierValueBlock extends ValueBlock
{
	//**********************************************************************************
	/**
	 * Constructor for "LocalObjectIdentifierValueBlock" class
	 * @param {Object} [parameters={}]
	 * @property {ArrayBuffer} [valueHex]
	 */
	constructor(parameters = {})
	{
		super(parameters);

		this.fromString(getParametersValue(parameters, VALUE, EMPTY_STRING));
	}
	//**********************************************************************************
	/**
	 * Base function for converting block from BER encoded array of bytes
	 * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array
	 * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started
	 * @param {!number} inputLength Maximum length of array of bytes which can be using in this function
	 * @returns {number} Offset after least decoded byte
	 */
	fromBER(inputBuffer, inputOffset, inputLength)
	{
		let resultOffset = inputOffset;

		while(inputLength > 0)
		{
			const sidBlock = new LocalSidValueBlock();
			resultOffset = sidBlock.fromBER(inputBuffer, resultOffset, inputLength);
			if(resultOffset === (-1))
			{
				this.blockLength = 0;
				this.error = sidBlock.error;
				return resultOffset;
			}

			if(this.value.length === 0)
				sidBlock.isFirstSid = true;

			this.blockLength += sidBlock.blockLength;
			inputLength -= sidBlock.blockLength;

			this.value.push(sidBlock);
		}

		return resultOffset;
	}
	//**********************************************************************************
	/**
	 * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)
	 * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes
	 * @returns {ArrayBuffer}
	 */
	toBER(sizeOnly = false)
	{
		const retBufs = [];

		for(let i = 0; i < this.value.length; i++)
		{
			const valueBuf = this.value[i].toBER(sizeOnly);
			if(valueBuf.byteLength === 0)
			{
				this.error = this.value[i].error;
				return (EMPTY_BUFFER);
			}

			retBufs.push(valueBuf);
		}

		return concat(retBufs);
	}
	//**********************************************************************************
	/**
	 * Create "LocalObjectIdentifierValueBlock" class from string
	 * @param {string} string Input string to convert from
	 * @returns {boolean}
	 */
	fromString(string)
	{
		this.value = []; // Clear existing SID values

		let pos1 = 0;
		let pos2 = 0;

		let sid = "";

		let flag = false;

		do
		{
			pos2 = string.indexOf(".", pos1);
			if(pos2 === (-1))
				sid = string.substr(pos1);
			else
				sid = string.substr(pos1, pos2 - pos1);

			pos1 = pos2 + 1;

			if(flag)
			{
				const sidBlock = this.value[0];

				let plus = 0;

				switch(sidBlock.valueDec)
				{
					case 0:
						break;
					case 1:
						plus = 40;
						break;
					case 2:
						plus = 80;
						break;
					default:
						this.value = []; // clear SID array
						return false; // ???
				}

				const parsedSID = parseInt(sid, 10);
				if(isNaN(parsedSID))
					return true;

				sidBlock.valueDec = parsedSID + plus;

				flag = false;
			}
			else
			{
				const sidBlock = new LocalSidValueBlock();
				if(sid > Number.MAX_SAFE_INTEGER)
				{
					assertBigInt();
					const sidValue = BigInt(sid);
					sidBlock.valueBigInt = sidValue;
				} else
				{
					sidBlock.valueDec = parseInt(sid, 10);
					if(isNaN(sidBlock.valueDec)) return true;
				}

				if(this.value.length === 0)
				{
					sidBlock.isFirstSid = true;
					flag = true;
				}

				this.value.push(sidBlock);
			}
		} while(pos2 !== (-1));

		return true;
	}
	//**********************************************************************************
	/**
	 * Converts "LocalObjectIdentifierValueBlock" class to string
	 * @returns {string}
	 */
	toString()
	{
		let result = "";
		let isHexOnly = false;

		for(let i = 0; i < this.value.length; i++)
		{
			isHexOnly = this.value[i].isHexOnly;

			let sidStr = this.value[i].toString();

			if(i !== 0)
				result = `${result}.`;

			if(isHexOnly)
			{
				sidStr = `{${sidStr}}`;

				if(this.value[i].isFirstSid)
					result = `2.{${sidStr} - 80}`;
				else
					result += sidStr;
			}
			else
				result += sidStr;
		}

		return result;
	}
	//**********************************************************************************
	/**
	 * Aux function, need to get a block name. Need to have it here for inheritance
	 * @returns {string}
	 */
	static blockName()
	{
		return "ObjectIdentifierValueBlock";
	}
	//**********************************************************************************
	/**
	 * Conversion for the block to JSON object
	 * @returns {Object}
	 */
	toJSON()
	{
		let object = {};

		//#region Seems at the moment (Sep 2016) there is no way how to check method is supported in "super" object
		try
		{
			object = super.toJSON();
		}
		catch(ex) { }
		//#endregion

		object.value = this.toString();
		object.sidArray = [];
		for(let i = 0; i < this.value.length; i++)
			object.sidArray.push(this.value[i].toJSON());

		return object;
	}
	//**********************************************************************************
}
//**************************************************************************************
/**
 * @extends BaseBlock
 */
class ObjectIdentifier extends BaseBlock
{
	//**********************************************************************************
	/**
	 * Constructor for "ObjectIdentifier" class
	 * @param {Object} [parameters={}]
	 * @property {ArrayBuffer} [valueHex]
	 */
	constructor(parameters = {})
	{
		super(parameters, LocalObjectIdentifierValueBlock);

		this.idBlock.tagClass = 1; // UNIVERSAL
		this.idBlock.tagNumber = 6; // OBJECT IDENTIFIER
	}
	//**********************************************************************************
	/**
	 * Aux function, need to get a block name. Need to have it here for inheritance
	 * @returns {string}
	 */
	static blockName()
	{
		return "OBJECT IDENTIFIER";
	}
	//**********************************************************************************
	toString()
	{
		return `${this.constructor.blockName()} : ${this.valueBlock.toString()}`;
	}
	//**********************************************************************************
}
//**************************************************************************************
//#endregion
//**************************************************************************************
//#region Declaration of all string's classes
//**************************************************************************************
class LocalUtf8StringValueBlock extends HexBlock(LocalBaseBlock)
{
	//**********************************************************************************
	//noinspection JSUnusedGlobalSymbols
	/**
	 * Constructor for "LocalUtf8StringValueBlock" class
	 * @param {Object} [parameters={}]
	 */
	constructor(parameters = {})
	{
		super(parameters);

		this.isHexOnly = true;
		this.value = ""; // String representation of decoded ArrayBuffer
	}
	//**********************************************************************************
	/**
	 * Aux function, need to get a block name. Need to have it here for inheritance
	 * @returns {string}
	 */
	static blockName()
	{
		return "Utf8StringValueBlock";
	}
	//**********************************************************************************
	//noinspection JSUnusedGlobalSymbols
	/**
	 * Conversion for the block to JSON object
	 * @returns {Object}
	 */
	toJSON()
	{
		let object = {};

		//#region Seems at the moment (Sep 2016) there is no way how to check method is supported in "super" object
		try
		{
			object = super.toJSON();
		}
		catch(ex) { }
		//#endregion

		object.value = this.value;

		return object;
	}
	//**********************************************************************************
}
//**************************************************************************************
/**
 * @extends BaseBlock
 */
class Utf8String extends BaseBlock
{
	//**********************************************************************************
	/**
	 * Constructor for "Utf8String" class
	 * @param {Object} [parameters={}]
	 * @property {ArrayBuffer} [valueHex]
	 */
	constructor(parameters = {})
	{
		super(parameters, LocalUtf8StringValueBlock);

		if(VALUE in parameters)
			this.fromString(parameters.value);

		this.idBlock.tagClass = 1; // UNIVERSAL
		this.idBlock.tagNumber = 12; // Utf8String
	}
	//**********************************************************************************
	/**
	 * Aux function, need to get a block name. Need to have it here for inheritance
	 * @returns {string}
	 */
	static blockName()
	{
		return "UTF8String";
	}
	//**********************************************************************************
	/**
	 * Base function for converting block from BER encoded array of bytes
	 * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array
	 * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started
	 * @param {!number} inputLength Maximum length of array of bytes which can be using in this function
	 * @returns {number} Offset after least decoded byte
	 */
	fromBER(inputBuffer, inputOffset, inputLength)
	{
		const resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, (this.lenBlock.isIndefiniteForm === true) ? inputLength : this.lenBlock.length);
		if(resultOffset === (-1))
		{
			this.error = this.valueBlock.error;
			return resultOffset;
		}

		this.fromBuffer(this.valueBlock.valueHex);

		if(this.idBlock.error.length === 0)
			this.blockLength += this.idBlock.blockLength;

		if(this.lenBlock.error.length === 0)
			this.blockLength += this.lenBlock.blockLength;

		if(this.valueBlock.error.length === 0)
			this.blockLength += this.valueBlock.blockLength;

		return resultOffset;
	}
	//**********************************************************************************
	/**
	 * Function converting ArrayBuffer into ASN.1 internal string
	 * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array
	 */
	fromBuffer(inputBuffer)
	{
		this.valueBlock.value = String.fromCharCode.apply(null, new Uint8Array(inputBuffer));

		try
		{
			//noinspection JSDeprecatedSymbols
			this.valueBlock.value = decodeURIComponent(escape(this.valueBlock.value));
		}
		catch(ex)
		{
			this.warnings.push(`Error during "decodeURIComponent": ${ex}, using raw string`);
		}
	}
	//**********************************************************************************
	/**
	 * Function converting JavaScript string into ASN.1 internal class
	 * @param {!string} inputString ASN.1 BER encoded array
	 */
	fromString(inputString)
	{
		//noinspection JSDeprecatedSymbols
		const str = unescape(encodeURIComponent(inputString));
		const strLen = str.length;

		this.valueBlock.valueHex = new ArrayBuffer(strLen);
		const view = new Uint8Array(this.valueBlock.valueHex);

		for(let i = 0; i < strLen; i++)
			view[i] = str.charCodeAt(i);

		this.valueBlock.value = inputString;
	}
	//**********************************************************************************
	toString()
	{
		return `${this.constructor.blockName()} : ${this.valueBlock.value}`;
	}
	//**********************************************************************************
}
//**************************************************************************************
//#region Declaration of ASN.1 RelativeObjectIdentifier type class
//**************************************************************************************
class LocalRelativeSidValueBlock extends HexBlock(LocalBaseBlock)
{
	//**********************************************************************************
	/**
	 * Constructor for "LocalRelativeSidValueBlock" class
	 * @param {Object} [parameters={}]
	 * @property {number} [valueDec]
	 */
	constructor(parameters = {})
	{
		super(parameters);

		this.valueDec = getParametersValue(parameters, VALUE_DEC, -1);
	}
	//**********************************************************************************
	/**
	 * Aux function, need to get a block name. Need to have it here for inheritance
	 * @returns {string}
	 */
	static blockName()
	{
		return "relativeSidBlock";
	}
	//**********************************************************************************
	/**
	 * Base function for converting block from BER encoded array of bytes
	 * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array
	 * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started
	 * @param {!number} inputLength Maximum length of array of bytes which can be using in this function
	 * @returns {number} Offset after least decoded byte
	 */
	fromBER(inputBuffer, inputOffset, inputLength)
	{
		if(inputLength === 0)
			return inputOffset;

		//#region Basic check for parameters
		//noinspection JSCheckFunctionSignatures
		if(checkBufferParams(this, inputBuffer, inputOffset, inputLength) === false)
			return (-1);
		//#endregion

		const intBuffer = new Uint8Array(inputBuffer, inputOffset, inputLength);

		this.valueHex = new ArrayBuffer(inputLength);
		let view = new Uint8Array(this.valueHex);

		for(let i = 0; i < inputLength; i++)
		{
			view[i] = intBuffer[i] & 0x7F;

			this.blockLength++;

			if((intBuffer[i] & 0x80) === 0x00)
				break;
		}

		//#region Adjust size of valueHex buffer
		const tempValueHex = new ArrayBuffer(this.blockLength);
		const tempView = new Uint8Array(tempValueHex);

		for(let i = 0; i < this.blockLength; i++)
			tempView[i] = view[i];

		//noinspection JSCheckFunctionSignatures
		this.valueHex = tempValueHex.slice(0);
		view = new Uint8Array(this.valueHex);
		//#endregion

		if((intBuffer[this.blockLength - 1] & 0x80) !== 0x00)
		{
			this.error = "End of input reached before message was fully decoded";
			return (-1);
		}

		if(view[0] === 0x00)
			this.warnings.push("Needlessly long format of SID encoding");

		if(this.blockLength <= 8)
			this.valueDec = utilFromBase(view, 7);
		else
		{
			this.isHexOnly = true;
			this.warnings.push("Too big SID for decoding, hex only");
		}

		return (inputOffset + this.blockLength);
	}
	//**********************************************************************************
	/**
	 * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)
	 * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes
	 * @returns {ArrayBuffer}
	 */
	toBER(sizeOnly = false)
	{
		//#region Initial variables
		let retBuf;
		let retView;
		//#endregion

		if(this.isHexOnly)
		{
			if(sizeOnly === true)
				return (new ArrayBuffer(this.valueHex.byteLength));

			const curView = new Uint8Array(this.valueHex);

			retBuf = new ArrayBuffer(this.blockLength);
			retView = new Uint8Array(retBuf);

			for(let i = 0; i < (this.blockLength - 1); i++)
				retView[i] = curView[i] | 0x80;

			retView[this.blockLength - 1] = curView[this.blockLength - 1];

			return retBuf;
		}

		const encodedBuf = utilToBase(this.valueDec, 7);
		if(encodedBuf.byteLength === 0)
		{
			this.error = "Error during encoding SID value";
			return (EMPTY_BUFFER);
		}

		retBuf = new ArrayBuffer(encodedBuf.byteLength);

		if(sizeOnly === false)
		{
			const encodedView = new Uint8Array(encodedBuf);
			retView = new Uint8Array(retBuf);

			for(let i = 0; i < (encodedBuf.byteLength - 1); i++)
				retView[i] = encodedView[i] | 0x80;

			retView[encodedBuf.byteLength - 1] = encodedView[encodedBuf.byteLength - 1];
		}

		return retBuf;
	}
	//**********************************************************************************
	/**
	 * Create string representation of current SID block
	 * @returns {string}
	 */
	toString()
	{
		let result = "";

		if(this.isHexOnly === true)
			result = bufferToHexCodes(this.valueHex, 0, this.valueHex.byteLength);
		else
		{
			result = this.valueDec.toString();
		}

		return result;
	}
	//**********************************************************************************
	//noinspection JSUnusedGlobalSymbols
	/**
	 * Conversion for the block to JSON object
	 * @returns {Object}
	 */
	toJSON()
	{
		let object = {};

		//#region Seems at the moment (Sep 2016) there is no way how to check method is supported in "super" object
		try
		{
			object = super.toJSON();
		} catch(ex) { }
		//#endregion

		object.valueDec = this.valueDec;

		return object;
	}
	//**********************************************************************************
}
//**************************************************************************************
class LocalRelativeObjectIdentifierValueBlock extends ValueBlock
{
	//**********************************************************************************
	/**
	 * Constructor for "LocalRelativeObjectIdentifierValueBlock" class
	 * @param {Object} [parameters={}]
	 * @property {ArrayBuffer} [valueHex]
	 */
	constructor(parameters = {})
	{
		super(parameters);

		this.fromString(getParametersValue(parameters, VALUE, EMPTY_STRING));
	}
	//**********************************************************************************
	/**
	 * Base function for converting block from BER encoded array of bytes
	 * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array
	 * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started
	 * @param {!number} inputLength Maximum length of array of bytes which can be using in this function
	 * @returns {number} Offset after least decoded byte
	 */
	fromBER(inputBuffer, inputOffset, inputLength)
	{
		let resultOffset = inputOffset;

		while(inputLength > 0)
		{
			const sidBlock = new LocalRelativeSidValueBlock();
			resultOffset = sidBlock.fromBER(inputBuffer, resultOffset, inputLength);
			if(resultOffset === (-1))
			{
				this.blockLength = 0;
				this.error = sidBlock.error;
				return resultOffset;
			}

			this.blockLength += sidBlock.blockLength;
			inputLength -= sidBlock.blockLength;

			this.value.push(sidBlock);
		}

		return resultOffset;
	}
	//**********************************************************************************
	/**
	 * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)
	 * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes
	 * @returns {ArrayBuffer}
	 */
	toBER(sizeOnly = false)
	{
		let retBufs = [];

		for(let i = 0; i < this.value.length; i++)
		{
			const valueBuf = this.value[i].toBER(sizeOnly);
			if(valueBuf.byteLength === 0)
			{
				this.error = this.value[i].error;
				return (EMPTY_BUFFER);
			}

			retBufs.push(valueBuf);
		}

		return concat(retBufs);
	}
	//**********************************************************************************
	/**
	 * Create "LocalRelativeObjectIdentifierValueBlock" class from string
	 * @param {string} string Input string to convert from
	 * @returns {boolean}
	 */
	fromString(string)
	{
		this.value = []; // Clear existing SID values

		let pos1 = 0;
		let pos2 = 0;

		let sid = "";

		do
		{
			pos2 = string.indexOf(".", pos1);
			if(pos2 === (-1))
				sid = string.substr(pos1);
			else
				sid = string.substr(pos1, pos2 - pos1);

			pos1 = pos2 + 1;

			const sidBlock = new LocalRelativeSidValueBlock();
			sidBlock.valueDec = parseInt(sid, 10);
			if(isNaN(sidBlock.valueDec))
				return true;

			this.value.push(sidBlock);

		} while(pos2 !== (-1));

		return true;
	}
	//**********************************************************************************
	/**
	 * Converts "LocalRelativeObjectIdentifierValueBlock" class to string
	 * @returns {string}
	 */
	toString()
	{
		let result = "";
		let isHexOnly = false;

		for(let i = 0; i < this.value.length; i++)
		{
			isHexOnly = this.value[i].isHexOnly;

			let sidStr = this.value[i].toString();

			if(i !== 0)
				result = `${result}.`;

			if(isHexOnly)
			{
				sidStr = `{${sidStr}}`;
				result += sidStr;
			} else
				result += sidStr;
		}

		return result;
	}
	//**********************************************************************************
	/**
	 * Aux function, need to get a block name. Need to have it here for inheritance
	 * @returns {string}
	 */
	static blockName()
	{
		return "RelativeObjectIdentifierValueBlock";
	}
	//**********************************************************************************
	/**
	 * Conversion for the block to JSON object
	 * @returns {Object}
	 */
	toJSON()
	{
		let object = {};

		//#region Seems at the moment (Sep 2016) there is no way how to check method is supported in "super" object
		try
		{
			object = super.toJSON();
		} catch(ex) { }
		//#endregion

		object.value = this.toString();
		object.sidArray = [];
		for(let i = 0; i < this.value.length; i++)
			object.sidArray.push(this.value[i].toJSON());

		return object;
	}
	//**********************************************************************************
}
//**************************************************************************************
/**
 * @extends BaseBlock
 */
class RelativeObjectIdentifier extends BaseBlock
{
	//**********************************************************************************
	/**
	 * Constructor for "RelativeObjectIdentifier" class
	 * @param {Object} [parameters={}]
	 * @property {ArrayBuffer} [valueHex]
	 */
	constructor(parameters = {})
	{
		super(parameters, LocalRelativeObjectIdentifierValueBlock);

		this.idBlock.tagClass = 1; // UNIVERSAL
		this.idBlock.tagNumber = 13; // RELATIVE OBJECT IDENTIFIER
	}
	//**********************************************************************************
	/**
	 * Aux function, need to get a block name. Need to have it here for inheritance
	 * @returns {string}
	 */
	static blockName()
	{
		return "RelativeObjectIdentifier";
	}
	//**********************************************************************************
}
//**************************************************************************************
//#endregion
//**************************************************************************************
/**
 * @extends LocalBaseBlock
 * @extends HexBlock
 */
class LocalBmpStringValueBlock extends HexBlock(LocalBaseBlock)
{
	//**********************************************************************************
	/**
	 * Constructor for "LocalBmpStringValueBlock" class
	 * @param {Object} [parameters={}]
	 */
	constructor(parameters = {})
	{
		super(parameters);

		this.isHexOnly = true;
		this.value = "";
	}
	//**********************************************************************************
	/**
	 * Aux function, need to get a block name. Need to have it here for inheritance
	 * @returns {string}
	 */
	static blockName()
	{
		return "BmpStringValueBlock";
	}
	//**********************************************************************************
	//noinspection JSUnusedGlobalSymbols
	/**
	 * Conversion for the block to JSON object
	 * @returns {Object}
	 */
	toJSON()
	{
		let object = {};

		//#region Seems at the moment (Sep 2016) there is no way how to check method is supported in "super" object
		try
		{
			object = super.toJSON();
		}
		catch(ex) { }
		//#endregion

		object.value = this.value;

		return object;
	}
	//**********************************************************************************
}
//**************************************************************************************
/**
 * @extends BaseBlock
 */
class BmpString extends BaseBlock
{
	//**********************************************************************************
	/**
	 * Constructor for "BmpString" class
	 * @param {Object} [parameters={}]
	 */
	constructor(parameters = {})
	{
		super(parameters, LocalBmpStringValueBlock);

		if(VALUE in parameters)
			this.fromString(parameters.value);

		this.idBlock.tagClass = 1; // UNIVERSAL
		this.idBlock.tagNumber = 30; // BmpString
	}
	//**********************************************************************************
	/**
	 * Aux function, need to get a block name. Need to have it here for inheritance
	 * @returns {string}
	 */
	static blockName()
	{
		return "BMPString";
	}
	//**********************************************************************************
	/**
	 * Base function for converting block from BER encoded array of bytes
	 * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array
	 * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started
	 * @param {!number} inputLength Maximum length of array of bytes which can be using in this function
	 * @returns {number} Offset after least decoded byte
	 */
	fromBER(inputBuffer, inputOffset, inputLength)
	{
		const resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, (this.lenBlock.isIndefiniteForm === true) ? inputLength : this.lenBlock.length);
		if(resultOffset === (-1))
		{
			this.error = this.valueBlock.error;
			return resultOffset;
		}

		this.fromBuffer(this.valueBlock.valueHex);

		if(this.idBlock.error.length === 0)
			this.blockLength += this.idBlock.blockLength;

		if(this.lenBlock.error.length === 0)
			this.blockLength += this.lenBlock.blockLength;

		if(this.valueBlock.error.length === 0)
			this.blockLength += this.valueBlock.blockLength;

		return resultOffset;
	}
	//**********************************************************************************
	/**
	 * Function converting ArrayBuffer into ASN.1 internal string
	 * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array
	 */
	fromBuffer(inputBuffer)
	{
		//noinspection JSCheckFunctionSignatures
		const copyBuffer = inputBuffer.slice(0);
		const valueView = new Uint8Array(copyBuffer);

		for(let i = 0; i < valueView.length; i += 2)
		{
			const temp = valueView[i];

			valueView[i] = valueView[i + 1];
			valueView[i + 1] = temp;
		}

		this.valueBlock.value = String.fromCharCode.apply(null, new Uint16Array(copyBuffer));
	}
	//**********************************************************************************
	/**
	 * Function converting JavaScript string into ASN.1 internal class
	 * @param {!string} inputString ASN.1 BER encoded array
	 */
	fromString(inputString)
	{
		const strLength = inputString.length;

		this.valueBlock.valueHex = new ArrayBuffer(strLength * 2);
		const valueHexView = new Uint8Array(this.valueBlock.valueHex);

		for(let i = 0; i < strLength; i++)
		{
			const codeBuf = utilToBase(inputString.charCodeAt(i), 8);
			const codeView = new Uint8Array(codeBuf);
			if(codeView.length > 2)
				continue;

			const dif = 2 - codeView.length;

			for(let j = (codeView.length - 1); j >= 0; j--)
				valueHexView[i * 2 + j + dif] = codeView[j];
		}

		this.valueBlock.value = inputString;
	}
	//**********************************************************************************
	toString()
	{
		return `${this.constructor.blockName()} : ${this.valueBlock.value}`;
	}
	//**********************************************************************************
}
//**************************************************************************************
class LocalUniversalStringValueBlock extends HexBlock(LocalBaseBlock)
{
	//**********************************************************************************
	/**
	 * Constructor for "LocalUniversalStringValueBlock" class
	 * @param {Object} [parameters={}]
	 */
	constructor(parameters = {})
	{
		super(parameters);

		this.isHexOnly = true;
		this.value = "";
	}
	//**********************************************************************************
	/**
	 * Aux function, need to get a block name. Need to have it here for inheritance
	 * @returns {string}
	 */
	static blockName()
	{
		return "UniversalStringValueBlock";
	}
	//**********************************************************************************
	//noinspection JSUnusedGlobalSymbols
	/**
	 * Conversion for the block to JSON object
	 * @returns {Object}
	 */
	toJSON()
	{
		let object = {};

		//#region Seems at the moment (Sep 2016) there is no way how to check method is supported in "super" object
		try
		{
			object = super.toJSON();
		}
		catch(ex) { }
		//#endregion

		object.value = this.value;

		return object;
	}
	//**********************************************************************************
}
//**************************************************************************************
/**
 * @extends BaseBlock
 */
class UniversalString extends BaseBlock
{
	//**********************************************************************************
	/**
	 * Constructor for "UniversalString" class
	 * @param {Object} [parameters={}]
	 */
	constructor(parameters = {})
	{
		super(parameters, LocalUniversalStringValueBlock);

		if(VALUE in parameters)
			this.fromString(parameters.value);

		this.idBlock.tagClass = 1; // UNIVERSAL
		this.idBlock.tagNumber = 28; // UniversalString
	}
	//**********************************************************************************
	/**
	 * Aux function, need to get a block name. Need to have it here for inheritance
	 * @returns {string}
	 */
	static blockName()
	{
		return "UniversalString";
	}
	//**********************************************************************************
	/**
	 * Base function for converting block from BER encoded array of bytes
	 * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array
	 * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started
	 * @param {!number} inputLength Maximum length of array of bytes which can be using in this function
	 * @returns {number} Offset after least decoded byte
	 */
	fromBER(inputBuffer, inputOffset, inputLength)
	{
		const resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, (this.lenBlock.isIndefiniteForm === true) ? inputLength : this.lenBlock.length);
		if(resultOffset === (-1))
		{
			this.error = this.valueBlock.error;
			return resultOffset;
		}

		this.fromBuffer(this.valueBlock.valueHex);

		if(this.idBlock.error.length === 0)
			this.blockLength += this.idBlock.blockLength;

		if(this.lenBlock.error.length === 0)
			this.blockLength += this.lenBlock.blockLength;

		if(this.valueBlock.error.length === 0)
			this.blockLength += this.valueBlock.blockLength;

		return resultOffset;
	}
	//**********************************************************************************
	/**
	 * Function converting ArrayBuffer into ASN.1 internal string
	 * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array
	 */
	fromBuffer(inputBuffer)
	{
		//noinspection JSCheckFunctionSignatures
		const copyBuffer = inputBuffer.slice(0);
		const valueView = new Uint8Array(copyBuffer);

		for(let i = 0; i < valueView.length; i += 4)
		{
			valueView[i] = valueView[i + 3];
			valueView[i + 1] = valueView[i + 2];
			valueView[i + 2] = 0x00;
			valueView[i + 3] = 0x00;
		}

		this.valueBlock.value = String.fromCharCode.apply(null, new Uint32Array(copyBuffer));
	}
	//**********************************************************************************
	/**
	 * Function converting JavaScript string into ASN.1 internal class
	 * @param {!string} inputString ASN.1 BER encoded array
	 */
	fromString(inputString)
	{
		const strLength = inputString.length;

		this.valueBlock.valueHex = new ArrayBuffer(strLength * 4);
		const valueHexView = new Uint8Array(this.valueBlock.valueHex);

		for(let i = 0; i < strLength; i++)
		{
			const codeBuf = utilToBase(inputString.charCodeAt(i), 8);
			const codeView = new Uint8Array(codeBuf);
			if(codeView.length > 4)
				continue;

			const dif = 4 - codeView.length;

			for(let j = (codeView.length - 1); j >= 0; j--)
				valueHexView[i * 4 + j + dif] = codeView[j];
		}

		this.valueBlock.value = inputString;
	}
	//**********************************************************************************
	toString()
	{
		return `${this.constructor.blockName()} : ${this.valueBlock.value}`;
	}
	//**********************************************************************************
}
//**************************************************************************************
class LocalSimpleStringValueBlock extends HexBlock(LocalBaseBlock)
{
	//**********************************************************************************
	/**
	 * Constructor for "LocalSimpleStringValueBlock" class
	 * @param {Object} [parameters={}]
	 */
	constructor(parameters = {})
	{
		super(parameters);

		this.value = "";
		this.isHexOnly = true;
	}
	//**********************************************************************************
	/**
	 * Aux function, need to get a block name. Need to have it here for inheritance
	 * @returns {string}
	 */
	static blockName()
	{
		return "SimpleStringValueBlock";
	}
	//**********************************************************************************
	//noinspection JSUnusedGlobalSymbols
	/**
	 * Conversion for the block to JSON object
	 * @returns {Object}
	 */
	toJSON()
	{
		let object = {};

		//#region Seems at the moment (Sep 2016) there is no way how to check method is supported in "super" object
		try
		{
			object = super.toJSON();
		}
		catch(ex) { }
		//#endregion

		object.value = this.value;

		return object;
	}
	//**********************************************************************************
}
//**************************************************************************************
/**
 * @extends BaseBlock
 */
class LocalSimpleStringBlock extends BaseBlock
{
	//**********************************************************************************
	/**
	 * Constructor for "LocalSimpleStringBlock" class
	 * @param {Object} [parameters={}]
	 */
	constructor(parameters = {})
	{
		super(parameters, LocalSimpleStringValueBlock);

		if(VALUE in parameters)
			this.fromString(parameters.value);
	}
	//**********************************************************************************
	/**
	 * Aux function, need to get a block name. Need to have it here for inheritance
	 * @returns {string}
	 */
	static blockName()
	{
		return "SIMPLESTRING";
	}
	//**********************************************************************************
	/**
	 * Base function for converting block from BER encoded array of bytes
	 * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array
	 * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started
	 * @param {!number} inputLength Maximum length of array of bytes which can be using in this function
	 * @returns {number} Offset after least decoded byte
	 */
	fromBER(inputBuffer, inputOffset, inputLength)
	{
		const resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, (this.lenBlock.isIndefiniteForm === true) ? inputLength : this.lenBlock.length);
		if(resultOffset === (-1))
		{
			this.error = this.valueBlock.error;
			return resultOffset;
		}

		this.fromBuffer(this.valueBlock.valueHex);

		if(this.idBlock.error.length === 0)
			this.blockLength += this.idBlock.blockLength;

		if(this.lenBlock.error.length === 0)
			this.blockLength += this.lenBlock.blockLength;

		if(this.valueBlock.error.length === 0)
			this.blockLength += this.valueBlock.blockLength;

		return resultOffset;
	}
	//**********************************************************************************
	/**
	 * Function converting ArrayBuffer into ASN.1 internal string
	 * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array
	 */
	fromBuffer(inputBuffer)
	{
		this.valueBlock.value = String.fromCharCode.apply(null, new Uint8Array(inputBuffer));
	}
	//**********************************************************************************
	/**
	 * Function converting JavaScript string into ASN.1 internal class
	 * @param {!string} inputString ASN.1 BER encoded array
	 */
	fromString(inputString)
	{
		const strLen = inputString.length;

		this.valueBlock.valueHex = new ArrayBuffer(strLen);
		const view = new Uint8Array(this.valueBlock.valueHex);

		for(let i = 0; i < strLen; i++)
			view[i] = inputString.charCodeAt(i);

		this.valueBlock.value = inputString;
	}
	//**********************************************************************************
	toString()
	{
		return `${this.constructor.blockName()} : ${this.valueBlock.value}`;
	}
	//**********************************************************************************
}
//**************************************************************************************
/**
 * @extends LocalSimpleStringBlock
 */
class NumericString extends LocalSimpleStringBlock
{
	//**********************************************************************************
	/**
	 * Constructor for "NumericString" class
	 * @param {Object} [parameters={}]
	 */
	constructor(parameters = {})
	{
		super(parameters);

		this.idBlock.tagClass = 1; // UNIVERSAL
		this.idBlock.tagNumber = 18; // NumericString
	}
	//**********************************************************************************
	/**
	 * Aux function, need to get a block name. Need to have it here for inheritance
	 * @returns {string}
	 */
	static blockName()
	{
		return "NumericString";
	}
	//**********************************************************************************
}
//**************************************************************************************
/**
 * @extends LocalSimpleStringBlock
 */
class PrintableString extends LocalSimpleStringBlock
{
	//**********************************************************************************
	/**
	 * Constructor for "PrintableString" class
	 * @param {Object} [parameters={}]
	 */
	constructor(parameters = {})
	{
		super(parameters);

		this.idBlock.tagClass = 1; // UNIVERSAL
		this.idBlock.tagNumber = 19; // PrintableString
	}
	//**********************************************************************************
	/**
	 * Aux function, need to get a block name. Need to have it here for inheritance
	 * @returns {string}
	 */
	static blockName()
	{
		return "PrintableString";
	}
	//**********************************************************************************
}
//**************************************************************************************
/**
 * @extends LocalSimpleStringBlock
 */
class TeletexString extends LocalSimpleStringBlock
{
	//**********************************************************************************
	/**
	 * Constructor for "TeletexString" class
	 * @param {Object} [parameters={}]
	 */
	constructor(parameters = {})
	{
		super(parameters);

		this.idBlock.tagClass = 1; // UNIVERSAL
		this.idBlock.tagNumber = 20; // TeletexString
	}
	//**********************************************************************************
	/**
	 * Aux function, need to get a block name. Need to have it here for inheritance
	 * @returns {string}
	 */
	static blockName()
	{
		return "TeletexString";
	}
	//**********************************************************************************
}
//**************************************************************************************
/**
 * @extends LocalSimpleStringBlock
 */
class VideotexString extends LocalSimpleStringBlock
{
	//**********************************************************************************
	/**
	 * Constructor for "VideotexString" class
	 * @param {Object} [parameters={}]
	 */
	constructor(parameters = {})
	{
		super(parameters);

		this.idBlock.tagClass = 1; // UNIVERSAL
		this.idBlock.tagNumber = 21; // VideotexString
	}
	//**********************************************************************************
	/**
	 * Aux function, need to get a block name. Need to have it here for inheritance
	 * @returns {string}
	 */
	static blockName()
	{
		return "VideotexString";
	}
	//**********************************************************************************
}
//**************************************************************************************
/**
 * @extends LocalSimpleStringBlock
 */
class IA5String extends LocalSimpleStringBlock
{
	//**********************************************************************************
	/**
	 * Constructor for "IA5String" class
	 * @param {Object} [parameters={}]
	 */
	constructor(parameters = {})
	{
		super(parameters);

		this.idBlock.tagClass = 1; // UNIVERSAL
		this.idBlock.tagNumber = 22; // IA5String
	}
	//**********************************************************************************
	/**
	 * Aux function, need to get a block name. Need to have it here for inheritance
	 * @returns {string}
	 */
	static blockName()
	{
		return "IA5String";
	}
	//**********************************************************************************
}
//**************************************************************************************
/**
 * @extends LocalSimpleStringBlock
 */
class GraphicString extends LocalSimpleStringBlock
{
	//**********************************************************************************
	/**
	 * Constructor for "GraphicString" class
	 * @param {Object} [parameters={}]
	 */
	constructor(parameters = {})
	{
		super(parameters);

		this.idBlock.tagClass = 1; // UNIVERSAL
		this.idBlock.tagNumber = 25; // GraphicString
	}
	//**********************************************************************************
	/**
	 * Aux function, need to get a block name. Need to have it here for inheritance
	 * @returns {string}
	 */
	static blockName()
	{
		return "GraphicString";
	}
	//**********************************************************************************
}
//**************************************************************************************
/**
 * @extends LocalSimpleStringBlock
 */
class VisibleString extends LocalSimpleStringBlock
{
	//**********************************************************************************
	/**
	 * Constructor for "VisibleString" class
	 * @param {Object} [parameters={}]
	 */
	constructor(parameters = {})
	{
		super(parameters);

		this.idBlock.tagClass = 1; // UNIVERSAL
		this.idBlock.tagNumber = 26; // VisibleString
	}
	//**********************************************************************************
	/**
	 * Aux function, need to get a block name. Need to have it here for inheritance
	 * @returns {string}
	 */
	static blockName()
	{
		return "VisibleString";
	}
	//**********************************************************************************
}
//**************************************************************************************
/**
 * @extends LocalSimpleStringBlock
 */
class GeneralString extends LocalSimpleStringBlock
{
	//**********************************************************************************
	/**
	 * Constructor for "GeneralString" class
	 * @param {Object} [parameters={}]
	 */
	constructor(parameters = {})
	{
		super(parameters);

		this.idBlock.tagClass = 1; // UNIVERSAL
		this.idBlock.tagNumber = 27; // GeneralString
	}
	//**********************************************************************************
	/**
	 * Aux function, need to get a block name. Need to have it here for inheritance
	 * @returns {string}
	 */
	static blockName()
	{
		return "GeneralString";
	}
	//**********************************************************************************
}
//**************************************************************************************
/**
 * @extends LocalSimpleStringBlock
 */
class CharacterString extends LocalSimpleStringBlock
{
	//**********************************************************************************
	/**
	 * Constructor for "CharacterString" class
	 * @param {Object} [parameters={}]
	 */
	constructor(parameters = {})
	{
		super(parameters);

		this.idBlock.tagClass = 1; // UNIVERSAL
		this.idBlock.tagNumber = 29; // CharacterString
	}
	//**********************************************************************************
	/**
	 * Aux function, need to get a block name. Need to have it here for inheritance
	 * @returns {string}
	 */
	static blockName()
	{
		return "CharacterString";
	}
	//**********************************************************************************
}
//**************************************************************************************
//#endregion
//**************************************************************************************
//#region Declaration of all date and time classes
//**************************************************************************************
/**
 * @extends VisibleString
 */
class UTCTime extends VisibleString
{
	//**********************************************************************************
	/**
	 * Constructor for "UTCTime" class
	 * @param {Object} [parameters={}]
	 * @property {string} [value] String representatio of the date
	 * @property {Date} [valueDate] JavaScript "Date" object
	 */
	constructor(parameters = {})
	{
		super(parameters);

		this.year = 0;
		this.month = 0;
		this.day = 0;
		this.hour = 0;
		this.minute = 0;
		this.second = 0;

		//#region Create UTCTime from ASN.1 UTC string value
		if(VALUE in parameters)
		{
			this.fromString(parameters.value);

			this.valueBlock.valueHex = new ArrayBuffer(parameters.value.length);
			const view = new Uint8Array(this.valueBlock.valueHex);

			for(let i = 0; i < parameters.value.length; i++)
				view[i] = parameters.value.charCodeAt(i);
		}
		//#endregion
		//#region Create GeneralizedTime from JavaScript Date type
		if(VALUE_DATE in parameters)
		{
			this.fromDate(parameters.valueDate);
			this.valueBlock.valueHex = this.toBuffer();
		}
		//#endregion

		this.idBlock.tagClass = 1; // UNIVERSAL
		this.idBlock.tagNumber = 23; // UTCTime
	}
	//**********************************************************************************
	/**
	 * Base function for converting block from BER encoded array of bytes
	 * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array
	 * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started
	 * @param {!number} inputLength Maximum length of array of bytes which can be using in this function
	 * @returns {number} Offset after least decoded byte
	 */
	fromBER(inputBuffer, inputOffset, inputLength)
	{
		const resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, (this.lenBlock.isIndefiniteForm === true) ? inputLength : this.lenBlock.length);
		if(resultOffset === (-1))
		{
			this.error = this.valueBlock.error;
			return resultOffset;
		}

		this.fromBuffer(this.valueBlock.valueHex);

		if(this.idBlock.error.length === 0)
			this.blockLength += this.idBlock.blockLength;

		if(this.lenBlock.error.length === 0)
			this.blockLength += this.lenBlock.blockLength;

		if(this.valueBlock.error.length === 0)
			this.blockLength += this.valueBlock.blockLength;

		return resultOffset;
	}
	//**********************************************************************************
	/**
	 * Function converting ArrayBuffer into ASN.1 internal string
	 * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array
	 */
	fromBuffer(inputBuffer)
	{
		this.fromString(String.fromCharCode.apply(null, new Uint8Array(inputBuffer)));
	}
	//**********************************************************************************
	/**
	 * Function converting ASN.1 internal string into ArrayBuffer
	 * @returns {ArrayBuffer}
	 */
	toBuffer()
	{
		const str = this.toString();

		const buffer = new ArrayBuffer(str.length);
		const view = new Uint8Array(buffer);

		for(let i = 0; i < str.length; i++)
			view[i] = str.charCodeAt(i);

		return buffer;
	}
	//**********************************************************************************
	/**
	 * Function converting "Date" object into ASN.1 internal string
	 * @param {!Date} inputDate JavaScript "Date" object
	 */
	fromDate(inputDate)
	{
		this.year = inputDate.getUTCFullYear();
		this.month = inputDate.getUTCMonth() + 1;
		this.day = inputDate.getUTCDate();
		this.hour = inputDate.getUTCHours();
		this.minute = inputDate.getUTCMinutes();
		this.second = inputDate.getUTCSeconds();
	}
	//**********************************************************************************
	//noinspection JSUnusedGlobalSymbols
	/**
	 * Function converting ASN.1 internal string into "Date" object
	 * @returns {Date}
	 */
	toDate()
	{
		return (new Date(Date.UTC(this.year, this.month - 1, this.day, this.hour, this.minute, this.second)));
	}
	//**********************************************************************************
	/**
	 * Function converting JavaScript string into ASN.1 internal class
	 * @param {!string} inputString ASN.1 BER encoded array
	 */
	fromString(inputString)
	{
		//#region Parse input string
		const parser = /(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})Z/ig;
		const parserArray = parser.exec(inputString);
		if(parserArray === null)
		{
			this.error = "Wrong input string for conversion";
			return;
		}
		//#endregion

		//#region Store parsed values
		const year = parseInt(parserArray[1], 10);
		if(year >= 50)
			this.year = 1900 + year;
		else
			this.year = 2000 + year;

		this.month = parseInt(parserArray[2], 10);
		this.day = parseInt(parserArray[3], 10);
		this.hour = parseInt(parserArray[4], 10);
		this.minute = parseInt(parserArray[5], 10);
		this.second = parseInt(parserArray[6], 10);
		//#endregion
	}
	//**********************************************************************************
	/**
	 * Function converting ASN.1 internal class into JavaScript string
	 * @returns {string}
	 */
	toString()
	{
		const outputArray = new Array(7);

		outputArray[0] = padNumber(((this.year < 2000) ? (this.year - 1900) : (this.year - 2000)), 2);
		outputArray[1] = padNumber(this.month, 2);
		outputArray[2] = padNumber(this.day, 2);
		outputArray[3] = padNumber(this.hour, 2);
		outputArray[4] = padNumber(this.minute, 2);
		outputArray[5] = padNumber(this.second, 2);
		outputArray[6] = "Z";

		return outputArray.join("");
	}
	//**********************************************************************************
	/**
	 * Aux function, need to get a block name. Need to have it here for inheritance
	 * @returns {string}
	 */
	static blockName()
	{
		return "UTCTime";
	}
	//**********************************************************************************
	/**
	 * Conversion for the block to JSON object
	 * @returns {Object}
	 */
	toJSON()
	{
		let object = {};

		//#region Seems at the moment (Sep 2016) there is no way how to check method is supported in "super" object
		try
		{
			object = super.toJSON();
		}
		catch(ex) { }
		//#endregion

		object.year = this.year;
		object.month = this.month;
		object.day = this.day;
		object.hour = this.hour;
		object.minute = this.minute;
		object.second = this.second;

		return object;
	}
	//**********************************************************************************
}
//**************************************************************************************
/**
 * @extends VisibleString
 */
class GeneralizedTime extends VisibleString
{
	//**********************************************************************************
	/**
	 * Constructor for "GeneralizedTime" class
	 * @param {Object} [parameters={}]
	 * @property {string} [value] String representatio of the date
	 * @property {Date} [valueDate] JavaScript "Date" object
	 */
	constructor(parameters = {})
	{
		super(parameters);

		this.year = 0;
		this.month = 0;
		this.day = 0;
		this.hour = 0;
		this.minute = 0;
		this.second = 0;
		this.millisecond = 0;

		//#region Create UTCTime from ASN.1 UTC string value
		if(VALUE in parameters)
		{
			this.fromString(parameters.value);

			this.valueBlock.valueHex = new ArrayBuffer(parameters.value.length);
			const view = new Uint8Array(this.valueBlock.valueHex);

			for(let i = 0; i < parameters.value.length; i++)
				view[i] = parameters.value.charCodeAt(i);
		}
		//#endregion
		//#region Create GeneralizedTime from JavaScript Date type
		if(VALUE_DATE in parameters)
		{
			this.fromDate(parameters.valueDate);
			this.valueBlock.valueHex = this.toBuffer();
		}
		//#endregion

		this.idBlock.tagClass = 1; // UNIVERSAL
		this.idBlock.tagNumber = 24; // GeneralizedTime
	}
	//**********************************************************************************
	/**
	 * Base function for converting block from BER encoded array of bytes
	 * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array
	 * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started
	 * @param {!number} inputLength Maximum length of array of bytes which can be using in this function
	 * @returns {number} Offset after least decoded byte
	 */
	fromBER(inputBuffer, inputOffset, inputLength)
	{
		const resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, (this.lenBlock.isIndefiniteForm === true) ? inputLength : this.lenBlock.length);
		if(resultOffset === (-1))
		{
			this.error = this.valueBlock.error;
			return resultOffset;
		}

		this.fromBuffer(this.valueBlock.valueHex);

		if(this.idBlock.error.length === 0)
			this.blockLength += this.idBlock.blockLength;

		if(this.lenBlock.error.length === 0)
			this.blockLength += this.lenBlock.blockLength;

		if(this.valueBlock.error.length === 0)
			this.blockLength += this.valueBlock.blockLength;

		return resultOffset;
	}
	//**********************************************************************************
	/**
	 * Function converting ArrayBuffer into ASN.1 internal string
	 * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array
	 */
	fromBuffer(inputBuffer)
	{
		this.fromString(String.fromCharCode.apply(null, new Uint8Array(inputBuffer)));
	}
	//**********************************************************************************
	/**
	 * Function converting ASN.1 internal string into ArrayBuffer
	 * @returns {ArrayBuffer}
	 */
	toBuffer()
	{
		const str = this.toString();

		const buffer = new ArrayBuffer(str.length);
		const view = new Uint8Array(buffer);

		for(let i = 0; i < str.length; i++)
			view[i] = str.charCodeAt(i);

		return buffer;
	}
	//**********************************************************************************
	/**
	 * Function converting "Date" object into ASN.1 internal string
	 * @param {!Date} inputDate JavaScript "Date" object
	 */
	fromDate(inputDate)
	{
		this.year = inputDate.getUTCFullYear();
		this.month = inputDate.getUTCMonth() + 1;
		this.day = inputDate.getUTCDate();
		this.hour = inputDate.getUTCHours();
		this.minute = inputDate.getUTCMinutes();
		this.second = inputDate.getUTCSeconds();
		this.millisecond = inputDate.getUTCMilliseconds();
	}
	//**********************************************************************************
	//noinspection JSUnusedGlobalSymbols
	/**
	 * Function converting ASN.1 internal string into "Date" object
	 * @returns {Date}
	 */
	toDate()
	{
		return (new Date(Date.UTC(this.year, this.month - 1, this.day, this.hour, this.minute, this.second, this.millisecond)));
	}
	//**********************************************************************************
	/**
	 * Function converting JavaScript string into ASN.1 internal class
	 * @param {!string} inputString ASN.1 BER encoded array
	 */
	fromString(inputString)
	{
		//#region Initial variables
		let isUTC = false;

		let timeString = "";
		let dateTimeString = "";
		let fractionPart = 0;

		let parser;

		let hourDifference = 0;
		let minuteDifference = 0;
		//#endregion

		//#region Convert as UTC time
		if(inputString[inputString.length - 1] === "Z")
		{
			timeString = inputString.substr(0, inputString.length - 1);

			isUTC = true;
		}
		//#endregion
		//#region Convert as local time
		else
		{
			//noinspection JSPrimitiveTypeWrapperUsage
			const number = new Number(inputString[inputString.length - 1]);

			if(isNaN(number.valueOf()))
				throw new Error("Wrong input string for conversion");

			timeString = inputString;
		}
		//#endregion

		//#region Check that we do not have a "+" and "-" symbols inside UTC time
		if(isUTC)
		{
			if(timeString.indexOf("+") !== (-1))
				throw new Error("Wrong input string for conversion");

			if(timeString.indexOf("-") !== (-1))
				throw new Error("Wrong input string for conversion");
		}
		//#endregion
		//#region Get "UTC time difference" in case of local time
		else
		{
			let multiplier = 1;
			let differencePosition = timeString.indexOf("+");
			let differenceString = "";

			if(differencePosition === (-1))
			{
				differencePosition = timeString.indexOf("-");
				multiplier = (-1);
			}

			if(differencePosition !== (-1))
			{
				differenceString = timeString.substr(differencePosition + 1);
				timeString = timeString.substr(0, differencePosition);

				if((differenceString.length !== 2) && (differenceString.length !== 4))
					throw new Error("Wrong input string for conversion");

				//noinspection JSPrimitiveTypeWrapperUsage
				let number = new Number(differenceString.substr(0, 2));

				if(isNaN(number.valueOf()))
					throw new Error("Wrong input string for conversion");

				hourDifference = multiplier * number;

				if(differenceString.length === 4)
				{
					//noinspection JSPrimitiveTypeWrapperUsage
					number = new Number(differenceString.substr(2, 2));

					if(isNaN(number.valueOf()))
						throw new Error("Wrong input string for conversion");

					minuteDifference = multiplier * number;
				}
			}
		}
		//#endregion

		//#region Get position of fraction point
		let fractionPointPosition = timeString.indexOf("."); // Check for "full stop" symbol
		if(fractionPointPosition === (-1))
			fractionPointPosition = timeString.indexOf(","); // Check for "comma" symbol
		//#endregion

		//#region Get fraction part
		if(fractionPointPosition !== (-1))
		{
			//noinspection JSPrimitiveTypeWrapperUsage
			const fractionPartCheck = new Number(`0${timeString.substr(fractionPointPosition)}`);

			if(isNaN(fractionPartCheck.valueOf()))
				throw new Error("Wrong input string for conversion");

			fractionPart = fractionPartCheck.valueOf();

			dateTimeString = timeString.substr(0, fractionPointPosition);
		}
		else
			dateTimeString = timeString;
		//#endregion

		//#region Parse internal date
		switch(true)
		{
			case (dateTimeString.length === 8): // "YYYYMMDD"
				parser = /(\d{4})(\d{2})(\d{2})/ig;
				if(fractionPointPosition !== (-1))
					throw new Error("Wrong input string for conversion"); // Here we should not have a "fraction point"
				break;
			case (dateTimeString.length === 10): // "YYYYMMDDHH"
				parser = /(\d{4})(\d{2})(\d{2})(\d{2})/ig;

				if(fractionPointPosition !== (-1))
				{
					let fractionResult = 60 * fractionPart;
					this.minute = Math.floor(fractionResult);

					fractionResult = 60 * (fractionResult - this.minute);
					this.second = Math.floor(fractionResult);

					fractionResult = 1000 * (fractionResult - this.second);
					this.millisecond = Math.floor(fractionResult);
				}
				break;
			case (dateTimeString.length === 12): // "YYYYMMDDHHMM"
				parser = /(\d{4})(\d{2})(\d{2})(\d{2})(\d{2})/ig;

				if(fractionPointPosition !== (-1))
				{
					let fractionResult = 60 * fractionPart;
					this.second = Math.floor(fractionResult);

					fractionResult = 1000 * (fractionResult - this.second);
					this.millisecond = Math.floor(fractionResult);
				}
				break;
			case (dateTimeString.length === 14): // "YYYYMMDDHHMMSS"
				parser = /(\d{4})(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})/ig;

				if(fractionPointPosition !== (-1))
				{
					const fractionResult = 1000 * fractionPart;
					this.millisecond = Math.floor(fractionResult);
				}
				break;
			default:
				throw new Error("Wrong input string for conversion");
		}
		//#endregion

		//#region Put parsed values at right places
		const parserArray = parser.exec(dateTimeString);
		if(parserArray === null)
			throw new Error("Wrong input string for conversion");

		for(let j = 1; j < parserArray.length; j++)
		{
			switch(j)
			{
				case 1:
					this.year = parseInt(parserArray[j], 10);
					break;
				case 2:
					this.month = parseInt(parserArray[j], 10);
					break;
				case 3:
					this.day = parseInt(parserArray[j], 10);
					break;
				case 4:
					this.hour = parseInt(parserArray[j], 10) + hourDifference;
					break;
				case 5:
					this.minute = parseInt(parserArray[j], 10) + minuteDifference;
					break;
				case 6:
					this.second = parseInt(parserArray[j], 10);
					break;
				default:
					throw new Error("Wrong input string for conversion");
			}
		}
		//#endregion

		//#region Get final date
		if(isUTC === false)
		{
			const tempDate = new Date(this.year, this.month, this.day, this.hour, this.minute, this.second, this.millisecond);

			this.year = tempDate.getUTCFullYear();
			this.month = tempDate.getUTCMonth();
			this.day = tempDate.getUTCDay();
			this.hour = tempDate.getUTCHours();
			this.minute = tempDate.getUTCMinutes();
			this.second = tempDate.getUTCSeconds();
			this.millisecond = tempDate.getUTCMilliseconds();
		}
		//#endregion
	}
	//**********************************************************************************
	/**
	 * Function converting ASN.1 internal class into JavaScript string
	 * @returns {string}
	 */
	toString()
	{
		const outputArray = [];

		outputArray.push(padNumber(this.year, 4));
		outputArray.push(padNumber(this.month, 2));
		outputArray.push(padNumber(this.day, 2));
		outputArray.push(padNumber(this.hour, 2));
		outputArray.push(padNumber(this.minute, 2));
		outputArray.push(padNumber(this.second, 2));
		if(this.millisecond !== 0)
		{
			outputArray.push(".");
			outputArray.push(padNumber(this.millisecond, 3));
		}
		outputArray.push("Z");

		return outputArray.join("");
	}
	//**********************************************************************************
	/**
	 * Aux function, need to get a block name. Need to have it here for inheritance
	 * @returns {string}
	 */
	static blockName()
	{
		return "GeneralizedTime";
	}
	//**********************************************************************************
	/**
	 * Conversion for the block to JSON object
	 * @returns {Object}
	 */
	toJSON()
	{
		let object = {};

		//#region Seems at the moment (Sep 2016) there is no way how to check method is supported in "super" object
		try
		{
			object = super.toJSON();
		}
		catch(ex) { }
		//#endregion

		object.year = this.year;
		object.month = this.month;
		object.day = this.day;
		object.hour = this.hour;
		object.minute = this.minute;
		object.second = this.second;
		object.millisecond = this.millisecond;

		return object;
	}
	//**********************************************************************************
}
//**************************************************************************************
/**
 * @extends Utf8String
 */
class DATE extends Utf8String
{
	//**********************************************************************************
	/**
	 * Constructor for "DATE" class
	 * @param {Object} [parameters={}]
	 */
	constructor(parameters = {})
	{
		super(parameters);

		this.idBlock.tagClass = 1; // UNIVERSAL
		this.idBlock.tagNumber = 31; // DATE
	}
	//**********************************************************************************
	/**
	 * Aux function, need to get a block name. Need to have it here for inheritance
	 * @returns {string}
	 */
	static blockName()
	{
		return "DATE";
	}
	//**********************************************************************************
}
//**************************************************************************************
/**
 * @extends Utf8String
 */
class TimeOfDay extends Utf8String
{
	//**********************************************************************************
	/**
	 * Constructor for "TimeOfDay" class
	 * @param {Object} [parameters={}]
	 */
	constructor(parameters = {})
	{
		super(parameters);

		this.idBlock.tagClass = 1; // UNIVERSAL
		this.idBlock.tagNumber = 32; // TimeOfDay
	}
	//**********************************************************************************
	/**
	 * Aux function, need to get a block name. Need to have it here for inheritance
	 * @returns {string}
	 */
	static blockName()
	{
		return "TimeOfDay";
	}
	//**********************************************************************************
}
//**************************************************************************************
/**
 * @extends Utf8String
 */
class DateTime extends Utf8String
{
	//**********************************************************************************
	/**
	 * Constructor for "DateTime" class
	 * @param {Object} [parameters={}]
	 */
	constructor(parameters = {})
	{
		super(parameters);

		this.idBlock.tagClass = 1; // UNIVERSAL
		this.idBlock.tagNumber = 33; // DateTime
	}
	//**********************************************************************************
	/**
	 * Aux function, need to get a block name. Need to have it here for inheritance
	 * @returns {string}
	 */
	static blockName()
	{
		return "DateTime";
	}
	//**********************************************************************************
}
//**************************************************************************************
/**
 * @extends Utf8String
 */
class Duration extends Utf8String
{
	//**********************************************************************************
	/**
	 * Constructor for "Duration" class
	 * @param {Object} [parameters={}]
	 */
	constructor(parameters = {})
	{
		super(parameters);

		this.idBlock.tagClass = 1; // UNIVERSAL
		this.idBlock.tagNumber = 34; // Duration
	}
	//**********************************************************************************
	/**
	 * Aux function, need to get a block name. Need to have it here for inheritance
	 * @returns {string}
	 */
	static blockName()
	{
		return "Duration";
	}
	//**********************************************************************************
}
//**************************************************************************************
/**
 * @extends Utf8String
 */
class TIME extends Utf8String
{
	//**********************************************************************************
	/**
	 * Constructor for "Time" class
	 * @param {Object} [parameters={}]
	 */
	constructor(parameters = {})
	{
		super(parameters);

		this.idBlock.tagClass = 1; // UNIVERSAL
		this.idBlock.tagNumber = 14; // Time
	}
	//**********************************************************************************
	/**
	 * Aux function, need to get a block name. Need to have it here for inheritance
	 * @returns {string}
	 */
	static blockName()
	{
		return "TIME";
	}
	//**********************************************************************************
}
//**************************************************************************************
//#endregion
//**************************************************************************************
//#region Declaration of special ASN.1 schema type Choice
//**************************************************************************************
class Choice
{
	//**********************************************************************************
	/**
	 * Constructor for "Choice" class
	 * @param {Object} [parameters={}]
	 * @property {Array} [value] Array of ASN.1 types for make a choice from
	 * @property {boolean} [optional]
	 */
	constructor(parameters = {})
	{
		this.value = getParametersValue(parameters, VALUE, []);
		this.optional = getParametersValue(parameters, OPTIONAL, false);
	}
	//**********************************************************************************
}
//**************************************************************************************
//#endregion
//**************************************************************************************
//#region Declaration of special ASN.1 schema type Any
//**************************************************************************************
class Any
{
	//**********************************************************************************
	/**
	 * Constructor for "Any" class
	 * @param {Object} [parameters={}]
	 * @property {string} [name]
	 * @property {boolean} [optional]
	 */
	constructor(parameters = {})
	{
		this.name = getParametersValue(parameters, NAME, EMPTY_STRING);
		this.optional = getParametersValue(parameters, OPTIONAL, false);
	}
	//**********************************************************************************
}
//**************************************************************************************
//#endregion
//**************************************************************************************
//#region Declaration of special ASN.1 schema type Repeated
//**************************************************************************************
class Repeated
{
	//**********************************************************************************
	/**
	 * Constructor for "Repeated" class
	 * @param {Object} [parameters={}]
	 * @property {string} [name]
	 * @property {boolean} [optional]
	 */
	constructor(parameters = {})
	{
		this.name = getParametersValue(parameters, NAME, EMPTY_STRING);
		this.optional = getParametersValue(parameters, OPTIONAL, false);
		this.value = getParametersValue(parameters, VALUE, new Any());
		this.local = getParametersValue(parameters, LOCAL, false); // Could local or global array to store elements
	}
	//**********************************************************************************
}
//**************************************************************************************
//#endregion
//**************************************************************************************
//#region Declaration of special ASN.1 schema type RawData
//**************************************************************************************
/**
 * @description Special class providing ability to have "toBER/fromBER" for raw ArrayBuffer
 */
class RawData
{
	//**********************************************************************************
	/**
	 * Constructor for "Repeated" class
	 * @param {Object} [parameters={}]
	 * @property {string} [name]
	 * @property {boolean} [optional]
	 */
	constructor(parameters = {})
	{
		this.data = getParametersValue(parameters, DATA, EMPTY_BUFFER);
	}
	//**********************************************************************************
	/**
	 * Base function for converting block from BER encoded array of bytes
	 * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array
	 * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started
	 * @param {!number} inputLength Maximum length of array of bytes which can be using in this function
	 * @returns {number} Offset after least decoded byte
	 */
	fromBER(inputBuffer, inputOffset, inputLength)
	{
		this.data = inputBuffer.slice(inputOffset, inputLength);
		return (inputOffset + inputLength);
	}
	//**********************************************************************************
	/**
	 * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)
	 * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes
	 * @returns {ArrayBuffer}
	 */
	toBER(sizeOnly = false)
	{
		return this.data;
	}
	//**********************************************************************************
}
//**************************************************************************************
//#endregion
//**************************************************************************************
//#region Major ASN.1 BER decoding function
//**************************************************************************************
/**
 * Internal library function for decoding ASN.1 BER
 * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array
 * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started
 * @param {!number} inputLength Maximum length of array of bytes which can be using in this function
 * @returns {{offset: number, result: Object}}
 */
function LocalFromBER(inputBuffer, inputOffset, inputLength)
{
	const incomingOffset = inputOffset; // Need to store initial offset since "inputOffset" is changing in the function

	//#region Local function changing a type for ASN.1 classes
	function localChangeType(inputObject, newType)
	{
		if(inputObject instanceof newType)
			return inputObject;

		const newObject = new newType();
		newObject.idBlock = inputObject.idBlock;
		newObject.lenBlock = inputObject.lenBlock;
		newObject.warnings = inputObject.warnings;
		//noinspection JSCheckFunctionSignatures
		newObject.valueBeforeDecode = inputObject.valueBeforeDecode.slice(0);

		return newObject;
	}
	//#endregion

	//#region Create a basic ASN.1 type since we need to return errors and warnings from the function
	let returnObject = new BaseBlock({}, Object);
	//#endregion

	//#region Basic check for parameters
	const baseBlock = new LocalBaseBlock();
	if(checkBufferParams(baseBlock, inputBuffer, inputOffset, inputLength) === false)
	{
		returnObject.error = baseBlock.error;
		return {
			offset: (-1),
			result: returnObject
		};
	}
	//#endregion

	//#region Getting Uint8Array from ArrayBuffer
	const intBuffer = new Uint8Array(inputBuffer, inputOffset, inputLength);
	//#endregion

	//#region Initial checks
	if(intBuffer.length === 0)
	{
		returnObject.error = "Zero buffer length";
		return {
			offset: (-1),
			result: returnObject
		};
	}
	//#endregion

	//#region Decode identification block of ASN.1 BER structure
	let resultOffset = returnObject.idBlock.fromBER(inputBuffer, inputOffset, inputLength);
	returnObject.warnings.concat(returnObject.idBlock.warnings);
	if(resultOffset === (-1))
	{
		returnObject.error = returnObject.idBlock.error;
		return {
			offset: (-1),
			result: returnObject
		};
	}

	inputOffset = resultOffset;
	inputLength -= returnObject.idBlock.blockLength;
	//#endregion

	//#region Decode length block of ASN.1 BER structure
	resultOffset = returnObject.lenBlock.fromBER(inputBuffer, inputOffset, inputLength);
	returnObject.warnings.concat(returnObject.lenBlock.warnings);
	if(resultOffset === (-1))
	{
		returnObject.error = returnObject.lenBlock.error;
		return {
			offset: (-1),
			result: returnObject
		};
	}

	inputOffset = resultOffset;
	inputLength -= returnObject.lenBlock.blockLength;
	//#endregion

	//#region Check for using indefinite length form in encoding for primitive types
	if((returnObject.idBlock.isConstructed === false) &&
		(returnObject.lenBlock.isIndefiniteForm === true))
	{
		returnObject.error = "Indefinite length form used for primitive encoding form";
		return {
			offset: (-1),
			result: returnObject
		};
	}
	//#endregion

	//#region Switch ASN.1 block type
	let newASN1Type = BaseBlock;

	switch(returnObject.idBlock.tagClass)
	{
		//#region UNIVERSAL
		case 1:
			//#region Check for reserved tag numbers
			if((returnObject.idBlock.tagNumber >= 37) &&
				(returnObject.idBlock.isHexOnly === false))
			{
				returnObject.error = "UNIVERSAL 37 and upper tags are reserved by ASN.1 standard";
				return {
					offset: (-1),
					result: returnObject
				};
			}
			//#endregion

			switch(returnObject.idBlock.tagNumber)
			{
				//#region EndOfContent type
				case 0:
					//#region Check for EndOfContent type
					if((returnObject.idBlock.isConstructed === true) &&
						(returnObject.lenBlock.length > 0))
					{
						returnObject.error = "Type [UNIVERSAL 0] is reserved";
						return {
							offset: (-1),
							result: returnObject
						};
					}
					//#endregion

					newASN1Type = EndOfContent;

					break;
				//#endregion
				//#region Boolean type
				case 1:
					newASN1Type = Boolean;
					break;
				//#endregion
				//#region Integer type
				case 2:
					newASN1Type = Integer;
					break;
				//#endregion
				//#region BitString type
				case 3:
					newASN1Type = BitString;
					break;
				//#endregion
				//#region OctetString type
				case 4:
					newASN1Type = OctetString;
					break;
				//#endregion
				//#region Null type
				case 5:
					newASN1Type = Null;
					break;
				//#endregion
				//#region OBJECT IDENTIFIER type
				case 6:
					newASN1Type = ObjectIdentifier;
					break;
				//#endregion
				//#region Enumerated type
				case 10:
					newASN1Type = Enumerated;
					break;
				//#endregion
				//#region Utf8String type
				case 12:
					newASN1Type = Utf8String;
					break;
				//#endregion
				//#region Time type
				//#region RELATIVE OBJECT IDENTIFIER type
				case 13:
					newASN1Type = RelativeObjectIdentifier;
					break;
				//#endregion
				case 14:
					newASN1Type = TIME;
					break;
				//#endregion
				//#region ASN.1 reserved type
				case 15:
					returnObject.error = "[UNIVERSAL 15] is reserved by ASN.1 standard";
					return {
						offset: (-1),
						result: returnObject
					};
				//#endregion
				//#region Sequence type
				case 16:
					newASN1Type = Sequence;
					break;
				//#endregion
				//#region Set type
				case 17:
					newASN1Type = Set;
					break;
				//#endregion
				//#region NumericString type
				case 18:
					newASN1Type = NumericString;
					break;
				//#endregion
				//#region PrintableString type
				case 19:
					newASN1Type = PrintableString;
					break;
				//#endregion
				//#region TeletexString type
				case 20:
					newASN1Type = TeletexString;
					break;
				//#endregion
				//#region VideotexString type
				case 21:
					newASN1Type = VideotexString;
					break;
				//#endregion
				//#region IA5String type
				case 22:
					newASN1Type = IA5String;
					break;
				//#endregion
				//#region UTCTime type
				case 23:
					newASN1Type = UTCTime;
					break;
				//#endregion
				//#region GeneralizedTime type
				case 24:
					newASN1Type = GeneralizedTime;
					break;
				//#endregion
				//#region GraphicString type
				case 25:
					newASN1Type = GraphicString;
					break;
				//#endregion
				//#region VisibleString type
				case 26:
					newASN1Type = VisibleString;
					break;
				//#endregion
				//#region GeneralString type
				case 27:
					newASN1Type = GeneralString;
					break;
				//#endregion
				//#region UniversalString type
				case 28:
					newASN1Type = UniversalString;
					break;
				//#endregion
				//#region CharacterString type
				case 29:
					newASN1Type = CharacterString;
					break;
				//#endregion
				//#region BmpString type
				case 30:
					newASN1Type = BmpString;
					break;
				//#endregion
				//#region DATE type
				case 31:
					newASN1Type = DATE;
					break;
				//#endregion
				//#region TimeOfDay type
				case 32:
					newASN1Type = TimeOfDay;
					break;
				//#endregion
				//#region Date-Time type
				case 33:
					newASN1Type = DateTime;
					break;
				//#endregion
				//#region Duration type
				case 34:
					newASN1Type = Duration;
					break;
				//#endregion
				//#region default
				default:
					{
						let newObject;

						if(returnObject.idBlock.isConstructed === true)
							newObject = new Constructed();
						else
							newObject = new Primitive();

						newObject.idBlock = returnObject.idBlock;
						newObject.lenBlock = returnObject.lenBlock;
						newObject.warnings = returnObject.warnings;

						returnObject = newObject;
					}
				//#endregion
			}
			break;
		//#endregion
		//#region All other tag classes
		case 2: // APPLICATION
		case 3: // CONTEXT-SPECIFIC
		case 4: // PRIVATE
		default:
			{
				if(returnObject.idBlock.isConstructed === true)
					newASN1Type = Constructed;
				else
					newASN1Type = Primitive;
			}
		//#endregion
	}
	//#endregion

	//#region Change type and perform BER decoding
	returnObject = localChangeType(returnObject, newASN1Type);
	resultOffset = returnObject.fromBER(inputBuffer, inputOffset, (returnObject.lenBlock.isIndefiniteForm === true) ? inputLength : returnObject.lenBlock.length);
	//#endregion

	//#region Coping incoming buffer for entire ASN.1 block
	returnObject.valueBeforeDecode = inputBuffer.slice(incomingOffset, incomingOffset + returnObject.blockLength);
	//#endregion

	return {
		offset: resultOffset,
		result: returnObject
	};
}
//**************************************************************************************
/**
 * Major function for decoding ASN.1 BER array into internal library structures
 * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array of bytes
 */
function fromBER(inputBuffer)
{
	if(inputBuffer.byteLength === 0)
	{
		const result = new BaseBlock({}, Object);
		result.error = "Input buffer has zero length";

		return {
			offset: (-1),
			result
		};
	}

	return LocalFromBER(inputBuffer, 0, inputBuffer.byteLength);
}
//**************************************************************************************
//#endregion
//**************************************************************************************
//#region Major scheme verification function
//**************************************************************************************
/**
 * Compare of two ASN.1 object trees
 * @param {!Object} root Root of input ASN.1 object tree
 * @param {!Object} inputData Input ASN.1 object tree
 * @param {!Object} inputSchema Input ASN.1 schema to compare with
 * @return {{verified: boolean}|{verified:boolean, result: Object}}
 */
function compareSchema(root, inputData, inputSchema)
{
	//#region Special case for Choice schema element type
	if(inputSchema instanceof Choice)
	{
		const choiceResult = false;

		for(let j = 0; j < inputSchema.value.length; j++)
		{
			const result = compareSchema(root, inputData, inputSchema.value[j]);
			if(result.verified === true)
			{
				return {
					verified: true,
					result: root
				};
			}
		}

		if(choiceResult === false)
		{
			const _result = {
				verified: false,
				result: {
					error: "Wrong values for Choice type"
				}
			};

			if(inputSchema.hasOwnProperty(NAME))
				_result.name = inputSchema.name;

			return _result;
		}
	}
	//#endregion

	//#region Special case for Any schema element type
	if(inputSchema instanceof Any)
	{
		//#region Add named component of ASN.1 schema
		if(inputSchema.hasOwnProperty(NAME))
			root[inputSchema.name] = inputData;
		//#endregion

		return {
			verified: true,
			result: root
		};
	}
	//#endregion

	//#region Initial check
	if((root instanceof Object) === false)
	{
		return {
			verified: false,
			result: { error: "Wrong root object" }
		};
	}

	if((inputData instanceof Object) === false)
	{
		return {
			verified: false,
			result: { error: "Wrong ASN.1 data" }
		};
	}

	if((inputSchema instanceof Object) === false)
	{
		return {
			verified: false,
			result: { error: "Wrong ASN.1 schema" }
		};
	}

	if((ID_BLOCK in inputSchema) === false)
	{
		return {
			verified: false,
			result: { error: "Wrong ASN.1 schema" }
		};
	}
	//#endregion

	//#region Comparing idBlock properties in ASN.1 data and ASN.1 schema
	//#region Encode and decode ASN.1 schema idBlock
	/// <remarks>This encoding/decoding is necessary because could be an errors in schema definition</remarks>
	if((FROM_BER in inputSchema.idBlock) === false)
	{
		return {
			verified: false,
			result: { error: "Wrong ASN.1 schema" }
		};
	}

	if((TO_BER in inputSchema.idBlock) === false)
	{
		return {
			verified: false,
			result: { error: "Wrong ASN.1 schema" }
		};
	}

	const encodedId = inputSchema.idBlock.toBER(false);
	if(encodedId.byteLength === 0)
	{
		return {
			verified: false,
			result: { error: "Error encoding idBlock for ASN.1 schema" }
		};
	}

	const decodedOffset = inputSchema.idBlock.fromBER(encodedId, 0, encodedId.byteLength);
	if(decodedOffset === (-1))
	{
		return {
			verified: false,
			result: { error: "Error decoding idBlock for ASN.1 schema" }
		};
	}
	//#endregion

	//#region tagClass
	if(inputSchema.idBlock.hasOwnProperty(TAG_CLASS) === false)
	{
		return {
			verified: false,
			result: { error: "Wrong ASN.1 schema" }
		};
	}

	if(inputSchema.idBlock.tagClass !== inputData.idBlock.tagClass)
	{
		return {
			verified: false,
			result: root
		};
	}
	//#endregion
	//#region tagNumber
	if(inputSchema.idBlock.hasOwnProperty(TAG_NUMBER) === false)
	{
		return {
			verified: false,
			result: { error: "Wrong ASN.1 schema" }
		};
	}

	if(inputSchema.idBlock.tagNumber !== inputData.idBlock.tagNumber)
	{
		return {
			verified: false,
			result: root
		};
	}
	//#endregion
	//#region isConstructed
	if(inputSchema.idBlock.hasOwnProperty(IS_CONSTRUCTED) === false)
	{
		return {
			verified: false,
			result: { error: "Wrong ASN.1 schema" }
		};
	}

	if(inputSchema.idBlock.isConstructed !== inputData.idBlock.isConstructed)
	{
		return {
			verified: false,
			result: root
		};
	}
	//#endregion
	//#region isHexOnly
	if((IS_HEX_ONLY in inputSchema.idBlock) === false) // Since 'isHexOnly' is an inherited property
	{
		return {
			verified: false,
			result: { error: "Wrong ASN.1 schema" }
		};
	}

	if(inputSchema.idBlock.isHexOnly !== inputData.idBlock.isHexOnly)
	{
		return {
			verified: false,
			result: root
		};
	}
	//#endregion
	//#region valueHex
	if(inputSchema.idBlock.isHexOnly === true)
	{
		if((VALUE_HEX in inputSchema.idBlock) === false) // Since 'valueHex' is an inherited property
		{
			return {
				verified: false,
				result: { error: "Wrong ASN.1 schema" }
			};
		}

		const schemaView = new Uint8Array(inputSchema.idBlock.valueHex);
		const asn1View = new Uint8Array(inputData.idBlock.valueHex);

		if(schemaView.length !== asn1View.length)
		{
			return {
				verified: false,
				result: root
			};
		}

		for(let i = 0; i < schemaView.length; i++)
		{
			if(schemaView[i] !== asn1View[1])
			{
				return {
					verified: false,
					result: root
				};
			}
		}
	}
	//#endregion
	//#endregion

	//#region Add named component of ASN.1 schema
	if(inputSchema.hasOwnProperty(NAME))
	{
		inputSchema.name = inputSchema.name.replace(/^\s+|\s+$/g, EMPTY_STRING);
		if(inputSchema.name !== "")
			root[inputSchema.name] = inputData;
	}
	//#endregion

	//#region Getting next ASN.1 block for comparison
	if(inputSchema.idBlock.isConstructed === true)
	{
		let admission = 0;
		let result = { verified: false };

		let maxLength = inputSchema.valueBlock.value.length;

		if(maxLength > 0)
		{
			if(inputSchema.valueBlock.value[0] instanceof Repeated)
				maxLength = inputData.valueBlock.value.length;
		}

		//#region Special case when constructive value has no elements
		if(maxLength === 0)
		{
			return {
				verified: true,
				result: root
			};
		}
		//#endregion

		//#region Special case when "inputData" has no values and "inputSchema" has all optional values
		if((inputData.valueBlock.value.length === 0) &&
			(inputSchema.valueBlock.value.length !== 0))
		{
			let _optional = true;

			for(let i = 0; i < inputSchema.valueBlock.value.length; i++)
				_optional = _optional && (inputSchema.valueBlock.value[i].optional || false);

			if(_optional === true)
			{
				return {
					verified: true,
					result: root
				};
			}

			//#region Delete early added name of block
			if(inputSchema.hasOwnProperty(NAME))
			{
				inputSchema.name = inputSchema.name.replace(/^\s+|\s+$/g, EMPTY_STRING);
				if(inputSchema.name !== "")
					delete root[inputSchema.name];
			}
			//#endregion

			root.error = "Inconsistent object length";

			return {
				verified: false,
				result: root
			};
		}
		//#endregion

		for(let i = 0; i < maxLength; i++)
		{
			//#region Special case when there is an OPTIONAL element of ASN.1 schema at the end
			if((i - admission) >= inputData.valueBlock.value.length)
			{
				if(inputSchema.valueBlock.value[i].optional === false)
				{
					const _result = {
						verified: false,
						result: root
					};

					root.error = "Inconsistent length between ASN.1 data and schema";

					//#region Delete early added name of block
					if(inputSchema.hasOwnProperty(NAME))
					{
						inputSchema.name = inputSchema.name.replace(/^\s+|\s+$/g, EMPTY_STRING);
						if(inputSchema.name !== "")
						{
							delete root[inputSchema.name];
							_result.name = inputSchema.name;
						}
					}
					//#endregion

					return _result;
				}
			}
			//#endregion
			else
			{
				//#region Special case for Repeated type of ASN.1 schema element
				if(inputSchema.valueBlock.value[0] instanceof Repeated)
				{
					result = compareSchema(root, inputData.valueBlock.value[i], inputSchema.valueBlock.value[0].value);
					if(result.verified === false)
					{
						if(inputSchema.valueBlock.value[0].optional === true)
							admission++;
						else
						{
							//#region Delete early added name of block
							if(inputSchema.hasOwnProperty(NAME))
							{
								inputSchema.name = inputSchema.name.replace(/^\s+|\s+$/g, EMPTY_STRING);
								if(inputSchema.name !== "")
									delete root[inputSchema.name];
							}
							//#endregion

							return result;
						}
					}

					if((NAME in inputSchema.valueBlock.value[0]) && (inputSchema.valueBlock.value[0].name.length > 0))
					{
						let arrayRoot = {};

						if((LOCAL in inputSchema.valueBlock.value[0]) && (inputSchema.valueBlock.value[0].local === true))
							arrayRoot = inputData;
						else
							arrayRoot = root;

						if(typeof arrayRoot[inputSchema.valueBlock.value[0].name] === "undefined")
							arrayRoot[inputSchema.valueBlock.value[0].name] = [];

						arrayRoot[inputSchema.valueBlock.value[0].name].push(inputData.valueBlock.value[i]);
					}
				}
				//#endregion
				else
				{
					result = compareSchema(root, inputData.valueBlock.value[i - admission], inputSchema.valueBlock.value[i]);
					if(result.verified === false)
					{
						if(inputSchema.valueBlock.value[i].optional === true)
							admission++;
						else
						{
							//#region Delete early added name of block
							if(inputSchema.hasOwnProperty(NAME))
							{
								inputSchema.name = inputSchema.name.replace(/^\s+|\s+$/g, EMPTY_STRING);
								if(inputSchema.name !== "")
									delete root[inputSchema.name];
							}
							//#endregion

							return result;
						}
					}
				}
			}
		}

		if(result.verified === false) // The situation may take place if last element is OPTIONAL and verification failed
		{
			const _result = {
				verified: false,
				result: root
			};

			//#region Delete early added name of block
			if(inputSchema.hasOwnProperty(NAME))
			{
				inputSchema.name = inputSchema.name.replace(/^\s+|\s+$/g, EMPTY_STRING);
				if(inputSchema.name !== "")
				{
					delete root[inputSchema.name];
					_result.name = inputSchema.name;
				}
			}
			//#endregion

			return _result;
		}

		return {
			verified: true,
			result: root
		};
	}
	//#endregion
	//#region Ability to parse internal value for primitive-encoded value (value of OctetString, for example)
	if((PRIMITIVE_SCHEMA in inputSchema) &&
		(VALUE_HEX in inputData.valueBlock))
	{
		//#region Decoding of raw ASN.1 data
		const asn1 = fromBER(inputData.valueBlock.valueHex);
		if(asn1.offset === (-1))
		{
			const _result = {
				verified: false,
				result: asn1.result
			};

			//#region Delete early added name of block
			if(inputSchema.hasOwnProperty(NAME))
			{
				inputSchema.name = inputSchema.name.replace(/^\s+|\s+$/g, EMPTY_STRING);
				if(inputSchema.name !== "")
				{
					delete root[inputSchema.name];
					_result.name = inputSchema.name;
				}
			}
			//#endregion

			return _result;
		}
		//#endregion

		return compareSchema(root, asn1.result, inputSchema.primitiveSchema);
	}

	return {
		verified: true,
		result: root
	};
	//#endregion
}
//**************************************************************************************
//noinspection JSUnusedGlobalSymbols
/**
 * ASN.1 schema verification for ArrayBuffer data
 * @param {!ArrayBuffer} inputBuffer Input BER-encoded ASN.1 data
 * @param {!Object} inputSchema Input ASN.1 schema to verify against to
 * @return {{verified: boolean}|{verified:boolean, result: Object}}
 */
function verifySchema(inputBuffer, inputSchema)
{
	//#region Initial check
	if((inputSchema instanceof Object) === false)
	{
		return {
			verified: false,
			result: { error: "Wrong ASN.1 schema type" }
		};
	}
	//#endregion

	//#region Decoding of raw ASN.1 data
	const asn1 = fromBER(inputBuffer);
	if(asn1.offset === (-1))
	{
		return {
			verified: false,
			result: asn1.result
		};
	}
	//#endregion

	//#region Compare ASN.1 struct with input schema
	return compareSchema(asn1.result, asn1.result, inputSchema);
	//#endregion
}
//**************************************************************************************
//#endregion
//**************************************************************************************
//#region Major function converting JSON to ASN.1 objects
//**************************************************************************************
//noinspection JSUnusedGlobalSymbols
/**
 * Converting from JSON to ASN.1 objects
 * @param {string|Object} json JSON string or object to convert to ASN.1 objects
 */
function fromJSON(json)
{
	// TODO Implement
}
//**************************************************************************************
//#endregion
//**************************************************************************************


/***/ }),

/***/ 6257:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   decode: () => (/* binding */ decode),
/* harmony export */   encode: () => (/* binding */ encode)
/* harmony export */ });
/*
 * base64-arraybuffer 1.0.2 <https://github.com/niklasvh/base64-arraybuffer>
 * Copyright (c) 2022 Niklas von Hertzen <https://hertzen.com>
 * Released under MIT License
 */
var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
// Use a lookup table to find the index.
var lookup = typeof Uint8Array === 'undefined' ? [] : new Uint8Array(256);
for (var i = 0; i < chars.length; i++) {
    lookup[chars.charCodeAt(i)] = i;
}
var encode = function (arraybuffer) {
    var bytes = new Uint8Array(arraybuffer), i, len = bytes.length, base64 = '';
    for (i = 0; i < len; i += 3) {
        base64 += chars[bytes[i] >> 2];
        base64 += chars[((bytes[i] & 3) << 4) | (bytes[i + 1] >> 4)];
        base64 += chars[((bytes[i + 1] & 15) << 2) | (bytes[i + 2] >> 6)];
        base64 += chars[bytes[i + 2] & 63];
    }
    if (len % 3 === 2) {
        base64 = base64.substring(0, base64.length - 1) + '=';
    }
    else if (len % 3 === 1) {
        base64 = base64.substring(0, base64.length - 2) + '==';
    }
    return base64;
};
var decode = function (base64) {
    var bufferLength = base64.length * 0.75, len = base64.length, i, p = 0, encoded1, encoded2, encoded3, encoded4;
    if (base64[base64.length - 1] === '=') {
        bufferLength--;
        if (base64[base64.length - 2] === '=') {
            bufferLength--;
        }
    }
    var arraybuffer = new ArrayBuffer(bufferLength), bytes = new Uint8Array(arraybuffer);
    for (i = 0; i < len; i += 4) {
        encoded1 = lookup[base64.charCodeAt(i)];
        encoded2 = lookup[base64.charCodeAt(i + 1)];
        encoded3 = lookup[base64.charCodeAt(i + 2)];
        encoded4 = lookup[base64.charCodeAt(i + 3)];
        bytes[p++] = (encoded1 << 2) | (encoded2 >> 4);
        bytes[p++] = ((encoded2 & 15) << 4) | (encoded3 >> 2);
        bytes[p++] = ((encoded3 & 3) << 6) | (encoded4 & 63);
    }
    return arraybuffer;
};


//# sourceMappingURL=base64-arraybuffer.es5.js.map


/***/ }),

/***/ 9404:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

/* module decorator */ module = __webpack_require__.nmd(module);
(function (module, exports) {
  'use strict';

  // Utils
  function assert (val, msg) {
    if (!val) throw new Error(msg || 'Assertion failed');
  }

  // Could use `inherits` module, but don't want to move from single file
  // architecture yet.
  function inherits (ctor, superCtor) {
    ctor.super_ = superCtor;
    var TempCtor = function () {};
    TempCtor.prototype = superCtor.prototype;
    ctor.prototype = new TempCtor();
    ctor.prototype.constructor = ctor;
  }

  // BN

  function BN (number, base, endian) {
    if (BN.isBN(number)) {
      return number;
    }

    this.negative = 0;
    this.words = null;
    this.length = 0;

    // Reduction context
    this.red = null;

    if (number !== null) {
      if (base === 'le' || base === 'be') {
        endian = base;
        base = 10;
      }

      this._init(number || 0, base || 10, endian || 'be');
    }
  }
  if (typeof module === 'object') {
    module.exports = BN;
  } else {
    exports.BN = BN;
  }

  BN.BN = BN;
  BN.wordSize = 26;

  var Buffer;
  try {
    if (typeof window !== 'undefined' && typeof window.Buffer !== 'undefined') {
      Buffer = window.Buffer;
    } else {
      Buffer = (__webpack_require__(181).Buffer);
    }
  } catch (e) {
  }

  BN.isBN = function isBN (num) {
    if (num instanceof BN) {
      return true;
    }

    return num !== null && typeof num === 'object' &&
      num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
  };

  BN.max = function max (left, right) {
    if (left.cmp(right) > 0) return left;
    return right;
  };

  BN.min = function min (left, right) {
    if (left.cmp(right) < 0) return left;
    return right;
  };

  BN.prototype._init = function init (number, base, endian) {
    if (typeof number === 'number') {
      return this._initNumber(number, base, endian);
    }

    if (typeof number === 'object') {
      return this._initArray(number, base, endian);
    }

    if (base === 'hex') {
      base = 16;
    }
    assert(base === (base | 0) && base >= 2 && base <= 36);

    number = number.toString().replace(/\s+/g, '');
    var start = 0;
    if (number[0] === '-') {
      start++;
      this.negative = 1;
    }

    if (start < number.length) {
      if (base === 16) {
        this._parseHex(number, start, endian);
      } else {
        this._parseBase(number, base, start);
        if (endian === 'le') {
          this._initArray(this.toArray(), base, endian);
        }
      }
    }
  };

  BN.prototype._initNumber = function _initNumber (number, base, endian) {
    if (number < 0) {
      this.negative = 1;
      number = -number;
    }
    if (number < 0x4000000) {
      this.words = [number & 0x3ffffff];
      this.length = 1;
    } else if (number < 0x10000000000000) {
      this.words = [
        number & 0x3ffffff,
        (number / 0x4000000) & 0x3ffffff
      ];
      this.length = 2;
    } else {
      assert(number < 0x20000000000000); // 2 ^ 53 (unsafe)
      this.words = [
        number & 0x3ffffff,
        (number / 0x4000000) & 0x3ffffff,
        1
      ];
      this.length = 3;
    }

    if (endian !== 'le') return;

    // Reverse the bytes
    this._initArray(this.toArray(), base, endian);
  };

  BN.prototype._initArray = function _initArray (number, base, endian) {
    // Perhaps a Uint8Array
    assert(typeof number.length === 'number');
    if (number.length <= 0) {
      this.words = [0];
      this.length = 1;
      return this;
    }

    this.length = Math.ceil(number.length / 3);
    this.words = new Array(this.length);
    for (var i = 0; i < this.length; i++) {
      this.words[i] = 0;
    }

    var j, w;
    var off = 0;
    if (endian === 'be') {
      for (i = number.length - 1, j = 0; i >= 0; i -= 3) {
        w = number[i] | (number[i - 1] << 8) | (number[i - 2] << 16);
        this.words[j] |= (w << off) & 0x3ffffff;
        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
        off += 24;
        if (off >= 26) {
          off -= 26;
          j++;
        }
      }
    } else if (endian === 'le') {
      for (i = 0, j = 0; i < number.length; i += 3) {
        w = number[i] | (number[i + 1] << 8) | (number[i + 2] << 16);
        this.words[j] |= (w << off) & 0x3ffffff;
        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
        off += 24;
        if (off >= 26) {
          off -= 26;
          j++;
        }
      }
    }
    return this._strip();
  };

  function parseHex4Bits (string, index) {
    var c = string.charCodeAt(index);
    // '0' - '9'
    if (c >= 48 && c <= 57) {
      return c - 48;
    // 'A' - 'F'
    } else if (c >= 65 && c <= 70) {
      return c - 55;
    // 'a' - 'f'
    } else if (c >= 97 && c <= 102) {
      return c - 87;
    } else {
      assert(false, 'Invalid character in ' + string);
    }
  }

  function parseHexByte (string, lowerBound, index) {
    var r = parseHex4Bits(string, index);
    if (index - 1 >= lowerBound) {
      r |= parseHex4Bits(string, index - 1) << 4;
    }
    return r;
  }

  BN.prototype._parseHex = function _parseHex (number, start, endian) {
    // Create possibly bigger array to ensure that it fits the number
    this.length = Math.ceil((number.length - start) / 6);
    this.words = new Array(this.length);
    for (var i = 0; i < this.length; i++) {
      this.words[i] = 0;
    }

    // 24-bits chunks
    var off = 0;
    var j = 0;

    var w;
    if (endian === 'be') {
      for (i = number.length - 1; i >= start; i -= 2) {
        w = parseHexByte(number, start, i) << off;
        this.words[j] |= w & 0x3ffffff;
        if (off >= 18) {
          off -= 18;
          j += 1;
          this.words[j] |= w >>> 26;
        } else {
          off += 8;
        }
      }
    } else {
      var parseLength = number.length - start;
      for (i = parseLength % 2 === 0 ? start + 1 : start; i < number.length; i += 2) {
        w = parseHexByte(number, start, i) << off;
        this.words[j] |= w & 0x3ffffff;
        if (off >= 18) {
          off -= 18;
          j += 1;
          this.words[j] |= w >>> 26;
        } else {
          off += 8;
        }
      }
    }

    this._strip();
  };

  function parseBase (str, start, end, mul) {
    var r = 0;
    var b = 0;
    var len = Math.min(str.length, end);
    for (var i = start; i < len; i++) {
      var c = str.charCodeAt(i) - 48;

      r *= mul;

      // 'a'
      if (c >= 49) {
        b = c - 49 + 0xa;

      // 'A'
      } else if (c >= 17) {
        b = c - 17 + 0xa;

      // '0' - '9'
      } else {
        b = c;
      }
      assert(c >= 0 && b < mul, 'Invalid character');
      r += b;
    }
    return r;
  }

  BN.prototype._parseBase = function _parseBase (number, base, start) {
    // Initialize as zero
    this.words = [0];
    this.length = 1;

    // Find length of limb in base
    for (var limbLen = 0, limbPow = 1; limbPow <= 0x3ffffff; limbPow *= base) {
      limbLen++;
    }
    limbLen--;
    limbPow = (limbPow / base) | 0;

    var total = number.length - start;
    var mod = total % limbLen;
    var end = Math.min(total, total - mod) + start;

    var word = 0;
    for (var i = start; i < end; i += limbLen) {
      word = parseBase(number, i, i + limbLen, base);

      this.imuln(limbPow);
      if (this.words[0] + word < 0x4000000) {
        this.words[0] += word;
      } else {
        this._iaddn(word);
      }
    }

    if (mod !== 0) {
      var pow = 1;
      word = parseBase(number, i, number.length, base);

      for (i = 0; i < mod; i++) {
        pow *= base;
      }

      this.imuln(pow);
      if (this.words[0] + word < 0x4000000) {
        this.words[0] += word;
      } else {
        this._iaddn(word);
      }
    }

    this._strip();
  };

  BN.prototype.copy = function copy (dest) {
    dest.words = new Array(this.length);
    for (var i = 0; i < this.length; i++) {
      dest.words[i] = this.words[i];
    }
    dest.length = this.length;
    dest.negative = this.negative;
    dest.red = this.red;
  };

  function move (dest, src) {
    dest.words = src.words;
    dest.length = src.length;
    dest.negative = src.negative;
    dest.red = src.red;
  }

  BN.prototype._move = function _move (dest) {
    move(dest, this);
  };

  BN.prototype.clone = function clone () {
    var r = new BN(null);
    this.copy(r);
    return r;
  };

  BN.prototype._expand = function _expand (size) {
    while (this.length < size) {
      this.words[this.length++] = 0;
    }
    return this;
  };

  // Remove leading `0` from `this`
  BN.prototype._strip = function strip () {
    while (this.length > 1 && this.words[this.length - 1] === 0) {
      this.length--;
    }
    return this._normSign();
  };

  BN.prototype._normSign = function _normSign () {
    // -0 = 0
    if (this.length === 1 && this.words[0] === 0) {
      this.negative = 0;
    }
    return this;
  };

  // Check Symbol.for because not everywhere where Symbol defined
  // See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol#Browser_compatibility
  if (typeof Symbol !== 'undefined' && typeof Symbol.for === 'function') {
    try {
      BN.prototype[Symbol.for('nodejs.util.inspect.custom')] = inspect;
    } catch (e) {
      BN.prototype.inspect = inspect;
    }
  } else {
    BN.prototype.inspect = inspect;
  }

  function inspect () {
    return (this.red ? '<BN-R: ' : '<BN: ') + this.toString(16) + '>';
  }

  /*

  var zeros = [];
  var groupSizes = [];
  var groupBases = [];

  var s = '';
  var i = -1;
  while (++i < BN.wordSize) {
    zeros[i] = s;
    s += '0';
  }
  groupSizes[0] = 0;
  groupSizes[1] = 0;
  groupBases[0] = 0;
  groupBases[1] = 0;
  var base = 2 - 1;
  while (++base < 36 + 1) {
    var groupSize = 0;
    var groupBase = 1;
    while (groupBase < (1 << BN.wordSize) / base) {
      groupBase *= base;
      groupSize += 1;
    }
    groupSizes[base] = groupSize;
    groupBases[base] = groupBase;
  }

  */

  var zeros = [
    '',
    '0',
    '00',
    '000',
    '0000',
    '00000',
    '000000',
    '0000000',
    '00000000',
    '000000000',
    '0000000000',
    '00000000000',
    '000000000000',
    '0000000000000',
    '00000000000000',
    '000000000000000',
    '0000000000000000',
    '00000000000000000',
    '000000000000000000',
    '0000000000000000000',
    '00000000000000000000',
    '000000000000000000000',
    '0000000000000000000000',
    '00000000000000000000000',
    '000000000000000000000000',
    '0000000000000000000000000'
  ];

  var groupSizes = [
    0, 0,
    25, 16, 12, 11, 10, 9, 8,
    8, 7, 7, 7, 7, 6, 6,
    6, 6, 6, 6, 6, 5, 5,
    5, 5, 5, 5, 5, 5, 5,
    5, 5, 5, 5, 5, 5, 5
  ];

  var groupBases = [
    0, 0,
    33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216,
    43046721, 10000000, 19487171, 35831808, 62748517, 7529536, 11390625,
    16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632,
    6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149,
    24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176
  ];

  BN.prototype.toString = function toString (base, padding) {
    base = base || 10;
    padding = padding | 0 || 1;

    var out;
    if (base === 16 || base === 'hex') {
      out = '';
      var off = 0;
      var carry = 0;
      for (var i = 0; i < this.length; i++) {
        var w = this.words[i];
        var word = (((w << off) | carry) & 0xffffff).toString(16);
        carry = (w >>> (24 - off)) & 0xffffff;
        off += 2;
        if (off >= 26) {
          off -= 26;
          i--;
        }
        if (carry !== 0 || i !== this.length - 1) {
          out = zeros[6 - word.length] + word + out;
        } else {
          out = word + out;
        }
      }
      if (carry !== 0) {
        out = carry.toString(16) + out;
      }
      while (out.length % padding !== 0) {
        out = '0' + out;
      }
      if (this.negative !== 0) {
        out = '-' + out;
      }
      return out;
    }

    if (base === (base | 0) && base >= 2 && base <= 36) {
      // var groupSize = Math.floor(BN.wordSize * Math.LN2 / Math.log(base));
      var groupSize = groupSizes[base];
      // var groupBase = Math.pow(base, groupSize);
      var groupBase = groupBases[base];
      out = '';
      var c = this.clone();
      c.negative = 0;
      while (!c.isZero()) {
        var r = c.modrn(groupBase).toString(base);
        c = c.idivn(groupBase);

        if (!c.isZero()) {
          out = zeros[groupSize - r.length] + r + out;
        } else {
          out = r + out;
        }
      }
      if (this.isZero()) {
        out = '0' + out;
      }
      while (out.length % padding !== 0) {
        out = '0' + out;
      }
      if (this.negative !== 0) {
        out = '-' + out;
      }
      return out;
    }

    assert(false, 'Base should be between 2 and 36');
  };

  BN.prototype.toNumber = function toNumber () {
    var ret = this.words[0];
    if (this.length === 2) {
      ret += this.words[1] * 0x4000000;
    } else if (this.length === 3 && this.words[2] === 0x01) {
      // NOTE: at this stage it is known that the top bit is set
      ret += 0x10000000000000 + (this.words[1] * 0x4000000);
    } else if (this.length > 2) {
      assert(false, 'Number can only safely store up to 53 bits');
    }
    return (this.negative !== 0) ? -ret : ret;
  };

  BN.prototype.toJSON = function toJSON () {
    return this.toString(16, 2);
  };

  if (Buffer) {
    BN.prototype.toBuffer = function toBuffer (endian, length) {
      return this.toArrayLike(Buffer, endian, length);
    };
  }

  BN.prototype.toArray = function toArray (endian, length) {
    return this.toArrayLike(Array, endian, length);
  };

  var allocate = function allocate (ArrayType, size) {
    if (ArrayType.allocUnsafe) {
      return ArrayType.allocUnsafe(size);
    }
    return new ArrayType(size);
  };

  BN.prototype.toArrayLike = function toArrayLike (ArrayType, endian, length) {
    this._strip();

    var byteLength = this.byteLength();
    var reqLength = length || Math.max(1, byteLength);
    assert(byteLength <= reqLength, 'byte array longer than desired length');
    assert(reqLength > 0, 'Requested array length <= 0');

    var res = allocate(ArrayType, reqLength);
    var postfix = endian === 'le' ? 'LE' : 'BE';
    this['_toArrayLike' + postfix](res, byteLength);
    return res;
  };

  BN.prototype._toArrayLikeLE = function _toArrayLikeLE (res, byteLength) {
    var position = 0;
    var carry = 0;

    for (var i = 0, shift = 0; i < this.length; i++) {
      var word = (this.words[i] << shift) | carry;

      res[position++] = word & 0xff;
      if (position < res.length) {
        res[position++] = (word >> 8) & 0xff;
      }
      if (position < res.length) {
        res[position++] = (word >> 16) & 0xff;
      }

      if (shift === 6) {
        if (position < res.length) {
          res[position++] = (word >> 24) & 0xff;
        }
        carry = 0;
        shift = 0;
      } else {
        carry = word >>> 24;
        shift += 2;
      }
    }

    if (position < res.length) {
      res[position++] = carry;

      while (position < res.length) {
        res[position++] = 0;
      }
    }
  };

  BN.prototype._toArrayLikeBE = function _toArrayLikeBE (res, byteLength) {
    var position = res.length - 1;
    var carry = 0;

    for (var i = 0, shift = 0; i < this.length; i++) {
      var word = (this.words[i] << shift) | carry;

      res[position--] = word & 0xff;
      if (position >= 0) {
        res[position--] = (word >> 8) & 0xff;
      }
      if (position >= 0) {
        res[position--] = (word >> 16) & 0xff;
      }

      if (shift === 6) {
        if (position >= 0) {
          res[position--] = (word >> 24) & 0xff;
        }
        carry = 0;
        shift = 0;
      } else {
        carry = word >>> 24;
        shift += 2;
      }
    }

    if (position >= 0) {
      res[position--] = carry;

      while (position >= 0) {
        res[position--] = 0;
      }
    }
  };

  if (Math.clz32) {
    BN.prototype._countBits = function _countBits (w) {
      return 32 - Math.clz32(w);
    };
  } else {
    BN.prototype._countBits = function _countBits (w) {
      var t = w;
      var r = 0;
      if (t >= 0x1000) {
        r += 13;
        t >>>= 13;
      }
      if (t >= 0x40) {
        r += 7;
        t >>>= 7;
      }
      if (t >= 0x8) {
        r += 4;
        t >>>= 4;
      }
      if (t >= 0x02) {
        r += 2;
        t >>>= 2;
      }
      return r + t;
    };
  }

  BN.prototype._zeroBits = function _zeroBits (w) {
    // Short-cut
    if (w === 0) return 26;

    var t = w;
    var r = 0;
    if ((t & 0x1fff) === 0) {
      r += 13;
      t >>>= 13;
    }
    if ((t & 0x7f) === 0) {
      r += 7;
      t >>>= 7;
    }
    if ((t & 0xf) === 0) {
      r += 4;
      t >>>= 4;
    }
    if ((t & 0x3) === 0) {
      r += 2;
      t >>>= 2;
    }
    if ((t & 0x1) === 0) {
      r++;
    }
    return r;
  };

  // Return number of used bits in a BN
  BN.prototype.bitLength = function bitLength () {
    var w = this.words[this.length - 1];
    var hi = this._countBits(w);
    return (this.length - 1) * 26 + hi;
  };

  function toBitArray (num) {
    var w = new Array(num.bitLength());

    for (var bit = 0; bit < w.length; bit++) {
      var off = (bit / 26) | 0;
      var wbit = bit % 26;

      w[bit] = (num.words[off] >>> wbit) & 0x01;
    }

    return w;
  }

  // Number of trailing zero bits
  BN.prototype.zeroBits = function zeroBits () {
    if (this.isZero()) return 0;

    var r = 0;
    for (var i = 0; i < this.length; i++) {
      var b = this._zeroBits(this.words[i]);
      r += b;
      if (b !== 26) break;
    }
    return r;
  };

  BN.prototype.byteLength = function byteLength () {
    return Math.ceil(this.bitLength() / 8);
  };

  BN.prototype.toTwos = function toTwos (width) {
    if (this.negative !== 0) {
      return this.abs().inotn(width).iaddn(1);
    }
    return this.clone();
  };

  BN.prototype.fromTwos = function fromTwos (width) {
    if (this.testn(width - 1)) {
      return this.notn(width).iaddn(1).ineg();
    }
    return this.clone();
  };

  BN.prototype.isNeg = function isNeg () {
    return this.negative !== 0;
  };

  // Return negative clone of `this`
  BN.prototype.neg = function neg () {
    return this.clone().ineg();
  };

  BN.prototype.ineg = function ineg () {
    if (!this.isZero()) {
      this.negative ^= 1;
    }

    return this;
  };

  // Or `num` with `this` in-place
  BN.prototype.iuor = function iuor (num) {
    while (this.length < num.length) {
      this.words[this.length++] = 0;
    }

    for (var i = 0; i < num.length; i++) {
      this.words[i] = this.words[i] | num.words[i];
    }

    return this._strip();
  };

  BN.prototype.ior = function ior (num) {
    assert((this.negative | num.negative) === 0);
    return this.iuor(num);
  };

  // Or `num` with `this`
  BN.prototype.or = function or (num) {
    if (this.length > num.length) return this.clone().ior(num);
    return num.clone().ior(this);
  };

  BN.prototype.uor = function uor (num) {
    if (this.length > num.length) return this.clone().iuor(num);
    return num.clone().iuor(this);
  };

  // And `num` with `this` in-place
  BN.prototype.iuand = function iuand (num) {
    // b = min-length(num, this)
    var b;
    if (this.length > num.length) {
      b = num;
    } else {
      b = this;
    }

    for (var i = 0; i < b.length; i++) {
      this.words[i] = this.words[i] & num.words[i];
    }

    this.length = b.length;

    return this._strip();
  };

  BN.prototype.iand = function iand (num) {
    assert((this.negative | num.negative) === 0);
    return this.iuand(num);
  };

  // And `num` with `this`
  BN.prototype.and = function and (num) {
    if (this.length > num.length) return this.clone().iand(num);
    return num.clone().iand(this);
  };

  BN.prototype.uand = function uand (num) {
    if (this.length > num.length) return this.clone().iuand(num);
    return num.clone().iuand(this);
  };

  // Xor `num` with `this` in-place
  BN.prototype.iuxor = function iuxor (num) {
    // a.length > b.length
    var a;
    var b;
    if (this.length > num.length) {
      a = this;
      b = num;
    } else {
      a = num;
      b = this;
    }

    for (var i = 0; i < b.length; i++) {
      this.words[i] = a.words[i] ^ b.words[i];
    }

    if (this !== a) {
      for (; i < a.length; i++) {
        this.words[i] = a.words[i];
      }
    }

    this.length = a.length;

    return this._strip();
  };

  BN.prototype.ixor = function ixor (num) {
    assert((this.negative | num.negative) === 0);
    return this.iuxor(num);
  };

  // Xor `num` with `this`
  BN.prototype.xor = function xor (num) {
    if (this.length > num.length) return this.clone().ixor(num);
    return num.clone().ixor(this);
  };

  BN.prototype.uxor = function uxor (num) {
    if (this.length > num.length) return this.clone().iuxor(num);
    return num.clone().iuxor(this);
  };

  // Not ``this`` with ``width`` bitwidth
  BN.prototype.inotn = function inotn (width) {
    assert(typeof width === 'number' && width >= 0);

    var bytesNeeded = Math.ceil(width / 26) | 0;
    var bitsLeft = width % 26;

    // Extend the buffer with leading zeroes
    this._expand(bytesNeeded);

    if (bitsLeft > 0) {
      bytesNeeded--;
    }

    // Handle complete words
    for (var i = 0; i < bytesNeeded; i++) {
      this.words[i] = ~this.words[i] & 0x3ffffff;
    }

    // Handle the residue
    if (bitsLeft > 0) {
      this.words[i] = ~this.words[i] & (0x3ffffff >> (26 - bitsLeft));
    }

    // And remove leading zeroes
    return this._strip();
  };

  BN.prototype.notn = function notn (width) {
    return this.clone().inotn(width);
  };

  // Set `bit` of `this`
  BN.prototype.setn = function setn (bit, val) {
    assert(typeof bit === 'number' && bit >= 0);

    var off = (bit / 26) | 0;
    var wbit = bit % 26;

    this._expand(off + 1);

    if (val) {
      this.words[off] = this.words[off] | (1 << wbit);
    } else {
      this.words[off] = this.words[off] & ~(1 << wbit);
    }

    return this._strip();
  };

  // Add `num` to `this` in-place
  BN.prototype.iadd = function iadd (num) {
    var r;

    // negative + positive
    if (this.negative !== 0 && num.negative === 0) {
      this.negative = 0;
      r = this.isub(num);
      this.negative ^= 1;
      return this._normSign();

    // positive + negative
    } else if (this.negative === 0 && num.negative !== 0) {
      num.negative = 0;
      r = this.isub(num);
      num.negative = 1;
      return r._normSign();
    }

    // a.length > b.length
    var a, b;
    if (this.length > num.length) {
      a = this;
      b = num;
    } else {
      a = num;
      b = this;
    }

    var carry = 0;
    for (var i = 0; i < b.length; i++) {
      r = (a.words[i] | 0) + (b.words[i] | 0) + carry;
      this.words[i] = r & 0x3ffffff;
      carry = r >>> 26;
    }
    for (; carry !== 0 && i < a.length; i++) {
      r = (a.words[i] | 0) + carry;
      this.words[i] = r & 0x3ffffff;
      carry = r >>> 26;
    }

    this.length = a.length;
    if (carry !== 0) {
      this.words[this.length] = carry;
      this.length++;
    // Copy the rest of the words
    } else if (a !== this) {
      for (; i < a.length; i++) {
        this.words[i] = a.words[i];
      }
    }

    return this;
  };

  // Add `num` to `this`
  BN.prototype.add = function add (num) {
    var res;
    if (num.negative !== 0 && this.negative === 0) {
      num.negative = 0;
      res = this.sub(num);
      num.negative ^= 1;
      return res;
    } else if (num.negative === 0 && this.negative !== 0) {
      this.negative = 0;
      res = num.sub(this);
      this.negative = 1;
      return res;
    }

    if (this.length > num.length) return this.clone().iadd(num);

    return num.clone().iadd(this);
  };

  // Subtract `num` from `this` in-place
  BN.prototype.isub = function isub (num) {
    // this - (-num) = this + num
    if (num.negative !== 0) {
      num.negative = 0;
      var r = this.iadd(num);
      num.negative = 1;
      return r._normSign();

    // -this - num = -(this + num)
    } else if (this.negative !== 0) {
      this.negative = 0;
      this.iadd(num);
      this.negative = 1;
      return this._normSign();
    }

    // At this point both numbers are positive
    var cmp = this.cmp(num);

    // Optimization - zeroify
    if (cmp === 0) {
      this.negative = 0;
      this.length = 1;
      this.words[0] = 0;
      return this;
    }

    // a > b
    var a, b;
    if (cmp > 0) {
      a = this;
      b = num;
    } else {
      a = num;
      b = this;
    }

    var carry = 0;
    for (var i = 0; i < b.length; i++) {
      r = (a.words[i] | 0) - (b.words[i] | 0) + carry;
      carry = r >> 26;
      this.words[i] = r & 0x3ffffff;
    }
    for (; carry !== 0 && i < a.length; i++) {
      r = (a.words[i] | 0) + carry;
      carry = r >> 26;
      this.words[i] = r & 0x3ffffff;
    }

    // Copy rest of the words
    if (carry === 0 && i < a.length && a !== this) {
      for (; i < a.length; i++) {
        this.words[i] = a.words[i];
      }
    }

    this.length = Math.max(this.length, i);

    if (a !== this) {
      this.negative = 1;
    }

    return this._strip();
  };

  // Subtract `num` from `this`
  BN.prototype.sub = function sub (num) {
    return this.clone().isub(num);
  };

  function smallMulTo (self, num, out) {
    out.negative = num.negative ^ self.negative;
    var len = (self.length + num.length) | 0;
    out.length = len;
    len = (len - 1) | 0;

    // Peel one iteration (compiler can't do it, because of code complexity)
    var a = self.words[0] | 0;
    var b = num.words[0] | 0;
    var r = a * b;

    var lo = r & 0x3ffffff;
    var carry = (r / 0x4000000) | 0;
    out.words[0] = lo;

    for (var k = 1; k < len; k++) {
      // Sum all words with the same `i + j = k` and accumulate `ncarry`,
      // note that ncarry could be >= 0x3ffffff
      var ncarry = carry >>> 26;
      var rword = carry & 0x3ffffff;
      var maxJ = Math.min(k, num.length - 1);
      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
        var i = (k - j) | 0;
        a = self.words[i] | 0;
        b = num.words[j] | 0;
        r = a * b + rword;
        ncarry += (r / 0x4000000) | 0;
        rword = r & 0x3ffffff;
      }
      out.words[k] = rword | 0;
      carry = ncarry | 0;
    }
    if (carry !== 0) {
      out.words[k] = carry | 0;
    } else {
      out.length--;
    }

    return out._strip();
  }

  // TODO(indutny): it may be reasonable to omit it for users who don't need
  // to work with 256-bit numbers, otherwise it gives 20% improvement for 256-bit
  // multiplication (like elliptic secp256k1).
  var comb10MulTo = function comb10MulTo (self, num, out) {
    var a = self.words;
    var b = num.words;
    var o = out.words;
    var c = 0;
    var lo;
    var mid;
    var hi;
    var a0 = a[0] | 0;
    var al0 = a0 & 0x1fff;
    var ah0 = a0 >>> 13;
    var a1 = a[1] | 0;
    var al1 = a1 & 0x1fff;
    var ah1 = a1 >>> 13;
    var a2 = a[2] | 0;
    var al2 = a2 & 0x1fff;
    var ah2 = a2 >>> 13;
    var a3 = a[3] | 0;
    var al3 = a3 & 0x1fff;
    var ah3 = a3 >>> 13;
    var a4 = a[4] | 0;
    var al4 = a4 & 0x1fff;
    var ah4 = a4 >>> 13;
    var a5 = a[5] | 0;
    var al5 = a5 & 0x1fff;
    var ah5 = a5 >>> 13;
    var a6 = a[6] | 0;
    var al6 = a6 & 0x1fff;
    var ah6 = a6 >>> 13;
    var a7 = a[7] | 0;
    var al7 = a7 & 0x1fff;
    var ah7 = a7 >>> 13;
    var a8 = a[8] | 0;
    var al8 = a8 & 0x1fff;
    var ah8 = a8 >>> 13;
    var a9 = a[9] | 0;
    var al9 = a9 & 0x1fff;
    var ah9 = a9 >>> 13;
    var b0 = b[0] | 0;
    var bl0 = b0 & 0x1fff;
    var bh0 = b0 >>> 13;
    var b1 = b[1] | 0;
    var bl1 = b1 & 0x1fff;
    var bh1 = b1 >>> 13;
    var b2 = b[2] | 0;
    var bl2 = b2 & 0x1fff;
    var bh2 = b2 >>> 13;
    var b3 = b[3] | 0;
    var bl3 = b3 & 0x1fff;
    var bh3 = b3 >>> 13;
    var b4 = b[4] | 0;
    var bl4 = b4 & 0x1fff;
    var bh4 = b4 >>> 13;
    var b5 = b[5] | 0;
    var bl5 = b5 & 0x1fff;
    var bh5 = b5 >>> 13;
    var b6 = b[6] | 0;
    var bl6 = b6 & 0x1fff;
    var bh6 = b6 >>> 13;
    var b7 = b[7] | 0;
    var bl7 = b7 & 0x1fff;
    var bh7 = b7 >>> 13;
    var b8 = b[8] | 0;
    var bl8 = b8 & 0x1fff;
    var bh8 = b8 >>> 13;
    var b9 = b[9] | 0;
    var bl9 = b9 & 0x1fff;
    var bh9 = b9 >>> 13;

    out.negative = self.negative ^ num.negative;
    out.length = 19;
    /* k = 0 */
    lo = Math.imul(al0, bl0);
    mid = Math.imul(al0, bh0);
    mid = (mid + Math.imul(ah0, bl0)) | 0;
    hi = Math.imul(ah0, bh0);
    var w0 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w0 >>> 26)) | 0;
    w0 &= 0x3ffffff;
    /* k = 1 */
    lo = Math.imul(al1, bl0);
    mid = Math.imul(al1, bh0);
    mid = (mid + Math.imul(ah1, bl0)) | 0;
    hi = Math.imul(ah1, bh0);
    lo = (lo + Math.imul(al0, bl1)) | 0;
    mid = (mid + Math.imul(al0, bh1)) | 0;
    mid = (mid + Math.imul(ah0, bl1)) | 0;
    hi = (hi + Math.imul(ah0, bh1)) | 0;
    var w1 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w1 >>> 26)) | 0;
    w1 &= 0x3ffffff;
    /* k = 2 */
    lo = Math.imul(al2, bl0);
    mid = Math.imul(al2, bh0);
    mid = (mid + Math.imul(ah2, bl0)) | 0;
    hi = Math.imul(ah2, bh0);
    lo = (lo + Math.imul(al1, bl1)) | 0;
    mid = (mid + Math.imul(al1, bh1)) | 0;
    mid = (mid + Math.imul(ah1, bl1)) | 0;
    hi = (hi + Math.imul(ah1, bh1)) | 0;
    lo = (lo + Math.imul(al0, bl2)) | 0;
    mid = (mid + Math.imul(al0, bh2)) | 0;
    mid = (mid + Math.imul(ah0, bl2)) | 0;
    hi = (hi + Math.imul(ah0, bh2)) | 0;
    var w2 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w2 >>> 26)) | 0;
    w2 &= 0x3ffffff;
    /* k = 3 */
    lo = Math.imul(al3, bl0);
    mid = Math.imul(al3, bh0);
    mid = (mid + Math.imul(ah3, bl0)) | 0;
    hi = Math.imul(ah3, bh0);
    lo = (lo + Math.imul(al2, bl1)) | 0;
    mid = (mid + Math.imul(al2, bh1)) | 0;
    mid = (mid + Math.imul(ah2, bl1)) | 0;
    hi = (hi + Math.imul(ah2, bh1)) | 0;
    lo = (lo + Math.imul(al1, bl2)) | 0;
    mid = (mid + Math.imul(al1, bh2)) | 0;
    mid = (mid + Math.imul(ah1, bl2)) | 0;
    hi = (hi + Math.imul(ah1, bh2)) | 0;
    lo = (lo + Math.imul(al0, bl3)) | 0;
    mid = (mid + Math.imul(al0, bh3)) | 0;
    mid = (mid + Math.imul(ah0, bl3)) | 0;
    hi = (hi + Math.imul(ah0, bh3)) | 0;
    var w3 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w3 >>> 26)) | 0;
    w3 &= 0x3ffffff;
    /* k = 4 */
    lo = Math.imul(al4, bl0);
    mid = Math.imul(al4, bh0);
    mid = (mid + Math.imul(ah4, bl0)) | 0;
    hi = Math.imul(ah4, bh0);
    lo = (lo + Math.imul(al3, bl1)) | 0;
    mid = (mid + Math.imul(al3, bh1)) | 0;
    mid = (mid + Math.imul(ah3, bl1)) | 0;
    hi = (hi + Math.imul(ah3, bh1)) | 0;
    lo = (lo + Math.imul(al2, bl2)) | 0;
    mid = (mid + Math.imul(al2, bh2)) | 0;
    mid = (mid + Math.imul(ah2, bl2)) | 0;
    hi = (hi + Math.imul(ah2, bh2)) | 0;
    lo = (lo + Math.imul(al1, bl3)) | 0;
    mid = (mid + Math.imul(al1, bh3)) | 0;
    mid = (mid + Math.imul(ah1, bl3)) | 0;
    hi = (hi + Math.imul(ah1, bh3)) | 0;
    lo = (lo + Math.imul(al0, bl4)) | 0;
    mid = (mid + Math.imul(al0, bh4)) | 0;
    mid = (mid + Math.imul(ah0, bl4)) | 0;
    hi = (hi + Math.imul(ah0, bh4)) | 0;
    var w4 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w4 >>> 26)) | 0;
    w4 &= 0x3ffffff;
    /* k = 5 */
    lo = Math.imul(al5, bl0);
    mid = Math.imul(al5, bh0);
    mid = (mid + Math.imul(ah5, bl0)) | 0;
    hi = Math.imul(ah5, bh0);
    lo = (lo + Math.imul(al4, bl1)) | 0;
    mid = (mid + Math.imul(al4, bh1)) | 0;
    mid = (mid + Math.imul(ah4, bl1)) | 0;
    hi = (hi + Math.imul(ah4, bh1)) | 0;
    lo = (lo + Math.imul(al3, bl2)) | 0;
    mid = (mid + Math.imul(al3, bh2)) | 0;
    mid = (mid + Math.imul(ah3, bl2)) | 0;
    hi = (hi + Math.imul(ah3, bh2)) | 0;
    lo = (lo + Math.imul(al2, bl3)) | 0;
    mid = (mid + Math.imul(al2, bh3)) | 0;
    mid = (mid + Math.imul(ah2, bl3)) | 0;
    hi = (hi + Math.imul(ah2, bh3)) | 0;
    lo = (lo + Math.imul(al1, bl4)) | 0;
    mid = (mid + Math.imul(al1, bh4)) | 0;
    mid = (mid + Math.imul(ah1, bl4)) | 0;
    hi = (hi + Math.imul(ah1, bh4)) | 0;
    lo = (lo + Math.imul(al0, bl5)) | 0;
    mid = (mid + Math.imul(al0, bh5)) | 0;
    mid = (mid + Math.imul(ah0, bl5)) | 0;
    hi = (hi + Math.imul(ah0, bh5)) | 0;
    var w5 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w5 >>> 26)) | 0;
    w5 &= 0x3ffffff;
    /* k = 6 */
    lo = Math.imul(al6, bl0);
    mid = Math.imul(al6, bh0);
    mid = (mid + Math.imul(ah6, bl0)) | 0;
    hi = Math.imul(ah6, bh0);
    lo = (lo + Math.imul(al5, bl1)) | 0;
    mid = (mid + Math.imul(al5, bh1)) | 0;
    mid = (mid + Math.imul(ah5, bl1)) | 0;
    hi = (hi + Math.imul(ah5, bh1)) | 0;
    lo = (lo + Math.imul(al4, bl2)) | 0;
    mid = (mid + Math.imul(al4, bh2)) | 0;
    mid = (mid + Math.imul(ah4, bl2)) | 0;
    hi = (hi + Math.imul(ah4, bh2)) | 0;
    lo = (lo + Math.imul(al3, bl3)) | 0;
    mid = (mid + Math.imul(al3, bh3)) | 0;
    mid = (mid + Math.imul(ah3, bl3)) | 0;
    hi = (hi + Math.imul(ah3, bh3)) | 0;
    lo = (lo + Math.imul(al2, bl4)) | 0;
    mid = (mid + Math.imul(al2, bh4)) | 0;
    mid = (mid + Math.imul(ah2, bl4)) | 0;
    hi = (hi + Math.imul(ah2, bh4)) | 0;
    lo = (lo + Math.imul(al1, bl5)) | 0;
    mid = (mid + Math.imul(al1, bh5)) | 0;
    mid = (mid + Math.imul(ah1, bl5)) | 0;
    hi = (hi + Math.imul(ah1, bh5)) | 0;
    lo = (lo + Math.imul(al0, bl6)) | 0;
    mid = (mid + Math.imul(al0, bh6)) | 0;
    mid = (mid + Math.imul(ah0, bl6)) | 0;
    hi = (hi + Math.imul(ah0, bh6)) | 0;
    var w6 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w6 >>> 26)) | 0;
    w6 &= 0x3ffffff;
    /* k = 7 */
    lo = Math.imul(al7, bl0);
    mid = Math.imul(al7, bh0);
    mid = (mid + Math.imul(ah7, bl0)) | 0;
    hi = Math.imul(ah7, bh0);
    lo = (lo + Math.imul(al6, bl1)) | 0;
    mid = (mid + Math.imul(al6, bh1)) | 0;
    mid = (mid + Math.imul(ah6, bl1)) | 0;
    hi = (hi + Math.imul(ah6, bh1)) | 0;
    lo = (lo + Math.imul(al5, bl2)) | 0;
    mid = (mid + Math.imul(al5, bh2)) | 0;
    mid = (mid + Math.imul(ah5, bl2)) | 0;
    hi = (hi + Math.imul(ah5, bh2)) | 0;
    lo = (lo + Math.imul(al4, bl3)) | 0;
    mid = (mid + Math.imul(al4, bh3)) | 0;
    mid = (mid + Math.imul(ah4, bl3)) | 0;
    hi = (hi + Math.imul(ah4, bh3)) | 0;
    lo = (lo + Math.imul(al3, bl4)) | 0;
    mid = (mid + Math.imul(al3, bh4)) | 0;
    mid = (mid + Math.imul(ah3, bl4)) | 0;
    hi = (hi + Math.imul(ah3, bh4)) | 0;
    lo = (lo + Math.imul(al2, bl5)) | 0;
    mid = (mid + Math.imul(al2, bh5)) | 0;
    mid = (mid + Math.imul(ah2, bl5)) | 0;
    hi = (hi + Math.imul(ah2, bh5)) | 0;
    lo = (lo + Math.imul(al1, bl6)) | 0;
    mid = (mid + Math.imul(al1, bh6)) | 0;
    mid = (mid + Math.imul(ah1, bl6)) | 0;
    hi = (hi + Math.imul(ah1, bh6)) | 0;
    lo = (lo + Math.imul(al0, bl7)) | 0;
    mid = (mid + Math.imul(al0, bh7)) | 0;
    mid = (mid + Math.imul(ah0, bl7)) | 0;
    hi = (hi + Math.imul(ah0, bh7)) | 0;
    var w7 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w7 >>> 26)) | 0;
    w7 &= 0x3ffffff;
    /* k = 8 */
    lo = Math.imul(al8, bl0);
    mid = Math.imul(al8, bh0);
    mid = (mid + Math.imul(ah8, bl0)) | 0;
    hi = Math.imul(ah8, bh0);
    lo = (lo + Math.imul(al7, bl1)) | 0;
    mid = (mid + Math.imul(al7, bh1)) | 0;
    mid = (mid + Math.imul(ah7, bl1)) | 0;
    hi = (hi + Math.imul(ah7, bh1)) | 0;
    lo = (lo + Math.imul(al6, bl2)) | 0;
    mid = (mid + Math.imul(al6, bh2)) | 0;
    mid = (mid + Math.imul(ah6, bl2)) | 0;
    hi = (hi + Math.imul(ah6, bh2)) | 0;
    lo = (lo + Math.imul(al5, bl3)) | 0;
    mid = (mid + Math.imul(al5, bh3)) | 0;
    mid = (mid + Math.imul(ah5, bl3)) | 0;
    hi = (hi + Math.imul(ah5, bh3)) | 0;
    lo = (lo + Math.imul(al4, bl4)) | 0;
    mid = (mid + Math.imul(al4, bh4)) | 0;
    mid = (mid + Math.imul(ah4, bl4)) | 0;
    hi = (hi + Math.imul(ah4, bh4)) | 0;
    lo = (lo + Math.imul(al3, bl5)) | 0;
    mid = (mid + Math.imul(al3, bh5)) | 0;
    mid = (mid + Math.imul(ah3, bl5)) | 0;
    hi = (hi + Math.imul(ah3, bh5)) | 0;
    lo = (lo + Math.imul(al2, bl6)) | 0;
    mid = (mid + Math.imul(al2, bh6)) | 0;
    mid = (mid + Math.imul(ah2, bl6)) | 0;
    hi = (hi + Math.imul(ah2, bh6)) | 0;
    lo = (lo + Math.imul(al1, bl7)) | 0;
    mid = (mid + Math.imul(al1, bh7)) | 0;
    mid = (mid + Math.imul(ah1, bl7)) | 0;
    hi = (hi + Math.imul(ah1, bh7)) | 0;
    lo = (lo + Math.imul(al0, bl8)) | 0;
    mid = (mid + Math.imul(al0, bh8)) | 0;
    mid = (mid + Math.imul(ah0, bl8)) | 0;
    hi = (hi + Math.imul(ah0, bh8)) | 0;
    var w8 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w8 >>> 26)) | 0;
    w8 &= 0x3ffffff;
    /* k = 9 */
    lo = Math.imul(al9, bl0);
    mid = Math.imul(al9, bh0);
    mid = (mid + Math.imul(ah9, bl0)) | 0;
    hi = Math.imul(ah9, bh0);
    lo = (lo + Math.imul(al8, bl1)) | 0;
    mid = (mid + Math.imul(al8, bh1)) | 0;
    mid = (mid + Math.imul(ah8, bl1)) | 0;
    hi = (hi + Math.imul(ah8, bh1)) | 0;
    lo = (lo + Math.imul(al7, bl2)) | 0;
    mid = (mid + Math.imul(al7, bh2)) | 0;
    mid = (mid + Math.imul(ah7, bl2)) | 0;
    hi = (hi + Math.imul(ah7, bh2)) | 0;
    lo = (lo + Math.imul(al6, bl3)) | 0;
    mid = (mid + Math.imul(al6, bh3)) | 0;
    mid = (mid + Math.imul(ah6, bl3)) | 0;
    hi = (hi + Math.imul(ah6, bh3)) | 0;
    lo = (lo + Math.imul(al5, bl4)) | 0;
    mid = (mid + Math.imul(al5, bh4)) | 0;
    mid = (mid + Math.imul(ah5, bl4)) | 0;
    hi = (hi + Math.imul(ah5, bh4)) | 0;
    lo = (lo + Math.imul(al4, bl5)) | 0;
    mid = (mid + Math.imul(al4, bh5)) | 0;
    mid = (mid + Math.imul(ah4, bl5)) | 0;
    hi = (hi + Math.imul(ah4, bh5)) | 0;
    lo = (lo + Math.imul(al3, bl6)) | 0;
    mid = (mid + Math.imul(al3, bh6)) | 0;
    mid = (mid + Math.imul(ah3, bl6)) | 0;
    hi = (hi + Math.imul(ah3, bh6)) | 0;
    lo = (lo + Math.imul(al2, bl7)) | 0;
    mid = (mid + Math.imul(al2, bh7)) | 0;
    mid = (mid + Math.imul(ah2, bl7)) | 0;
    hi = (hi + Math.imul(ah2, bh7)) | 0;
    lo = (lo + Math.imul(al1, bl8)) | 0;
    mid = (mid + Math.imul(al1, bh8)) | 0;
    mid = (mid + Math.imul(ah1, bl8)) | 0;
    hi = (hi + Math.imul(ah1, bh8)) | 0;
    lo = (lo + Math.imul(al0, bl9)) | 0;
    mid = (mid + Math.imul(al0, bh9)) | 0;
    mid = (mid + Math.imul(ah0, bl9)) | 0;
    hi = (hi + Math.imul(ah0, bh9)) | 0;
    var w9 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w9 >>> 26)) | 0;
    w9 &= 0x3ffffff;
    /* k = 10 */
    lo = Math.imul(al9, bl1);
    mid = Math.imul(al9, bh1);
    mid = (mid + Math.imul(ah9, bl1)) | 0;
    hi = Math.imul(ah9, bh1);
    lo = (lo + Math.imul(al8, bl2)) | 0;
    mid = (mid + Math.imul(al8, bh2)) | 0;
    mid = (mid + Math.imul(ah8, bl2)) | 0;
    hi = (hi + Math.imul(ah8, bh2)) | 0;
    lo = (lo + Math.imul(al7, bl3)) | 0;
    mid = (mid + Math.imul(al7, bh3)) | 0;
    mid = (mid + Math.imul(ah7, bl3)) | 0;
    hi = (hi + Math.imul(ah7, bh3)) | 0;
    lo = (lo + Math.imul(al6, bl4)) | 0;
    mid = (mid + Math.imul(al6, bh4)) | 0;
    mid = (mid + Math.imul(ah6, bl4)) | 0;
    hi = (hi + Math.imul(ah6, bh4)) | 0;
    lo = (lo + Math.imul(al5, bl5)) | 0;
    mid = (mid + Math.imul(al5, bh5)) | 0;
    mid = (mid + Math.imul(ah5, bl5)) | 0;
    hi = (hi + Math.imul(ah5, bh5)) | 0;
    lo = (lo + Math.imul(al4, bl6)) | 0;
    mid = (mid + Math.imul(al4, bh6)) | 0;
    mid = (mid + Math.imul(ah4, bl6)) | 0;
    hi = (hi + Math.imul(ah4, bh6)) | 0;
    lo = (lo + Math.imul(al3, bl7)) | 0;
    mid = (mid + Math.imul(al3, bh7)) | 0;
    mid = (mid + Math.imul(ah3, bl7)) | 0;
    hi = (hi + Math.imul(ah3, bh7)) | 0;
    lo = (lo + Math.imul(al2, bl8)) | 0;
    mid = (mid + Math.imul(al2, bh8)) | 0;
    mid = (mid + Math.imul(ah2, bl8)) | 0;
    hi = (hi + Math.imul(ah2, bh8)) | 0;
    lo = (lo + Math.imul(al1, bl9)) | 0;
    mid = (mid + Math.imul(al1, bh9)) | 0;
    mid = (mid + Math.imul(ah1, bl9)) | 0;
    hi = (hi + Math.imul(ah1, bh9)) | 0;
    var w10 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w10 >>> 26)) | 0;
    w10 &= 0x3ffffff;
    /* k = 11 */
    lo = Math.imul(al9, bl2);
    mid = Math.imul(al9, bh2);
    mid = (mid + Math.imul(ah9, bl2)) | 0;
    hi = Math.imul(ah9, bh2);
    lo = (lo + Math.imul(al8, bl3)) | 0;
    mid = (mid + Math.imul(al8, bh3)) | 0;
    mid = (mid + Math.imul(ah8, bl3)) | 0;
    hi = (hi + Math.imul(ah8, bh3)) | 0;
    lo = (lo + Math.imul(al7, bl4)) | 0;
    mid = (mid + Math.imul(al7, bh4)) | 0;
    mid = (mid + Math.imul(ah7, bl4)) | 0;
    hi = (hi + Math.imul(ah7, bh4)) | 0;
    lo = (lo + Math.imul(al6, bl5)) | 0;
    mid = (mid + Math.imul(al6, bh5)) | 0;
    mid = (mid + Math.imul(ah6, bl5)) | 0;
    hi = (hi + Math.imul(ah6, bh5)) | 0;
    lo = (lo + Math.imul(al5, bl6)) | 0;
    mid = (mid + Math.imul(al5, bh6)) | 0;
    mid = (mid + Math.imul(ah5, bl6)) | 0;
    hi = (hi + Math.imul(ah5, bh6)) | 0;
    lo = (lo + Math.imul(al4, bl7)) | 0;
    mid = (mid + Math.imul(al4, bh7)) | 0;
    mid = (mid + Math.imul(ah4, bl7)) | 0;
    hi = (hi + Math.imul(ah4, bh7)) | 0;
    lo = (lo + Math.imul(al3, bl8)) | 0;
    mid = (mid + Math.imul(al3, bh8)) | 0;
    mid = (mid + Math.imul(ah3, bl8)) | 0;
    hi = (hi + Math.imul(ah3, bh8)) | 0;
    lo = (lo + Math.imul(al2, bl9)) | 0;
    mid = (mid + Math.imul(al2, bh9)) | 0;
    mid = (mid + Math.imul(ah2, bl9)) | 0;
    hi = (hi + Math.imul(ah2, bh9)) | 0;
    var w11 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w11 >>> 26)) | 0;
    w11 &= 0x3ffffff;
    /* k = 12 */
    lo = Math.imul(al9, bl3);
    mid = Math.imul(al9, bh3);
    mid = (mid + Math.imul(ah9, bl3)) | 0;
    hi = Math.imul(ah9, bh3);
    lo = (lo + Math.imul(al8, bl4)) | 0;
    mid = (mid + Math.imul(al8, bh4)) | 0;
    mid = (mid + Math.imul(ah8, bl4)) | 0;
    hi = (hi + Math.imul(ah8, bh4)) | 0;
    lo = (lo + Math.imul(al7, bl5)) | 0;
    mid = (mid + Math.imul(al7, bh5)) | 0;
    mid = (mid + Math.imul(ah7, bl5)) | 0;
    hi = (hi + Math.imul(ah7, bh5)) | 0;
    lo = (lo + Math.imul(al6, bl6)) | 0;
    mid = (mid + Math.imul(al6, bh6)) | 0;
    mid = (mid + Math.imul(ah6, bl6)) | 0;
    hi = (hi + Math.imul(ah6, bh6)) | 0;
    lo = (lo + Math.imul(al5, bl7)) | 0;
    mid = (mid + Math.imul(al5, bh7)) | 0;
    mid = (mid + Math.imul(ah5, bl7)) | 0;
    hi = (hi + Math.imul(ah5, bh7)) | 0;
    lo = (lo + Math.imul(al4, bl8)) | 0;
    mid = (mid + Math.imul(al4, bh8)) | 0;
    mid = (mid + Math.imul(ah4, bl8)) | 0;
    hi = (hi + Math.imul(ah4, bh8)) | 0;
    lo = (lo + Math.imul(al3, bl9)) | 0;
    mid = (mid + Math.imul(al3, bh9)) | 0;
    mid = (mid + Math.imul(ah3, bl9)) | 0;
    hi = (hi + Math.imul(ah3, bh9)) | 0;
    var w12 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w12 >>> 26)) | 0;
    w12 &= 0x3ffffff;
    /* k = 13 */
    lo = Math.imul(al9, bl4);
    mid = Math.imul(al9, bh4);
    mid = (mid + Math.imul(ah9, bl4)) | 0;
    hi = Math.imul(ah9, bh4);
    lo = (lo + Math.imul(al8, bl5)) | 0;
    mid = (mid + Math.imul(al8, bh5)) | 0;
    mid = (mid + Math.imul(ah8, bl5)) | 0;
    hi = (hi + Math.imul(ah8, bh5)) | 0;
    lo = (lo + Math.imul(al7, bl6)) | 0;
    mid = (mid + Math.imul(al7, bh6)) | 0;
    mid = (mid + Math.imul(ah7, bl6)) | 0;
    hi = (hi + Math.imul(ah7, bh6)) | 0;
    lo = (lo + Math.imul(al6, bl7)) | 0;
    mid = (mid + Math.imul(al6, bh7)) | 0;
    mid = (mid + Math.imul(ah6, bl7)) | 0;
    hi = (hi + Math.imul(ah6, bh7)) | 0;
    lo = (lo + Math.imul(al5, bl8)) | 0;
    mid = (mid + Math.imul(al5, bh8)) | 0;
    mid = (mid + Math.imul(ah5, bl8)) | 0;
    hi = (hi + Math.imul(ah5, bh8)) | 0;
    lo = (lo + Math.imul(al4, bl9)) | 0;
    mid = (mid + Math.imul(al4, bh9)) | 0;
    mid = (mid + Math.imul(ah4, bl9)) | 0;
    hi = (hi + Math.imul(ah4, bh9)) | 0;
    var w13 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w13 >>> 26)) | 0;
    w13 &= 0x3ffffff;
    /* k = 14 */
    lo = Math.imul(al9, bl5);
    mid = Math.imul(al9, bh5);
    mid = (mid + Math.imul(ah9, bl5)) | 0;
    hi = Math.imul(ah9, bh5);
    lo = (lo + Math.imul(al8, bl6)) | 0;
    mid = (mid + Math.imul(al8, bh6)) | 0;
    mid = (mid + Math.imul(ah8, bl6)) | 0;
    hi = (hi + Math.imul(ah8, bh6)) | 0;
    lo = (lo + Math.imul(al7, bl7)) | 0;
    mid = (mid + Math.imul(al7, bh7)) | 0;
    mid = (mid + Math.imul(ah7, bl7)) | 0;
    hi = (hi + Math.imul(ah7, bh7)) | 0;
    lo = (lo + Math.imul(al6, bl8)) | 0;
    mid = (mid + Math.imul(al6, bh8)) | 0;
    mid = (mid + Math.imul(ah6, bl8)) | 0;
    hi = (hi + Math.imul(ah6, bh8)) | 0;
    lo = (lo + Math.imul(al5, bl9)) | 0;
    mid = (mid + Math.imul(al5, bh9)) | 0;
    mid = (mid + Math.imul(ah5, bl9)) | 0;
    hi = (hi + Math.imul(ah5, bh9)) | 0;
    var w14 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w14 >>> 26)) | 0;
    w14 &= 0x3ffffff;
    /* k = 15 */
    lo = Math.imul(al9, bl6);
    mid = Math.imul(al9, bh6);
    mid = (mid + Math.imul(ah9, bl6)) | 0;
    hi = Math.imul(ah9, bh6);
    lo = (lo + Math.imul(al8, bl7)) | 0;
    mid = (mid + Math.imul(al8, bh7)) | 0;
    mid = (mid + Math.imul(ah8, bl7)) | 0;
    hi = (hi + Math.imul(ah8, bh7)) | 0;
    lo = (lo + Math.imul(al7, bl8)) | 0;
    mid = (mid + Math.imul(al7, bh8)) | 0;
    mid = (mid + Math.imul(ah7, bl8)) | 0;
    hi = (hi + Math.imul(ah7, bh8)) | 0;
    lo = (lo + Math.imul(al6, bl9)) | 0;
    mid = (mid + Math.imul(al6, bh9)) | 0;
    mid = (mid + Math.imul(ah6, bl9)) | 0;
    hi = (hi + Math.imul(ah6, bh9)) | 0;
    var w15 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w15 >>> 26)) | 0;
    w15 &= 0x3ffffff;
    /* k = 16 */
    lo = Math.imul(al9, bl7);
    mid = Math.imul(al9, bh7);
    mid = (mid + Math.imul(ah9, bl7)) | 0;
    hi = Math.imul(ah9, bh7);
    lo = (lo + Math.imul(al8, bl8)) | 0;
    mid = (mid + Math.imul(al8, bh8)) | 0;
    mid = (mid + Math.imul(ah8, bl8)) | 0;
    hi = (hi + Math.imul(ah8, bh8)) | 0;
    lo = (lo + Math.imul(al7, bl9)) | 0;
    mid = (mid + Math.imul(al7, bh9)) | 0;
    mid = (mid + Math.imul(ah7, bl9)) | 0;
    hi = (hi + Math.imul(ah7, bh9)) | 0;
    var w16 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w16 >>> 26)) | 0;
    w16 &= 0x3ffffff;
    /* k = 17 */
    lo = Math.imul(al9, bl8);
    mid = Math.imul(al9, bh8);
    mid = (mid + Math.imul(ah9, bl8)) | 0;
    hi = Math.imul(ah9, bh8);
    lo = (lo + Math.imul(al8, bl9)) | 0;
    mid = (mid + Math.imul(al8, bh9)) | 0;
    mid = (mid + Math.imul(ah8, bl9)) | 0;
    hi = (hi + Math.imul(ah8, bh9)) | 0;
    var w17 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w17 >>> 26)) | 0;
    w17 &= 0x3ffffff;
    /* k = 18 */
    lo = Math.imul(al9, bl9);
    mid = Math.imul(al9, bh9);
    mid = (mid + Math.imul(ah9, bl9)) | 0;
    hi = Math.imul(ah9, bh9);
    var w18 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w18 >>> 26)) | 0;
    w18 &= 0x3ffffff;
    o[0] = w0;
    o[1] = w1;
    o[2] = w2;
    o[3] = w3;
    o[4] = w4;
    o[5] = w5;
    o[6] = w6;
    o[7] = w7;
    o[8] = w8;
    o[9] = w9;
    o[10] = w10;
    o[11] = w11;
    o[12] = w12;
    o[13] = w13;
    o[14] = w14;
    o[15] = w15;
    o[16] = w16;
    o[17] = w17;
    o[18] = w18;
    if (c !== 0) {
      o[19] = c;
      out.length++;
    }
    return out;
  };

  // Polyfill comb
  if (!Math.imul) {
    comb10MulTo = smallMulTo;
  }

  function bigMulTo (self, num, out) {
    out.negative = num.negative ^ self.negative;
    out.length = self.length + num.length;

    var carry = 0;
    var hncarry = 0;
    for (var k = 0; k < out.length - 1; k++) {
      // Sum all words with the same `i + j = k` and accumulate `ncarry`,
      // note that ncarry could be >= 0x3ffffff
      var ncarry = hncarry;
      hncarry = 0;
      var rword = carry & 0x3ffffff;
      var maxJ = Math.min(k, num.length - 1);
      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
        var i = k - j;
        var a = self.words[i] | 0;
        var b = num.words[j] | 0;
        var r = a * b;

        var lo = r & 0x3ffffff;
        ncarry = (ncarry + ((r / 0x4000000) | 0)) | 0;
        lo = (lo + rword) | 0;
        rword = lo & 0x3ffffff;
        ncarry = (ncarry + (lo >>> 26)) | 0;

        hncarry += ncarry >>> 26;
        ncarry &= 0x3ffffff;
      }
      out.words[k] = rword;
      carry = ncarry;
      ncarry = hncarry;
    }
    if (carry !== 0) {
      out.words[k] = carry;
    } else {
      out.length--;
    }

    return out._strip();
  }

  function jumboMulTo (self, num, out) {
    // Temporary disable, see https://github.com/indutny/bn.js/issues/211
    // var fftm = new FFTM();
    // return fftm.mulp(self, num, out);
    return bigMulTo(self, num, out);
  }

  BN.prototype.mulTo = function mulTo (num, out) {
    var res;
    var len = this.length + num.length;
    if (this.length === 10 && num.length === 10) {
      res = comb10MulTo(this, num, out);
    } else if (len < 63) {
      res = smallMulTo(this, num, out);
    } else if (len < 1024) {
      res = bigMulTo(this, num, out);
    } else {
      res = jumboMulTo(this, num, out);
    }

    return res;
  };

  // Cooley-Tukey algorithm for FFT
  // slightly revisited to rely on looping instead of recursion

  function FFTM (x, y) {
    this.x = x;
    this.y = y;
  }

  FFTM.prototype.makeRBT = function makeRBT (N) {
    var t = new Array(N);
    var l = BN.prototype._countBits(N) - 1;
    for (var i = 0; i < N; i++) {
      t[i] = this.revBin(i, l, N);
    }

    return t;
  };

  // Returns binary-reversed representation of `x`
  FFTM.prototype.revBin = function revBin (x, l, N) {
    if (x === 0 || x === N - 1) return x;

    var rb = 0;
    for (var i = 0; i < l; i++) {
      rb |= (x & 1) << (l - i - 1);
      x >>= 1;
    }

    return rb;
  };

  // Performs "tweedling" phase, therefore 'emulating'
  // behaviour of the recursive algorithm
  FFTM.prototype.permute = function permute (rbt, rws, iws, rtws, itws, N) {
    for (var i = 0; i < N; i++) {
      rtws[i] = rws[rbt[i]];
      itws[i] = iws[rbt[i]];
    }
  };

  FFTM.prototype.transform = function transform (rws, iws, rtws, itws, N, rbt) {
    this.permute(rbt, rws, iws, rtws, itws, N);

    for (var s = 1; s < N; s <<= 1) {
      var l = s << 1;

      var rtwdf = Math.cos(2 * Math.PI / l);
      var itwdf = Math.sin(2 * Math.PI / l);

      for (var p = 0; p < N; p += l) {
        var rtwdf_ = rtwdf;
        var itwdf_ = itwdf;

        for (var j = 0; j < s; j++) {
          var re = rtws[p + j];
          var ie = itws[p + j];

          var ro = rtws[p + j + s];
          var io = itws[p + j + s];

          var rx = rtwdf_ * ro - itwdf_ * io;

          io = rtwdf_ * io + itwdf_ * ro;
          ro = rx;

          rtws[p + j] = re + ro;
          itws[p + j] = ie + io;

          rtws[p + j + s] = re - ro;
          itws[p + j + s] = ie - io;

          /* jshint maxdepth : false */
          if (j !== l) {
            rx = rtwdf * rtwdf_ - itwdf * itwdf_;

            itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
            rtwdf_ = rx;
          }
        }
      }
    }
  };

  FFTM.prototype.guessLen13b = function guessLen13b (n, m) {
    var N = Math.max(m, n) | 1;
    var odd = N & 1;
    var i = 0;
    for (N = N / 2 | 0; N; N = N >>> 1) {
      i++;
    }

    return 1 << i + 1 + odd;
  };

  FFTM.prototype.conjugate = function conjugate (rws, iws, N) {
    if (N <= 1) return;

    for (var i = 0; i < N / 2; i++) {
      var t = rws[i];

      rws[i] = rws[N - i - 1];
      rws[N - i - 1] = t;

      t = iws[i];

      iws[i] = -iws[N - i - 1];
      iws[N - i - 1] = -t;
    }
  };

  FFTM.prototype.normalize13b = function normalize13b (ws, N) {
    var carry = 0;
    for (var i = 0; i < N / 2; i++) {
      var w = Math.round(ws[2 * i + 1] / N) * 0x2000 +
        Math.round(ws[2 * i] / N) +
        carry;

      ws[i] = w & 0x3ffffff;

      if (w < 0x4000000) {
        carry = 0;
      } else {
        carry = w / 0x4000000 | 0;
      }
    }

    return ws;
  };

  FFTM.prototype.convert13b = function convert13b (ws, len, rws, N) {
    var carry = 0;
    for (var i = 0; i < len; i++) {
      carry = carry + (ws[i] | 0);

      rws[2 * i] = carry & 0x1fff; carry = carry >>> 13;
      rws[2 * i + 1] = carry & 0x1fff; carry = carry >>> 13;
    }

    // Pad with zeroes
    for (i = 2 * len; i < N; ++i) {
      rws[i] = 0;
    }

    assert(carry === 0);
    assert((carry & ~0x1fff) === 0);
  };

  FFTM.prototype.stub = function stub (N) {
    var ph = new Array(N);
    for (var i = 0; i < N; i++) {
      ph[i] = 0;
    }

    return ph;
  };

  FFTM.prototype.mulp = function mulp (x, y, out) {
    var N = 2 * this.guessLen13b(x.length, y.length);

    var rbt = this.makeRBT(N);

    var _ = this.stub(N);

    var rws = new Array(N);
    var rwst = new Array(N);
    var iwst = new Array(N);

    var nrws = new Array(N);
    var nrwst = new Array(N);
    var niwst = new Array(N);

    var rmws = out.words;
    rmws.length = N;

    this.convert13b(x.words, x.length, rws, N);
    this.convert13b(y.words, y.length, nrws, N);

    this.transform(rws, _, rwst, iwst, N, rbt);
    this.transform(nrws, _, nrwst, niwst, N, rbt);

    for (var i = 0; i < N; i++) {
      var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];
      iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];
      rwst[i] = rx;
    }

    this.conjugate(rwst, iwst, N);
    this.transform(rwst, iwst, rmws, _, N, rbt);
    this.conjugate(rmws, _, N);
    this.normalize13b(rmws, N);

    out.negative = x.negative ^ y.negative;
    out.length = x.length + y.length;
    return out._strip();
  };

  // Multiply `this` by `num`
  BN.prototype.mul = function mul (num) {
    var out = new BN(null);
    out.words = new Array(this.length + num.length);
    return this.mulTo(num, out);
  };

  // Multiply employing FFT
  BN.prototype.mulf = function mulf (num) {
    var out = new BN(null);
    out.words = new Array(this.length + num.length);
    return jumboMulTo(this, num, out);
  };

  // In-place Multiplication
  BN.prototype.imul = function imul (num) {
    return this.clone().mulTo(num, this);
  };

  BN.prototype.imuln = function imuln (num) {
    var isNegNum = num < 0;
    if (isNegNum) num = -num;

    assert(typeof num === 'number');
    assert(num < 0x4000000);

    // Carry
    var carry = 0;
    for (var i = 0; i < this.length; i++) {
      var w = (this.words[i] | 0) * num;
      var lo = (w & 0x3ffffff) + (carry & 0x3ffffff);
      carry >>= 26;
      carry += (w / 0x4000000) | 0;
      // NOTE: lo is 27bit maximum
      carry += lo >>> 26;
      this.words[i] = lo & 0x3ffffff;
    }

    if (carry !== 0) {
      this.words[i] = carry;
      this.length++;
    }

    return isNegNum ? this.ineg() : this;
  };

  BN.prototype.muln = function muln (num) {
    return this.clone().imuln(num);
  };

  // `this` * `this`
  BN.prototype.sqr = function sqr () {
    return this.mul(this);
  };

  // `this` * `this` in-place
  BN.prototype.isqr = function isqr () {
    return this.imul(this.clone());
  };

  // Math.pow(`this`, `num`)
  BN.prototype.pow = function pow (num) {
    var w = toBitArray(num);
    if (w.length === 0) return new BN(1);

    // Skip leading zeroes
    var res = this;
    for (var i = 0; i < w.length; i++, res = res.sqr()) {
      if (w[i] !== 0) break;
    }

    if (++i < w.length) {
      for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {
        if (w[i] === 0) continue;

        res = res.mul(q);
      }
    }

    return res;
  };

  // Shift-left in-place
  BN.prototype.iushln = function iushln (bits) {
    assert(typeof bits === 'number' && bits >= 0);
    var r = bits % 26;
    var s = (bits - r) / 26;
    var carryMask = (0x3ffffff >>> (26 - r)) << (26 - r);
    var i;

    if (r !== 0) {
      var carry = 0;

      for (i = 0; i < this.length; i++) {
        var newCarry = this.words[i] & carryMask;
        var c = ((this.words[i] | 0) - newCarry) << r;
        this.words[i] = c | carry;
        carry = newCarry >>> (26 - r);
      }

      if (carry) {
        this.words[i] = carry;
        this.length++;
      }
    }

    if (s !== 0) {
      for (i = this.length - 1; i >= 0; i--) {
        this.words[i + s] = this.words[i];
      }

      for (i = 0; i < s; i++) {
        this.words[i] = 0;
      }

      this.length += s;
    }

    return this._strip();
  };

  BN.prototype.ishln = function ishln (bits) {
    // TODO(indutny): implement me
    assert(this.negative === 0);
    return this.iushln(bits);
  };

  // Shift-right in-place
  // NOTE: `hint` is a lowest bit before trailing zeroes
  // NOTE: if `extended` is present - it will be filled with destroyed bits
  BN.prototype.iushrn = function iushrn (bits, hint, extended) {
    assert(typeof bits === 'number' && bits >= 0);
    var h;
    if (hint) {
      h = (hint - (hint % 26)) / 26;
    } else {
      h = 0;
    }

    var r = bits % 26;
    var s = Math.min((bits - r) / 26, this.length);
    var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);
    var maskedWords = extended;

    h -= s;
    h = Math.max(0, h);

    // Extended mode, copy masked part
    if (maskedWords) {
      for (var i = 0; i < s; i++) {
        maskedWords.words[i] = this.words[i];
      }
      maskedWords.length = s;
    }

    if (s === 0) {
      // No-op, we should not move anything at all
    } else if (this.length > s) {
      this.length -= s;
      for (i = 0; i < this.length; i++) {
        this.words[i] = this.words[i + s];
      }
    } else {
      this.words[0] = 0;
      this.length = 1;
    }

    var carry = 0;
    for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {
      var word = this.words[i] | 0;
      this.words[i] = (carry << (26 - r)) | (word >>> r);
      carry = word & mask;
    }

    // Push carried bits as a mask
    if (maskedWords && carry !== 0) {
      maskedWords.words[maskedWords.length++] = carry;
    }

    if (this.length === 0) {
      this.words[0] = 0;
      this.length = 1;
    }

    return this._strip();
  };

  BN.prototype.ishrn = function ishrn (bits, hint, extended) {
    // TODO(indutny): implement me
    assert(this.negative === 0);
    return this.iushrn(bits, hint, extended);
  };

  // Shift-left
  BN.prototype.shln = function shln (bits) {
    return this.clone().ishln(bits);
  };

  BN.prototype.ushln = function ushln (bits) {
    return this.clone().iushln(bits);
  };

  // Shift-right
  BN.prototype.shrn = function shrn (bits) {
    return this.clone().ishrn(bits);
  };

  BN.prototype.ushrn = function ushrn (bits) {
    return this.clone().iushrn(bits);
  };

  // Test if n bit is set
  BN.prototype.testn = function testn (bit) {
    assert(typeof bit === 'number' && bit >= 0);
    var r = bit % 26;
    var s = (bit - r) / 26;
    var q = 1 << r;

    // Fast case: bit is much higher than all existing words
    if (this.length <= s) return false;

    // Check bit and return
    var w = this.words[s];

    return !!(w & q);
  };

  // Return only lowers bits of number (in-place)
  BN.prototype.imaskn = function imaskn (bits) {
    assert(typeof bits === 'number' && bits >= 0);
    var r = bits % 26;
    var s = (bits - r) / 26;

    assert(this.negative === 0, 'imaskn works only with positive numbers');

    if (this.length <= s) {
      return this;
    }

    if (r !== 0) {
      s++;
    }
    this.length = Math.min(s, this.length);

    if (r !== 0) {
      var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);
      this.words[this.length - 1] &= mask;
    }

    return this._strip();
  };

  // Return only lowers bits of number
  BN.prototype.maskn = function maskn (bits) {
    return this.clone().imaskn(bits);
  };

  // Add plain number `num` to `this`
  BN.prototype.iaddn = function iaddn (num) {
    assert(typeof num === 'number');
    assert(num < 0x4000000);
    if (num < 0) return this.isubn(-num);

    // Possible sign change
    if (this.negative !== 0) {
      if (this.length === 1 && (this.words[0] | 0) <= num) {
        this.words[0] = num - (this.words[0] | 0);
        this.negative = 0;
        return this;
      }

      this.negative = 0;
      this.isubn(num);
      this.negative = 1;
      return this;
    }

    // Add without checks
    return this._iaddn(num);
  };

  BN.prototype._iaddn = function _iaddn (num) {
    this.words[0] += num;

    // Carry
    for (var i = 0; i < this.length && this.words[i] >= 0x4000000; i++) {
      this.words[i] -= 0x4000000;
      if (i === this.length - 1) {
        this.words[i + 1] = 1;
      } else {
        this.words[i + 1]++;
      }
    }
    this.length = Math.max(this.length, i + 1);

    return this;
  };

  // Subtract plain number `num` from `this`
  BN.prototype.isubn = function isubn (num) {
    assert(typeof num === 'number');
    assert(num < 0x4000000);
    if (num < 0) return this.iaddn(-num);

    if (this.negative !== 0) {
      this.negative = 0;
      this.iaddn(num);
      this.negative = 1;
      return this;
    }

    this.words[0] -= num;

    if (this.length === 1 && this.words[0] < 0) {
      this.words[0] = -this.words[0];
      this.negative = 1;
    } else {
      // Carry
      for (var i = 0; i < this.length && this.words[i] < 0; i++) {
        this.words[i] += 0x4000000;
        this.words[i + 1] -= 1;
      }
    }

    return this._strip();
  };

  BN.prototype.addn = function addn (num) {
    return this.clone().iaddn(num);
  };

  BN.prototype.subn = function subn (num) {
    return this.clone().isubn(num);
  };

  BN.prototype.iabs = function iabs () {
    this.negative = 0;

    return this;
  };

  BN.prototype.abs = function abs () {
    return this.clone().iabs();
  };

  BN.prototype._ishlnsubmul = function _ishlnsubmul (num, mul, shift) {
    var len = num.length + shift;
    var i;

    this._expand(len);

    var w;
    var carry = 0;
    for (i = 0; i < num.length; i++) {
      w = (this.words[i + shift] | 0) + carry;
      var right = (num.words[i] | 0) * mul;
      w -= right & 0x3ffffff;
      carry = (w >> 26) - ((right / 0x4000000) | 0);
      this.words[i + shift] = w & 0x3ffffff;
    }
    for (; i < this.length - shift; i++) {
      w = (this.words[i + shift] | 0) + carry;
      carry = w >> 26;
      this.words[i + shift] = w & 0x3ffffff;
    }

    if (carry === 0) return this._strip();

    // Subtraction overflow
    assert(carry === -1);
    carry = 0;
    for (i = 0; i < this.length; i++) {
      w = -(this.words[i] | 0) + carry;
      carry = w >> 26;
      this.words[i] = w & 0x3ffffff;
    }
    this.negative = 1;

    return this._strip();
  };

  BN.prototype._wordDiv = function _wordDiv (num, mode) {
    var shift = this.length - num.length;

    var a = this.clone();
    var b = num;

    // Normalize
    var bhi = b.words[b.length - 1] | 0;
    var bhiBits = this._countBits(bhi);
    shift = 26 - bhiBits;
    if (shift !== 0) {
      b = b.ushln(shift);
      a.iushln(shift);
      bhi = b.words[b.length - 1] | 0;
    }

    // Initialize quotient
    var m = a.length - b.length;
    var q;

    if (mode !== 'mod') {
      q = new BN(null);
      q.length = m + 1;
      q.words = new Array(q.length);
      for (var i = 0; i < q.length; i++) {
        q.words[i] = 0;
      }
    }

    var diff = a.clone()._ishlnsubmul(b, 1, m);
    if (diff.negative === 0) {
      a = diff;
      if (q) {
        q.words[m] = 1;
      }
    }

    for (var j = m - 1; j >= 0; j--) {
      var qj = (a.words[b.length + j] | 0) * 0x4000000 +
        (a.words[b.length + j - 1] | 0);

      // NOTE: (qj / bhi) is (0x3ffffff * 0x4000000 + 0x3ffffff) / 0x2000000 max
      // (0x7ffffff)
      qj = Math.min((qj / bhi) | 0, 0x3ffffff);

      a._ishlnsubmul(b, qj, j);
      while (a.negative !== 0) {
        qj--;
        a.negative = 0;
        a._ishlnsubmul(b, 1, j);
        if (!a.isZero()) {
          a.negative ^= 1;
        }
      }
      if (q) {
        q.words[j] = qj;
      }
    }
    if (q) {
      q._strip();
    }
    a._strip();

    // Denormalize
    if (mode !== 'div' && shift !== 0) {
      a.iushrn(shift);
    }

    return {
      div: q || null,
      mod: a
    };
  };

  // NOTE: 1) `mode` can be set to `mod` to request mod only,
  //       to `div` to request div only, or be absent to
  //       request both div & mod
  //       2) `positive` is true if unsigned mod is requested
  BN.prototype.divmod = function divmod (num, mode, positive) {
    assert(!num.isZero());

    if (this.isZero()) {
      return {
        div: new BN(0),
        mod: new BN(0)
      };
    }

    var div, mod, res;
    if (this.negative !== 0 && num.negative === 0) {
      res = this.neg().divmod(num, mode);

      if (mode !== 'mod') {
        div = res.div.neg();
      }

      if (mode !== 'div') {
        mod = res.mod.neg();
        if (positive && mod.negative !== 0) {
          mod.iadd(num);
        }
      }

      return {
        div: div,
        mod: mod
      };
    }

    if (this.negative === 0 && num.negative !== 0) {
      res = this.divmod(num.neg(), mode);

      if (mode !== 'mod') {
        div = res.div.neg();
      }

      return {
        div: div,
        mod: res.mod
      };
    }

    if ((this.negative & num.negative) !== 0) {
      res = this.neg().divmod(num.neg(), mode);

      if (mode !== 'div') {
        mod = res.mod.neg();
        if (positive && mod.negative !== 0) {
          mod.isub(num);
        }
      }

      return {
        div: res.div,
        mod: mod
      };
    }

    // Both numbers are positive at this point

    // Strip both numbers to approximate shift value
    if (num.length > this.length || this.cmp(num) < 0) {
      return {
        div: new BN(0),
        mod: this
      };
    }

    // Very short reduction
    if (num.length === 1) {
      if (mode === 'div') {
        return {
          div: this.divn(num.words[0]),
          mod: null
        };
      }

      if (mode === 'mod') {
        return {
          div: null,
          mod: new BN(this.modrn(num.words[0]))
        };
      }

      return {
        div: this.divn(num.words[0]),
        mod: new BN(this.modrn(num.words[0]))
      };
    }

    return this._wordDiv(num, mode);
  };

  // Find `this` / `num`
  BN.prototype.div = function div (num) {
    return this.divmod(num, 'div', false).div;
  };

  // Find `this` % `num`
  BN.prototype.mod = function mod (num) {
    return this.divmod(num, 'mod', false).mod;
  };

  BN.prototype.umod = function umod (num) {
    return this.divmod(num, 'mod', true).mod;
  };

  // Find Round(`this` / `num`)
  BN.prototype.divRound = function divRound (num) {
    var dm = this.divmod(num);

    // Fast case - exact division
    if (dm.mod.isZero()) return dm.div;

    var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;

    var half = num.ushrn(1);
    var r2 = num.andln(1);
    var cmp = mod.cmp(half);

    // Round down
    if (cmp < 0 || (r2 === 1 && cmp === 0)) return dm.div;

    // Round up
    return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
  };

  BN.prototype.modrn = function modrn (num) {
    var isNegNum = num < 0;
    if (isNegNum) num = -num;

    assert(num <= 0x3ffffff);
    var p = (1 << 26) % num;

    var acc = 0;
    for (var i = this.length - 1; i >= 0; i--) {
      acc = (p * acc + (this.words[i] | 0)) % num;
    }

    return isNegNum ? -acc : acc;
  };

  // WARNING: DEPRECATED
  BN.prototype.modn = function modn (num) {
    return this.modrn(num);
  };

  // In-place division by number
  BN.prototype.idivn = function idivn (num) {
    var isNegNum = num < 0;
    if (isNegNum) num = -num;

    assert(num <= 0x3ffffff);

    var carry = 0;
    for (var i = this.length - 1; i >= 0; i--) {
      var w = (this.words[i] | 0) + carry * 0x4000000;
      this.words[i] = (w / num) | 0;
      carry = w % num;
    }

    this._strip();
    return isNegNum ? this.ineg() : this;
  };

  BN.prototype.divn = function divn (num) {
    return this.clone().idivn(num);
  };

  BN.prototype.egcd = function egcd (p) {
    assert(p.negative === 0);
    assert(!p.isZero());

    var x = this;
    var y = p.clone();

    if (x.negative !== 0) {
      x = x.umod(p);
    } else {
      x = x.clone();
    }

    // A * x + B * y = x
    var A = new BN(1);
    var B = new BN(0);

    // C * x + D * y = y
    var C = new BN(0);
    var D = new BN(1);

    var g = 0;

    while (x.isEven() && y.isEven()) {
      x.iushrn(1);
      y.iushrn(1);
      ++g;
    }

    var yp = y.clone();
    var xp = x.clone();

    while (!x.isZero()) {
      for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
      if (i > 0) {
        x.iushrn(i);
        while (i-- > 0) {
          if (A.isOdd() || B.isOdd()) {
            A.iadd(yp);
            B.isub(xp);
          }

          A.iushrn(1);
          B.iushrn(1);
        }
      }

      for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
      if (j > 0) {
        y.iushrn(j);
        while (j-- > 0) {
          if (C.isOdd() || D.isOdd()) {
            C.iadd(yp);
            D.isub(xp);
          }

          C.iushrn(1);
          D.iushrn(1);
        }
      }

      if (x.cmp(y) >= 0) {
        x.isub(y);
        A.isub(C);
        B.isub(D);
      } else {
        y.isub(x);
        C.isub(A);
        D.isub(B);
      }
    }

    return {
      a: C,
      b: D,
      gcd: y.iushln(g)
    };
  };

  // This is reduced incarnation of the binary EEA
  // above, designated to invert members of the
  // _prime_ fields F(p) at a maximal speed
  BN.prototype._invmp = function _invmp (p) {
    assert(p.negative === 0);
    assert(!p.isZero());

    var a = this;
    var b = p.clone();

    if (a.negative !== 0) {
      a = a.umod(p);
    } else {
      a = a.clone();
    }

    var x1 = new BN(1);
    var x2 = new BN(0);

    var delta = b.clone();

    while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
      for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
      if (i > 0) {
        a.iushrn(i);
        while (i-- > 0) {
          if (x1.isOdd()) {
            x1.iadd(delta);
          }

          x1.iushrn(1);
        }
      }

      for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
      if (j > 0) {
        b.iushrn(j);
        while (j-- > 0) {
          if (x2.isOdd()) {
            x2.iadd(delta);
          }

          x2.iushrn(1);
        }
      }

      if (a.cmp(b) >= 0) {
        a.isub(b);
        x1.isub(x2);
      } else {
        b.isub(a);
        x2.isub(x1);
      }
    }

    var res;
    if (a.cmpn(1) === 0) {
      res = x1;
    } else {
      res = x2;
    }

    if (res.cmpn(0) < 0) {
      res.iadd(p);
    }

    return res;
  };

  BN.prototype.gcd = function gcd (num) {
    if (this.isZero()) return num.abs();
    if (num.isZero()) return this.abs();

    var a = this.clone();
    var b = num.clone();
    a.negative = 0;
    b.negative = 0;

    // Remove common factor of two
    for (var shift = 0; a.isEven() && b.isEven(); shift++) {
      a.iushrn(1);
      b.iushrn(1);
    }

    do {
      while (a.isEven()) {
        a.iushrn(1);
      }
      while (b.isEven()) {
        b.iushrn(1);
      }

      var r = a.cmp(b);
      if (r < 0) {
        // Swap `a` and `b` to make `a` always bigger than `b`
        var t = a;
        a = b;
        b = t;
      } else if (r === 0 || b.cmpn(1) === 0) {
        break;
      }

      a.isub(b);
    } while (true);

    return b.iushln(shift);
  };

  // Invert number in the field F(num)
  BN.prototype.invm = function invm (num) {
    return this.egcd(num).a.umod(num);
  };

  BN.prototype.isEven = function isEven () {
    return (this.words[0] & 1) === 0;
  };

  BN.prototype.isOdd = function isOdd () {
    return (this.words[0] & 1) === 1;
  };

  // And first word and num
  BN.prototype.andln = function andln (num) {
    return this.words[0] & num;
  };

  // Increment at the bit position in-line
  BN.prototype.bincn = function bincn (bit) {
    assert(typeof bit === 'number');
    var r = bit % 26;
    var s = (bit - r) / 26;
    var q = 1 << r;

    // Fast case: bit is much higher than all existing words
    if (this.length <= s) {
      this._expand(s + 1);
      this.words[s] |= q;
      return this;
    }

    // Add bit and propagate, if needed
    var carry = q;
    for (var i = s; carry !== 0 && i < this.length; i++) {
      var w = this.words[i] | 0;
      w += carry;
      carry = w >>> 26;
      w &= 0x3ffffff;
      this.words[i] = w;
    }
    if (carry !== 0) {
      this.words[i] = carry;
      this.length++;
    }
    return this;
  };

  BN.prototype.isZero = function isZero () {
    return this.length === 1 && this.words[0] === 0;
  };

  BN.prototype.cmpn = function cmpn (num) {
    var negative = num < 0;

    if (this.negative !== 0 && !negative) return -1;
    if (this.negative === 0 && negative) return 1;

    this._strip();

    var res;
    if (this.length > 1) {
      res = 1;
    } else {
      if (negative) {
        num = -num;
      }

      assert(num <= 0x3ffffff, 'Number is too big');

      var w = this.words[0] | 0;
      res = w === num ? 0 : w < num ? -1 : 1;
    }
    if (this.negative !== 0) return -res | 0;
    return res;
  };

  // Compare two numbers and return:
  // 1 - if `this` > `num`
  // 0 - if `this` == `num`
  // -1 - if `this` < `num`
  BN.prototype.cmp = function cmp (num) {
    if (this.negative !== 0 && num.negative === 0) return -1;
    if (this.negative === 0 && num.negative !== 0) return 1;

    var res = this.ucmp(num);
    if (this.negative !== 0) return -res | 0;
    return res;
  };

  // Unsigned comparison
  BN.prototype.ucmp = function ucmp (num) {
    // At this point both numbers have the same sign
    if (this.length > num.length) return 1;
    if (this.length < num.length) return -1;

    var res = 0;
    for (var i = this.length - 1; i >= 0; i--) {
      var a = this.words[i] | 0;
      var b = num.words[i] | 0;

      if (a === b) continue;
      if (a < b) {
        res = -1;
      } else if (a > b) {
        res = 1;
      }
      break;
    }
    return res;
  };

  BN.prototype.gtn = function gtn (num) {
    return this.cmpn(num) === 1;
  };

  BN.prototype.gt = function gt (num) {
    return this.cmp(num) === 1;
  };

  BN.prototype.gten = function gten (num) {
    return this.cmpn(num) >= 0;
  };

  BN.prototype.gte = function gte (num) {
    return this.cmp(num) >= 0;
  };

  BN.prototype.ltn = function ltn (num) {
    return this.cmpn(num) === -1;
  };

  BN.prototype.lt = function lt (num) {
    return this.cmp(num) === -1;
  };

  BN.prototype.lten = function lten (num) {
    return this.cmpn(num) <= 0;
  };

  BN.prototype.lte = function lte (num) {
    return this.cmp(num) <= 0;
  };

  BN.prototype.eqn = function eqn (num) {
    return this.cmpn(num) === 0;
  };

  BN.prototype.eq = function eq (num) {
    return this.cmp(num) === 0;
  };

  //
  // A reduce context, could be using montgomery or something better, depending
  // on the `m` itself.
  //
  BN.red = function red (num) {
    return new Red(num);
  };

  BN.prototype.toRed = function toRed (ctx) {
    assert(!this.red, 'Already a number in reduction context');
    assert(this.negative === 0, 'red works only with positives');
    return ctx.convertTo(this)._forceRed(ctx);
  };

  BN.prototype.fromRed = function fromRed () {
    assert(this.red, 'fromRed works only with numbers in reduction context');
    return this.red.convertFrom(this);
  };

  BN.prototype._forceRed = function _forceRed (ctx) {
    this.red = ctx;
    return this;
  };

  BN.prototype.forceRed = function forceRed (ctx) {
    assert(!this.red, 'Already a number in reduction context');
    return this._forceRed(ctx);
  };

  BN.prototype.redAdd = function redAdd (num) {
    assert(this.red, 'redAdd works only with red numbers');
    return this.red.add(this, num);
  };

  BN.prototype.redIAdd = function redIAdd (num) {
    assert(this.red, 'redIAdd works only with red numbers');
    return this.red.iadd(this, num);
  };

  BN.prototype.redSub = function redSub (num) {
    assert(this.red, 'redSub works only with red numbers');
    return this.red.sub(this, num);
  };

  BN.prototype.redISub = function redISub (num) {
    assert(this.red, 'redISub works only with red numbers');
    return this.red.isub(this, num);
  };

  BN.prototype.redShl = function redShl (num) {
    assert(this.red, 'redShl works only with red numbers');
    return this.red.shl(this, num);
  };

  BN.prototype.redMul = function redMul (num) {
    assert(this.red, 'redMul works only with red numbers');
    this.red._verify2(this, num);
    return this.red.mul(this, num);
  };

  BN.prototype.redIMul = function redIMul (num) {
    assert(this.red, 'redMul works only with red numbers');
    this.red._verify2(this, num);
    return this.red.imul(this, num);
  };

  BN.prototype.redSqr = function redSqr () {
    assert(this.red, 'redSqr works only with red numbers');
    this.red._verify1(this);
    return this.red.sqr(this);
  };

  BN.prototype.redISqr = function redISqr () {
    assert(this.red, 'redISqr works only with red numbers');
    this.red._verify1(this);
    return this.red.isqr(this);
  };

  // Square root over p
  BN.prototype.redSqrt = function redSqrt () {
    assert(this.red, 'redSqrt works only with red numbers');
    this.red._verify1(this);
    return this.red.sqrt(this);
  };

  BN.prototype.redInvm = function redInvm () {
    assert(this.red, 'redInvm works only with red numbers');
    this.red._verify1(this);
    return this.red.invm(this);
  };

  // Return negative clone of `this` % `red modulo`
  BN.prototype.redNeg = function redNeg () {
    assert(this.red, 'redNeg works only with red numbers');
    this.red._verify1(this);
    return this.red.neg(this);
  };

  BN.prototype.redPow = function redPow (num) {
    assert(this.red && !num.red, 'redPow(normalNum)');
    this.red._verify1(this);
    return this.red.pow(this, num);
  };

  // Prime numbers with efficient reduction
  var primes = {
    k256: null,
    p224: null,
    p192: null,
    p25519: null
  };

  // Pseudo-Mersenne prime
  function MPrime (name, p) {
    // P = 2 ^ N - K
    this.name = name;
    this.p = new BN(p, 16);
    this.n = this.p.bitLength();
    this.k = new BN(1).iushln(this.n).isub(this.p);

    this.tmp = this._tmp();
  }

  MPrime.prototype._tmp = function _tmp () {
    var tmp = new BN(null);
    tmp.words = new Array(Math.ceil(this.n / 13));
    return tmp;
  };

  MPrime.prototype.ireduce = function ireduce (num) {
    // Assumes that `num` is less than `P^2`
    // num = HI * (2 ^ N - K) + HI * K + LO = HI * K + LO (mod P)
    var r = num;
    var rlen;

    do {
      this.split(r, this.tmp);
      r = this.imulK(r);
      r = r.iadd(this.tmp);
      rlen = r.bitLength();
    } while (rlen > this.n);

    var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
    if (cmp === 0) {
      r.words[0] = 0;
      r.length = 1;
    } else if (cmp > 0) {
      r.isub(this.p);
    } else {
      if (r.strip !== undefined) {
        // r is a BN v4 instance
        r.strip();
      } else {
        // r is a BN v5 instance
        r._strip();
      }
    }

    return r;
  };

  MPrime.prototype.split = function split (input, out) {
    input.iushrn(this.n, 0, out);
  };

  MPrime.prototype.imulK = function imulK (num) {
    return num.imul(this.k);
  };

  function K256 () {
    MPrime.call(
      this,
      'k256',
      'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f');
  }
  inherits(K256, MPrime);

  K256.prototype.split = function split (input, output) {
    // 256 = 9 * 26 + 22
    var mask = 0x3fffff;

    var outLen = Math.min(input.length, 9);
    for (var i = 0; i < outLen; i++) {
      output.words[i] = input.words[i];
    }
    output.length = outLen;

    if (input.length <= 9) {
      input.words[0] = 0;
      input.length = 1;
      return;
    }

    // Shift by 9 limbs
    var prev = input.words[9];
    output.words[output.length++] = prev & mask;

    for (i = 10; i < input.length; i++) {
      var next = input.words[i] | 0;
      input.words[i - 10] = ((next & mask) << 4) | (prev >>> 22);
      prev = next;
    }
    prev >>>= 22;
    input.words[i - 10] = prev;
    if (prev === 0 && input.length > 10) {
      input.length -= 10;
    } else {
      input.length -= 9;
    }
  };

  K256.prototype.imulK = function imulK (num) {
    // K = 0x1000003d1 = [ 0x40, 0x3d1 ]
    num.words[num.length] = 0;
    num.words[num.length + 1] = 0;
    num.length += 2;

    // bounded at: 0x40 * 0x3ffffff + 0x3d0 = 0x100000390
    var lo = 0;
    for (var i = 0; i < num.length; i++) {
      var w = num.words[i] | 0;
      lo += w * 0x3d1;
      num.words[i] = lo & 0x3ffffff;
      lo = w * 0x40 + ((lo / 0x4000000) | 0);
    }

    // Fast length reduction
    if (num.words[num.length - 1] === 0) {
      num.length--;
      if (num.words[num.length - 1] === 0) {
        num.length--;
      }
    }
    return num;
  };

  function P224 () {
    MPrime.call(
      this,
      'p224',
      'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001');
  }
  inherits(P224, MPrime);

  function P192 () {
    MPrime.call(
      this,
      'p192',
      'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff');
  }
  inherits(P192, MPrime);

  function P25519 () {
    // 2 ^ 255 - 19
    MPrime.call(
      this,
      '25519',
      '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed');
  }
  inherits(P25519, MPrime);

  P25519.prototype.imulK = function imulK (num) {
    // K = 0x13
    var carry = 0;
    for (var i = 0; i < num.length; i++) {
      var hi = (num.words[i] | 0) * 0x13 + carry;
      var lo = hi & 0x3ffffff;
      hi >>>= 26;

      num.words[i] = lo;
      carry = hi;
    }
    if (carry !== 0) {
      num.words[num.length++] = carry;
    }
    return num;
  };

  // Exported mostly for testing purposes, use plain name instead
  BN._prime = function prime (name) {
    // Cached version of prime
    if (primes[name]) return primes[name];

    var prime;
    if (name === 'k256') {
      prime = new K256();
    } else if (name === 'p224') {
      prime = new P224();
    } else if (name === 'p192') {
      prime = new P192();
    } else if (name === 'p25519') {
      prime = new P25519();
    } else {
      throw new Error('Unknown prime ' + name);
    }
    primes[name] = prime;

    return prime;
  };

  //
  // Base reduction engine
  //
  function Red (m) {
    if (typeof m === 'string') {
      var prime = BN._prime(m);
      this.m = prime.p;
      this.prime = prime;
    } else {
      assert(m.gtn(1), 'modulus must be greater than 1');
      this.m = m;
      this.prime = null;
    }
  }

  Red.prototype._verify1 = function _verify1 (a) {
    assert(a.negative === 0, 'red works only with positives');
    assert(a.red, 'red works only with red numbers');
  };

  Red.prototype._verify2 = function _verify2 (a, b) {
    assert((a.negative | b.negative) === 0, 'red works only with positives');
    assert(a.red && a.red === b.red,
      'red works only with red numbers');
  };

  Red.prototype.imod = function imod (a) {
    if (this.prime) return this.prime.ireduce(a)._forceRed(this);

    move(a, a.umod(this.m)._forceRed(this));
    return a;
  };

  Red.prototype.neg = function neg (a) {
    if (a.isZero()) {
      return a.clone();
    }

    return this.m.sub(a)._forceRed(this);
  };

  Red.prototype.add = function add (a, b) {
    this._verify2(a, b);

    var res = a.add(b);
    if (res.cmp(this.m) >= 0) {
      res.isub(this.m);
    }
    return res._forceRed(this);
  };

  Red.prototype.iadd = function iadd (a, b) {
    this._verify2(a, b);

    var res = a.iadd(b);
    if (res.cmp(this.m) >= 0) {
      res.isub(this.m);
    }
    return res;
  };

  Red.prototype.sub = function sub (a, b) {
    this._verify2(a, b);

    var res = a.sub(b);
    if (res.cmpn(0) < 0) {
      res.iadd(this.m);
    }
    return res._forceRed(this);
  };

  Red.prototype.isub = function isub (a, b) {
    this._verify2(a, b);

    var res = a.isub(b);
    if (res.cmpn(0) < 0) {
      res.iadd(this.m);
    }
    return res;
  };

  Red.prototype.shl = function shl (a, num) {
    this._verify1(a);
    return this.imod(a.ushln(num));
  };

  Red.prototype.imul = function imul (a, b) {
    this._verify2(a, b);
    return this.imod(a.imul(b));
  };

  Red.prototype.mul = function mul (a, b) {
    this._verify2(a, b);
    return this.imod(a.mul(b));
  };

  Red.prototype.isqr = function isqr (a) {
    return this.imul(a, a.clone());
  };

  Red.prototype.sqr = function sqr (a) {
    return this.mul(a, a);
  };

  Red.prototype.sqrt = function sqrt (a) {
    if (a.isZero()) return a.clone();

    var mod3 = this.m.andln(3);
    assert(mod3 % 2 === 1);

    // Fast case
    if (mod3 === 3) {
      var pow = this.m.add(new BN(1)).iushrn(2);
      return this.pow(a, pow);
    }

    // Tonelli-Shanks algorithm (Totally unoptimized and slow)
    //
    // Find Q and S, that Q * 2 ^ S = (P - 1)
    var q = this.m.subn(1);
    var s = 0;
    while (!q.isZero() && q.andln(1) === 0) {
      s++;
      q.iushrn(1);
    }
    assert(!q.isZero());

    var one = new BN(1).toRed(this);
    var nOne = one.redNeg();

    // Find quadratic non-residue
    // NOTE: Max is such because of generalized Riemann hypothesis.
    var lpow = this.m.subn(1).iushrn(1);
    var z = this.m.bitLength();
    z = new BN(2 * z * z).toRed(this);

    while (this.pow(z, lpow).cmp(nOne) !== 0) {
      z.redIAdd(nOne);
    }

    var c = this.pow(z, q);
    var r = this.pow(a, q.addn(1).iushrn(1));
    var t = this.pow(a, q);
    var m = s;
    while (t.cmp(one) !== 0) {
      var tmp = t;
      for (var i = 0; tmp.cmp(one) !== 0; i++) {
        tmp = tmp.redSqr();
      }
      assert(i < m);
      var b = this.pow(c, new BN(1).iushln(m - i - 1));

      r = r.redMul(b);
      c = b.redSqr();
      t = t.redMul(c);
      m = i;
    }

    return r;
  };

  Red.prototype.invm = function invm (a) {
    var inv = a._invmp(this.m);
    if (inv.negative !== 0) {
      inv.negative = 0;
      return this.imod(inv).redNeg();
    } else {
      return this.imod(inv);
    }
  };

  Red.prototype.pow = function pow (a, num) {
    if (num.isZero()) return new BN(1).toRed(this);
    if (num.cmpn(1) === 0) return a.clone();

    var windowSize = 4;
    var wnd = new Array(1 << windowSize);
    wnd[0] = new BN(1).toRed(this);
    wnd[1] = a;
    for (var i = 2; i < wnd.length; i++) {
      wnd[i] = this.mul(wnd[i - 1], a);
    }

    var res = wnd[0];
    var current = 0;
    var currentLen = 0;
    var start = num.bitLength() % 26;
    if (start === 0) {
      start = 26;
    }

    for (i = num.length - 1; i >= 0; i--) {
      var word = num.words[i];
      for (var j = start - 1; j >= 0; j--) {
        var bit = (word >> j) & 1;
        if (res !== wnd[0]) {
          res = this.sqr(res);
        }

        if (bit === 0 && current === 0) {
          currentLen = 0;
          continue;
        }

        current <<= 1;
        current |= bit;
        currentLen++;
        if (currentLen !== windowSize && (i !== 0 || j !== 0)) continue;

        res = this.mul(res, wnd[current]);
        currentLen = 0;
        current = 0;
      }
      start = 26;
    }

    return res;
  };

  Red.prototype.convertTo = function convertTo (num) {
    var r = num.umod(this.m);

    return r === num ? r.clone() : r;
  };

  Red.prototype.convertFrom = function convertFrom (num) {
    var res = num.clone();
    res.red = null;
    return res;
  };

  //
  // Montgomery method engine
  //

  BN.mont = function mont (num) {
    return new Mont(num);
  };

  function Mont (m) {
    Red.call(this, m);

    this.shift = this.m.bitLength();
    if (this.shift % 26 !== 0) {
      this.shift += 26 - (this.shift % 26);
    }

    this.r = new BN(1).iushln(this.shift);
    this.r2 = this.imod(this.r.sqr());
    this.rinv = this.r._invmp(this.m);

    this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
    this.minv = this.minv.umod(this.r);
    this.minv = this.r.sub(this.minv);
  }
  inherits(Mont, Red);

  Mont.prototype.convertTo = function convertTo (num) {
    return this.imod(num.ushln(this.shift));
  };

  Mont.prototype.convertFrom = function convertFrom (num) {
    var r = this.imod(num.mul(this.rinv));
    r.red = null;
    return r;
  };

  Mont.prototype.imul = function imul (a, b) {
    if (a.isZero() || b.isZero()) {
      a.words[0] = 0;
      a.length = 1;
      return a;
    }

    var t = a.imul(b);
    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
    var u = t.isub(c).iushrn(this.shift);
    var res = u;

    if (u.cmp(this.m) >= 0) {
      res = u.isub(this.m);
    } else if (u.cmpn(0) < 0) {
      res = u.iadd(this.m);
    }

    return res._forceRed(this);
  };

  Mont.prototype.mul = function mul (a, b) {
    if (a.isZero() || b.isZero()) return new BN(0)._forceRed(this);

    var t = a.mul(b);
    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
    var u = t.isub(c).iushrn(this.shift);
    var res = u;
    if (u.cmp(this.m) >= 0) {
      res = u.isub(this.m);
    } else if (u.cmpn(0) < 0) {
      res = u.iadd(this.m);
    }

    return res._forceRed(this);
  };

  Mont.prototype.invm = function invm (a) {
    // (AR)^-1 * R^2 = (A^-1 * R^-1) * R^2 = A^-1 * R
    var res = this.imod(a._invmp(this.m).mul(this.r2));
    return res._forceRed(this);
  };
})( false || module, this);


/***/ }),

/***/ 5037:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var r;

module.exports = function rand(len) {
  if (!r)
    r = new Rand(null);

  return r.generate(len);
};

function Rand(rand) {
  this.rand = rand;
}
module.exports.Rand = Rand;

Rand.prototype.generate = function generate(len) {
  return this._rand(len);
};

// Emulate crypto API using randy
Rand.prototype._rand = function _rand(n) {
  if (this.rand.getBytes)
    return this.rand.getBytes(n);

  var res = new Uint8Array(n);
  for (var i = 0; i < res.length; i++)
    res[i] = this.rand.getByte();
  return res;
};

if (typeof self === 'object') {
  if (self.crypto && self.crypto.getRandomValues) {
    // Modern browsers
    Rand.prototype._rand = function _rand(n) {
      var arr = new Uint8Array(n);
      self.crypto.getRandomValues(arr);
      return arr;
    };
  } else if (self.msCrypto && self.msCrypto.getRandomValues) {
    // IE
    Rand.prototype._rand = function _rand(n) {
      var arr = new Uint8Array(n);
      self.msCrypto.getRandomValues(arr);
      return arr;
    };

  // Safari's WebWorkers do not have `crypto`
  } else if (typeof window === 'object') {
    // Old junk
    Rand.prototype._rand = function() {
      throw new Error('Not implemented yet');
    };
  }
} else {
  // Node.js or Web worker with no crypto support
  try {
    var crypto = __webpack_require__(6982);
    if (typeof crypto.randomBytes !== 'function')
      throw new Error('Not supported');

    Rand.prototype._rand = function _rand(n) {
      return crypto.randomBytes(n);
    };
  } catch (e) {
  }
}


/***/ }),

/***/ 955:
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory, undef) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__webpack_require__(9021), __webpack_require__(754), __webpack_require__(4636), __webpack_require__(9506), __webpack_require__(7165));
	}
	else {}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var BlockCipher = C_lib.BlockCipher;
	    var C_algo = C.algo;

	    // Lookup tables
	    var SBOX = [];
	    var INV_SBOX = [];
	    var SUB_MIX_0 = [];
	    var SUB_MIX_1 = [];
	    var SUB_MIX_2 = [];
	    var SUB_MIX_3 = [];
	    var INV_SUB_MIX_0 = [];
	    var INV_SUB_MIX_1 = [];
	    var INV_SUB_MIX_2 = [];
	    var INV_SUB_MIX_3 = [];

	    // Compute lookup tables
	    (function () {
	        // Compute double table
	        var d = [];
	        for (var i = 0; i < 256; i++) {
	            if (i < 128) {
	                d[i] = i << 1;
	            } else {
	                d[i] = (i << 1) ^ 0x11b;
	            }
	        }

	        // Walk GF(2^8)
	        var x = 0;
	        var xi = 0;
	        for (var i = 0; i < 256; i++) {
	            // Compute sbox
	            var sx = xi ^ (xi << 1) ^ (xi << 2) ^ (xi << 3) ^ (xi << 4);
	            sx = (sx >>> 8) ^ (sx & 0xff) ^ 0x63;
	            SBOX[x] = sx;
	            INV_SBOX[sx] = x;

	            // Compute multiplication
	            var x2 = d[x];
	            var x4 = d[x2];
	            var x8 = d[x4];

	            // Compute sub bytes, mix columns tables
	            var t = (d[sx] * 0x101) ^ (sx * 0x1010100);
	            SUB_MIX_0[x] = (t << 24) | (t >>> 8);
	            SUB_MIX_1[x] = (t << 16) | (t >>> 16);
	            SUB_MIX_2[x] = (t << 8)  | (t >>> 24);
	            SUB_MIX_3[x] = t;

	            // Compute inv sub bytes, inv mix columns tables
	            var t = (x8 * 0x1010101) ^ (x4 * 0x10001) ^ (x2 * 0x101) ^ (x * 0x1010100);
	            INV_SUB_MIX_0[sx] = (t << 24) | (t >>> 8);
	            INV_SUB_MIX_1[sx] = (t << 16) | (t >>> 16);
	            INV_SUB_MIX_2[sx] = (t << 8)  | (t >>> 24);
	            INV_SUB_MIX_3[sx] = t;

	            // Compute next counter
	            if (!x) {
	                x = xi = 1;
	            } else {
	                x = x2 ^ d[d[d[x8 ^ x2]]];
	                xi ^= d[d[xi]];
	            }
	        }
	    }());

	    // Precomputed Rcon lookup
	    var RCON = [0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36];

	    /**
	     * AES block cipher algorithm.
	     */
	    var AES = C_algo.AES = BlockCipher.extend({
	        _doReset: function () {
	            // Skip reset of nRounds has been set before and key did not change
	            if (this._nRounds && this._keyPriorReset === this._key) {
	                return;
	            }

	            // Shortcuts
	            var key = this._keyPriorReset = this._key;
	            var keyWords = key.words;
	            var keySize = key.sigBytes / 4;

	            // Compute number of rounds
	            var nRounds = this._nRounds = keySize + 6;

	            // Compute number of key schedule rows
	            var ksRows = (nRounds + 1) * 4;

	            // Compute key schedule
	            var keySchedule = this._keySchedule = [];
	            for (var ksRow = 0; ksRow < ksRows; ksRow++) {
	                if (ksRow < keySize) {
	                    keySchedule[ksRow] = keyWords[ksRow];
	                } else {
	                    var t = keySchedule[ksRow - 1];

	                    if (!(ksRow % keySize)) {
	                        // Rot word
	                        t = (t << 8) | (t >>> 24);

	                        // Sub word
	                        t = (SBOX[t >>> 24] << 24) | (SBOX[(t >>> 16) & 0xff] << 16) | (SBOX[(t >>> 8) & 0xff] << 8) | SBOX[t & 0xff];

	                        // Mix Rcon
	                        t ^= RCON[(ksRow / keySize) | 0] << 24;
	                    } else if (keySize > 6 && ksRow % keySize == 4) {
	                        // Sub word
	                        t = (SBOX[t >>> 24] << 24) | (SBOX[(t >>> 16) & 0xff] << 16) | (SBOX[(t >>> 8) & 0xff] << 8) | SBOX[t & 0xff];
	                    }

	                    keySchedule[ksRow] = keySchedule[ksRow - keySize] ^ t;
	                }
	            }

	            // Compute inv key schedule
	            var invKeySchedule = this._invKeySchedule = [];
	            for (var invKsRow = 0; invKsRow < ksRows; invKsRow++) {
	                var ksRow = ksRows - invKsRow;

	                if (invKsRow % 4) {
	                    var t = keySchedule[ksRow];
	                } else {
	                    var t = keySchedule[ksRow - 4];
	                }

	                if (invKsRow < 4 || ksRow <= 4) {
	                    invKeySchedule[invKsRow] = t;
	                } else {
	                    invKeySchedule[invKsRow] = INV_SUB_MIX_0[SBOX[t >>> 24]] ^ INV_SUB_MIX_1[SBOX[(t >>> 16) & 0xff]] ^
	                                               INV_SUB_MIX_2[SBOX[(t >>> 8) & 0xff]] ^ INV_SUB_MIX_3[SBOX[t & 0xff]];
	                }
	            }
	        },

	        encryptBlock: function (M, offset) {
	            this._doCryptBlock(M, offset, this._keySchedule, SUB_MIX_0, SUB_MIX_1, SUB_MIX_2, SUB_MIX_3, SBOX);
	        },

	        decryptBlock: function (M, offset) {
	            // Swap 2nd and 4th rows
	            var t = M[offset + 1];
	            M[offset + 1] = M[offset + 3];
	            M[offset + 3] = t;

	            this._doCryptBlock(M, offset, this._invKeySchedule, INV_SUB_MIX_0, INV_SUB_MIX_1, INV_SUB_MIX_2, INV_SUB_MIX_3, INV_SBOX);

	            // Inv swap 2nd and 4th rows
	            var t = M[offset + 1];
	            M[offset + 1] = M[offset + 3];
	            M[offset + 3] = t;
	        },

	        _doCryptBlock: function (M, offset, keySchedule, SUB_MIX_0, SUB_MIX_1, SUB_MIX_2, SUB_MIX_3, SBOX) {
	            // Shortcut
	            var nRounds = this._nRounds;

	            // Get input, add round key
	            var s0 = M[offset]     ^ keySchedule[0];
	            var s1 = M[offset + 1] ^ keySchedule[1];
	            var s2 = M[offset + 2] ^ keySchedule[2];
	            var s3 = M[offset + 3] ^ keySchedule[3];

	            // Key schedule row counter
	            var ksRow = 4;

	            // Rounds
	            for (var round = 1; round < nRounds; round++) {
	                // Shift rows, sub bytes, mix columns, add round key
	                var t0 = SUB_MIX_0[s0 >>> 24] ^ SUB_MIX_1[(s1 >>> 16) & 0xff] ^ SUB_MIX_2[(s2 >>> 8) & 0xff] ^ SUB_MIX_3[s3 & 0xff] ^ keySchedule[ksRow++];
	                var t1 = SUB_MIX_0[s1 >>> 24] ^ SUB_MIX_1[(s2 >>> 16) & 0xff] ^ SUB_MIX_2[(s3 >>> 8) & 0xff] ^ SUB_MIX_3[s0 & 0xff] ^ keySchedule[ksRow++];
	                var t2 = SUB_MIX_0[s2 >>> 24] ^ SUB_MIX_1[(s3 >>> 16) & 0xff] ^ SUB_MIX_2[(s0 >>> 8) & 0xff] ^ SUB_MIX_3[s1 & 0xff] ^ keySchedule[ksRow++];
	                var t3 = SUB_MIX_0[s3 >>> 24] ^ SUB_MIX_1[(s0 >>> 16) & 0xff] ^ SUB_MIX_2[(s1 >>> 8) & 0xff] ^ SUB_MIX_3[s2 & 0xff] ^ keySchedule[ksRow++];

	                // Update state
	                s0 = t0;
	                s1 = t1;
	                s2 = t2;
	                s3 = t3;
	            }

	            // Shift rows, sub bytes, add round key
	            var t0 = ((SBOX[s0 >>> 24] << 24) | (SBOX[(s1 >>> 16) & 0xff] << 16) | (SBOX[(s2 >>> 8) & 0xff] << 8) | SBOX[s3 & 0xff]) ^ keySchedule[ksRow++];
	            var t1 = ((SBOX[s1 >>> 24] << 24) | (SBOX[(s2 >>> 16) & 0xff] << 16) | (SBOX[(s3 >>> 8) & 0xff] << 8) | SBOX[s0 & 0xff]) ^ keySchedule[ksRow++];
	            var t2 = ((SBOX[s2 >>> 24] << 24) | (SBOX[(s3 >>> 16) & 0xff] << 16) | (SBOX[(s0 >>> 8) & 0xff] << 8) | SBOX[s1 & 0xff]) ^ keySchedule[ksRow++];
	            var t3 = ((SBOX[s3 >>> 24] << 24) | (SBOX[(s0 >>> 16) & 0xff] << 16) | (SBOX[(s1 >>> 8) & 0xff] << 8) | SBOX[s2 & 0xff]) ^ keySchedule[ksRow++];

	            // Set output
	            M[offset]     = t0;
	            M[offset + 1] = t1;
	            M[offset + 2] = t2;
	            M[offset + 3] = t3;
	        },

	        keySize: 256/32
	    });

	    /**
	     * Shortcut functions to the cipher's object interface.
	     *
	     * @example
	     *
	     *     var ciphertext = CryptoJS.AES.encrypt(message, key, cfg);
	     *     var plaintext  = CryptoJS.AES.decrypt(ciphertext, key, cfg);
	     */
	    C.AES = BlockCipher._createHelper(AES);
	}());


	return CryptoJS.AES;

}));

/***/ }),

/***/ 7165:
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory, undef) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__webpack_require__(9021), __webpack_require__(9506));
	}
	else {}
}(this, function (CryptoJS) {

	/**
	 * Cipher core components.
	 */
	CryptoJS.lib.Cipher || (function (undefined) {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var Base = C_lib.Base;
	    var WordArray = C_lib.WordArray;
	    var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm;
	    var C_enc = C.enc;
	    var Utf8 = C_enc.Utf8;
	    var Base64 = C_enc.Base64;
	    var C_algo = C.algo;
	    var EvpKDF = C_algo.EvpKDF;

	    /**
	     * Abstract base cipher template.
	     *
	     * @property {number} keySize This cipher's key size. Default: 4 (128 bits)
	     * @property {number} ivSize This cipher's IV size. Default: 4 (128 bits)
	     * @property {number} _ENC_XFORM_MODE A constant representing encryption mode.
	     * @property {number} _DEC_XFORM_MODE A constant representing decryption mode.
	     */
	    var Cipher = C_lib.Cipher = BufferedBlockAlgorithm.extend({
	        /**
	         * Configuration options.
	         *
	         * @property {WordArray} iv The IV to use for this operation.
	         */
	        cfg: Base.extend(),

	        /**
	         * Creates this cipher in encryption mode.
	         *
	         * @param {WordArray} key The key.
	         * @param {Object} cfg (Optional) The configuration options to use for this operation.
	         *
	         * @return {Cipher} A cipher instance.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var cipher = CryptoJS.algo.AES.createEncryptor(keyWordArray, { iv: ivWordArray });
	         */
	        createEncryptor: function (key, cfg) {
	            return this.create(this._ENC_XFORM_MODE, key, cfg);
	        },

	        /**
	         * Creates this cipher in decryption mode.
	         *
	         * @param {WordArray} key The key.
	         * @param {Object} cfg (Optional) The configuration options to use for this operation.
	         *
	         * @return {Cipher} A cipher instance.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var cipher = CryptoJS.algo.AES.createDecryptor(keyWordArray, { iv: ivWordArray });
	         */
	        createDecryptor: function (key, cfg) {
	            return this.create(this._DEC_XFORM_MODE, key, cfg);
	        },

	        /**
	         * Initializes a newly created cipher.
	         *
	         * @param {number} xformMode Either the encryption or decryption transormation mode constant.
	         * @param {WordArray} key The key.
	         * @param {Object} cfg (Optional) The configuration options to use for this operation.
	         *
	         * @example
	         *
	         *     var cipher = CryptoJS.algo.AES.create(CryptoJS.algo.AES._ENC_XFORM_MODE, keyWordArray, { iv: ivWordArray });
	         */
	        init: function (xformMode, key, cfg) {
	            // Apply config defaults
	            this.cfg = this.cfg.extend(cfg);

	            // Store transform mode and key
	            this._xformMode = xformMode;
	            this._key = key;

	            // Set initial values
	            this.reset();
	        },

	        /**
	         * Resets this cipher to its initial state.
	         *
	         * @example
	         *
	         *     cipher.reset();
	         */
	        reset: function () {
	            // Reset data buffer
	            BufferedBlockAlgorithm.reset.call(this);

	            // Perform concrete-cipher logic
	            this._doReset();
	        },

	        /**
	         * Adds data to be encrypted or decrypted.
	         *
	         * @param {WordArray|string} dataUpdate The data to encrypt or decrypt.
	         *
	         * @return {WordArray} The data after processing.
	         *
	         * @example
	         *
	         *     var encrypted = cipher.process('data');
	         *     var encrypted = cipher.process(wordArray);
	         */
	        process: function (dataUpdate) {
	            // Append
	            this._append(dataUpdate);

	            // Process available blocks
	            return this._process();
	        },

	        /**
	         * Finalizes the encryption or decryption process.
	         * Note that the finalize operation is effectively a destructive, read-once operation.
	         *
	         * @param {WordArray|string} dataUpdate The final data to encrypt or decrypt.
	         *
	         * @return {WordArray} The data after final processing.
	         *
	         * @example
	         *
	         *     var encrypted = cipher.finalize();
	         *     var encrypted = cipher.finalize('data');
	         *     var encrypted = cipher.finalize(wordArray);
	         */
	        finalize: function (dataUpdate) {
	            // Final data update
	            if (dataUpdate) {
	                this._append(dataUpdate);
	            }

	            // Perform concrete-cipher logic
	            var finalProcessedData = this._doFinalize();

	            return finalProcessedData;
	        },

	        keySize: 128/32,

	        ivSize: 128/32,

	        _ENC_XFORM_MODE: 1,

	        _DEC_XFORM_MODE: 2,

	        /**
	         * Creates shortcut functions to a cipher's object interface.
	         *
	         * @param {Cipher} cipher The cipher to create a helper for.
	         *
	         * @return {Object} An object with encrypt and decrypt shortcut functions.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var AES = CryptoJS.lib.Cipher._createHelper(CryptoJS.algo.AES);
	         */
	        _createHelper: (function () {
	            function selectCipherStrategy(key) {
	                if (typeof key == 'string') {
	                    return PasswordBasedCipher;
	                } else {
	                    return SerializableCipher;
	                }
	            }

	            return function (cipher) {
	                return {
	                    encrypt: function (message, key, cfg) {
	                        return selectCipherStrategy(key).encrypt(cipher, message, key, cfg);
	                    },

	                    decrypt: function (ciphertext, key, cfg) {
	                        return selectCipherStrategy(key).decrypt(cipher, ciphertext, key, cfg);
	                    }
	                };
	            };
	        }())
	    });

	    /**
	     * Abstract base stream cipher template.
	     *
	     * @property {number} blockSize The number of 32-bit words this cipher operates on. Default: 1 (32 bits)
	     */
	    var StreamCipher = C_lib.StreamCipher = Cipher.extend({
	        _doFinalize: function () {
	            // Process partial blocks
	            var finalProcessedBlocks = this._process(!!'flush');

	            return finalProcessedBlocks;
	        },

	        blockSize: 1
	    });

	    /**
	     * Mode namespace.
	     */
	    var C_mode = C.mode = {};

	    /**
	     * Abstract base block cipher mode template.
	     */
	    var BlockCipherMode = C_lib.BlockCipherMode = Base.extend({
	        /**
	         * Creates this mode for encryption.
	         *
	         * @param {Cipher} cipher A block cipher instance.
	         * @param {Array} iv The IV words.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var mode = CryptoJS.mode.CBC.createEncryptor(cipher, iv.words);
	         */
	        createEncryptor: function (cipher, iv) {
	            return this.Encryptor.create(cipher, iv);
	        },

	        /**
	         * Creates this mode for decryption.
	         *
	         * @param {Cipher} cipher A block cipher instance.
	         * @param {Array} iv The IV words.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var mode = CryptoJS.mode.CBC.createDecryptor(cipher, iv.words);
	         */
	        createDecryptor: function (cipher, iv) {
	            return this.Decryptor.create(cipher, iv);
	        },

	        /**
	         * Initializes a newly created mode.
	         *
	         * @param {Cipher} cipher A block cipher instance.
	         * @param {Array} iv The IV words.
	         *
	         * @example
	         *
	         *     var mode = CryptoJS.mode.CBC.Encryptor.create(cipher, iv.words);
	         */
	        init: function (cipher, iv) {
	            this._cipher = cipher;
	            this._iv = iv;
	        }
	    });

	    /**
	     * Cipher Block Chaining mode.
	     */
	    var CBC = C_mode.CBC = (function () {
	        /**
	         * Abstract base CBC mode.
	         */
	        var CBC = BlockCipherMode.extend();

	        /**
	         * CBC encryptor.
	         */
	        CBC.Encryptor = CBC.extend({
	            /**
	             * Processes the data block at offset.
	             *
	             * @param {Array} words The data words to operate on.
	             * @param {number} offset The offset where the block starts.
	             *
	             * @example
	             *
	             *     mode.processBlock(data.words, offset);
	             */
	            processBlock: function (words, offset) {
	                // Shortcuts
	                var cipher = this._cipher;
	                var blockSize = cipher.blockSize;

	                // XOR and encrypt
	                xorBlock.call(this, words, offset, blockSize);
	                cipher.encryptBlock(words, offset);

	                // Remember this block to use with next block
	                this._prevBlock = words.slice(offset, offset + blockSize);
	            }
	        });

	        /**
	         * CBC decryptor.
	         */
	        CBC.Decryptor = CBC.extend({
	            /**
	             * Processes the data block at offset.
	             *
	             * @param {Array} words The data words to operate on.
	             * @param {number} offset The offset where the block starts.
	             *
	             * @example
	             *
	             *     mode.processBlock(data.words, offset);
	             */
	            processBlock: function (words, offset) {
	                // Shortcuts
	                var cipher = this._cipher;
	                var blockSize = cipher.blockSize;

	                // Remember this block to use with next block
	                var thisBlock = words.slice(offset, offset + blockSize);

	                // Decrypt and XOR
	                cipher.decryptBlock(words, offset);
	                xorBlock.call(this, words, offset, blockSize);

	                // This block becomes the previous block
	                this._prevBlock = thisBlock;
	            }
	        });

	        function xorBlock(words, offset, blockSize) {
	            // Shortcut
	            var iv = this._iv;

	            // Choose mixing block
	            if (iv) {
	                var block = iv;

	                // Remove IV for subsequent blocks
	                this._iv = undefined;
	            } else {
	                var block = this._prevBlock;
	            }

	            // XOR blocks
	            for (var i = 0; i < blockSize; i++) {
	                words[offset + i] ^= block[i];
	            }
	        }

	        return CBC;
	    }());

	    /**
	     * Padding namespace.
	     */
	    var C_pad = C.pad = {};

	    /**
	     * PKCS #5/7 padding strategy.
	     */
	    var Pkcs7 = C_pad.Pkcs7 = {
	        /**
	         * Pads data using the algorithm defined in PKCS #5/7.
	         *
	         * @param {WordArray} data The data to pad.
	         * @param {number} blockSize The multiple that the data should be padded to.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     CryptoJS.pad.Pkcs7.pad(wordArray, 4);
	         */
	        pad: function (data, blockSize) {
	            // Shortcut
	            var blockSizeBytes = blockSize * 4;

	            // Count padding bytes
	            var nPaddingBytes = blockSizeBytes - data.sigBytes % blockSizeBytes;

	            // Create padding word
	            var paddingWord = (nPaddingBytes << 24) | (nPaddingBytes << 16) | (nPaddingBytes << 8) | nPaddingBytes;

	            // Create padding
	            var paddingWords = [];
	            for (var i = 0; i < nPaddingBytes; i += 4) {
	                paddingWords.push(paddingWord);
	            }
	            var padding = WordArray.create(paddingWords, nPaddingBytes);

	            // Add padding
	            data.concat(padding);
	        },

	        /**
	         * Unpads data that had been padded using the algorithm defined in PKCS #5/7.
	         *
	         * @param {WordArray} data The data to unpad.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     CryptoJS.pad.Pkcs7.unpad(wordArray);
	         */
	        unpad: function (data) {
	            // Get number of padding bytes from last byte
	            var nPaddingBytes = data.words[(data.sigBytes - 1) >>> 2] & 0xff;

	            // Remove padding
	            data.sigBytes -= nPaddingBytes;
	        }
	    };

	    /**
	     * Abstract base block cipher template.
	     *
	     * @property {number} blockSize The number of 32-bit words this cipher operates on. Default: 4 (128 bits)
	     */
	    var BlockCipher = C_lib.BlockCipher = Cipher.extend({
	        /**
	         * Configuration options.
	         *
	         * @property {Mode} mode The block mode to use. Default: CBC
	         * @property {Padding} padding The padding strategy to use. Default: Pkcs7
	         */
	        cfg: Cipher.cfg.extend({
	            mode: CBC,
	            padding: Pkcs7
	        }),

	        reset: function () {
	            // Reset cipher
	            Cipher.reset.call(this);

	            // Shortcuts
	            var cfg = this.cfg;
	            var iv = cfg.iv;
	            var mode = cfg.mode;

	            // Reset block mode
	            if (this._xformMode == this._ENC_XFORM_MODE) {
	                var modeCreator = mode.createEncryptor;
	            } else /* if (this._xformMode == this._DEC_XFORM_MODE) */ {
	                var modeCreator = mode.createDecryptor;
	                // Keep at least one block in the buffer for unpadding
	                this._minBufferSize = 1;
	            }

	            if (this._mode && this._mode.__creator == modeCreator) {
	                this._mode.init(this, iv && iv.words);
	            } else {
	                this._mode = modeCreator.call(mode, this, iv && iv.words);
	                this._mode.__creator = modeCreator;
	            }
	        },

	        _doProcessBlock: function (words, offset) {
	            this._mode.processBlock(words, offset);
	        },

	        _doFinalize: function () {
	            // Shortcut
	            var padding = this.cfg.padding;

	            // Finalize
	            if (this._xformMode == this._ENC_XFORM_MODE) {
	                // Pad data
	                padding.pad(this._data, this.blockSize);

	                // Process final blocks
	                var finalProcessedBlocks = this._process(!!'flush');
	            } else /* if (this._xformMode == this._DEC_XFORM_MODE) */ {
	                // Process final blocks
	                var finalProcessedBlocks = this._process(!!'flush');

	                // Unpad data
	                padding.unpad(finalProcessedBlocks);
	            }

	            return finalProcessedBlocks;
	        },

	        blockSize: 128/32
	    });

	    /**
	     * A collection of cipher parameters.
	     *
	     * @property {WordArray} ciphertext The raw ciphertext.
	     * @property {WordArray} key The key to this ciphertext.
	     * @property {WordArray} iv The IV used in the ciphering operation.
	     * @property {WordArray} salt The salt used with a key derivation function.
	     * @property {Cipher} algorithm The cipher algorithm.
	     * @property {Mode} mode The block mode used in the ciphering operation.
	     * @property {Padding} padding The padding scheme used in the ciphering operation.
	     * @property {number} blockSize The block size of the cipher.
	     * @property {Format} formatter The default formatting strategy to convert this cipher params object to a string.
	     */
	    var CipherParams = C_lib.CipherParams = Base.extend({
	        /**
	         * Initializes a newly created cipher params object.
	         *
	         * @param {Object} cipherParams An object with any of the possible cipher parameters.
	         *
	         * @example
	         *
	         *     var cipherParams = CryptoJS.lib.CipherParams.create({
	         *         ciphertext: ciphertextWordArray,
	         *         key: keyWordArray,
	         *         iv: ivWordArray,
	         *         salt: saltWordArray,
	         *         algorithm: CryptoJS.algo.AES,
	         *         mode: CryptoJS.mode.CBC,
	         *         padding: CryptoJS.pad.PKCS7,
	         *         blockSize: 4,
	         *         formatter: CryptoJS.format.OpenSSL
	         *     });
	         */
	        init: function (cipherParams) {
	            this.mixIn(cipherParams);
	        },

	        /**
	         * Converts this cipher params object to a string.
	         *
	         * @param {Format} formatter (Optional) The formatting strategy to use.
	         *
	         * @return {string} The stringified cipher params.
	         *
	         * @throws Error If neither the formatter nor the default formatter is set.
	         *
	         * @example
	         *
	         *     var string = cipherParams + '';
	         *     var string = cipherParams.toString();
	         *     var string = cipherParams.toString(CryptoJS.format.OpenSSL);
	         */
	        toString: function (formatter) {
	            return (formatter || this.formatter).stringify(this);
	        }
	    });

	    /**
	     * Format namespace.
	     */
	    var C_format = C.format = {};

	    /**
	     * OpenSSL formatting strategy.
	     */
	    var OpenSSLFormatter = C_format.OpenSSL = {
	        /**
	         * Converts a cipher params object to an OpenSSL-compatible string.
	         *
	         * @param {CipherParams} cipherParams The cipher params object.
	         *
	         * @return {string} The OpenSSL-compatible string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var openSSLString = CryptoJS.format.OpenSSL.stringify(cipherParams);
	         */
	        stringify: function (cipherParams) {
	            // Shortcuts
	            var ciphertext = cipherParams.ciphertext;
	            var salt = cipherParams.salt;

	            // Format
	            if (salt) {
	                var wordArray = WordArray.create([0x53616c74, 0x65645f5f]).concat(salt).concat(ciphertext);
	            } else {
	                var wordArray = ciphertext;
	            }

	            return wordArray.toString(Base64);
	        },

	        /**
	         * Converts an OpenSSL-compatible string to a cipher params object.
	         *
	         * @param {string} openSSLStr The OpenSSL-compatible string.
	         *
	         * @return {CipherParams} The cipher params object.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var cipherParams = CryptoJS.format.OpenSSL.parse(openSSLString);
	         */
	        parse: function (openSSLStr) {
	            // Parse base64
	            var ciphertext = Base64.parse(openSSLStr);

	            // Shortcut
	            var ciphertextWords = ciphertext.words;

	            // Test for salt
	            if (ciphertextWords[0] == 0x53616c74 && ciphertextWords[1] == 0x65645f5f) {
	                // Extract salt
	                var salt = WordArray.create(ciphertextWords.slice(2, 4));

	                // Remove salt from ciphertext
	                ciphertextWords.splice(0, 4);
	                ciphertext.sigBytes -= 16;
	            }

	            return CipherParams.create({ ciphertext: ciphertext, salt: salt });
	        }
	    };

	    /**
	     * A cipher wrapper that returns ciphertext as a serializable cipher params object.
	     */
	    var SerializableCipher = C_lib.SerializableCipher = Base.extend({
	        /**
	         * Configuration options.
	         *
	         * @property {Formatter} format The formatting strategy to convert cipher param objects to and from a string. Default: OpenSSL
	         */
	        cfg: Base.extend({
	            format: OpenSSLFormatter
	        }),

	        /**
	         * Encrypts a message.
	         *
	         * @param {Cipher} cipher The cipher algorithm to use.
	         * @param {WordArray|string} message The message to encrypt.
	         * @param {WordArray} key The key.
	         * @param {Object} cfg (Optional) The configuration options to use for this operation.
	         *
	         * @return {CipherParams} A cipher params object.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key);
	         *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key, { iv: iv });
	         *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key, { iv: iv, format: CryptoJS.format.OpenSSL });
	         */
	        encrypt: function (cipher, message, key, cfg) {
	            // Apply config defaults
	            cfg = this.cfg.extend(cfg);

	            // Encrypt
	            var encryptor = cipher.createEncryptor(key, cfg);
	            var ciphertext = encryptor.finalize(message);

	            // Shortcut
	            var cipherCfg = encryptor.cfg;

	            // Create and return serializable cipher params
	            return CipherParams.create({
	                ciphertext: ciphertext,
	                key: key,
	                iv: cipherCfg.iv,
	                algorithm: cipher,
	                mode: cipherCfg.mode,
	                padding: cipherCfg.padding,
	                blockSize: cipher.blockSize,
	                formatter: cfg.format
	            });
	        },

	        /**
	         * Decrypts serialized ciphertext.
	         *
	         * @param {Cipher} cipher The cipher algorithm to use.
	         * @param {CipherParams|string} ciphertext The ciphertext to decrypt.
	         * @param {WordArray} key The key.
	         * @param {Object} cfg (Optional) The configuration options to use for this operation.
	         *
	         * @return {WordArray} The plaintext.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var plaintext = CryptoJS.lib.SerializableCipher.decrypt(CryptoJS.algo.AES, formattedCiphertext, key, { iv: iv, format: CryptoJS.format.OpenSSL });
	         *     var plaintext = CryptoJS.lib.SerializableCipher.decrypt(CryptoJS.algo.AES, ciphertextParams, key, { iv: iv, format: CryptoJS.format.OpenSSL });
	         */
	        decrypt: function (cipher, ciphertext, key, cfg) {
	            // Apply config defaults
	            cfg = this.cfg.extend(cfg);

	            // Convert string to CipherParams
	            ciphertext = this._parse(ciphertext, cfg.format);

	            // Decrypt
	            var plaintext = cipher.createDecryptor(key, cfg).finalize(ciphertext.ciphertext);

	            return plaintext;
	        },

	        /**
	         * Converts serialized ciphertext to CipherParams,
	         * else assumed CipherParams already and returns ciphertext unchanged.
	         *
	         * @param {CipherParams|string} ciphertext The ciphertext.
	         * @param {Formatter} format The formatting strategy to use to parse serialized ciphertext.
	         *
	         * @return {CipherParams} The unserialized ciphertext.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var ciphertextParams = CryptoJS.lib.SerializableCipher._parse(ciphertextStringOrParams, format);
	         */
	        _parse: function (ciphertext, format) {
	            if (typeof ciphertext == 'string') {
	                return format.parse(ciphertext, this);
	            } else {
	                return ciphertext;
	            }
	        }
	    });

	    /**
	     * Key derivation function namespace.
	     */
	    var C_kdf = C.kdf = {};

	    /**
	     * OpenSSL key derivation function.
	     */
	    var OpenSSLKdf = C_kdf.OpenSSL = {
	        /**
	         * Derives a key and IV from a password.
	         *
	         * @param {string} password The password to derive from.
	         * @param {number} keySize The size in words of the key to generate.
	         * @param {number} ivSize The size in words of the IV to generate.
	         * @param {WordArray|string} salt (Optional) A 64-bit salt to use. If omitted, a salt will be generated randomly.
	         *
	         * @return {CipherParams} A cipher params object with the key, IV, and salt.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var derivedParams = CryptoJS.kdf.OpenSSL.execute('Password', 256/32, 128/32);
	         *     var derivedParams = CryptoJS.kdf.OpenSSL.execute('Password', 256/32, 128/32, 'saltsalt');
	         */
	        execute: function (password, keySize, ivSize, salt) {
	            // Generate random salt
	            if (!salt) {
	                salt = WordArray.random(64/8);
	            }

	            // Derive key and IV
	            var key = EvpKDF.create({ keySize: keySize + ivSize }).compute(password, salt);

	            // Separate key and IV
	            var iv = WordArray.create(key.words.slice(keySize), ivSize * 4);
	            key.sigBytes = keySize * 4;

	            // Return params
	            return CipherParams.create({ key: key, iv: iv, salt: salt });
	        }
	    };

	    /**
	     * A serializable cipher wrapper that derives the key from a password,
	     * and returns ciphertext as a serializable cipher params object.
	     */
	    var PasswordBasedCipher = C_lib.PasswordBasedCipher = SerializableCipher.extend({
	        /**
	         * Configuration options.
	         *
	         * @property {KDF} kdf The key derivation function to use to generate a key and IV from a password. Default: OpenSSL
	         */
	        cfg: SerializableCipher.cfg.extend({
	            kdf: OpenSSLKdf
	        }),

	        /**
	         * Encrypts a message using a password.
	         *
	         * @param {Cipher} cipher The cipher algorithm to use.
	         * @param {WordArray|string} message The message to encrypt.
	         * @param {string} password The password.
	         * @param {Object} cfg (Optional) The configuration options to use for this operation.
	         *
	         * @return {CipherParams} A cipher params object.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var ciphertextParams = CryptoJS.lib.PasswordBasedCipher.encrypt(CryptoJS.algo.AES, message, 'password');
	         *     var ciphertextParams = CryptoJS.lib.PasswordBasedCipher.encrypt(CryptoJS.algo.AES, message, 'password', { format: CryptoJS.format.OpenSSL });
	         */
	        encrypt: function (cipher, message, password, cfg) {
	            // Apply config defaults
	            cfg = this.cfg.extend(cfg);

	            // Derive key and other params
	            var derivedParams = cfg.kdf.execute(password, cipher.keySize, cipher.ivSize);

	            // Add IV to config
	            cfg.iv = derivedParams.iv;

	            // Encrypt
	            var ciphertext = SerializableCipher.encrypt.call(this, cipher, message, derivedParams.key, cfg);

	            // Mix in derived params
	            ciphertext.mixIn(derivedParams);

	            return ciphertext;
	        },

	        /**
	         * Decrypts serialized ciphertext using a password.
	         *
	         * @param {Cipher} cipher The cipher algorithm to use.
	         * @param {CipherParams|string} ciphertext The ciphertext to decrypt.
	         * @param {string} password The password.
	         * @param {Object} cfg (Optional) The configuration options to use for this operation.
	         *
	         * @return {WordArray} The plaintext.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var plaintext = CryptoJS.lib.PasswordBasedCipher.decrypt(CryptoJS.algo.AES, formattedCiphertext, 'password', { format: CryptoJS.format.OpenSSL });
	         *     var plaintext = CryptoJS.lib.PasswordBasedCipher.decrypt(CryptoJS.algo.AES, ciphertextParams, 'password', { format: CryptoJS.format.OpenSSL });
	         */
	        decrypt: function (cipher, ciphertext, password, cfg) {
	            // Apply config defaults
	            cfg = this.cfg.extend(cfg);

	            // Convert string to CipherParams
	            ciphertext = this._parse(ciphertext, cfg.format);

	            // Derive key and other params
	            var derivedParams = cfg.kdf.execute(password, cipher.keySize, cipher.ivSize, ciphertext.salt);

	            // Add IV to config
	            cfg.iv = derivedParams.iv;

	            // Decrypt
	            var plaintext = SerializableCipher.decrypt.call(this, cipher, ciphertext, derivedParams.key, cfg);

	            return plaintext;
	        }
	    });
	}());


}));

/***/ }),

/***/ 9021:
/***/ (function(module, exports) {

;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory();
	}
	else {}
}(this, function () {

	/**
	 * CryptoJS core components.
	 */
	var CryptoJS = CryptoJS || (function (Math, undefined) {
	    /*
	     * Local polyfil of Object.create
	     */
	    var create = Object.create || (function () {
	        function F() {};

	        return function (obj) {
	            var subtype;

	            F.prototype = obj;

	            subtype = new F();

	            F.prototype = null;

	            return subtype;
	        };
	    }())

	    /**
	     * CryptoJS namespace.
	     */
	    var C = {};

	    /**
	     * Library namespace.
	     */
	    var C_lib = C.lib = {};

	    /**
	     * Base object for prototypal inheritance.
	     */
	    var Base = C_lib.Base = (function () {


	        return {
	            /**
	             * Creates a new object that inherits from this object.
	             *
	             * @param {Object} overrides Properties to copy into the new object.
	             *
	             * @return {Object} The new object.
	             *
	             * @static
	             *
	             * @example
	             *
	             *     var MyType = CryptoJS.lib.Base.extend({
	             *         field: 'value',
	             *
	             *         method: function () {
	             *         }
	             *     });
	             */
	            extend: function (overrides) {
	                // Spawn
	                var subtype = create(this);

	                // Augment
	                if (overrides) {
	                    subtype.mixIn(overrides);
	                }

	                // Create default initializer
	                if (!subtype.hasOwnProperty('init') || this.init === subtype.init) {
	                    subtype.init = function () {
	                        subtype.$super.init.apply(this, arguments);
	                    };
	                }

	                // Initializer's prototype is the subtype object
	                subtype.init.prototype = subtype;

	                // Reference supertype
	                subtype.$super = this;

	                return subtype;
	            },

	            /**
	             * Extends this object and runs the init method.
	             * Arguments to create() will be passed to init().
	             *
	             * @return {Object} The new object.
	             *
	             * @static
	             *
	             * @example
	             *
	             *     var instance = MyType.create();
	             */
	            create: function () {
	                var instance = this.extend();
	                instance.init.apply(instance, arguments);

	                return instance;
	            },

	            /**
	             * Initializes a newly created object.
	             * Override this method to add some logic when your objects are created.
	             *
	             * @example
	             *
	             *     var MyType = CryptoJS.lib.Base.extend({
	             *         init: function () {
	             *             // ...
	             *         }
	             *     });
	             */
	            init: function () {
	            },

	            /**
	             * Copies properties into this object.
	             *
	             * @param {Object} properties The properties to mix in.
	             *
	             * @example
	             *
	             *     MyType.mixIn({
	             *         field: 'value'
	             *     });
	             */
	            mixIn: function (properties) {
	                for (var propertyName in properties) {
	                    if (properties.hasOwnProperty(propertyName)) {
	                        this[propertyName] = properties[propertyName];
	                    }
	                }

	                // IE won't copy toString using the loop above
	                if (properties.hasOwnProperty('toString')) {
	                    this.toString = properties.toString;
	                }
	            },

	            /**
	             * Creates a copy of this object.
	             *
	             * @return {Object} The clone.
	             *
	             * @example
	             *
	             *     var clone = instance.clone();
	             */
	            clone: function () {
	                return this.init.prototype.extend(this);
	            }
	        };
	    }());

	    /**
	     * An array of 32-bit words.
	     *
	     * @property {Array} words The array of 32-bit words.
	     * @property {number} sigBytes The number of significant bytes in this word array.
	     */
	    var WordArray = C_lib.WordArray = Base.extend({
	        /**
	         * Initializes a newly created word array.
	         *
	         * @param {Array} words (Optional) An array of 32-bit words.
	         * @param {number} sigBytes (Optional) The number of significant bytes in the words.
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.lib.WordArray.create();
	         *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607]);
	         *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607], 6);
	         */
	        init: function (words, sigBytes) {
	            words = this.words = words || [];

	            if (sigBytes != undefined) {
	                this.sigBytes = sigBytes;
	            } else {
	                this.sigBytes = words.length * 4;
	            }
	        },

	        /**
	         * Converts this word array to a string.
	         *
	         * @param {Encoder} encoder (Optional) The encoding strategy to use. Default: CryptoJS.enc.Hex
	         *
	         * @return {string} The stringified word array.
	         *
	         * @example
	         *
	         *     var string = wordArray + '';
	         *     var string = wordArray.toString();
	         *     var string = wordArray.toString(CryptoJS.enc.Utf8);
	         */
	        toString: function (encoder) {
	            return (encoder || Hex).stringify(this);
	        },

	        /**
	         * Concatenates a word array to this word array.
	         *
	         * @param {WordArray} wordArray The word array to append.
	         *
	         * @return {WordArray} This word array.
	         *
	         * @example
	         *
	         *     wordArray1.concat(wordArray2);
	         */
	        concat: function (wordArray) {
	            // Shortcuts
	            var thisWords = this.words;
	            var thatWords = wordArray.words;
	            var thisSigBytes = this.sigBytes;
	            var thatSigBytes = wordArray.sigBytes;

	            // Clamp excess bits
	            this.clamp();

	            // Concat
	            if (thisSigBytes % 4) {
	                // Copy one byte at a time
	                for (var i = 0; i < thatSigBytes; i++) {
	                    var thatByte = (thatWords[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
	                    thisWords[(thisSigBytes + i) >>> 2] |= thatByte << (24 - ((thisSigBytes + i) % 4) * 8);
	                }
	            } else {
	                // Copy one word at a time
	                for (var i = 0; i < thatSigBytes; i += 4) {
	                    thisWords[(thisSigBytes + i) >>> 2] = thatWords[i >>> 2];
	                }
	            }
	            this.sigBytes += thatSigBytes;

	            // Chainable
	            return this;
	        },

	        /**
	         * Removes insignificant bits.
	         *
	         * @example
	         *
	         *     wordArray.clamp();
	         */
	        clamp: function () {
	            // Shortcuts
	            var words = this.words;
	            var sigBytes = this.sigBytes;

	            // Clamp
	            words[sigBytes >>> 2] &= 0xffffffff << (32 - (sigBytes % 4) * 8);
	            words.length = Math.ceil(sigBytes / 4);
	        },

	        /**
	         * Creates a copy of this word array.
	         *
	         * @return {WordArray} The clone.
	         *
	         * @example
	         *
	         *     var clone = wordArray.clone();
	         */
	        clone: function () {
	            var clone = Base.clone.call(this);
	            clone.words = this.words.slice(0);

	            return clone;
	        },

	        /**
	         * Creates a word array filled with random bytes.
	         *
	         * @param {number} nBytes The number of random bytes to generate.
	         *
	         * @return {WordArray} The random word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.lib.WordArray.random(16);
	         */
	        random: function (nBytes) {
	            var words = [];

	            var r = (function (m_w) {
	                var m_w = m_w;
	                var m_z = 0x3ade68b1;
	                var mask = 0xffffffff;

	                return function () {
	                    m_z = (0x9069 * (m_z & 0xFFFF) + (m_z >> 0x10)) & mask;
	                    m_w = (0x4650 * (m_w & 0xFFFF) + (m_w >> 0x10)) & mask;
	                    var result = ((m_z << 0x10) + m_w) & mask;
	                    result /= 0x100000000;
	                    result += 0.5;
	                    return result * (Math.random() > .5 ? 1 : -1);
	                }
	            });

	            for (var i = 0, rcache; i < nBytes; i += 4) {
	                var _r = r((rcache || Math.random()) * 0x100000000);

	                rcache = _r() * 0x3ade67b7;
	                words.push((_r() * 0x100000000) | 0);
	            }

	            return new WordArray.init(words, nBytes);
	        }
	    });

	    /**
	     * Encoder namespace.
	     */
	    var C_enc = C.enc = {};

	    /**
	     * Hex encoding strategy.
	     */
	    var Hex = C_enc.Hex = {
	        /**
	         * Converts a word array to a hex string.
	         *
	         * @param {WordArray} wordArray The word array.
	         *
	         * @return {string} The hex string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var hexString = CryptoJS.enc.Hex.stringify(wordArray);
	         */
	        stringify: function (wordArray) {
	            // Shortcuts
	            var words = wordArray.words;
	            var sigBytes = wordArray.sigBytes;

	            // Convert
	            var hexChars = [];
	            for (var i = 0; i < sigBytes; i++) {
	                var bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
	                hexChars.push((bite >>> 4).toString(16));
	                hexChars.push((bite & 0x0f).toString(16));
	            }

	            return hexChars.join('');
	        },

	        /**
	         * Converts a hex string to a word array.
	         *
	         * @param {string} hexStr The hex string.
	         *
	         * @return {WordArray} The word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.enc.Hex.parse(hexString);
	         */
	        parse: function (hexStr) {
	            // Shortcut
	            var hexStrLength = hexStr.length;

	            // Convert
	            var words = [];
	            for (var i = 0; i < hexStrLength; i += 2) {
	                words[i >>> 3] |= parseInt(hexStr.substr(i, 2), 16) << (24 - (i % 8) * 4);
	            }

	            return new WordArray.init(words, hexStrLength / 2);
	        }
	    };

	    /**
	     * Latin1 encoding strategy.
	     */
	    var Latin1 = C_enc.Latin1 = {
	        /**
	         * Converts a word array to a Latin1 string.
	         *
	         * @param {WordArray} wordArray The word array.
	         *
	         * @return {string} The Latin1 string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var latin1String = CryptoJS.enc.Latin1.stringify(wordArray);
	         */
	        stringify: function (wordArray) {
	            // Shortcuts
	            var words = wordArray.words;
	            var sigBytes = wordArray.sigBytes;

	            // Convert
	            var latin1Chars = [];
	            for (var i = 0; i < sigBytes; i++) {
	                var bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
	                latin1Chars.push(String.fromCharCode(bite));
	            }

	            return latin1Chars.join('');
	        },

	        /**
	         * Converts a Latin1 string to a word array.
	         *
	         * @param {string} latin1Str The Latin1 string.
	         *
	         * @return {WordArray} The word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.enc.Latin1.parse(latin1String);
	         */
	        parse: function (latin1Str) {
	            // Shortcut
	            var latin1StrLength = latin1Str.length;

	            // Convert
	            var words = [];
	            for (var i = 0; i < latin1StrLength; i++) {
	                words[i >>> 2] |= (latin1Str.charCodeAt(i) & 0xff) << (24 - (i % 4) * 8);
	            }

	            return new WordArray.init(words, latin1StrLength);
	        }
	    };

	    /**
	     * UTF-8 encoding strategy.
	     */
	    var Utf8 = C_enc.Utf8 = {
	        /**
	         * Converts a word array to a UTF-8 string.
	         *
	         * @param {WordArray} wordArray The word array.
	         *
	         * @return {string} The UTF-8 string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var utf8String = CryptoJS.enc.Utf8.stringify(wordArray);
	         */
	        stringify: function (wordArray) {
	            try {
	                return decodeURIComponent(escape(Latin1.stringify(wordArray)));
	            } catch (e) {
	                throw new Error('Malformed UTF-8 data');
	            }
	        },

	        /**
	         * Converts a UTF-8 string to a word array.
	         *
	         * @param {string} utf8Str The UTF-8 string.
	         *
	         * @return {WordArray} The word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.enc.Utf8.parse(utf8String);
	         */
	        parse: function (utf8Str) {
	            return Latin1.parse(unescape(encodeURIComponent(utf8Str)));
	        }
	    };

	    /**
	     * Abstract buffered block algorithm template.
	     *
	     * The property blockSize must be implemented in a concrete subtype.
	     *
	     * @property {number} _minBufferSize The number of blocks that should be kept unprocessed in the buffer. Default: 0
	     */
	    var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm = Base.extend({
	        /**
	         * Resets this block algorithm's data buffer to its initial state.
	         *
	         * @example
	         *
	         *     bufferedBlockAlgorithm.reset();
	         */
	        reset: function () {
	            // Initial values
	            this._data = new WordArray.init();
	            this._nDataBytes = 0;
	        },

	        /**
	         * Adds new data to this block algorithm's buffer.
	         *
	         * @param {WordArray|string} data The data to append. Strings are converted to a WordArray using UTF-8.
	         *
	         * @example
	         *
	         *     bufferedBlockAlgorithm._append('data');
	         *     bufferedBlockAlgorithm._append(wordArray);
	         */
	        _append: function (data) {
	            // Convert string to WordArray, else assume WordArray already
	            if (typeof data == 'string') {
	                data = Utf8.parse(data);
	            }

	            // Append
	            this._data.concat(data);
	            this._nDataBytes += data.sigBytes;
	        },

	        /**
	         * Processes available data blocks.
	         *
	         * This method invokes _doProcessBlock(offset), which must be implemented by a concrete subtype.
	         *
	         * @param {boolean} doFlush Whether all blocks and partial blocks should be processed.
	         *
	         * @return {WordArray} The processed data.
	         *
	         * @example
	         *
	         *     var processedData = bufferedBlockAlgorithm._process();
	         *     var processedData = bufferedBlockAlgorithm._process(!!'flush');
	         */
	        _process: function (doFlush) {
	            // Shortcuts
	            var data = this._data;
	            var dataWords = data.words;
	            var dataSigBytes = data.sigBytes;
	            var blockSize = this.blockSize;
	            var blockSizeBytes = blockSize * 4;

	            // Count blocks ready
	            var nBlocksReady = dataSigBytes / blockSizeBytes;
	            if (doFlush) {
	                // Round up to include partial blocks
	                nBlocksReady = Math.ceil(nBlocksReady);
	            } else {
	                // Round down to include only full blocks,
	                // less the number of blocks that must remain in the buffer
	                nBlocksReady = Math.max((nBlocksReady | 0) - this._minBufferSize, 0);
	            }

	            // Count words ready
	            var nWordsReady = nBlocksReady * blockSize;

	            // Count bytes ready
	            var nBytesReady = Math.min(nWordsReady * 4, dataSigBytes);

	            // Process blocks
	            if (nWordsReady) {
	                for (var offset = 0; offset < nWordsReady; offset += blockSize) {
	                    // Perform concrete-algorithm logic
	                    this._doProcessBlock(dataWords, offset);
	                }

	                // Remove processed words
	                var processedWords = dataWords.splice(0, nWordsReady);
	                data.sigBytes -= nBytesReady;
	            }

	            // Return processed words
	            return new WordArray.init(processedWords, nBytesReady);
	        },

	        /**
	         * Creates a copy of this object.
	         *
	         * @return {Object} The clone.
	         *
	         * @example
	         *
	         *     var clone = bufferedBlockAlgorithm.clone();
	         */
	        clone: function () {
	            var clone = Base.clone.call(this);
	            clone._data = this._data.clone();

	            return clone;
	        },

	        _minBufferSize: 0
	    });

	    /**
	     * Abstract hasher template.
	     *
	     * @property {number} blockSize The number of 32-bit words this hasher operates on. Default: 16 (512 bits)
	     */
	    var Hasher = C_lib.Hasher = BufferedBlockAlgorithm.extend({
	        /**
	         * Configuration options.
	         */
	        cfg: Base.extend(),

	        /**
	         * Initializes a newly created hasher.
	         *
	         * @param {Object} cfg (Optional) The configuration options to use for this hash computation.
	         *
	         * @example
	         *
	         *     var hasher = CryptoJS.algo.SHA256.create();
	         */
	        init: function (cfg) {
	            // Apply config defaults
	            this.cfg = this.cfg.extend(cfg);

	            // Set initial values
	            this.reset();
	        },

	        /**
	         * Resets this hasher to its initial state.
	         *
	         * @example
	         *
	         *     hasher.reset();
	         */
	        reset: function () {
	            // Reset data buffer
	            BufferedBlockAlgorithm.reset.call(this);

	            // Perform concrete-hasher logic
	            this._doReset();
	        },

	        /**
	         * Updates this hasher with a message.
	         *
	         * @param {WordArray|string} messageUpdate The message to append.
	         *
	         * @return {Hasher} This hasher.
	         *
	         * @example
	         *
	         *     hasher.update('message');
	         *     hasher.update(wordArray);
	         */
	        update: function (messageUpdate) {
	            // Append
	            this._append(messageUpdate);

	            // Update the hash
	            this._process();

	            // Chainable
	            return this;
	        },

	        /**
	         * Finalizes the hash computation.
	         * Note that the finalize operation is effectively a destructive, read-once operation.
	         *
	         * @param {WordArray|string} messageUpdate (Optional) A final message update.
	         *
	         * @return {WordArray} The hash.
	         *
	         * @example
	         *
	         *     var hash = hasher.finalize();
	         *     var hash = hasher.finalize('message');
	         *     var hash = hasher.finalize(wordArray);
	         */
	        finalize: function (messageUpdate) {
	            // Final message update
	            if (messageUpdate) {
	                this._append(messageUpdate);
	            }

	            // Perform concrete-hasher logic
	            var hash = this._doFinalize();

	            return hash;
	        },

	        blockSize: 512/32,

	        /**
	         * Creates a shortcut function to a hasher's object interface.
	         *
	         * @param {Hasher} hasher The hasher to create a helper for.
	         *
	         * @return {Function} The shortcut function.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var SHA256 = CryptoJS.lib.Hasher._createHelper(CryptoJS.algo.SHA256);
	         */
	        _createHelper: function (hasher) {
	            return function (message, cfg) {
	                return new hasher.init(cfg).finalize(message);
	            };
	        },

	        /**
	         * Creates a shortcut function to the HMAC's object interface.
	         *
	         * @param {Hasher} hasher The hasher to use in this HMAC helper.
	         *
	         * @return {Function} The shortcut function.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var HmacSHA256 = CryptoJS.lib.Hasher._createHmacHelper(CryptoJS.algo.SHA256);
	         */
	        _createHmacHelper: function (hasher) {
	            return function (message, key) {
	                return new C_algo.HMAC.init(hasher, key).finalize(message);
	            };
	        }
	    });

	    /**
	     * Algorithm namespace.
	     */
	    var C_algo = C.algo = {};

	    return C;
	}(Math));


	return CryptoJS;

}));

/***/ }),

/***/ 754:
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__webpack_require__(9021));
	}
	else {}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var WordArray = C_lib.WordArray;
	    var C_enc = C.enc;

	    /**
	     * Base64 encoding strategy.
	     */
	    var Base64 = C_enc.Base64 = {
	        /**
	         * Converts a word array to a Base64 string.
	         *
	         * @param {WordArray} wordArray The word array.
	         *
	         * @return {string} The Base64 string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var base64String = CryptoJS.enc.Base64.stringify(wordArray);
	         */
	        stringify: function (wordArray) {
	            // Shortcuts
	            var words = wordArray.words;
	            var sigBytes = wordArray.sigBytes;
	            var map = this._map;

	            // Clamp excess bits
	            wordArray.clamp();

	            // Convert
	            var base64Chars = [];
	            for (var i = 0; i < sigBytes; i += 3) {
	                var byte1 = (words[i >>> 2]       >>> (24 - (i % 4) * 8))       & 0xff;
	                var byte2 = (words[(i + 1) >>> 2] >>> (24 - ((i + 1) % 4) * 8)) & 0xff;
	                var byte3 = (words[(i + 2) >>> 2] >>> (24 - ((i + 2) % 4) * 8)) & 0xff;

	                var triplet = (byte1 << 16) | (byte2 << 8) | byte3;

	                for (var j = 0; (j < 4) && (i + j * 0.75 < sigBytes); j++) {
	                    base64Chars.push(map.charAt((triplet >>> (6 * (3 - j))) & 0x3f));
	                }
	            }

	            // Add padding
	            var paddingChar = map.charAt(64);
	            if (paddingChar) {
	                while (base64Chars.length % 4) {
	                    base64Chars.push(paddingChar);
	                }
	            }

	            return base64Chars.join('');
	        },

	        /**
	         * Converts a Base64 string to a word array.
	         *
	         * @param {string} base64Str The Base64 string.
	         *
	         * @return {WordArray} The word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.enc.Base64.parse(base64String);
	         */
	        parse: function (base64Str) {
	            // Shortcuts
	            var base64StrLength = base64Str.length;
	            var map = this._map;
	            var reverseMap = this._reverseMap;

	            if (!reverseMap) {
	                    reverseMap = this._reverseMap = [];
	                    for (var j = 0; j < map.length; j++) {
	                        reverseMap[map.charCodeAt(j)] = j;
	                    }
	            }

	            // Ignore padding
	            var paddingChar = map.charAt(64);
	            if (paddingChar) {
	                var paddingIndex = base64Str.indexOf(paddingChar);
	                if (paddingIndex !== -1) {
	                    base64StrLength = paddingIndex;
	                }
	            }

	            // Convert
	            return parseLoop(base64Str, base64StrLength, reverseMap);

	        },

	        _map: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/='
	    };

	    function parseLoop(base64Str, base64StrLength, reverseMap) {
	      var words = [];
	      var nBytes = 0;
	      for (var i = 0; i < base64StrLength; i++) {
	          if (i % 4) {
	              var bits1 = reverseMap[base64Str.charCodeAt(i - 1)] << ((i % 4) * 2);
	              var bits2 = reverseMap[base64Str.charCodeAt(i)] >>> (6 - (i % 4) * 2);
	              words[nBytes >>> 2] |= (bits1 | bits2) << (24 - (nBytes % 4) * 8);
	              nBytes++;
	          }
	      }
	      return WordArray.create(words, nBytes);
	    }
	}());


	return CryptoJS.enc.Base64;

}));

/***/ }),

/***/ 5503:
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__webpack_require__(9021));
	}
	else {}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var WordArray = C_lib.WordArray;
	    var C_enc = C.enc;

	    /**
	     * UTF-16 BE encoding strategy.
	     */
	    var Utf16BE = C_enc.Utf16 = C_enc.Utf16BE = {
	        /**
	         * Converts a word array to a UTF-16 BE string.
	         *
	         * @param {WordArray} wordArray The word array.
	         *
	         * @return {string} The UTF-16 BE string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var utf16String = CryptoJS.enc.Utf16.stringify(wordArray);
	         */
	        stringify: function (wordArray) {
	            // Shortcuts
	            var words = wordArray.words;
	            var sigBytes = wordArray.sigBytes;

	            // Convert
	            var utf16Chars = [];
	            for (var i = 0; i < sigBytes; i += 2) {
	                var codePoint = (words[i >>> 2] >>> (16 - (i % 4) * 8)) & 0xffff;
	                utf16Chars.push(String.fromCharCode(codePoint));
	            }

	            return utf16Chars.join('');
	        },

	        /**
	         * Converts a UTF-16 BE string to a word array.
	         *
	         * @param {string} utf16Str The UTF-16 BE string.
	         *
	         * @return {WordArray} The word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.enc.Utf16.parse(utf16String);
	         */
	        parse: function (utf16Str) {
	            // Shortcut
	            var utf16StrLength = utf16Str.length;

	            // Convert
	            var words = [];
	            for (var i = 0; i < utf16StrLength; i++) {
	                words[i >>> 1] |= utf16Str.charCodeAt(i) << (16 - (i % 2) * 16);
	            }

	            return WordArray.create(words, utf16StrLength * 2);
	        }
	    };

	    /**
	     * UTF-16 LE encoding strategy.
	     */
	    C_enc.Utf16LE = {
	        /**
	         * Converts a word array to a UTF-16 LE string.
	         *
	         * @param {WordArray} wordArray The word array.
	         *
	         * @return {string} The UTF-16 LE string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var utf16Str = CryptoJS.enc.Utf16LE.stringify(wordArray);
	         */
	        stringify: function (wordArray) {
	            // Shortcuts
	            var words = wordArray.words;
	            var sigBytes = wordArray.sigBytes;

	            // Convert
	            var utf16Chars = [];
	            for (var i = 0; i < sigBytes; i += 2) {
	                var codePoint = swapEndian((words[i >>> 2] >>> (16 - (i % 4) * 8)) & 0xffff);
	                utf16Chars.push(String.fromCharCode(codePoint));
	            }

	            return utf16Chars.join('');
	        },

	        /**
	         * Converts a UTF-16 LE string to a word array.
	         *
	         * @param {string} utf16Str The UTF-16 LE string.
	         *
	         * @return {WordArray} The word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.enc.Utf16LE.parse(utf16Str);
	         */
	        parse: function (utf16Str) {
	            // Shortcut
	            var utf16StrLength = utf16Str.length;

	            // Convert
	            var words = [];
	            for (var i = 0; i < utf16StrLength; i++) {
	                words[i >>> 1] |= swapEndian(utf16Str.charCodeAt(i) << (16 - (i % 2) * 16));
	            }

	            return WordArray.create(words, utf16StrLength * 2);
	        }
	    };

	    function swapEndian(word) {
	        return ((word << 8) & 0xff00ff00) | ((word >>> 8) & 0x00ff00ff);
	    }
	}());


	return CryptoJS.enc.Utf16;

}));

/***/ }),

/***/ 9506:
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory, undef) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__webpack_require__(9021), __webpack_require__(5471), __webpack_require__(1025));
	}
	else {}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var Base = C_lib.Base;
	    var WordArray = C_lib.WordArray;
	    var C_algo = C.algo;
	    var MD5 = C_algo.MD5;

	    /**
	     * This key derivation function is meant to conform with EVP_BytesToKey.
	     * www.openssl.org/docs/crypto/EVP_BytesToKey.html
	     */
	    var EvpKDF = C_algo.EvpKDF = Base.extend({
	        /**
	         * Configuration options.
	         *
	         * @property {number} keySize The key size in words to generate. Default: 4 (128 bits)
	         * @property {Hasher} hasher The hash algorithm to use. Default: MD5
	         * @property {number} iterations The number of iterations to perform. Default: 1
	         */
	        cfg: Base.extend({
	            keySize: 128/32,
	            hasher: MD5,
	            iterations: 1
	        }),

	        /**
	         * Initializes a newly created key derivation function.
	         *
	         * @param {Object} cfg (Optional) The configuration options to use for the derivation.
	         *
	         * @example
	         *
	         *     var kdf = CryptoJS.algo.EvpKDF.create();
	         *     var kdf = CryptoJS.algo.EvpKDF.create({ keySize: 8 });
	         *     var kdf = CryptoJS.algo.EvpKDF.create({ keySize: 8, iterations: 1000 });
	         */
	        init: function (cfg) {
	            this.cfg = this.cfg.extend(cfg);
	        },

	        /**
	         * Derives a key from a password.
	         *
	         * @param {WordArray|string} password The password.
	         * @param {WordArray|string} salt A salt.
	         *
	         * @return {WordArray} The derived key.
	         *
	         * @example
	         *
	         *     var key = kdf.compute(password, salt);
	         */
	        compute: function (password, salt) {
	            // Shortcut
	            var cfg = this.cfg;

	            // Init hasher
	            var hasher = cfg.hasher.create();

	            // Initial values
	            var derivedKey = WordArray.create();

	            // Shortcuts
	            var derivedKeyWords = derivedKey.words;
	            var keySize = cfg.keySize;
	            var iterations = cfg.iterations;

	            // Generate key
	            while (derivedKeyWords.length < keySize) {
	                if (block) {
	                    hasher.update(block);
	                }
	                var block = hasher.update(password).finalize(salt);
	                hasher.reset();

	                // Iterations
	                for (var i = 1; i < iterations; i++) {
	                    block = hasher.finalize(block);
	                    hasher.reset();
	                }

	                derivedKey.concat(block);
	            }
	            derivedKey.sigBytes = keySize * 4;

	            return derivedKey;
	        }
	    });

	    /**
	     * Derives a key from a password.
	     *
	     * @param {WordArray|string} password The password.
	     * @param {WordArray|string} salt A salt.
	     * @param {Object} cfg (Optional) The configuration options to use for this computation.
	     *
	     * @return {WordArray} The derived key.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var key = CryptoJS.EvpKDF(password, salt);
	     *     var key = CryptoJS.EvpKDF(password, salt, { keySize: 8 });
	     *     var key = CryptoJS.EvpKDF(password, salt, { keySize: 8, iterations: 1000 });
	     */
	    C.EvpKDF = function (password, salt, cfg) {
	        return EvpKDF.create(cfg).compute(password, salt);
	    };
	}());


	return CryptoJS.EvpKDF;

}));

/***/ }),

/***/ 25:
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory, undef) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__webpack_require__(9021), __webpack_require__(7165));
	}
	else {}
}(this, function (CryptoJS) {

	(function (undefined) {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var CipherParams = C_lib.CipherParams;
	    var C_enc = C.enc;
	    var Hex = C_enc.Hex;
	    var C_format = C.format;

	    var HexFormatter = C_format.Hex = {
	        /**
	         * Converts the ciphertext of a cipher params object to a hexadecimally encoded string.
	         *
	         * @param {CipherParams} cipherParams The cipher params object.
	         *
	         * @return {string} The hexadecimally encoded string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var hexString = CryptoJS.format.Hex.stringify(cipherParams);
	         */
	        stringify: function (cipherParams) {
	            return cipherParams.ciphertext.toString(Hex);
	        },

	        /**
	         * Converts a hexadecimally encoded ciphertext string to a cipher params object.
	         *
	         * @param {string} input The hexadecimally encoded string.
	         *
	         * @return {CipherParams} The cipher params object.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var cipherParams = CryptoJS.format.Hex.parse(hexString);
	         */
	        parse: function (input) {
	            var ciphertext = Hex.parse(input);
	            return CipherParams.create({ ciphertext: ciphertext });
	        }
	    };
	}());


	return CryptoJS.format.Hex;

}));

/***/ }),

/***/ 1025:
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__webpack_require__(9021));
	}
	else {}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var Base = C_lib.Base;
	    var C_enc = C.enc;
	    var Utf8 = C_enc.Utf8;
	    var C_algo = C.algo;

	    /**
	     * HMAC algorithm.
	     */
	    var HMAC = C_algo.HMAC = Base.extend({
	        /**
	         * Initializes a newly created HMAC.
	         *
	         * @param {Hasher} hasher The hash algorithm to use.
	         * @param {WordArray|string} key The secret key.
	         *
	         * @example
	         *
	         *     var hmacHasher = CryptoJS.algo.HMAC.create(CryptoJS.algo.SHA256, key);
	         */
	        init: function (hasher, key) {
	            // Init hasher
	            hasher = this._hasher = new hasher.init();

	            // Convert string to WordArray, else assume WordArray already
	            if (typeof key == 'string') {
	                key = Utf8.parse(key);
	            }

	            // Shortcuts
	            var hasherBlockSize = hasher.blockSize;
	            var hasherBlockSizeBytes = hasherBlockSize * 4;

	            // Allow arbitrary length keys
	            if (key.sigBytes > hasherBlockSizeBytes) {
	                key = hasher.finalize(key);
	            }

	            // Clamp excess bits
	            key.clamp();

	            // Clone key for inner and outer pads
	            var oKey = this._oKey = key.clone();
	            var iKey = this._iKey = key.clone();

	            // Shortcuts
	            var oKeyWords = oKey.words;
	            var iKeyWords = iKey.words;

	            // XOR keys with pad constants
	            for (var i = 0; i < hasherBlockSize; i++) {
	                oKeyWords[i] ^= 0x5c5c5c5c;
	                iKeyWords[i] ^= 0x36363636;
	            }
	            oKey.sigBytes = iKey.sigBytes = hasherBlockSizeBytes;

	            // Set initial values
	            this.reset();
	        },

	        /**
	         * Resets this HMAC to its initial state.
	         *
	         * @example
	         *
	         *     hmacHasher.reset();
	         */
	        reset: function () {
	            // Shortcut
	            var hasher = this._hasher;

	            // Reset
	            hasher.reset();
	            hasher.update(this._iKey);
	        },

	        /**
	         * Updates this HMAC with a message.
	         *
	         * @param {WordArray|string} messageUpdate The message to append.
	         *
	         * @return {HMAC} This HMAC instance.
	         *
	         * @example
	         *
	         *     hmacHasher.update('message');
	         *     hmacHasher.update(wordArray);
	         */
	        update: function (messageUpdate) {
	            this._hasher.update(messageUpdate);

	            // Chainable
	            return this;
	        },

	        /**
	         * Finalizes the HMAC computation.
	         * Note that the finalize operation is effectively a destructive, read-once operation.
	         *
	         * @param {WordArray|string} messageUpdate (Optional) A final message update.
	         *
	         * @return {WordArray} The HMAC.
	         *
	         * @example
	         *
	         *     var hmac = hmacHasher.finalize();
	         *     var hmac = hmacHasher.finalize('message');
	         *     var hmac = hmacHasher.finalize(wordArray);
	         */
	        finalize: function (messageUpdate) {
	            // Shortcut
	            var hasher = this._hasher;

	            // Compute HMAC
	            var innerHash = hasher.finalize(messageUpdate);
	            hasher.reset();
	            var hmac = hasher.finalize(this._oKey.clone().concat(innerHash));

	            return hmac;
	        }
	    });
	}());


}));

/***/ }),

/***/ 1396:
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory, undef) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__webpack_require__(9021), __webpack_require__(3240), __webpack_require__(6440), __webpack_require__(5503), __webpack_require__(754), __webpack_require__(4636), __webpack_require__(5471), __webpack_require__(3009), __webpack_require__(6308), __webpack_require__(1380), __webpack_require__(9557), __webpack_require__(5953), __webpack_require__(8056), __webpack_require__(1025), __webpack_require__(19), __webpack_require__(9506), __webpack_require__(7165), __webpack_require__(2169), __webpack_require__(6939), __webpack_require__(6372), __webpack_require__(3797), __webpack_require__(8454), __webpack_require__(2073), __webpack_require__(4905), __webpack_require__(482), __webpack_require__(2155), __webpack_require__(8124), __webpack_require__(25), __webpack_require__(955), __webpack_require__(7628), __webpack_require__(7193), __webpack_require__(6298), __webpack_require__(2696));
	}
	else {}
}(this, function (CryptoJS) {

	return CryptoJS;

}));

/***/ }),

/***/ 6440:
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__webpack_require__(9021));
	}
	else {}
}(this, function (CryptoJS) {

	(function () {
	    // Check if typed arrays are supported
	    if (typeof ArrayBuffer != 'function') {
	        return;
	    }

	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var WordArray = C_lib.WordArray;

	    // Reference original init
	    var superInit = WordArray.init;

	    // Augment WordArray.init to handle typed arrays
	    var subInit = WordArray.init = function (typedArray) {
	        // Convert buffers to uint8
	        if (typedArray instanceof ArrayBuffer) {
	            typedArray = new Uint8Array(typedArray);
	        }

	        // Convert other array views to uint8
	        if (
	            typedArray instanceof Int8Array ||
	            (typeof Uint8ClampedArray !== "undefined" && typedArray instanceof Uint8ClampedArray) ||
	            typedArray instanceof Int16Array ||
	            typedArray instanceof Uint16Array ||
	            typedArray instanceof Int32Array ||
	            typedArray instanceof Uint32Array ||
	            typedArray instanceof Float32Array ||
	            typedArray instanceof Float64Array
	        ) {
	            typedArray = new Uint8Array(typedArray.buffer, typedArray.byteOffset, typedArray.byteLength);
	        }

	        // Handle Uint8Array
	        if (typedArray instanceof Uint8Array) {
	            // Shortcut
	            var typedArrayByteLength = typedArray.byteLength;

	            // Extract bytes
	            var words = [];
	            for (var i = 0; i < typedArrayByteLength; i++) {
	                words[i >>> 2] |= typedArray[i] << (24 - (i % 4) * 8);
	            }

	            // Initialize this word array
	            superInit.call(this, words, typedArrayByteLength);
	        } else {
	            // Else call normal init
	            superInit.apply(this, arguments);
	        }
	    };

	    subInit.prototype = WordArray;
	}());


	return CryptoJS.lib.WordArray;

}));

/***/ }),

/***/ 4636:
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__webpack_require__(9021));
	}
	else {}
}(this, function (CryptoJS) {

	(function (Math) {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var WordArray = C_lib.WordArray;
	    var Hasher = C_lib.Hasher;
	    var C_algo = C.algo;

	    // Constants table
	    var T = [];

	    // Compute constants
	    (function () {
	        for (var i = 0; i < 64; i++) {
	            T[i] = (Math.abs(Math.sin(i + 1)) * 0x100000000) | 0;
	        }
	    }());

	    /**
	     * MD5 hash algorithm.
	     */
	    var MD5 = C_algo.MD5 = Hasher.extend({
	        _doReset: function () {
	            this._hash = new WordArray.init([
	                0x67452301, 0xefcdab89,
	                0x98badcfe, 0x10325476
	            ]);
	        },

	        _doProcessBlock: function (M, offset) {
	            // Swap endian
	            for (var i = 0; i < 16; i++) {
	                // Shortcuts
	                var offset_i = offset + i;
	                var M_offset_i = M[offset_i];

	                M[offset_i] = (
	                    (((M_offset_i << 8)  | (M_offset_i >>> 24)) & 0x00ff00ff) |
	                    (((M_offset_i << 24) | (M_offset_i >>> 8))  & 0xff00ff00)
	                );
	            }

	            // Shortcuts
	            var H = this._hash.words;

	            var M_offset_0  = M[offset + 0];
	            var M_offset_1  = M[offset + 1];
	            var M_offset_2  = M[offset + 2];
	            var M_offset_3  = M[offset + 3];
	            var M_offset_4  = M[offset + 4];
	            var M_offset_5  = M[offset + 5];
	            var M_offset_6  = M[offset + 6];
	            var M_offset_7  = M[offset + 7];
	            var M_offset_8  = M[offset + 8];
	            var M_offset_9  = M[offset + 9];
	            var M_offset_10 = M[offset + 10];
	            var M_offset_11 = M[offset + 11];
	            var M_offset_12 = M[offset + 12];
	            var M_offset_13 = M[offset + 13];
	            var M_offset_14 = M[offset + 14];
	            var M_offset_15 = M[offset + 15];

	            // Working varialbes
	            var a = H[0];
	            var b = H[1];
	            var c = H[2];
	            var d = H[3];

	            // Computation
	            a = FF(a, b, c, d, M_offset_0,  7,  T[0]);
	            d = FF(d, a, b, c, M_offset_1,  12, T[1]);
	            c = FF(c, d, a, b, M_offset_2,  17, T[2]);
	            b = FF(b, c, d, a, M_offset_3,  22, T[3]);
	            a = FF(a, b, c, d, M_offset_4,  7,  T[4]);
	            d = FF(d, a, b, c, M_offset_5,  12, T[5]);
	            c = FF(c, d, a, b, M_offset_6,  17, T[6]);
	            b = FF(b, c, d, a, M_offset_7,  22, T[7]);
	            a = FF(a, b, c, d, M_offset_8,  7,  T[8]);
	            d = FF(d, a, b, c, M_offset_9,  12, T[9]);
	            c = FF(c, d, a, b, M_offset_10, 17, T[10]);
	            b = FF(b, c, d, a, M_offset_11, 22, T[11]);
	            a = FF(a, b, c, d, M_offset_12, 7,  T[12]);
	            d = FF(d, a, b, c, M_offset_13, 12, T[13]);
	            c = FF(c, d, a, b, M_offset_14, 17, T[14]);
	            b = FF(b, c, d, a, M_offset_15, 22, T[15]);

	            a = GG(a, b, c, d, M_offset_1,  5,  T[16]);
	            d = GG(d, a, b, c, M_offset_6,  9,  T[17]);
	            c = GG(c, d, a, b, M_offset_11, 14, T[18]);
	            b = GG(b, c, d, a, M_offset_0,  20, T[19]);
	            a = GG(a, b, c, d, M_offset_5,  5,  T[20]);
	            d = GG(d, a, b, c, M_offset_10, 9,  T[21]);
	            c = GG(c, d, a, b, M_offset_15, 14, T[22]);
	            b = GG(b, c, d, a, M_offset_4,  20, T[23]);
	            a = GG(a, b, c, d, M_offset_9,  5,  T[24]);
	            d = GG(d, a, b, c, M_offset_14, 9,  T[25]);
	            c = GG(c, d, a, b, M_offset_3,  14, T[26]);
	            b = GG(b, c, d, a, M_offset_8,  20, T[27]);
	            a = GG(a, b, c, d, M_offset_13, 5,  T[28]);
	            d = GG(d, a, b, c, M_offset_2,  9,  T[29]);
	            c = GG(c, d, a, b, M_offset_7,  14, T[30]);
	            b = GG(b, c, d, a, M_offset_12, 20, T[31]);

	            a = HH(a, b, c, d, M_offset_5,  4,  T[32]);
	            d = HH(d, a, b, c, M_offset_8,  11, T[33]);
	            c = HH(c, d, a, b, M_offset_11, 16, T[34]);
	            b = HH(b, c, d, a, M_offset_14, 23, T[35]);
	            a = HH(a, b, c, d, M_offset_1,  4,  T[36]);
	            d = HH(d, a, b, c, M_offset_4,  11, T[37]);
	            c = HH(c, d, a, b, M_offset_7,  16, T[38]);
	            b = HH(b, c, d, a, M_offset_10, 23, T[39]);
	            a = HH(a, b, c, d, M_offset_13, 4,  T[40]);
	            d = HH(d, a, b, c, M_offset_0,  11, T[41]);
	            c = HH(c, d, a, b, M_offset_3,  16, T[42]);
	            b = HH(b, c, d, a, M_offset_6,  23, T[43]);
	            a = HH(a, b, c, d, M_offset_9,  4,  T[44]);
	            d = HH(d, a, b, c, M_offset_12, 11, T[45]);
	            c = HH(c, d, a, b, M_offset_15, 16, T[46]);
	            b = HH(b, c, d, a, M_offset_2,  23, T[47]);

	            a = II(a, b, c, d, M_offset_0,  6,  T[48]);
	            d = II(d, a, b, c, M_offset_7,  10, T[49]);
	            c = II(c, d, a, b, M_offset_14, 15, T[50]);
	            b = II(b, c, d, a, M_offset_5,  21, T[51]);
	            a = II(a, b, c, d, M_offset_12, 6,  T[52]);
	            d = II(d, a, b, c, M_offset_3,  10, T[53]);
	            c = II(c, d, a, b, M_offset_10, 15, T[54]);
	            b = II(b, c, d, a, M_offset_1,  21, T[55]);
	            a = II(a, b, c, d, M_offset_8,  6,  T[56]);
	            d = II(d, a, b, c, M_offset_15, 10, T[57]);
	            c = II(c, d, a, b, M_offset_6,  15, T[58]);
	            b = II(b, c, d, a, M_offset_13, 21, T[59]);
	            a = II(a, b, c, d, M_offset_4,  6,  T[60]);
	            d = II(d, a, b, c, M_offset_11, 10, T[61]);
	            c = II(c, d, a, b, M_offset_2,  15, T[62]);
	            b = II(b, c, d, a, M_offset_9,  21, T[63]);

	            // Intermediate hash value
	            H[0] = (H[0] + a) | 0;
	            H[1] = (H[1] + b) | 0;
	            H[2] = (H[2] + c) | 0;
	            H[3] = (H[3] + d) | 0;
	        },

	        _doFinalize: function () {
	            // Shortcuts
	            var data = this._data;
	            var dataWords = data.words;

	            var nBitsTotal = this._nDataBytes * 8;
	            var nBitsLeft = data.sigBytes * 8;

	            // Add padding
	            dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);

	            var nBitsTotalH = Math.floor(nBitsTotal / 0x100000000);
	            var nBitsTotalL = nBitsTotal;
	            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 15] = (
	                (((nBitsTotalH << 8)  | (nBitsTotalH >>> 24)) & 0x00ff00ff) |
	                (((nBitsTotalH << 24) | (nBitsTotalH >>> 8))  & 0xff00ff00)
	            );
	            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = (
	                (((nBitsTotalL << 8)  | (nBitsTotalL >>> 24)) & 0x00ff00ff) |
	                (((nBitsTotalL << 24) | (nBitsTotalL >>> 8))  & 0xff00ff00)
	            );

	            data.sigBytes = (dataWords.length + 1) * 4;

	            // Hash final blocks
	            this._process();

	            // Shortcuts
	            var hash = this._hash;
	            var H = hash.words;

	            // Swap endian
	            for (var i = 0; i < 4; i++) {
	                // Shortcut
	                var H_i = H[i];

	                H[i] = (((H_i << 8)  | (H_i >>> 24)) & 0x00ff00ff) |
	                       (((H_i << 24) | (H_i >>> 8))  & 0xff00ff00);
	            }

	            // Return final computed hash
	            return hash;
	        },

	        clone: function () {
	            var clone = Hasher.clone.call(this);
	            clone._hash = this._hash.clone();

	            return clone;
	        }
	    });

	    function FF(a, b, c, d, x, s, t) {
	        var n = a + ((b & c) | (~b & d)) + x + t;
	        return ((n << s) | (n >>> (32 - s))) + b;
	    }

	    function GG(a, b, c, d, x, s, t) {
	        var n = a + ((b & d) | (c & ~d)) + x + t;
	        return ((n << s) | (n >>> (32 - s))) + b;
	    }

	    function HH(a, b, c, d, x, s, t) {
	        var n = a + (b ^ c ^ d) + x + t;
	        return ((n << s) | (n >>> (32 - s))) + b;
	    }

	    function II(a, b, c, d, x, s, t) {
	        var n = a + (c ^ (b | ~d)) + x + t;
	        return ((n << s) | (n >>> (32 - s))) + b;
	    }

	    /**
	     * Shortcut function to the hasher's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     *
	     * @return {WordArray} The hash.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hash = CryptoJS.MD5('message');
	     *     var hash = CryptoJS.MD5(wordArray);
	     */
	    C.MD5 = Hasher._createHelper(MD5);

	    /**
	     * Shortcut function to the HMAC's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     * @param {WordArray|string} key The secret key.
	     *
	     * @return {WordArray} The HMAC.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hmac = CryptoJS.HmacMD5(message, key);
	     */
	    C.HmacMD5 = Hasher._createHmacHelper(MD5);
	}(Math));


	return CryptoJS.MD5;

}));

/***/ }),

/***/ 2169:
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory, undef) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__webpack_require__(9021), __webpack_require__(7165));
	}
	else {}
}(this, function (CryptoJS) {

	/**
	 * Cipher Feedback block mode.
	 */
	CryptoJS.mode.CFB = (function () {
	    var CFB = CryptoJS.lib.BlockCipherMode.extend();

	    CFB.Encryptor = CFB.extend({
	        processBlock: function (words, offset) {
	            // Shortcuts
	            var cipher = this._cipher;
	            var blockSize = cipher.blockSize;

	            generateKeystreamAndEncrypt.call(this, words, offset, blockSize, cipher);

	            // Remember this block to use with next block
	            this._prevBlock = words.slice(offset, offset + blockSize);
	        }
	    });

	    CFB.Decryptor = CFB.extend({
	        processBlock: function (words, offset) {
	            // Shortcuts
	            var cipher = this._cipher;
	            var blockSize = cipher.blockSize;

	            // Remember this block to use with next block
	            var thisBlock = words.slice(offset, offset + blockSize);

	            generateKeystreamAndEncrypt.call(this, words, offset, blockSize, cipher);

	            // This block becomes the previous block
	            this._prevBlock = thisBlock;
	        }
	    });

	    function generateKeystreamAndEncrypt(words, offset, blockSize, cipher) {
	        // Shortcut
	        var iv = this._iv;

	        // Generate keystream
	        if (iv) {
	            var keystream = iv.slice(0);

	            // Remove IV for subsequent blocks
	            this._iv = undefined;
	        } else {
	            var keystream = this._prevBlock;
	        }
	        cipher.encryptBlock(keystream, 0);

	        // Encrypt
	        for (var i = 0; i < blockSize; i++) {
	            words[offset + i] ^= keystream[i];
	        }
	    }

	    return CFB;
	}());


	return CryptoJS.mode.CFB;

}));

/***/ }),

/***/ 6372:
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory, undef) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__webpack_require__(9021), __webpack_require__(7165));
	}
	else {}
}(this, function (CryptoJS) {

	/** @preserve
	 * Counter block mode compatible with  Dr Brian Gladman fileenc.c
	 * derived from CryptoJS.mode.CTR
	 * Jan Hruby jhruby.web@gmail.com
	 */
	CryptoJS.mode.CTRGladman = (function () {
	    var CTRGladman = CryptoJS.lib.BlockCipherMode.extend();

		function incWord(word)
		{
			if (((word >> 24) & 0xff) === 0xff) { //overflow
			var b1 = (word >> 16)&0xff;
			var b2 = (word >> 8)&0xff;
			var b3 = word & 0xff;

			if (b1 === 0xff) // overflow b1
			{
			b1 = 0;
			if (b2 === 0xff)
			{
				b2 = 0;
				if (b3 === 0xff)
				{
					b3 = 0;
				}
				else
				{
					++b3;
				}
			}
			else
			{
				++b2;
			}
			}
			else
			{
			++b1;
			}

			word = 0;
			word += (b1 << 16);
			word += (b2 << 8);
			word += b3;
			}
			else
			{
			word += (0x01 << 24);
			}
			return word;
		}

		function incCounter(counter)
		{
			if ((counter[0] = incWord(counter[0])) === 0)
			{
				// encr_data in fileenc.c from  Dr Brian Gladman's counts only with DWORD j < 8
				counter[1] = incWord(counter[1]);
			}
			return counter;
		}

	    var Encryptor = CTRGladman.Encryptor = CTRGladman.extend({
	        processBlock: function (words, offset) {
	            // Shortcuts
	            var cipher = this._cipher
	            var blockSize = cipher.blockSize;
	            var iv = this._iv;
	            var counter = this._counter;

	            // Generate keystream
	            if (iv) {
	                counter = this._counter = iv.slice(0);

	                // Remove IV for subsequent blocks
	                this._iv = undefined;
	            }

				incCounter(counter);

				var keystream = counter.slice(0);
	            cipher.encryptBlock(keystream, 0);

	            // Encrypt
	            for (var i = 0; i < blockSize; i++) {
	                words[offset + i] ^= keystream[i];
	            }
	        }
	    });

	    CTRGladman.Decryptor = Encryptor;

	    return CTRGladman;
	}());




	return CryptoJS.mode.CTRGladman;

}));

/***/ }),

/***/ 6939:
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory, undef) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__webpack_require__(9021), __webpack_require__(7165));
	}
	else {}
}(this, function (CryptoJS) {

	/**
	 * Counter block mode.
	 */
	CryptoJS.mode.CTR = (function () {
	    var CTR = CryptoJS.lib.BlockCipherMode.extend();

	    var Encryptor = CTR.Encryptor = CTR.extend({
	        processBlock: function (words, offset) {
	            // Shortcuts
	            var cipher = this._cipher
	            var blockSize = cipher.blockSize;
	            var iv = this._iv;
	            var counter = this._counter;

	            // Generate keystream
	            if (iv) {
	                counter = this._counter = iv.slice(0);

	                // Remove IV for subsequent blocks
	                this._iv = undefined;
	            }
	            var keystream = counter.slice(0);
	            cipher.encryptBlock(keystream, 0);

	            // Increment counter
	            counter[blockSize - 1] = (counter[blockSize - 1] + 1) | 0

	            // Encrypt
	            for (var i = 0; i < blockSize; i++) {
	                words[offset + i] ^= keystream[i];
	            }
	        }
	    });

	    CTR.Decryptor = Encryptor;

	    return CTR;
	}());


	return CryptoJS.mode.CTR;

}));

/***/ }),

/***/ 8454:
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory, undef) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__webpack_require__(9021), __webpack_require__(7165));
	}
	else {}
}(this, function (CryptoJS) {

	/**
	 * Electronic Codebook block mode.
	 */
	CryptoJS.mode.ECB = (function () {
	    var ECB = CryptoJS.lib.BlockCipherMode.extend();

	    ECB.Encryptor = ECB.extend({
	        processBlock: function (words, offset) {
	            this._cipher.encryptBlock(words, offset);
	        }
	    });

	    ECB.Decryptor = ECB.extend({
	        processBlock: function (words, offset) {
	            this._cipher.decryptBlock(words, offset);
	        }
	    });

	    return ECB;
	}());


	return CryptoJS.mode.ECB;

}));

/***/ }),

/***/ 3797:
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory, undef) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__webpack_require__(9021), __webpack_require__(7165));
	}
	else {}
}(this, function (CryptoJS) {

	/**
	 * Output Feedback block mode.
	 */
	CryptoJS.mode.OFB = (function () {
	    var OFB = CryptoJS.lib.BlockCipherMode.extend();

	    var Encryptor = OFB.Encryptor = OFB.extend({
	        processBlock: function (words, offset) {
	            // Shortcuts
	            var cipher = this._cipher
	            var blockSize = cipher.blockSize;
	            var iv = this._iv;
	            var keystream = this._keystream;

	            // Generate keystream
	            if (iv) {
	                keystream = this._keystream = iv.slice(0);

	                // Remove IV for subsequent blocks
	                this._iv = undefined;
	            }
	            cipher.encryptBlock(keystream, 0);

	            // Encrypt
	            for (var i = 0; i < blockSize; i++) {
	                words[offset + i] ^= keystream[i];
	            }
	        }
	    });

	    OFB.Decryptor = Encryptor;

	    return OFB;
	}());


	return CryptoJS.mode.OFB;

}));

/***/ }),

/***/ 2073:
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory, undef) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__webpack_require__(9021), __webpack_require__(7165));
	}
	else {}
}(this, function (CryptoJS) {

	/**
	 * ANSI X.923 padding strategy.
	 */
	CryptoJS.pad.AnsiX923 = {
	    pad: function (data, blockSize) {
	        // Shortcuts
	        var dataSigBytes = data.sigBytes;
	        var blockSizeBytes = blockSize * 4;

	        // Count padding bytes
	        var nPaddingBytes = blockSizeBytes - dataSigBytes % blockSizeBytes;

	        // Compute last byte position
	        var lastBytePos = dataSigBytes + nPaddingBytes - 1;

	        // Pad
	        data.clamp();
	        data.words[lastBytePos >>> 2] |= nPaddingBytes << (24 - (lastBytePos % 4) * 8);
	        data.sigBytes += nPaddingBytes;
	    },

	    unpad: function (data) {
	        // Get number of padding bytes from last byte
	        var nPaddingBytes = data.words[(data.sigBytes - 1) >>> 2] & 0xff;

	        // Remove padding
	        data.sigBytes -= nPaddingBytes;
	    }
	};


	return CryptoJS.pad.Ansix923;

}));

/***/ }),

/***/ 4905:
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory, undef) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__webpack_require__(9021), __webpack_require__(7165));
	}
	else {}
}(this, function (CryptoJS) {

	/**
	 * ISO 10126 padding strategy.
	 */
	CryptoJS.pad.Iso10126 = {
	    pad: function (data, blockSize) {
	        // Shortcut
	        var blockSizeBytes = blockSize * 4;

	        // Count padding bytes
	        var nPaddingBytes = blockSizeBytes - data.sigBytes % blockSizeBytes;

	        // Pad
	        data.concat(CryptoJS.lib.WordArray.random(nPaddingBytes - 1)).
	             concat(CryptoJS.lib.WordArray.create([nPaddingBytes << 24], 1));
	    },

	    unpad: function (data) {
	        // Get number of padding bytes from last byte
	        var nPaddingBytes = data.words[(data.sigBytes - 1) >>> 2] & 0xff;

	        // Remove padding
	        data.sigBytes -= nPaddingBytes;
	    }
	};


	return CryptoJS.pad.Iso10126;

}));

/***/ }),

/***/ 482:
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory, undef) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__webpack_require__(9021), __webpack_require__(7165));
	}
	else {}
}(this, function (CryptoJS) {

	/**
	 * ISO/IEC 9797-1 Padding Method 2.
	 */
	CryptoJS.pad.Iso97971 = {
	    pad: function (data, blockSize) {
	        // Add 0x80 byte
	        data.concat(CryptoJS.lib.WordArray.create([0x80000000], 1));

	        // Zero pad the rest
	        CryptoJS.pad.ZeroPadding.pad(data, blockSize);
	    },

	    unpad: function (data) {
	        // Remove zero padding
	        CryptoJS.pad.ZeroPadding.unpad(data);

	        // Remove one more byte -- the 0x80 byte
	        data.sigBytes--;
	    }
	};


	return CryptoJS.pad.Iso97971;

}));

/***/ }),

/***/ 8124:
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory, undef) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__webpack_require__(9021), __webpack_require__(7165));
	}
	else {}
}(this, function (CryptoJS) {

	/**
	 * A noop padding strategy.
	 */
	CryptoJS.pad.NoPadding = {
	    pad: function () {
	    },

	    unpad: function () {
	    }
	};


	return CryptoJS.pad.NoPadding;

}));

/***/ }),

/***/ 2155:
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory, undef) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__webpack_require__(9021), __webpack_require__(7165));
	}
	else {}
}(this, function (CryptoJS) {

	/**
	 * Zero padding strategy.
	 */
	CryptoJS.pad.ZeroPadding = {
	    pad: function (data, blockSize) {
	        // Shortcut
	        var blockSizeBytes = blockSize * 4;

	        // Pad
	        data.clamp();
	        data.sigBytes += blockSizeBytes - ((data.sigBytes % blockSizeBytes) || blockSizeBytes);
	    },

	    unpad: function (data) {
	        // Shortcut
	        var dataWords = data.words;

	        // Unpad
	        var i = data.sigBytes - 1;
	        while (!((dataWords[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff)) {
	            i--;
	        }
	        data.sigBytes = i + 1;
	    }
	};


	return CryptoJS.pad.ZeroPadding;

}));

/***/ }),

/***/ 19:
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory, undef) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__webpack_require__(9021), __webpack_require__(5471), __webpack_require__(1025));
	}
	else {}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var Base = C_lib.Base;
	    var WordArray = C_lib.WordArray;
	    var C_algo = C.algo;
	    var SHA1 = C_algo.SHA1;
	    var HMAC = C_algo.HMAC;

	    /**
	     * Password-Based Key Derivation Function 2 algorithm.
	     */
	    var PBKDF2 = C_algo.PBKDF2 = Base.extend({
	        /**
	         * Configuration options.
	         *
	         * @property {number} keySize The key size in words to generate. Default: 4 (128 bits)
	         * @property {Hasher} hasher The hasher to use. Default: SHA1
	         * @property {number} iterations The number of iterations to perform. Default: 1
	         */
	        cfg: Base.extend({
	            keySize: 128/32,
	            hasher: SHA1,
	            iterations: 1
	        }),

	        /**
	         * Initializes a newly created key derivation function.
	         *
	         * @param {Object} cfg (Optional) The configuration options to use for the derivation.
	         *
	         * @example
	         *
	         *     var kdf = CryptoJS.algo.PBKDF2.create();
	         *     var kdf = CryptoJS.algo.PBKDF2.create({ keySize: 8 });
	         *     var kdf = CryptoJS.algo.PBKDF2.create({ keySize: 8, iterations: 1000 });
	         */
	        init: function (cfg) {
	            this.cfg = this.cfg.extend(cfg);
	        },

	        /**
	         * Computes the Password-Based Key Derivation Function 2.
	         *
	         * @param {WordArray|string} password The password.
	         * @param {WordArray|string} salt A salt.
	         *
	         * @return {WordArray} The derived key.
	         *
	         * @example
	         *
	         *     var key = kdf.compute(password, salt);
	         */
	        compute: function (password, salt) {
	            // Shortcut
	            var cfg = this.cfg;

	            // Init HMAC
	            var hmac = HMAC.create(cfg.hasher, password);

	            // Initial values
	            var derivedKey = WordArray.create();
	            var blockIndex = WordArray.create([0x00000001]);

	            // Shortcuts
	            var derivedKeyWords = derivedKey.words;
	            var blockIndexWords = blockIndex.words;
	            var keySize = cfg.keySize;
	            var iterations = cfg.iterations;

	            // Generate key
	            while (derivedKeyWords.length < keySize) {
	                var block = hmac.update(salt).finalize(blockIndex);
	                hmac.reset();

	                // Shortcuts
	                var blockWords = block.words;
	                var blockWordsLength = blockWords.length;

	                // Iterations
	                var intermediate = block;
	                for (var i = 1; i < iterations; i++) {
	                    intermediate = hmac.finalize(intermediate);
	                    hmac.reset();

	                    // Shortcut
	                    var intermediateWords = intermediate.words;

	                    // XOR intermediate with block
	                    for (var j = 0; j < blockWordsLength; j++) {
	                        blockWords[j] ^= intermediateWords[j];
	                    }
	                }

	                derivedKey.concat(block);
	                blockIndexWords[0]++;
	            }
	            derivedKey.sigBytes = keySize * 4;

	            return derivedKey;
	        }
	    });

	    /**
	     * Computes the Password-Based Key Derivation Function 2.
	     *
	     * @param {WordArray|string} password The password.
	     * @param {WordArray|string} salt A salt.
	     * @param {Object} cfg (Optional) The configuration options to use for this computation.
	     *
	     * @return {WordArray} The derived key.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var key = CryptoJS.PBKDF2(password, salt);
	     *     var key = CryptoJS.PBKDF2(password, salt, { keySize: 8 });
	     *     var key = CryptoJS.PBKDF2(password, salt, { keySize: 8, iterations: 1000 });
	     */
	    C.PBKDF2 = function (password, salt, cfg) {
	        return PBKDF2.create(cfg).compute(password, salt);
	    };
	}());


	return CryptoJS.PBKDF2;

}));

/***/ }),

/***/ 2696:
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory, undef) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__webpack_require__(9021), __webpack_require__(754), __webpack_require__(4636), __webpack_require__(9506), __webpack_require__(7165));
	}
	else {}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var StreamCipher = C_lib.StreamCipher;
	    var C_algo = C.algo;

	    // Reusable objects
	    var S  = [];
	    var C_ = [];
	    var G  = [];

	    /**
	     * Rabbit stream cipher algorithm.
	     *
	     * This is a legacy version that neglected to convert the key to little-endian.
	     * This error doesn't affect the cipher's security,
	     * but it does affect its compatibility with other implementations.
	     */
	    var RabbitLegacy = C_algo.RabbitLegacy = StreamCipher.extend({
	        _doReset: function () {
	            // Shortcuts
	            var K = this._key.words;
	            var iv = this.cfg.iv;

	            // Generate initial state values
	            var X = this._X = [
	                K[0], (K[3] << 16) | (K[2] >>> 16),
	                K[1], (K[0] << 16) | (K[3] >>> 16),
	                K[2], (K[1] << 16) | (K[0] >>> 16),
	                K[3], (K[2] << 16) | (K[1] >>> 16)
	            ];

	            // Generate initial counter values
	            var C = this._C = [
	                (K[2] << 16) | (K[2] >>> 16), (K[0] & 0xffff0000) | (K[1] & 0x0000ffff),
	                (K[3] << 16) | (K[3] >>> 16), (K[1] & 0xffff0000) | (K[2] & 0x0000ffff),
	                (K[0] << 16) | (K[0] >>> 16), (K[2] & 0xffff0000) | (K[3] & 0x0000ffff),
	                (K[1] << 16) | (K[1] >>> 16), (K[3] & 0xffff0000) | (K[0] & 0x0000ffff)
	            ];

	            // Carry bit
	            this._b = 0;

	            // Iterate the system four times
	            for (var i = 0; i < 4; i++) {
	                nextState.call(this);
	            }

	            // Modify the counters
	            for (var i = 0; i < 8; i++) {
	                C[i] ^= X[(i + 4) & 7];
	            }

	            // IV setup
	            if (iv) {
	                // Shortcuts
	                var IV = iv.words;
	                var IV_0 = IV[0];
	                var IV_1 = IV[1];

	                // Generate four subvectors
	                var i0 = (((IV_0 << 8) | (IV_0 >>> 24)) & 0x00ff00ff) | (((IV_0 << 24) | (IV_0 >>> 8)) & 0xff00ff00);
	                var i2 = (((IV_1 << 8) | (IV_1 >>> 24)) & 0x00ff00ff) | (((IV_1 << 24) | (IV_1 >>> 8)) & 0xff00ff00);
	                var i1 = (i0 >>> 16) | (i2 & 0xffff0000);
	                var i3 = (i2 << 16)  | (i0 & 0x0000ffff);

	                // Modify counter values
	                C[0] ^= i0;
	                C[1] ^= i1;
	                C[2] ^= i2;
	                C[3] ^= i3;
	                C[4] ^= i0;
	                C[5] ^= i1;
	                C[6] ^= i2;
	                C[7] ^= i3;

	                // Iterate the system four times
	                for (var i = 0; i < 4; i++) {
	                    nextState.call(this);
	                }
	            }
	        },

	        _doProcessBlock: function (M, offset) {
	            // Shortcut
	            var X = this._X;

	            // Iterate the system
	            nextState.call(this);

	            // Generate four keystream words
	            S[0] = X[0] ^ (X[5] >>> 16) ^ (X[3] << 16);
	            S[1] = X[2] ^ (X[7] >>> 16) ^ (X[5] << 16);
	            S[2] = X[4] ^ (X[1] >>> 16) ^ (X[7] << 16);
	            S[3] = X[6] ^ (X[3] >>> 16) ^ (X[1] << 16);

	            for (var i = 0; i < 4; i++) {
	                // Swap endian
	                S[i] = (((S[i] << 8)  | (S[i] >>> 24)) & 0x00ff00ff) |
	                       (((S[i] << 24) | (S[i] >>> 8))  & 0xff00ff00);

	                // Encrypt
	                M[offset + i] ^= S[i];
	            }
	        },

	        blockSize: 128/32,

	        ivSize: 64/32
	    });

	    function nextState() {
	        // Shortcuts
	        var X = this._X;
	        var C = this._C;

	        // Save old counter values
	        for (var i = 0; i < 8; i++) {
	            C_[i] = C[i];
	        }

	        // Calculate new counter values
	        C[0] = (C[0] + 0x4d34d34d + this._b) | 0;
	        C[1] = (C[1] + 0xd34d34d3 + ((C[0] >>> 0) < (C_[0] >>> 0) ? 1 : 0)) | 0;
	        C[2] = (C[2] + 0x34d34d34 + ((C[1] >>> 0) < (C_[1] >>> 0) ? 1 : 0)) | 0;
	        C[3] = (C[3] + 0x4d34d34d + ((C[2] >>> 0) < (C_[2] >>> 0) ? 1 : 0)) | 0;
	        C[4] = (C[4] + 0xd34d34d3 + ((C[3] >>> 0) < (C_[3] >>> 0) ? 1 : 0)) | 0;
	        C[5] = (C[5] + 0x34d34d34 + ((C[4] >>> 0) < (C_[4] >>> 0) ? 1 : 0)) | 0;
	        C[6] = (C[6] + 0x4d34d34d + ((C[5] >>> 0) < (C_[5] >>> 0) ? 1 : 0)) | 0;
	        C[7] = (C[7] + 0xd34d34d3 + ((C[6] >>> 0) < (C_[6] >>> 0) ? 1 : 0)) | 0;
	        this._b = (C[7] >>> 0) < (C_[7] >>> 0) ? 1 : 0;

	        // Calculate the g-values
	        for (var i = 0; i < 8; i++) {
	            var gx = X[i] + C[i];

	            // Construct high and low argument for squaring
	            var ga = gx & 0xffff;
	            var gb = gx >>> 16;

	            // Calculate high and low result of squaring
	            var gh = ((((ga * ga) >>> 17) + ga * gb) >>> 15) + gb * gb;
	            var gl = (((gx & 0xffff0000) * gx) | 0) + (((gx & 0x0000ffff) * gx) | 0);

	            // High XOR low
	            G[i] = gh ^ gl;
	        }

	        // Calculate new state values
	        X[0] = (G[0] + ((G[7] << 16) | (G[7] >>> 16)) + ((G[6] << 16) | (G[6] >>> 16))) | 0;
	        X[1] = (G[1] + ((G[0] << 8)  | (G[0] >>> 24)) + G[7]) | 0;
	        X[2] = (G[2] + ((G[1] << 16) | (G[1] >>> 16)) + ((G[0] << 16) | (G[0] >>> 16))) | 0;
	        X[3] = (G[3] + ((G[2] << 8)  | (G[2] >>> 24)) + G[1]) | 0;
	        X[4] = (G[4] + ((G[3] << 16) | (G[3] >>> 16)) + ((G[2] << 16) | (G[2] >>> 16))) | 0;
	        X[5] = (G[5] + ((G[4] << 8)  | (G[4] >>> 24)) + G[3]) | 0;
	        X[6] = (G[6] + ((G[5] << 16) | (G[5] >>> 16)) + ((G[4] << 16) | (G[4] >>> 16))) | 0;
	        X[7] = (G[7] + ((G[6] << 8)  | (G[6] >>> 24)) + G[5]) | 0;
	    }

	    /**
	     * Shortcut functions to the cipher's object interface.
	     *
	     * @example
	     *
	     *     var ciphertext = CryptoJS.RabbitLegacy.encrypt(message, key, cfg);
	     *     var plaintext  = CryptoJS.RabbitLegacy.decrypt(ciphertext, key, cfg);
	     */
	    C.RabbitLegacy = StreamCipher._createHelper(RabbitLegacy);
	}());


	return CryptoJS.RabbitLegacy;

}));

/***/ }),

/***/ 6298:
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory, undef) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__webpack_require__(9021), __webpack_require__(754), __webpack_require__(4636), __webpack_require__(9506), __webpack_require__(7165));
	}
	else {}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var StreamCipher = C_lib.StreamCipher;
	    var C_algo = C.algo;

	    // Reusable objects
	    var S  = [];
	    var C_ = [];
	    var G  = [];

	    /**
	     * Rabbit stream cipher algorithm
	     */
	    var Rabbit = C_algo.Rabbit = StreamCipher.extend({
	        _doReset: function () {
	            // Shortcuts
	            var K = this._key.words;
	            var iv = this.cfg.iv;

	            // Swap endian
	            for (var i = 0; i < 4; i++) {
	                K[i] = (((K[i] << 8)  | (K[i] >>> 24)) & 0x00ff00ff) |
	                       (((K[i] << 24) | (K[i] >>> 8))  & 0xff00ff00);
	            }

	            // Generate initial state values
	            var X = this._X = [
	                K[0], (K[3] << 16) | (K[2] >>> 16),
	                K[1], (K[0] << 16) | (K[3] >>> 16),
	                K[2], (K[1] << 16) | (K[0] >>> 16),
	                K[3], (K[2] << 16) | (K[1] >>> 16)
	            ];

	            // Generate initial counter values
	            var C = this._C = [
	                (K[2] << 16) | (K[2] >>> 16), (K[0] & 0xffff0000) | (K[1] & 0x0000ffff),
	                (K[3] << 16) | (K[3] >>> 16), (K[1] & 0xffff0000) | (K[2] & 0x0000ffff),
	                (K[0] << 16) | (K[0] >>> 16), (K[2] & 0xffff0000) | (K[3] & 0x0000ffff),
	                (K[1] << 16) | (K[1] >>> 16), (K[3] & 0xffff0000) | (K[0] & 0x0000ffff)
	            ];

	            // Carry bit
	            this._b = 0;

	            // Iterate the system four times
	            for (var i = 0; i < 4; i++) {
	                nextState.call(this);
	            }

	            // Modify the counters
	            for (var i = 0; i < 8; i++) {
	                C[i] ^= X[(i + 4) & 7];
	            }

	            // IV setup
	            if (iv) {
	                // Shortcuts
	                var IV = iv.words;
	                var IV_0 = IV[0];
	                var IV_1 = IV[1];

	                // Generate four subvectors
	                var i0 = (((IV_0 << 8) | (IV_0 >>> 24)) & 0x00ff00ff) | (((IV_0 << 24) | (IV_0 >>> 8)) & 0xff00ff00);
	                var i2 = (((IV_1 << 8) | (IV_1 >>> 24)) & 0x00ff00ff) | (((IV_1 << 24) | (IV_1 >>> 8)) & 0xff00ff00);
	                var i1 = (i0 >>> 16) | (i2 & 0xffff0000);
	                var i3 = (i2 << 16)  | (i0 & 0x0000ffff);

	                // Modify counter values
	                C[0] ^= i0;
	                C[1] ^= i1;
	                C[2] ^= i2;
	                C[3] ^= i3;
	                C[4] ^= i0;
	                C[5] ^= i1;
	                C[6] ^= i2;
	                C[7] ^= i3;

	                // Iterate the system four times
	                for (var i = 0; i < 4; i++) {
	                    nextState.call(this);
	                }
	            }
	        },

	        _doProcessBlock: function (M, offset) {
	            // Shortcut
	            var X = this._X;

	            // Iterate the system
	            nextState.call(this);

	            // Generate four keystream words
	            S[0] = X[0] ^ (X[5] >>> 16) ^ (X[3] << 16);
	            S[1] = X[2] ^ (X[7] >>> 16) ^ (X[5] << 16);
	            S[2] = X[4] ^ (X[1] >>> 16) ^ (X[7] << 16);
	            S[3] = X[6] ^ (X[3] >>> 16) ^ (X[1] << 16);

	            for (var i = 0; i < 4; i++) {
	                // Swap endian
	                S[i] = (((S[i] << 8)  | (S[i] >>> 24)) & 0x00ff00ff) |
	                       (((S[i] << 24) | (S[i] >>> 8))  & 0xff00ff00);

	                // Encrypt
	                M[offset + i] ^= S[i];
	            }
	        },

	        blockSize: 128/32,

	        ivSize: 64/32
	    });

	    function nextState() {
	        // Shortcuts
	        var X = this._X;
	        var C = this._C;

	        // Save old counter values
	        for (var i = 0; i < 8; i++) {
	            C_[i] = C[i];
	        }

	        // Calculate new counter values
	        C[0] = (C[0] + 0x4d34d34d + this._b) | 0;
	        C[1] = (C[1] + 0xd34d34d3 + ((C[0] >>> 0) < (C_[0] >>> 0) ? 1 : 0)) | 0;
	        C[2] = (C[2] + 0x34d34d34 + ((C[1] >>> 0) < (C_[1] >>> 0) ? 1 : 0)) | 0;
	        C[3] = (C[3] + 0x4d34d34d + ((C[2] >>> 0) < (C_[2] >>> 0) ? 1 : 0)) | 0;
	        C[4] = (C[4] + 0xd34d34d3 + ((C[3] >>> 0) < (C_[3] >>> 0) ? 1 : 0)) | 0;
	        C[5] = (C[5] + 0x34d34d34 + ((C[4] >>> 0) < (C_[4] >>> 0) ? 1 : 0)) | 0;
	        C[6] = (C[6] + 0x4d34d34d + ((C[5] >>> 0) < (C_[5] >>> 0) ? 1 : 0)) | 0;
	        C[7] = (C[7] + 0xd34d34d3 + ((C[6] >>> 0) < (C_[6] >>> 0) ? 1 : 0)) | 0;
	        this._b = (C[7] >>> 0) < (C_[7] >>> 0) ? 1 : 0;

	        // Calculate the g-values
	        for (var i = 0; i < 8; i++) {
	            var gx = X[i] + C[i];

	            // Construct high and low argument for squaring
	            var ga = gx & 0xffff;
	            var gb = gx >>> 16;

	            // Calculate high and low result of squaring
	            var gh = ((((ga * ga) >>> 17) + ga * gb) >>> 15) + gb * gb;
	            var gl = (((gx & 0xffff0000) * gx) | 0) + (((gx & 0x0000ffff) * gx) | 0);

	            // High XOR low
	            G[i] = gh ^ gl;
	        }

	        // Calculate new state values
	        X[0] = (G[0] + ((G[7] << 16) | (G[7] >>> 16)) + ((G[6] << 16) | (G[6] >>> 16))) | 0;
	        X[1] = (G[1] + ((G[0] << 8)  | (G[0] >>> 24)) + G[7]) | 0;
	        X[2] = (G[2] + ((G[1] << 16) | (G[1] >>> 16)) + ((G[0] << 16) | (G[0] >>> 16))) | 0;
	        X[3] = (G[3] + ((G[2] << 8)  | (G[2] >>> 24)) + G[1]) | 0;
	        X[4] = (G[4] + ((G[3] << 16) | (G[3] >>> 16)) + ((G[2] << 16) | (G[2] >>> 16))) | 0;
	        X[5] = (G[5] + ((G[4] << 8)  | (G[4] >>> 24)) + G[3]) | 0;
	        X[6] = (G[6] + ((G[5] << 16) | (G[5] >>> 16)) + ((G[4] << 16) | (G[4] >>> 16))) | 0;
	        X[7] = (G[7] + ((G[6] << 8)  | (G[6] >>> 24)) + G[5]) | 0;
	    }

	    /**
	     * Shortcut functions to the cipher's object interface.
	     *
	     * @example
	     *
	     *     var ciphertext = CryptoJS.Rabbit.encrypt(message, key, cfg);
	     *     var plaintext  = CryptoJS.Rabbit.decrypt(ciphertext, key, cfg);
	     */
	    C.Rabbit = StreamCipher._createHelper(Rabbit);
	}());


	return CryptoJS.Rabbit;

}));

/***/ }),

/***/ 7193:
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory, undef) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__webpack_require__(9021), __webpack_require__(754), __webpack_require__(4636), __webpack_require__(9506), __webpack_require__(7165));
	}
	else {}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var StreamCipher = C_lib.StreamCipher;
	    var C_algo = C.algo;

	    /**
	     * RC4 stream cipher algorithm.
	     */
	    var RC4 = C_algo.RC4 = StreamCipher.extend({
	        _doReset: function () {
	            // Shortcuts
	            var key = this._key;
	            var keyWords = key.words;
	            var keySigBytes = key.sigBytes;

	            // Init sbox
	            var S = this._S = [];
	            for (var i = 0; i < 256; i++) {
	                S[i] = i;
	            }

	            // Key setup
	            for (var i = 0, j = 0; i < 256; i++) {
	                var keyByteIndex = i % keySigBytes;
	                var keyByte = (keyWords[keyByteIndex >>> 2] >>> (24 - (keyByteIndex % 4) * 8)) & 0xff;

	                j = (j + S[i] + keyByte) % 256;

	                // Swap
	                var t = S[i];
	                S[i] = S[j];
	                S[j] = t;
	            }

	            // Counters
	            this._i = this._j = 0;
	        },

	        _doProcessBlock: function (M, offset) {
	            M[offset] ^= generateKeystreamWord.call(this);
	        },

	        keySize: 256/32,

	        ivSize: 0
	    });

	    function generateKeystreamWord() {
	        // Shortcuts
	        var S = this._S;
	        var i = this._i;
	        var j = this._j;

	        // Generate keystream word
	        var keystreamWord = 0;
	        for (var n = 0; n < 4; n++) {
	            i = (i + 1) % 256;
	            j = (j + S[i]) % 256;

	            // Swap
	            var t = S[i];
	            S[i] = S[j];
	            S[j] = t;

	            keystreamWord |= S[(S[i] + S[j]) % 256] << (24 - n * 8);
	        }

	        // Update counters
	        this._i = i;
	        this._j = j;

	        return keystreamWord;
	    }

	    /**
	     * Shortcut functions to the cipher's object interface.
	     *
	     * @example
	     *
	     *     var ciphertext = CryptoJS.RC4.encrypt(message, key, cfg);
	     *     var plaintext  = CryptoJS.RC4.decrypt(ciphertext, key, cfg);
	     */
	    C.RC4 = StreamCipher._createHelper(RC4);

	    /**
	     * Modified RC4 stream cipher algorithm.
	     */
	    var RC4Drop = C_algo.RC4Drop = RC4.extend({
	        /**
	         * Configuration options.
	         *
	         * @property {number} drop The number of keystream words to drop. Default 192
	         */
	        cfg: RC4.cfg.extend({
	            drop: 192
	        }),

	        _doReset: function () {
	            RC4._doReset.call(this);

	            // Drop
	            for (var i = this.cfg.drop; i > 0; i--) {
	                generateKeystreamWord.call(this);
	            }
	        }
	    });

	    /**
	     * Shortcut functions to the cipher's object interface.
	     *
	     * @example
	     *
	     *     var ciphertext = CryptoJS.RC4Drop.encrypt(message, key, cfg);
	     *     var plaintext  = CryptoJS.RC4Drop.decrypt(ciphertext, key, cfg);
	     */
	    C.RC4Drop = StreamCipher._createHelper(RC4Drop);
	}());


	return CryptoJS.RC4;

}));

/***/ }),

/***/ 8056:
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__webpack_require__(9021));
	}
	else {}
}(this, function (CryptoJS) {

	/** @preserve
	(c) 2012 by C√©dric Mesnil. All rights reserved.

	Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:

	    - Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
	    - Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.

	THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*/

	(function (Math) {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var WordArray = C_lib.WordArray;
	    var Hasher = C_lib.Hasher;
	    var C_algo = C.algo;

	    // Constants table
	    var _zl = WordArray.create([
	        0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15,
	        7,  4, 13,  1, 10,  6, 15,  3, 12,  0,  9,  5,  2, 14, 11,  8,
	        3, 10, 14,  4,  9, 15,  8,  1,  2,  7,  0,  6, 13, 11,  5, 12,
	        1,  9, 11, 10,  0,  8, 12,  4, 13,  3,  7, 15, 14,  5,  6,  2,
	        4,  0,  5,  9,  7, 12,  2, 10, 14,  1,  3,  8, 11,  6, 15, 13]);
	    var _zr = WordArray.create([
	        5, 14,  7,  0,  9,  2, 11,  4, 13,  6, 15,  8,  1, 10,  3, 12,
	        6, 11,  3,  7,  0, 13,  5, 10, 14, 15,  8, 12,  4,  9,  1,  2,
	        15,  5,  1,  3,  7, 14,  6,  9, 11,  8, 12,  2, 10,  0,  4, 13,
	        8,  6,  4,  1,  3, 11, 15,  0,  5, 12,  2, 13,  9,  7, 10, 14,
	        12, 15, 10,  4,  1,  5,  8,  7,  6,  2, 13, 14,  0,  3,  9, 11]);
	    var _sl = WordArray.create([
	         11, 14, 15, 12,  5,  8,  7,  9, 11, 13, 14, 15,  6,  7,  9,  8,
	        7, 6,   8, 13, 11,  9,  7, 15,  7, 12, 15,  9, 11,  7, 13, 12,
	        11, 13,  6,  7, 14,  9, 13, 15, 14,  8, 13,  6,  5, 12,  7,  5,
	          11, 12, 14, 15, 14, 15,  9,  8,  9, 14,  5,  6,  8,  6,  5, 12,
	        9, 15,  5, 11,  6,  8, 13, 12,  5, 12, 13, 14, 11,  8,  5,  6 ]);
	    var _sr = WordArray.create([
	        8,  9,  9, 11, 13, 15, 15,  5,  7,  7,  8, 11, 14, 14, 12,  6,
	        9, 13, 15,  7, 12,  8,  9, 11,  7,  7, 12,  7,  6, 15, 13, 11,
	        9,  7, 15, 11,  8,  6,  6, 14, 12, 13,  5, 14, 13, 13,  7,  5,
	        15,  5,  8, 11, 14, 14,  6, 14,  6,  9, 12,  9, 12,  5, 15,  8,
	        8,  5, 12,  9, 12,  5, 14,  6,  8, 13,  6,  5, 15, 13, 11, 11 ]);

	    var _hl =  WordArray.create([ 0x00000000, 0x5A827999, 0x6ED9EBA1, 0x8F1BBCDC, 0xA953FD4E]);
	    var _hr =  WordArray.create([ 0x50A28BE6, 0x5C4DD124, 0x6D703EF3, 0x7A6D76E9, 0x00000000]);

	    /**
	     * RIPEMD160 hash algorithm.
	     */
	    var RIPEMD160 = C_algo.RIPEMD160 = Hasher.extend({
	        _doReset: function () {
	            this._hash  = WordArray.create([0x67452301, 0xEFCDAB89, 0x98BADCFE, 0x10325476, 0xC3D2E1F0]);
	        },

	        _doProcessBlock: function (M, offset) {

	            // Swap endian
	            for (var i = 0; i < 16; i++) {
	                // Shortcuts
	                var offset_i = offset + i;
	                var M_offset_i = M[offset_i];

	                // Swap
	                M[offset_i] = (
	                    (((M_offset_i << 8)  | (M_offset_i >>> 24)) & 0x00ff00ff) |
	                    (((M_offset_i << 24) | (M_offset_i >>> 8))  & 0xff00ff00)
	                );
	            }
	            // Shortcut
	            var H  = this._hash.words;
	            var hl = _hl.words;
	            var hr = _hr.words;
	            var zl = _zl.words;
	            var zr = _zr.words;
	            var sl = _sl.words;
	            var sr = _sr.words;

	            // Working variables
	            var al, bl, cl, dl, el;
	            var ar, br, cr, dr, er;

	            ar = al = H[0];
	            br = bl = H[1];
	            cr = cl = H[2];
	            dr = dl = H[3];
	            er = el = H[4];
	            // Computation
	            var t;
	            for (var i = 0; i < 80; i += 1) {
	                t = (al +  M[offset+zl[i]])|0;
	                if (i<16){
		            t +=  f1(bl,cl,dl) + hl[0];
	                } else if (i<32) {
		            t +=  f2(bl,cl,dl) + hl[1];
	                } else if (i<48) {
		            t +=  f3(bl,cl,dl) + hl[2];
	                } else if (i<64) {
		            t +=  f4(bl,cl,dl) + hl[3];
	                } else {// if (i<80) {
		            t +=  f5(bl,cl,dl) + hl[4];
	                }
	                t = t|0;
	                t =  rotl(t,sl[i]);
	                t = (t+el)|0;
	                al = el;
	                el = dl;
	                dl = rotl(cl, 10);
	                cl = bl;
	                bl = t;

	                t = (ar + M[offset+zr[i]])|0;
	                if (i<16){
		            t +=  f5(br,cr,dr) + hr[0];
	                } else if (i<32) {
		            t +=  f4(br,cr,dr) + hr[1];
	                } else if (i<48) {
		            t +=  f3(br,cr,dr) + hr[2];
	                } else if (i<64) {
		            t +=  f2(br,cr,dr) + hr[3];
	                } else {// if (i<80) {
		            t +=  f1(br,cr,dr) + hr[4];
	                }
	                t = t|0;
	                t =  rotl(t,sr[i]) ;
	                t = (t+er)|0;
	                ar = er;
	                er = dr;
	                dr = rotl(cr, 10);
	                cr = br;
	                br = t;
	            }
	            // Intermediate hash value
	            t    = (H[1] + cl + dr)|0;
	            H[1] = (H[2] + dl + er)|0;
	            H[2] = (H[3] + el + ar)|0;
	            H[3] = (H[4] + al + br)|0;
	            H[4] = (H[0] + bl + cr)|0;
	            H[0] =  t;
	        },

	        _doFinalize: function () {
	            // Shortcuts
	            var data = this._data;
	            var dataWords = data.words;

	            var nBitsTotal = this._nDataBytes * 8;
	            var nBitsLeft = data.sigBytes * 8;

	            // Add padding
	            dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);
	            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = (
	                (((nBitsTotal << 8)  | (nBitsTotal >>> 24)) & 0x00ff00ff) |
	                (((nBitsTotal << 24) | (nBitsTotal >>> 8))  & 0xff00ff00)
	            );
	            data.sigBytes = (dataWords.length + 1) * 4;

	            // Hash final blocks
	            this._process();

	            // Shortcuts
	            var hash = this._hash;
	            var H = hash.words;

	            // Swap endian
	            for (var i = 0; i < 5; i++) {
	                // Shortcut
	                var H_i = H[i];

	                // Swap
	                H[i] = (((H_i << 8)  | (H_i >>> 24)) & 0x00ff00ff) |
	                       (((H_i << 24) | (H_i >>> 8))  & 0xff00ff00);
	            }

	            // Return final computed hash
	            return hash;
	        },

	        clone: function () {
	            var clone = Hasher.clone.call(this);
	            clone._hash = this._hash.clone();

	            return clone;
	        }
	    });


	    function f1(x, y, z) {
	        return ((x) ^ (y) ^ (z));

	    }

	    function f2(x, y, z) {
	        return (((x)&(y)) | ((~x)&(z)));
	    }

	    function f3(x, y, z) {
	        return (((x) | (~(y))) ^ (z));
	    }

	    function f4(x, y, z) {
	        return (((x) & (z)) | ((y)&(~(z))));
	    }

	    function f5(x, y, z) {
	        return ((x) ^ ((y) |(~(z))));

	    }

	    function rotl(x,n) {
	        return (x<<n) | (x>>>(32-n));
	    }


	    /**
	     * Shortcut function to the hasher's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     *
	     * @return {WordArray} The hash.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hash = CryptoJS.RIPEMD160('message');
	     *     var hash = CryptoJS.RIPEMD160(wordArray);
	     */
	    C.RIPEMD160 = Hasher._createHelper(RIPEMD160);

	    /**
	     * Shortcut function to the HMAC's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     * @param {WordArray|string} key The secret key.
	     *
	     * @return {WordArray} The HMAC.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hmac = CryptoJS.HmacRIPEMD160(message, key);
	     */
	    C.HmacRIPEMD160 = Hasher._createHmacHelper(RIPEMD160);
	}(Math));


	return CryptoJS.RIPEMD160;

}));

/***/ }),

/***/ 5471:
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__webpack_require__(9021));
	}
	else {}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var WordArray = C_lib.WordArray;
	    var Hasher = C_lib.Hasher;
	    var C_algo = C.algo;

	    // Reusable object
	    var W = [];

	    /**
	     * SHA-1 hash algorithm.
	     */
	    var SHA1 = C_algo.SHA1 = Hasher.extend({
	        _doReset: function () {
	            this._hash = new WordArray.init([
	                0x67452301, 0xefcdab89,
	                0x98badcfe, 0x10325476,
	                0xc3d2e1f0
	            ]);
	        },

	        _doProcessBlock: function (M, offset) {
	            // Shortcut
	            var H = this._hash.words;

	            // Working variables
	            var a = H[0];
	            var b = H[1];
	            var c = H[2];
	            var d = H[3];
	            var e = H[4];

	            // Computation
	            for (var i = 0; i < 80; i++) {
	                if (i < 16) {
	                    W[i] = M[offset + i] | 0;
	                } else {
	                    var n = W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16];
	                    W[i] = (n << 1) | (n >>> 31);
	                }

	                var t = ((a << 5) | (a >>> 27)) + e + W[i];
	                if (i < 20) {
	                    t += ((b & c) | (~b & d)) + 0x5a827999;
	                } else if (i < 40) {
	                    t += (b ^ c ^ d) + 0x6ed9eba1;
	                } else if (i < 60) {
	                    t += ((b & c) | (b & d) | (c & d)) - 0x70e44324;
	                } else /* if (i < 80) */ {
	                    t += (b ^ c ^ d) - 0x359d3e2a;
	                }

	                e = d;
	                d = c;
	                c = (b << 30) | (b >>> 2);
	                b = a;
	                a = t;
	            }

	            // Intermediate hash value
	            H[0] = (H[0] + a) | 0;
	            H[1] = (H[1] + b) | 0;
	            H[2] = (H[2] + c) | 0;
	            H[3] = (H[3] + d) | 0;
	            H[4] = (H[4] + e) | 0;
	        },

	        _doFinalize: function () {
	            // Shortcuts
	            var data = this._data;
	            var dataWords = data.words;

	            var nBitsTotal = this._nDataBytes * 8;
	            var nBitsLeft = data.sigBytes * 8;

	            // Add padding
	            dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);
	            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = Math.floor(nBitsTotal / 0x100000000);
	            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 15] = nBitsTotal;
	            data.sigBytes = dataWords.length * 4;

	            // Hash final blocks
	            this._process();

	            // Return final computed hash
	            return this._hash;
	        },

	        clone: function () {
	            var clone = Hasher.clone.call(this);
	            clone._hash = this._hash.clone();

	            return clone;
	        }
	    });

	    /**
	     * Shortcut function to the hasher's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     *
	     * @return {WordArray} The hash.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hash = CryptoJS.SHA1('message');
	     *     var hash = CryptoJS.SHA1(wordArray);
	     */
	    C.SHA1 = Hasher._createHelper(SHA1);

	    /**
	     * Shortcut function to the HMAC's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     * @param {WordArray|string} key The secret key.
	     *
	     * @return {WordArray} The HMAC.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hmac = CryptoJS.HmacSHA1(message, key);
	     */
	    C.HmacSHA1 = Hasher._createHmacHelper(SHA1);
	}());


	return CryptoJS.SHA1;

}));

/***/ }),

/***/ 6308:
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory, undef) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__webpack_require__(9021), __webpack_require__(3009));
	}
	else {}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var WordArray = C_lib.WordArray;
	    var C_algo = C.algo;
	    var SHA256 = C_algo.SHA256;

	    /**
	     * SHA-224 hash algorithm.
	     */
	    var SHA224 = C_algo.SHA224 = SHA256.extend({
	        _doReset: function () {
	            this._hash = new WordArray.init([
	                0xc1059ed8, 0x367cd507, 0x3070dd17, 0xf70e5939,
	                0xffc00b31, 0x68581511, 0x64f98fa7, 0xbefa4fa4
	            ]);
	        },

	        _doFinalize: function () {
	            var hash = SHA256._doFinalize.call(this);

	            hash.sigBytes -= 4;

	            return hash;
	        }
	    });

	    /**
	     * Shortcut function to the hasher's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     *
	     * @return {WordArray} The hash.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hash = CryptoJS.SHA224('message');
	     *     var hash = CryptoJS.SHA224(wordArray);
	     */
	    C.SHA224 = SHA256._createHelper(SHA224);

	    /**
	     * Shortcut function to the HMAC's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     * @param {WordArray|string} key The secret key.
	     *
	     * @return {WordArray} The HMAC.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hmac = CryptoJS.HmacSHA224(message, key);
	     */
	    C.HmacSHA224 = SHA256._createHmacHelper(SHA224);
	}());


	return CryptoJS.SHA224;

}));

/***/ }),

/***/ 3009:
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__webpack_require__(9021));
	}
	else {}
}(this, function (CryptoJS) {

	(function (Math) {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var WordArray = C_lib.WordArray;
	    var Hasher = C_lib.Hasher;
	    var C_algo = C.algo;

	    // Initialization and round constants tables
	    var H = [];
	    var K = [];

	    // Compute constants
	    (function () {
	        function isPrime(n) {
	            var sqrtN = Math.sqrt(n);
	            for (var factor = 2; factor <= sqrtN; factor++) {
	                if (!(n % factor)) {
	                    return false;
	                }
	            }

	            return true;
	        }

	        function getFractionalBits(n) {
	            return ((n - (n | 0)) * 0x100000000) | 0;
	        }

	        var n = 2;
	        var nPrime = 0;
	        while (nPrime < 64) {
	            if (isPrime(n)) {
	                if (nPrime < 8) {
	                    H[nPrime] = getFractionalBits(Math.pow(n, 1 / 2));
	                }
	                K[nPrime] = getFractionalBits(Math.pow(n, 1 / 3));

	                nPrime++;
	            }

	            n++;
	        }
	    }());

	    // Reusable object
	    var W = [];

	    /**
	     * SHA-256 hash algorithm.
	     */
	    var SHA256 = C_algo.SHA256 = Hasher.extend({
	        _doReset: function () {
	            this._hash = new WordArray.init(H.slice(0));
	        },

	        _doProcessBlock: function (M, offset) {
	            // Shortcut
	            var H = this._hash.words;

	            // Working variables
	            var a = H[0];
	            var b = H[1];
	            var c = H[2];
	            var d = H[3];
	            var e = H[4];
	            var f = H[5];
	            var g = H[6];
	            var h = H[7];

	            // Computation
	            for (var i = 0; i < 64; i++) {
	                if (i < 16) {
	                    W[i] = M[offset + i] | 0;
	                } else {
	                    var gamma0x = W[i - 15];
	                    var gamma0  = ((gamma0x << 25) | (gamma0x >>> 7))  ^
	                                  ((gamma0x << 14) | (gamma0x >>> 18)) ^
	                                   (gamma0x >>> 3);

	                    var gamma1x = W[i - 2];
	                    var gamma1  = ((gamma1x << 15) | (gamma1x >>> 17)) ^
	                                  ((gamma1x << 13) | (gamma1x >>> 19)) ^
	                                   (gamma1x >>> 10);

	                    W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16];
	                }

	                var ch  = (e & f) ^ (~e & g);
	                var maj = (a & b) ^ (a & c) ^ (b & c);

	                var sigma0 = ((a << 30) | (a >>> 2)) ^ ((a << 19) | (a >>> 13)) ^ ((a << 10) | (a >>> 22));
	                var sigma1 = ((e << 26) | (e >>> 6)) ^ ((e << 21) | (e >>> 11)) ^ ((e << 7)  | (e >>> 25));

	                var t1 = h + sigma1 + ch + K[i] + W[i];
	                var t2 = sigma0 + maj;

	                h = g;
	                g = f;
	                f = e;
	                e = (d + t1) | 0;
	                d = c;
	                c = b;
	                b = a;
	                a = (t1 + t2) | 0;
	            }

	            // Intermediate hash value
	            H[0] = (H[0] + a) | 0;
	            H[1] = (H[1] + b) | 0;
	            H[2] = (H[2] + c) | 0;
	            H[3] = (H[3] + d) | 0;
	            H[4] = (H[4] + e) | 0;
	            H[5] = (H[5] + f) | 0;
	            H[6] = (H[6] + g) | 0;
	            H[7] = (H[7] + h) | 0;
	        },

	        _doFinalize: function () {
	            // Shortcuts
	            var data = this._data;
	            var dataWords = data.words;

	            var nBitsTotal = this._nDataBytes * 8;
	            var nBitsLeft = data.sigBytes * 8;

	            // Add padding
	            dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);
	            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = Math.floor(nBitsTotal / 0x100000000);
	            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 15] = nBitsTotal;
	            data.sigBytes = dataWords.length * 4;

	            // Hash final blocks
	            this._process();

	            // Return final computed hash
	            return this._hash;
	        },

	        clone: function () {
	            var clone = Hasher.clone.call(this);
	            clone._hash = this._hash.clone();

	            return clone;
	        }
	    });

	    /**
	     * Shortcut function to the hasher's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     *
	     * @return {WordArray} The hash.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hash = CryptoJS.SHA256('message');
	     *     var hash = CryptoJS.SHA256(wordArray);
	     */
	    C.SHA256 = Hasher._createHelper(SHA256);

	    /**
	     * Shortcut function to the HMAC's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     * @param {WordArray|string} key The secret key.
	     *
	     * @return {WordArray} The HMAC.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hmac = CryptoJS.HmacSHA256(message, key);
	     */
	    C.HmacSHA256 = Hasher._createHmacHelper(SHA256);
	}(Math));


	return CryptoJS.SHA256;

}));

/***/ }),

/***/ 5953:
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory, undef) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__webpack_require__(9021), __webpack_require__(3240));
	}
	else {}
}(this, function (CryptoJS) {

	(function (Math) {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var WordArray = C_lib.WordArray;
	    var Hasher = C_lib.Hasher;
	    var C_x64 = C.x64;
	    var X64Word = C_x64.Word;
	    var C_algo = C.algo;

	    // Constants tables
	    var RHO_OFFSETS = [];
	    var PI_INDEXES  = [];
	    var ROUND_CONSTANTS = [];

	    // Compute Constants
	    (function () {
	        // Compute rho offset constants
	        var x = 1, y = 0;
	        for (var t = 0; t < 24; t++) {
	            RHO_OFFSETS[x + 5 * y] = ((t + 1) * (t + 2) / 2) % 64;

	            var newX = y % 5;
	            var newY = (2 * x + 3 * y) % 5;
	            x = newX;
	            y = newY;
	        }

	        // Compute pi index constants
	        for (var x = 0; x < 5; x++) {
	            for (var y = 0; y < 5; y++) {
	                PI_INDEXES[x + 5 * y] = y + ((2 * x + 3 * y) % 5) * 5;
	            }
	        }

	        // Compute round constants
	        var LFSR = 0x01;
	        for (var i = 0; i < 24; i++) {
	            var roundConstantMsw = 0;
	            var roundConstantLsw = 0;

	            for (var j = 0; j < 7; j++) {
	                if (LFSR & 0x01) {
	                    var bitPosition = (1 << j) - 1;
	                    if (bitPosition < 32) {
	                        roundConstantLsw ^= 1 << bitPosition;
	                    } else /* if (bitPosition >= 32) */ {
	                        roundConstantMsw ^= 1 << (bitPosition - 32);
	                    }
	                }

	                // Compute next LFSR
	                if (LFSR & 0x80) {
	                    // Primitive polynomial over GF(2): x^8 + x^6 + x^5 + x^4 + 1
	                    LFSR = (LFSR << 1) ^ 0x71;
	                } else {
	                    LFSR <<= 1;
	                }
	            }

	            ROUND_CONSTANTS[i] = X64Word.create(roundConstantMsw, roundConstantLsw);
	        }
	    }());

	    // Reusable objects for temporary values
	    var T = [];
	    (function () {
	        for (var i = 0; i < 25; i++) {
	            T[i] = X64Word.create();
	        }
	    }());

	    /**
	     * SHA-3 hash algorithm.
	     */
	    var SHA3 = C_algo.SHA3 = Hasher.extend({
	        /**
	         * Configuration options.
	         *
	         * @property {number} outputLength
	         *   The desired number of bits in the output hash.
	         *   Only values permitted are: 224, 256, 384, 512.
	         *   Default: 512
	         */
	        cfg: Hasher.cfg.extend({
	            outputLength: 512
	        }),

	        _doReset: function () {
	            var state = this._state = []
	            for (var i = 0; i < 25; i++) {
	                state[i] = new X64Word.init();
	            }

	            this.blockSize = (1600 - 2 * this.cfg.outputLength) / 32;
	        },

	        _doProcessBlock: function (M, offset) {
	            // Shortcuts
	            var state = this._state;
	            var nBlockSizeLanes = this.blockSize / 2;

	            // Absorb
	            for (var i = 0; i < nBlockSizeLanes; i++) {
	                // Shortcuts
	                var M2i  = M[offset + 2 * i];
	                var M2i1 = M[offset + 2 * i + 1];

	                // Swap endian
	                M2i = (
	                    (((M2i << 8)  | (M2i >>> 24)) & 0x00ff00ff) |
	                    (((M2i << 24) | (M2i >>> 8))  & 0xff00ff00)
	                );
	                M2i1 = (
	                    (((M2i1 << 8)  | (M2i1 >>> 24)) & 0x00ff00ff) |
	                    (((M2i1 << 24) | (M2i1 >>> 8))  & 0xff00ff00)
	                );

	                // Absorb message into state
	                var lane = state[i];
	                lane.high ^= M2i1;
	                lane.low  ^= M2i;
	            }

	            // Rounds
	            for (var round = 0; round < 24; round++) {
	                // Theta
	                for (var x = 0; x < 5; x++) {
	                    // Mix column lanes
	                    var tMsw = 0, tLsw = 0;
	                    for (var y = 0; y < 5; y++) {
	                        var lane = state[x + 5 * y];
	                        tMsw ^= lane.high;
	                        tLsw ^= lane.low;
	                    }

	                    // Temporary values
	                    var Tx = T[x];
	                    Tx.high = tMsw;
	                    Tx.low  = tLsw;
	                }
	                for (var x = 0; x < 5; x++) {
	                    // Shortcuts
	                    var Tx4 = T[(x + 4) % 5];
	                    var Tx1 = T[(x + 1) % 5];
	                    var Tx1Msw = Tx1.high;
	                    var Tx1Lsw = Tx1.low;

	                    // Mix surrounding columns
	                    var tMsw = Tx4.high ^ ((Tx1Msw << 1) | (Tx1Lsw >>> 31));
	                    var tLsw = Tx4.low  ^ ((Tx1Lsw << 1) | (Tx1Msw >>> 31));
	                    for (var y = 0; y < 5; y++) {
	                        var lane = state[x + 5 * y];
	                        lane.high ^= tMsw;
	                        lane.low  ^= tLsw;
	                    }
	                }

	                // Rho Pi
	                for (var laneIndex = 1; laneIndex < 25; laneIndex++) {
	                    // Shortcuts
	                    var lane = state[laneIndex];
	                    var laneMsw = lane.high;
	                    var laneLsw = lane.low;
	                    var rhoOffset = RHO_OFFSETS[laneIndex];

	                    // Rotate lanes
	                    if (rhoOffset < 32) {
	                        var tMsw = (laneMsw << rhoOffset) | (laneLsw >>> (32 - rhoOffset));
	                        var tLsw = (laneLsw << rhoOffset) | (laneMsw >>> (32 - rhoOffset));
	                    } else /* if (rhoOffset >= 32) */ {
	                        var tMsw = (laneLsw << (rhoOffset - 32)) | (laneMsw >>> (64 - rhoOffset));
	                        var tLsw = (laneMsw << (rhoOffset - 32)) | (laneLsw >>> (64 - rhoOffset));
	                    }

	                    // Transpose lanes
	                    var TPiLane = T[PI_INDEXES[laneIndex]];
	                    TPiLane.high = tMsw;
	                    TPiLane.low  = tLsw;
	                }

	                // Rho pi at x = y = 0
	                var T0 = T[0];
	                var state0 = state[0];
	                T0.high = state0.high;
	                T0.low  = state0.low;

	                // Chi
	                for (var x = 0; x < 5; x++) {
	                    for (var y = 0; y < 5; y++) {
	                        // Shortcuts
	                        var laneIndex = x + 5 * y;
	                        var lane = state[laneIndex];
	                        var TLane = T[laneIndex];
	                        var Tx1Lane = T[((x + 1) % 5) + 5 * y];
	                        var Tx2Lane = T[((x + 2) % 5) + 5 * y];

	                        // Mix rows
	                        lane.high = TLane.high ^ (~Tx1Lane.high & Tx2Lane.high);
	                        lane.low  = TLane.low  ^ (~Tx1Lane.low  & Tx2Lane.low);
	                    }
	                }

	                // Iota
	                var lane = state[0];
	                var roundConstant = ROUND_CONSTANTS[round];
	                lane.high ^= roundConstant.high;
	                lane.low  ^= roundConstant.low;;
	            }
	        },

	        _doFinalize: function () {
	            // Shortcuts
	            var data = this._data;
	            var dataWords = data.words;
	            var nBitsTotal = this._nDataBytes * 8;
	            var nBitsLeft = data.sigBytes * 8;
	            var blockSizeBits = this.blockSize * 32;

	            // Add padding
	            dataWords[nBitsLeft >>> 5] |= 0x1 << (24 - nBitsLeft % 32);
	            dataWords[((Math.ceil((nBitsLeft + 1) / blockSizeBits) * blockSizeBits) >>> 5) - 1] |= 0x80;
	            data.sigBytes = dataWords.length * 4;

	            // Hash final blocks
	            this._process();

	            // Shortcuts
	            var state = this._state;
	            var outputLengthBytes = this.cfg.outputLength / 8;
	            var outputLengthLanes = outputLengthBytes / 8;

	            // Squeeze
	            var hashWords = [];
	            for (var i = 0; i < outputLengthLanes; i++) {
	                // Shortcuts
	                var lane = state[i];
	                var laneMsw = lane.high;
	                var laneLsw = lane.low;

	                // Swap endian
	                laneMsw = (
	                    (((laneMsw << 8)  | (laneMsw >>> 24)) & 0x00ff00ff) |
	                    (((laneMsw << 24) | (laneMsw >>> 8))  & 0xff00ff00)
	                );
	                laneLsw = (
	                    (((laneLsw << 8)  | (laneLsw >>> 24)) & 0x00ff00ff) |
	                    (((laneLsw << 24) | (laneLsw >>> 8))  & 0xff00ff00)
	                );

	                // Squeeze state to retrieve hash
	                hashWords.push(laneLsw);
	                hashWords.push(laneMsw);
	            }

	            // Return final computed hash
	            return new WordArray.init(hashWords, outputLengthBytes);
	        },

	        clone: function () {
	            var clone = Hasher.clone.call(this);

	            var state = clone._state = this._state.slice(0);
	            for (var i = 0; i < 25; i++) {
	                state[i] = state[i].clone();
	            }

	            return clone;
	        }
	    });

	    /**
	     * Shortcut function to the hasher's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     *
	     * @return {WordArray} The hash.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hash = CryptoJS.SHA3('message');
	     *     var hash = CryptoJS.SHA3(wordArray);
	     */
	    C.SHA3 = Hasher._createHelper(SHA3);

	    /**
	     * Shortcut function to the HMAC's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     * @param {WordArray|string} key The secret key.
	     *
	     * @return {WordArray} The HMAC.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hmac = CryptoJS.HmacSHA3(message, key);
	     */
	    C.HmacSHA3 = Hasher._createHmacHelper(SHA3);
	}(Math));


	return CryptoJS.SHA3;

}));

/***/ }),

/***/ 9557:
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory, undef) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__webpack_require__(9021), __webpack_require__(3240), __webpack_require__(1380));
	}
	else {}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_x64 = C.x64;
	    var X64Word = C_x64.Word;
	    var X64WordArray = C_x64.WordArray;
	    var C_algo = C.algo;
	    var SHA512 = C_algo.SHA512;

	    /**
	     * SHA-384 hash algorithm.
	     */
	    var SHA384 = C_algo.SHA384 = SHA512.extend({
	        _doReset: function () {
	            this._hash = new X64WordArray.init([
	                new X64Word.init(0xcbbb9d5d, 0xc1059ed8), new X64Word.init(0x629a292a, 0x367cd507),
	                new X64Word.init(0x9159015a, 0x3070dd17), new X64Word.init(0x152fecd8, 0xf70e5939),
	                new X64Word.init(0x67332667, 0xffc00b31), new X64Word.init(0x8eb44a87, 0x68581511),
	                new X64Word.init(0xdb0c2e0d, 0x64f98fa7), new X64Word.init(0x47b5481d, 0xbefa4fa4)
	            ]);
	        },

	        _doFinalize: function () {
	            var hash = SHA512._doFinalize.call(this);

	            hash.sigBytes -= 16;

	            return hash;
	        }
	    });

	    /**
	     * Shortcut function to the hasher's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     *
	     * @return {WordArray} The hash.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hash = CryptoJS.SHA384('message');
	     *     var hash = CryptoJS.SHA384(wordArray);
	     */
	    C.SHA384 = SHA512._createHelper(SHA384);

	    /**
	     * Shortcut function to the HMAC's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     * @param {WordArray|string} key The secret key.
	     *
	     * @return {WordArray} The HMAC.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hmac = CryptoJS.HmacSHA384(message, key);
	     */
	    C.HmacSHA384 = SHA512._createHmacHelper(SHA384);
	}());


	return CryptoJS.SHA384;

}));

/***/ }),

/***/ 1380:
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory, undef) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__webpack_require__(9021), __webpack_require__(3240));
	}
	else {}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var Hasher = C_lib.Hasher;
	    var C_x64 = C.x64;
	    var X64Word = C_x64.Word;
	    var X64WordArray = C_x64.WordArray;
	    var C_algo = C.algo;

	    function X64Word_create() {
	        return X64Word.create.apply(X64Word, arguments);
	    }

	    // Constants
	    var K = [
	        X64Word_create(0x428a2f98, 0xd728ae22), X64Word_create(0x71374491, 0x23ef65cd),
	        X64Word_create(0xb5c0fbcf, 0xec4d3b2f), X64Word_create(0xe9b5dba5, 0x8189dbbc),
	        X64Word_create(0x3956c25b, 0xf348b538), X64Word_create(0x59f111f1, 0xb605d019),
	        X64Word_create(0x923f82a4, 0xaf194f9b), X64Word_create(0xab1c5ed5, 0xda6d8118),
	        X64Word_create(0xd807aa98, 0xa3030242), X64Word_create(0x12835b01, 0x45706fbe),
	        X64Word_create(0x243185be, 0x4ee4b28c), X64Word_create(0x550c7dc3, 0xd5ffb4e2),
	        X64Word_create(0x72be5d74, 0xf27b896f), X64Word_create(0x80deb1fe, 0x3b1696b1),
	        X64Word_create(0x9bdc06a7, 0x25c71235), X64Word_create(0xc19bf174, 0xcf692694),
	        X64Word_create(0xe49b69c1, 0x9ef14ad2), X64Word_create(0xefbe4786, 0x384f25e3),
	        X64Word_create(0x0fc19dc6, 0x8b8cd5b5), X64Word_create(0x240ca1cc, 0x77ac9c65),
	        X64Word_create(0x2de92c6f, 0x592b0275), X64Word_create(0x4a7484aa, 0x6ea6e483),
	        X64Word_create(0x5cb0a9dc, 0xbd41fbd4), X64Word_create(0x76f988da, 0x831153b5),
	        X64Word_create(0x983e5152, 0xee66dfab), X64Word_create(0xa831c66d, 0x2db43210),
	        X64Word_create(0xb00327c8, 0x98fb213f), X64Word_create(0xbf597fc7, 0xbeef0ee4),
	        X64Word_create(0xc6e00bf3, 0x3da88fc2), X64Word_create(0xd5a79147, 0x930aa725),
	        X64Word_create(0x06ca6351, 0xe003826f), X64Word_create(0x14292967, 0x0a0e6e70),
	        X64Word_create(0x27b70a85, 0x46d22ffc), X64Word_create(0x2e1b2138, 0x5c26c926),
	        X64Word_create(0x4d2c6dfc, 0x5ac42aed), X64Word_create(0x53380d13, 0x9d95b3df),
	        X64Word_create(0x650a7354, 0x8baf63de), X64Word_create(0x766a0abb, 0x3c77b2a8),
	        X64Word_create(0x81c2c92e, 0x47edaee6), X64Word_create(0x92722c85, 0x1482353b),
	        X64Word_create(0xa2bfe8a1, 0x4cf10364), X64Word_create(0xa81a664b, 0xbc423001),
	        X64Word_create(0xc24b8b70, 0xd0f89791), X64Word_create(0xc76c51a3, 0x0654be30),
	        X64Word_create(0xd192e819, 0xd6ef5218), X64Word_create(0xd6990624, 0x5565a910),
	        X64Word_create(0xf40e3585, 0x5771202a), X64Word_create(0x106aa070, 0x32bbd1b8),
	        X64Word_create(0x19a4c116, 0xb8d2d0c8), X64Word_create(0x1e376c08, 0x5141ab53),
	        X64Word_create(0x2748774c, 0xdf8eeb99), X64Word_create(0x34b0bcb5, 0xe19b48a8),
	        X64Word_create(0x391c0cb3, 0xc5c95a63), X64Word_create(0x4ed8aa4a, 0xe3418acb),
	        X64Word_create(0x5b9cca4f, 0x7763e373), X64Word_create(0x682e6ff3, 0xd6b2b8a3),
	        X64Word_create(0x748f82ee, 0x5defb2fc), X64Word_create(0x78a5636f, 0x43172f60),
	        X64Word_create(0x84c87814, 0xa1f0ab72), X64Word_create(0x8cc70208, 0x1a6439ec),
	        X64Word_create(0x90befffa, 0x23631e28), X64Word_create(0xa4506ceb, 0xde82bde9),
	        X64Word_create(0xbef9a3f7, 0xb2c67915), X64Word_create(0xc67178f2, 0xe372532b),
	        X64Word_create(0xca273ece, 0xea26619c), X64Word_create(0xd186b8c7, 0x21c0c207),
	        X64Word_create(0xeada7dd6, 0xcde0eb1e), X64Word_create(0xf57d4f7f, 0xee6ed178),
	        X64Word_create(0x06f067aa, 0x72176fba), X64Word_create(0x0a637dc5, 0xa2c898a6),
	        X64Word_create(0x113f9804, 0xbef90dae), X64Word_create(0x1b710b35, 0x131c471b),
	        X64Word_create(0x28db77f5, 0x23047d84), X64Word_create(0x32caab7b, 0x40c72493),
	        X64Word_create(0x3c9ebe0a, 0x15c9bebc), X64Word_create(0x431d67c4, 0x9c100d4c),
	        X64Word_create(0x4cc5d4be, 0xcb3e42b6), X64Word_create(0x597f299c, 0xfc657e2a),
	        X64Word_create(0x5fcb6fab, 0x3ad6faec), X64Word_create(0x6c44198c, 0x4a475817)
	    ];

	    // Reusable objects
	    var W = [];
	    (function () {
	        for (var i = 0; i < 80; i++) {
	            W[i] = X64Word_create();
	        }
	    }());

	    /**
	     * SHA-512 hash algorithm.
	     */
	    var SHA512 = C_algo.SHA512 = Hasher.extend({
	        _doReset: function () {
	            this._hash = new X64WordArray.init([
	                new X64Word.init(0x6a09e667, 0xf3bcc908), new X64Word.init(0xbb67ae85, 0x84caa73b),
	                new X64Word.init(0x3c6ef372, 0xfe94f82b), new X64Word.init(0xa54ff53a, 0x5f1d36f1),
	                new X64Word.init(0x510e527f, 0xade682d1), new X64Word.init(0x9b05688c, 0x2b3e6c1f),
	                new X64Word.init(0x1f83d9ab, 0xfb41bd6b), new X64Word.init(0x5be0cd19, 0x137e2179)
	            ]);
	        },

	        _doProcessBlock: function (M, offset) {
	            // Shortcuts
	            var H = this._hash.words;

	            var H0 = H[0];
	            var H1 = H[1];
	            var H2 = H[2];
	            var H3 = H[3];
	            var H4 = H[4];
	            var H5 = H[5];
	            var H6 = H[6];
	            var H7 = H[7];

	            var H0h = H0.high;
	            var H0l = H0.low;
	            var H1h = H1.high;
	            var H1l = H1.low;
	            var H2h = H2.high;
	            var H2l = H2.low;
	            var H3h = H3.high;
	            var H3l = H3.low;
	            var H4h = H4.high;
	            var H4l = H4.low;
	            var H5h = H5.high;
	            var H5l = H5.low;
	            var H6h = H6.high;
	            var H6l = H6.low;
	            var H7h = H7.high;
	            var H7l = H7.low;

	            // Working variables
	            var ah = H0h;
	            var al = H0l;
	            var bh = H1h;
	            var bl = H1l;
	            var ch = H2h;
	            var cl = H2l;
	            var dh = H3h;
	            var dl = H3l;
	            var eh = H4h;
	            var el = H4l;
	            var fh = H5h;
	            var fl = H5l;
	            var gh = H6h;
	            var gl = H6l;
	            var hh = H7h;
	            var hl = H7l;

	            // Rounds
	            for (var i = 0; i < 80; i++) {
	                // Shortcut
	                var Wi = W[i];

	                // Extend message
	                if (i < 16) {
	                    var Wih = Wi.high = M[offset + i * 2]     | 0;
	                    var Wil = Wi.low  = M[offset + i * 2 + 1] | 0;
	                } else {
	                    // Gamma0
	                    var gamma0x  = W[i - 15];
	                    var gamma0xh = gamma0x.high;
	                    var gamma0xl = gamma0x.low;
	                    var gamma0h  = ((gamma0xh >>> 1) | (gamma0xl << 31)) ^ ((gamma0xh >>> 8) | (gamma0xl << 24)) ^ (gamma0xh >>> 7);
	                    var gamma0l  = ((gamma0xl >>> 1) | (gamma0xh << 31)) ^ ((gamma0xl >>> 8) | (gamma0xh << 24)) ^ ((gamma0xl >>> 7) | (gamma0xh << 25));

	                    // Gamma1
	                    var gamma1x  = W[i - 2];
	                    var gamma1xh = gamma1x.high;
	                    var gamma1xl = gamma1x.low;
	                    var gamma1h  = ((gamma1xh >>> 19) | (gamma1xl << 13)) ^ ((gamma1xh << 3) | (gamma1xl >>> 29)) ^ (gamma1xh >>> 6);
	                    var gamma1l  = ((gamma1xl >>> 19) | (gamma1xh << 13)) ^ ((gamma1xl << 3) | (gamma1xh >>> 29)) ^ ((gamma1xl >>> 6) | (gamma1xh << 26));

	                    // W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16]
	                    var Wi7  = W[i - 7];
	                    var Wi7h = Wi7.high;
	                    var Wi7l = Wi7.low;

	                    var Wi16  = W[i - 16];
	                    var Wi16h = Wi16.high;
	                    var Wi16l = Wi16.low;

	                    var Wil = gamma0l + Wi7l;
	                    var Wih = gamma0h + Wi7h + ((Wil >>> 0) < (gamma0l >>> 0) ? 1 : 0);
	                    var Wil = Wil + gamma1l;
	                    var Wih = Wih + gamma1h + ((Wil >>> 0) < (gamma1l >>> 0) ? 1 : 0);
	                    var Wil = Wil + Wi16l;
	                    var Wih = Wih + Wi16h + ((Wil >>> 0) < (Wi16l >>> 0) ? 1 : 0);

	                    Wi.high = Wih;
	                    Wi.low  = Wil;
	                }

	                var chh  = (eh & fh) ^ (~eh & gh);
	                var chl  = (el & fl) ^ (~el & gl);
	                var majh = (ah & bh) ^ (ah & ch) ^ (bh & ch);
	                var majl = (al & bl) ^ (al & cl) ^ (bl & cl);

	                var sigma0h = ((ah >>> 28) | (al << 4))  ^ ((ah << 30)  | (al >>> 2)) ^ ((ah << 25) | (al >>> 7));
	                var sigma0l = ((al >>> 28) | (ah << 4))  ^ ((al << 30)  | (ah >>> 2)) ^ ((al << 25) | (ah >>> 7));
	                var sigma1h = ((eh >>> 14) | (el << 18)) ^ ((eh >>> 18) | (el << 14)) ^ ((eh << 23) | (el >>> 9));
	                var sigma1l = ((el >>> 14) | (eh << 18)) ^ ((el >>> 18) | (eh << 14)) ^ ((el << 23) | (eh >>> 9));

	                // t1 = h + sigma1 + ch + K[i] + W[i]
	                var Ki  = K[i];
	                var Kih = Ki.high;
	                var Kil = Ki.low;

	                var t1l = hl + sigma1l;
	                var t1h = hh + sigma1h + ((t1l >>> 0) < (hl >>> 0) ? 1 : 0);
	                var t1l = t1l + chl;
	                var t1h = t1h + chh + ((t1l >>> 0) < (chl >>> 0) ? 1 : 0);
	                var t1l = t1l + Kil;
	                var t1h = t1h + Kih + ((t1l >>> 0) < (Kil >>> 0) ? 1 : 0);
	                var t1l = t1l + Wil;
	                var t1h = t1h + Wih + ((t1l >>> 0) < (Wil >>> 0) ? 1 : 0);

	                // t2 = sigma0 + maj
	                var t2l = sigma0l + majl;
	                var t2h = sigma0h + majh + ((t2l >>> 0) < (sigma0l >>> 0) ? 1 : 0);

	                // Update working variables
	                hh = gh;
	                hl = gl;
	                gh = fh;
	                gl = fl;
	                fh = eh;
	                fl = el;
	                el = (dl + t1l) | 0;
	                eh = (dh + t1h + ((el >>> 0) < (dl >>> 0) ? 1 : 0)) | 0;
	                dh = ch;
	                dl = cl;
	                ch = bh;
	                cl = bl;
	                bh = ah;
	                bl = al;
	                al = (t1l + t2l) | 0;
	                ah = (t1h + t2h + ((al >>> 0) < (t1l >>> 0) ? 1 : 0)) | 0;
	            }

	            // Intermediate hash value
	            H0l = H0.low  = (H0l + al);
	            H0.high = (H0h + ah + ((H0l >>> 0) < (al >>> 0) ? 1 : 0));
	            H1l = H1.low  = (H1l + bl);
	            H1.high = (H1h + bh + ((H1l >>> 0) < (bl >>> 0) ? 1 : 0));
	            H2l = H2.low  = (H2l + cl);
	            H2.high = (H2h + ch + ((H2l >>> 0) < (cl >>> 0) ? 1 : 0));
	            H3l = H3.low  = (H3l + dl);
	            H3.high = (H3h + dh + ((H3l >>> 0) < (dl >>> 0) ? 1 : 0));
	            H4l = H4.low  = (H4l + el);
	            H4.high = (H4h + eh + ((H4l >>> 0) < (el >>> 0) ? 1 : 0));
	            H5l = H5.low  = (H5l + fl);
	            H5.high = (H5h + fh + ((H5l >>> 0) < (fl >>> 0) ? 1 : 0));
	            H6l = H6.low  = (H6l + gl);
	            H6.high = (H6h + gh + ((H6l >>> 0) < (gl >>> 0) ? 1 : 0));
	            H7l = H7.low  = (H7l + hl);
	            H7.high = (H7h + hh + ((H7l >>> 0) < (hl >>> 0) ? 1 : 0));
	        },

	        _doFinalize: function () {
	            // Shortcuts
	            var data = this._data;
	            var dataWords = data.words;

	            var nBitsTotal = this._nDataBytes * 8;
	            var nBitsLeft = data.sigBytes * 8;

	            // Add padding
	            dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);
	            dataWords[(((nBitsLeft + 128) >>> 10) << 5) + 30] = Math.floor(nBitsTotal / 0x100000000);
	            dataWords[(((nBitsLeft + 128) >>> 10) << 5) + 31] = nBitsTotal;
	            data.sigBytes = dataWords.length * 4;

	            // Hash final blocks
	            this._process();

	            // Convert hash to 32-bit word array before returning
	            var hash = this._hash.toX32();

	            // Return final computed hash
	            return hash;
	        },

	        clone: function () {
	            var clone = Hasher.clone.call(this);
	            clone._hash = this._hash.clone();

	            return clone;
	        },

	        blockSize: 1024/32
	    });

	    /**
	     * Shortcut function to the hasher's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     *
	     * @return {WordArray} The hash.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hash = CryptoJS.SHA512('message');
	     *     var hash = CryptoJS.SHA512(wordArray);
	     */
	    C.SHA512 = Hasher._createHelper(SHA512);

	    /**
	     * Shortcut function to the HMAC's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     * @param {WordArray|string} key The secret key.
	     *
	     * @return {WordArray} The HMAC.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hmac = CryptoJS.HmacSHA512(message, key);
	     */
	    C.HmacSHA512 = Hasher._createHmacHelper(SHA512);
	}());


	return CryptoJS.SHA512;

}));

/***/ }),

/***/ 7628:
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory, undef) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__webpack_require__(9021), __webpack_require__(754), __webpack_require__(4636), __webpack_require__(9506), __webpack_require__(7165));
	}
	else {}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var WordArray = C_lib.WordArray;
	    var BlockCipher = C_lib.BlockCipher;
	    var C_algo = C.algo;

	    // Permuted Choice 1 constants
	    var PC1 = [
	        57, 49, 41, 33, 25, 17, 9,  1,
	        58, 50, 42, 34, 26, 18, 10, 2,
	        59, 51, 43, 35, 27, 19, 11, 3,
	        60, 52, 44, 36, 63, 55, 47, 39,
	        31, 23, 15, 7,  62, 54, 46, 38,
	        30, 22, 14, 6,  61, 53, 45, 37,
	        29, 21, 13, 5,  28, 20, 12, 4
	    ];

	    // Permuted Choice 2 constants
	    var PC2 = [
	        14, 17, 11, 24, 1,  5,
	        3,  28, 15, 6,  21, 10,
	        23, 19, 12, 4,  26, 8,
	        16, 7,  27, 20, 13, 2,
	        41, 52, 31, 37, 47, 55,
	        30, 40, 51, 45, 33, 48,
	        44, 49, 39, 56, 34, 53,
	        46, 42, 50, 36, 29, 32
	    ];

	    // Cumulative bit shift constants
	    var BIT_SHIFTS = [1,  2,  4,  6,  8,  10, 12, 14, 15, 17, 19, 21, 23, 25, 27, 28];

	    // SBOXes and round permutation constants
	    var SBOX_P = [
	        {
	            0x0: 0x808200,
	            0x10000000: 0x8000,
	            0x20000000: 0x808002,
	            0x30000000: 0x2,
	            0x40000000: 0x200,
	            0x50000000: 0x808202,
	            0x60000000: 0x800202,
	            0x70000000: 0x800000,
	            0x80000000: 0x202,
	            0x90000000: 0x800200,
	            0xa0000000: 0x8200,
	            0xb0000000: 0x808000,
	            0xc0000000: 0x8002,
	            0xd0000000: 0x800002,
	            0xe0000000: 0x0,
	            0xf0000000: 0x8202,
	            0x8000000: 0x0,
	            0x18000000: 0x808202,
	            0x28000000: 0x8202,
	            0x38000000: 0x8000,
	            0x48000000: 0x808200,
	            0x58000000: 0x200,
	            0x68000000: 0x808002,
	            0x78000000: 0x2,
	            0x88000000: 0x800200,
	            0x98000000: 0x8200,
	            0xa8000000: 0x808000,
	            0xb8000000: 0x800202,
	            0xc8000000: 0x800002,
	            0xd8000000: 0x8002,
	            0xe8000000: 0x202,
	            0xf8000000: 0x800000,
	            0x1: 0x8000,
	            0x10000001: 0x2,
	            0x20000001: 0x808200,
	            0x30000001: 0x800000,
	            0x40000001: 0x808002,
	            0x50000001: 0x8200,
	            0x60000001: 0x200,
	            0x70000001: 0x800202,
	            0x80000001: 0x808202,
	            0x90000001: 0x808000,
	            0xa0000001: 0x800002,
	            0xb0000001: 0x8202,
	            0xc0000001: 0x202,
	            0xd0000001: 0x800200,
	            0xe0000001: 0x8002,
	            0xf0000001: 0x0,
	            0x8000001: 0x808202,
	            0x18000001: 0x808000,
	            0x28000001: 0x800000,
	            0x38000001: 0x200,
	            0x48000001: 0x8000,
	            0x58000001: 0x800002,
	            0x68000001: 0x2,
	            0x78000001: 0x8202,
	            0x88000001: 0x8002,
	            0x98000001: 0x800202,
	            0xa8000001: 0x202,
	            0xb8000001: 0x808200,
	            0xc8000001: 0x800200,
	            0xd8000001: 0x0,
	            0xe8000001: 0x8200,
	            0xf8000001: 0x808002
	        },
	        {
	            0x0: 0x40084010,
	            0x1000000: 0x4000,
	            0x2000000: 0x80000,
	            0x3000000: 0x40080010,
	            0x4000000: 0x40000010,
	            0x5000000: 0x40084000,
	            0x6000000: 0x40004000,
	            0x7000000: 0x10,
	            0x8000000: 0x84000,
	            0x9000000: 0x40004010,
	            0xa000000: 0x40000000,
	            0xb000000: 0x84010,
	            0xc000000: 0x80010,
	            0xd000000: 0x0,
	            0xe000000: 0x4010,
	            0xf000000: 0x40080000,
	            0x800000: 0x40004000,
	            0x1800000: 0x84010,
	            0x2800000: 0x10,
	            0x3800000: 0x40004010,
	            0x4800000: 0x40084010,
	            0x5800000: 0x40000000,
	            0x6800000: 0x80000,
	            0x7800000: 0x40080010,
	            0x8800000: 0x80010,
	            0x9800000: 0x0,
	            0xa800000: 0x4000,
	            0xb800000: 0x40080000,
	            0xc800000: 0x40000010,
	            0xd800000: 0x84000,
	            0xe800000: 0x40084000,
	            0xf800000: 0x4010,
	            0x10000000: 0x0,
	            0x11000000: 0x40080010,
	            0x12000000: 0x40004010,
	            0x13000000: 0x40084000,
	            0x14000000: 0x40080000,
	            0x15000000: 0x10,
	            0x16000000: 0x84010,
	            0x17000000: 0x4000,
	            0x18000000: 0x4010,
	            0x19000000: 0x80000,
	            0x1a000000: 0x80010,
	            0x1b000000: 0x40000010,
	            0x1c000000: 0x84000,
	            0x1d000000: 0x40004000,
	            0x1e000000: 0x40000000,
	            0x1f000000: 0x40084010,
	            0x10800000: 0x84010,
	            0x11800000: 0x80000,
	            0x12800000: 0x40080000,
	            0x13800000: 0x4000,
	            0x14800000: 0x40004000,
	            0x15800000: 0x40084010,
	            0x16800000: 0x10,
	            0x17800000: 0x40000000,
	            0x18800000: 0x40084000,
	            0x19800000: 0x40000010,
	            0x1a800000: 0x40004010,
	            0x1b800000: 0x80010,
	            0x1c800000: 0x0,
	            0x1d800000: 0x4010,
	            0x1e800000: 0x40080010,
	            0x1f800000: 0x84000
	        },
	        {
	            0x0: 0x104,
	            0x100000: 0x0,
	            0x200000: 0x4000100,
	            0x300000: 0x10104,
	            0x400000: 0x10004,
	            0x500000: 0x4000004,
	            0x600000: 0x4010104,
	            0x700000: 0x4010000,
	            0x800000: 0x4000000,
	            0x900000: 0x4010100,
	            0xa00000: 0x10100,
	            0xb00000: 0x4010004,
	            0xc00000: 0x4000104,
	            0xd00000: 0x10000,
	            0xe00000: 0x4,
	            0xf00000: 0x100,
	            0x80000: 0x4010100,
	            0x180000: 0x4010004,
	            0x280000: 0x0,
	            0x380000: 0x4000100,
	            0x480000: 0x4000004,
	            0x580000: 0x10000,
	            0x680000: 0x10004,
	            0x780000: 0x104,
	            0x880000: 0x4,
	            0x980000: 0x100,
	            0xa80000: 0x4010000,
	            0xb80000: 0x10104,
	            0xc80000: 0x10100,
	            0xd80000: 0x4000104,
	            0xe80000: 0x4010104,
	            0xf80000: 0x4000000,
	            0x1000000: 0x4010100,
	            0x1100000: 0x10004,
	            0x1200000: 0x10000,
	            0x1300000: 0x4000100,
	            0x1400000: 0x100,
	            0x1500000: 0x4010104,
	            0x1600000: 0x4000004,
	            0x1700000: 0x0,
	            0x1800000: 0x4000104,
	            0x1900000: 0x4000000,
	            0x1a00000: 0x4,
	            0x1b00000: 0x10100,
	            0x1c00000: 0x4010000,
	            0x1d00000: 0x104,
	            0x1e00000: 0x10104,
	            0x1f00000: 0x4010004,
	            0x1080000: 0x4000000,
	            0x1180000: 0x104,
	            0x1280000: 0x4010100,
	            0x1380000: 0x0,
	            0x1480000: 0x10004,
	            0x1580000: 0x4000100,
	            0x1680000: 0x100,
	            0x1780000: 0x4010004,
	            0x1880000: 0x10000,
	            0x1980000: 0x4010104,
	            0x1a80000: 0x10104,
	            0x1b80000: 0x4000004,
	            0x1c80000: 0x4000104,
	            0x1d80000: 0x4010000,
	            0x1e80000: 0x4,
	            0x1f80000: 0x10100
	        },
	        {
	            0x0: 0x80401000,
	            0x10000: 0x80001040,
	            0x20000: 0x401040,
	            0x30000: 0x80400000,
	            0x40000: 0x0,
	            0x50000: 0x401000,
	            0x60000: 0x80000040,
	            0x70000: 0x400040,
	            0x80000: 0x80000000,
	            0x90000: 0x400000,
	            0xa0000: 0x40,
	            0xb0000: 0x80001000,
	            0xc0000: 0x80400040,
	            0xd0000: 0x1040,
	            0xe0000: 0x1000,
	            0xf0000: 0x80401040,
	            0x8000: 0x80001040,
	            0x18000: 0x40,
	            0x28000: 0x80400040,
	            0x38000: 0x80001000,
	            0x48000: 0x401000,
	            0x58000: 0x80401040,
	            0x68000: 0x0,
	            0x78000: 0x80400000,
	            0x88000: 0x1000,
	            0x98000: 0x80401000,
	            0xa8000: 0x400000,
	            0xb8000: 0x1040,
	            0xc8000: 0x80000000,
	            0xd8000: 0x400040,
	            0xe8000: 0x401040,
	            0xf8000: 0x80000040,
	            0x100000: 0x400040,
	            0x110000: 0x401000,
	            0x120000: 0x80000040,
	            0x130000: 0x0,
	            0x140000: 0x1040,
	            0x150000: 0x80400040,
	            0x160000: 0x80401000,
	            0x170000: 0x80001040,
	            0x180000: 0x80401040,
	            0x190000: 0x80000000,
	            0x1a0000: 0x80400000,
	            0x1b0000: 0x401040,
	            0x1c0000: 0x80001000,
	            0x1d0000: 0x400000,
	            0x1e0000: 0x40,
	            0x1f0000: 0x1000,
	            0x108000: 0x80400000,
	            0x118000: 0x80401040,
	            0x128000: 0x0,
	            0x138000: 0x401000,
	            0x148000: 0x400040,
	            0x158000: 0x80000000,
	            0x168000: 0x80001040,
	            0x178000: 0x40,
	            0x188000: 0x80000040,
	            0x198000: 0x1000,
	            0x1a8000: 0x80001000,
	            0x1b8000: 0x80400040,
	            0x1c8000: 0x1040,
	            0x1d8000: 0x80401000,
	            0x1e8000: 0x400000,
	            0x1f8000: 0x401040
	        },
	        {
	            0x0: 0x80,
	            0x1000: 0x1040000,
	            0x2000: 0x40000,
	            0x3000: 0x20000000,
	            0x4000: 0x20040080,
	            0x5000: 0x1000080,
	            0x6000: 0x21000080,
	            0x7000: 0x40080,
	            0x8000: 0x1000000,
	            0x9000: 0x20040000,
	            0xa000: 0x20000080,
	            0xb000: 0x21040080,
	            0xc000: 0x21040000,
	            0xd000: 0x0,
	            0xe000: 0x1040080,
	            0xf000: 0x21000000,
	            0x800: 0x1040080,
	            0x1800: 0x21000080,
	            0x2800: 0x80,
	            0x3800: 0x1040000,
	            0x4800: 0x40000,
	            0x5800: 0x20040080,
	            0x6800: 0x21040000,
	            0x7800: 0x20000000,
	            0x8800: 0x20040000,
	            0x9800: 0x0,
	            0xa800: 0x21040080,
	            0xb800: 0x1000080,
	            0xc800: 0x20000080,
	            0xd800: 0x21000000,
	            0xe800: 0x1000000,
	            0xf800: 0x40080,
	            0x10000: 0x40000,
	            0x11000: 0x80,
	            0x12000: 0x20000000,
	            0x13000: 0x21000080,
	            0x14000: 0x1000080,
	            0x15000: 0x21040000,
	            0x16000: 0x20040080,
	            0x17000: 0x1000000,
	            0x18000: 0x21040080,
	            0x19000: 0x21000000,
	            0x1a000: 0x1040000,
	            0x1b000: 0x20040000,
	            0x1c000: 0x40080,
	            0x1d000: 0x20000080,
	            0x1e000: 0x0,
	            0x1f000: 0x1040080,
	            0x10800: 0x21000080,
	            0x11800: 0x1000000,
	            0x12800: 0x1040000,
	            0x13800: 0x20040080,
	            0x14800: 0x20000000,
	            0x15800: 0x1040080,
	            0x16800: 0x80,
	            0x17800: 0x21040000,
	            0x18800: 0x40080,
	            0x19800: 0x21040080,
	            0x1a800: 0x0,
	            0x1b800: 0x21000000,
	            0x1c800: 0x1000080,
	            0x1d800: 0x40000,
	            0x1e800: 0x20040000,
	            0x1f800: 0x20000080
	        },
	        {
	            0x0: 0x10000008,
	            0x100: 0x2000,
	            0x200: 0x10200000,
	            0x300: 0x10202008,
	            0x400: 0x10002000,
	            0x500: 0x200000,
	            0x600: 0x200008,
	            0x700: 0x10000000,
	            0x800: 0x0,
	            0x900: 0x10002008,
	            0xa00: 0x202000,
	            0xb00: 0x8,
	            0xc00: 0x10200008,
	            0xd00: 0x202008,
	            0xe00: 0x2008,
	            0xf00: 0x10202000,
	            0x80: 0x10200000,
	            0x180: 0x10202008,
	            0x280: 0x8,
	            0x380: 0x200000,
	            0x480: 0x202008,
	            0x580: 0x10000008,
	            0x680: 0x10002000,
	            0x780: 0x2008,
	            0x880: 0x200008,
	            0x980: 0x2000,
	            0xa80: 0x10002008,
	            0xb80: 0x10200008,
	            0xc80: 0x0,
	            0xd80: 0x10202000,
	            0xe80: 0x202000,
	            0xf80: 0x10000000,
	            0x1000: 0x10002000,
	            0x1100: 0x10200008,
	            0x1200: 0x10202008,
	            0x1300: 0x2008,
	            0x1400: 0x200000,
	            0x1500: 0x10000000,
	            0x1600: 0x10000008,
	            0x1700: 0x202000,
	            0x1800: 0x202008,
	            0x1900: 0x0,
	            0x1a00: 0x8,
	            0x1b00: 0x10200000,
	            0x1c00: 0x2000,
	            0x1d00: 0x10002008,
	            0x1e00: 0x10202000,
	            0x1f00: 0x200008,
	            0x1080: 0x8,
	            0x1180: 0x202000,
	            0x1280: 0x200000,
	            0x1380: 0x10000008,
	            0x1480: 0x10002000,
	            0x1580: 0x2008,
	            0x1680: 0x10202008,
	            0x1780: 0x10200000,
	            0x1880: 0x10202000,
	            0x1980: 0x10200008,
	            0x1a80: 0x2000,
	            0x1b80: 0x202008,
	            0x1c80: 0x200008,
	            0x1d80: 0x0,
	            0x1e80: 0x10000000,
	            0x1f80: 0x10002008
	        },
	        {
	            0x0: 0x100000,
	            0x10: 0x2000401,
	            0x20: 0x400,
	            0x30: 0x100401,
	            0x40: 0x2100401,
	            0x50: 0x0,
	            0x60: 0x1,
	            0x70: 0x2100001,
	            0x80: 0x2000400,
	            0x90: 0x100001,
	            0xa0: 0x2000001,
	            0xb0: 0x2100400,
	            0xc0: 0x2100000,
	            0xd0: 0x401,
	            0xe0: 0x100400,
	            0xf0: 0x2000000,
	            0x8: 0x2100001,
	            0x18: 0x0,
	            0x28: 0x2000401,
	            0x38: 0x2100400,
	            0x48: 0x100000,
	            0x58: 0x2000001,
	            0x68: 0x2000000,
	            0x78: 0x401,
	            0x88: 0x100401,
	            0x98: 0x2000400,
	            0xa8: 0x2100000,
	            0xb8: 0x100001,
	            0xc8: 0x400,
	            0xd8: 0x2100401,
	            0xe8: 0x1,
	            0xf8: 0x100400,
	            0x100: 0x2000000,
	            0x110: 0x100000,
	            0x120: 0x2000401,
	            0x130: 0x2100001,
	            0x140: 0x100001,
	            0x150: 0x2000400,
	            0x160: 0x2100400,
	            0x170: 0x100401,
	            0x180: 0x401,
	            0x190: 0x2100401,
	            0x1a0: 0x100400,
	            0x1b0: 0x1,
	            0x1c0: 0x0,
	            0x1d0: 0x2100000,
	            0x1e0: 0x2000001,
	            0x1f0: 0x400,
	            0x108: 0x100400,
	            0x118: 0x2000401,
	            0x128: 0x2100001,
	            0x138: 0x1,
	            0x148: 0x2000000,
	            0x158: 0x100000,
	            0x168: 0x401,
	            0x178: 0x2100400,
	            0x188: 0x2000001,
	            0x198: 0x2100000,
	            0x1a8: 0x0,
	            0x1b8: 0x2100401,
	            0x1c8: 0x100401,
	            0x1d8: 0x400,
	            0x1e8: 0x2000400,
	            0x1f8: 0x100001
	        },
	        {
	            0x0: 0x8000820,
	            0x1: 0x20000,
	            0x2: 0x8000000,
	            0x3: 0x20,
	            0x4: 0x20020,
	            0x5: 0x8020820,
	            0x6: 0x8020800,
	            0x7: 0x800,
	            0x8: 0x8020000,
	            0x9: 0x8000800,
	            0xa: 0x20800,
	            0xb: 0x8020020,
	            0xc: 0x820,
	            0xd: 0x0,
	            0xe: 0x8000020,
	            0xf: 0x20820,
	            0x80000000: 0x800,
	            0x80000001: 0x8020820,
	            0x80000002: 0x8000820,
	            0x80000003: 0x8000000,
	            0x80000004: 0x8020000,
	            0x80000005: 0x20800,
	            0x80000006: 0x20820,
	            0x80000007: 0x20,
	            0x80000008: 0x8000020,
	            0x80000009: 0x820,
	            0x8000000a: 0x20020,
	            0x8000000b: 0x8020800,
	            0x8000000c: 0x0,
	            0x8000000d: 0x8020020,
	            0x8000000e: 0x8000800,
	            0x8000000f: 0x20000,
	            0x10: 0x20820,
	            0x11: 0x8020800,
	            0x12: 0x20,
	            0x13: 0x800,
	            0x14: 0x8000800,
	            0x15: 0x8000020,
	            0x16: 0x8020020,
	            0x17: 0x20000,
	            0x18: 0x0,
	            0x19: 0x20020,
	            0x1a: 0x8020000,
	            0x1b: 0x8000820,
	            0x1c: 0x8020820,
	            0x1d: 0x20800,
	            0x1e: 0x820,
	            0x1f: 0x8000000,
	            0x80000010: 0x20000,
	            0x80000011: 0x800,
	            0x80000012: 0x8020020,
	            0x80000013: 0x20820,
	            0x80000014: 0x20,
	            0x80000015: 0x8020000,
	            0x80000016: 0x8000000,
	            0x80000017: 0x8000820,
	            0x80000018: 0x8020820,
	            0x80000019: 0x8000020,
	            0x8000001a: 0x8000800,
	            0x8000001b: 0x0,
	            0x8000001c: 0x20800,
	            0x8000001d: 0x820,
	            0x8000001e: 0x20020,
	            0x8000001f: 0x8020800
	        }
	    ];

	    // Masks that select the SBOX input
	    var SBOX_MASK = [
	        0xf8000001, 0x1f800000, 0x01f80000, 0x001f8000,
	        0x0001f800, 0x00001f80, 0x000001f8, 0x8000001f
	    ];

	    /**
	     * DES block cipher algorithm.
	     */
	    var DES = C_algo.DES = BlockCipher.extend({
	        _doReset: function () {
	            // Shortcuts
	            var key = this._key;
	            var keyWords = key.words;

	            // Select 56 bits according to PC1
	            var keyBits = [];
	            for (var i = 0; i < 56; i++) {
	                var keyBitPos = PC1[i] - 1;
	                keyBits[i] = (keyWords[keyBitPos >>> 5] >>> (31 - keyBitPos % 32)) & 1;
	            }

	            // Assemble 16 subkeys
	            var subKeys = this._subKeys = [];
	            for (var nSubKey = 0; nSubKey < 16; nSubKey++) {
	                // Create subkey
	                var subKey = subKeys[nSubKey] = [];

	                // Shortcut
	                var bitShift = BIT_SHIFTS[nSubKey];

	                // Select 48 bits according to PC2
	                for (var i = 0; i < 24; i++) {
	                    // Select from the left 28 key bits
	                    subKey[(i / 6) | 0] |= keyBits[((PC2[i] - 1) + bitShift) % 28] << (31 - i % 6);

	                    // Select from the right 28 key bits
	                    subKey[4 + ((i / 6) | 0)] |= keyBits[28 + (((PC2[i + 24] - 1) + bitShift) % 28)] << (31 - i % 6);
	                }

	                // Since each subkey is applied to an expanded 32-bit input,
	                // the subkey can be broken into 8 values scaled to 32-bits,
	                // which allows the key to be used without expansion
	                subKey[0] = (subKey[0] << 1) | (subKey[0] >>> 31);
	                for (var i = 1; i < 7; i++) {
	                    subKey[i] = subKey[i] >>> ((i - 1) * 4 + 3);
	                }
	                subKey[7] = (subKey[7] << 5) | (subKey[7] >>> 27);
	            }

	            // Compute inverse subkeys
	            var invSubKeys = this._invSubKeys = [];
	            for (var i = 0; i < 16; i++) {
	                invSubKeys[i] = subKeys[15 - i];
	            }
	        },

	        encryptBlock: function (M, offset) {
	            this._doCryptBlock(M, offset, this._subKeys);
	        },

	        decryptBlock: function (M, offset) {
	            this._doCryptBlock(M, offset, this._invSubKeys);
	        },

	        _doCryptBlock: function (M, offset, subKeys) {
	            // Get input
	            this._lBlock = M[offset];
	            this._rBlock = M[offset + 1];

	            // Initial permutation
	            exchangeLR.call(this, 4,  0x0f0f0f0f);
	            exchangeLR.call(this, 16, 0x0000ffff);
	            exchangeRL.call(this, 2,  0x33333333);
	            exchangeRL.call(this, 8,  0x00ff00ff);
	            exchangeLR.call(this, 1,  0x55555555);

	            // Rounds
	            for (var round = 0; round < 16; round++) {
	                // Shortcuts
	                var subKey = subKeys[round];
	                var lBlock = this._lBlock;
	                var rBlock = this._rBlock;

	                // Feistel function
	                var f = 0;
	                for (var i = 0; i < 8; i++) {
	                    f |= SBOX_P[i][((rBlock ^ subKey[i]) & SBOX_MASK[i]) >>> 0];
	                }
	                this._lBlock = rBlock;
	                this._rBlock = lBlock ^ f;
	            }

	            // Undo swap from last round
	            var t = this._lBlock;
	            this._lBlock = this._rBlock;
	            this._rBlock = t;

	            // Final permutation
	            exchangeLR.call(this, 1,  0x55555555);
	            exchangeRL.call(this, 8,  0x00ff00ff);
	            exchangeRL.call(this, 2,  0x33333333);
	            exchangeLR.call(this, 16, 0x0000ffff);
	            exchangeLR.call(this, 4,  0x0f0f0f0f);

	            // Set output
	            M[offset] = this._lBlock;
	            M[offset + 1] = this._rBlock;
	        },

	        keySize: 64/32,

	        ivSize: 64/32,

	        blockSize: 64/32
	    });

	    // Swap bits across the left and right words
	    function exchangeLR(offset, mask) {
	        var t = ((this._lBlock >>> offset) ^ this._rBlock) & mask;
	        this._rBlock ^= t;
	        this._lBlock ^= t << offset;
	    }

	    function exchangeRL(offset, mask) {
	        var t = ((this._rBlock >>> offset) ^ this._lBlock) & mask;
	        this._lBlock ^= t;
	        this._rBlock ^= t << offset;
	    }

	    /**
	     * Shortcut functions to the cipher's object interface.
	     *
	     * @example
	     *
	     *     var ciphertext = CryptoJS.DES.encrypt(message, key, cfg);
	     *     var plaintext  = CryptoJS.DES.decrypt(ciphertext, key, cfg);
	     */
	    C.DES = BlockCipher._createHelper(DES);

	    /**
	     * Triple-DES block cipher algorithm.
	     */
	    var TripleDES = C_algo.TripleDES = BlockCipher.extend({
	        _doReset: function () {
	            // Shortcuts
	            var key = this._key;
	            var keyWords = key.words;

	            // Create DES instances
	            this._des1 = DES.createEncryptor(WordArray.create(keyWords.slice(0, 2)));
	            this._des2 = DES.createEncryptor(WordArray.create(keyWords.slice(2, 4)));
	            this._des3 = DES.createEncryptor(WordArray.create(keyWords.slice(4, 6)));
	        },

	        encryptBlock: function (M, offset) {
	            this._des1.encryptBlock(M, offset);
	            this._des2.decryptBlock(M, offset);
	            this._des3.encryptBlock(M, offset);
	        },

	        decryptBlock: function (M, offset) {
	            this._des3.decryptBlock(M, offset);
	            this._des2.encryptBlock(M, offset);
	            this._des1.decryptBlock(M, offset);
	        },

	        keySize: 192/32,

	        ivSize: 64/32,

	        blockSize: 64/32
	    });

	    /**
	     * Shortcut functions to the cipher's object interface.
	     *
	     * @example
	     *
	     *     var ciphertext = CryptoJS.TripleDES.encrypt(message, key, cfg);
	     *     var plaintext  = CryptoJS.TripleDES.decrypt(ciphertext, key, cfg);
	     */
	    C.TripleDES = BlockCipher._createHelper(TripleDES);
	}());


	return CryptoJS.TripleDES;

}));

/***/ }),

/***/ 3240:
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__webpack_require__(9021));
	}
	else {}
}(this, function (CryptoJS) {

	(function (undefined) {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var Base = C_lib.Base;
	    var X32WordArray = C_lib.WordArray;

	    /**
	     * x64 namespace.
	     */
	    var C_x64 = C.x64 = {};

	    /**
	     * A 64-bit word.
	     */
	    var X64Word = C_x64.Word = Base.extend({
	        /**
	         * Initializes a newly created 64-bit word.
	         *
	         * @param {number} high The high 32 bits.
	         * @param {number} low The low 32 bits.
	         *
	         * @example
	         *
	         *     var x64Word = CryptoJS.x64.Word.create(0x00010203, 0x04050607);
	         */
	        init: function (high, low) {
	            this.high = high;
	            this.low = low;
	        }

	        /**
	         * Bitwise NOTs this word.
	         *
	         * @return {X64Word} A new x64-Word object after negating.
	         *
	         * @example
	         *
	         *     var negated = x64Word.not();
	         */
	        // not: function () {
	            // var high = ~this.high;
	            // var low = ~this.low;

	            // return X64Word.create(high, low);
	        // },

	        /**
	         * Bitwise ANDs this word with the passed word.
	         *
	         * @param {X64Word} word The x64-Word to AND with this word.
	         *
	         * @return {X64Word} A new x64-Word object after ANDing.
	         *
	         * @example
	         *
	         *     var anded = x64Word.and(anotherX64Word);
	         */
	        // and: function (word) {
	            // var high = this.high & word.high;
	            // var low = this.low & word.low;

	            // return X64Word.create(high, low);
	        // },

	        /**
	         * Bitwise ORs this word with the passed word.
	         *
	         * @param {X64Word} word The x64-Word to OR with this word.
	         *
	         * @return {X64Word} A new x64-Word object after ORing.
	         *
	         * @example
	         *
	         *     var ored = x64Word.or(anotherX64Word);
	         */
	        // or: function (word) {
	            // var high = this.high | word.high;
	            // var low = this.low | word.low;

	            // return X64Word.create(high, low);
	        // },

	        /**
	         * Bitwise XORs this word with the passed word.
	         *
	         * @param {X64Word} word The x64-Word to XOR with this word.
	         *
	         * @return {X64Word} A new x64-Word object after XORing.
	         *
	         * @example
	         *
	         *     var xored = x64Word.xor(anotherX64Word);
	         */
	        // xor: function (word) {
	            // var high = this.high ^ word.high;
	            // var low = this.low ^ word.low;

	            // return X64Word.create(high, low);
	        // },

	        /**
	         * Shifts this word n bits to the left.
	         *
	         * @param {number} n The number of bits to shift.
	         *
	         * @return {X64Word} A new x64-Word object after shifting.
	         *
	         * @example
	         *
	         *     var shifted = x64Word.shiftL(25);
	         */
	        // shiftL: function (n) {
	            // if (n < 32) {
	                // var high = (this.high << n) | (this.low >>> (32 - n));
	                // var low = this.low << n;
	            // } else {
	                // var high = this.low << (n - 32);
	                // var low = 0;
	            // }

	            // return X64Word.create(high, low);
	        // },

	        /**
	         * Shifts this word n bits to the right.
	         *
	         * @param {number} n The number of bits to shift.
	         *
	         * @return {X64Word} A new x64-Word object after shifting.
	         *
	         * @example
	         *
	         *     var shifted = x64Word.shiftR(7);
	         */
	        // shiftR: function (n) {
	            // if (n < 32) {
	                // var low = (this.low >>> n) | (this.high << (32 - n));
	                // var high = this.high >>> n;
	            // } else {
	                // var low = this.high >>> (n - 32);
	                // var high = 0;
	            // }

	            // return X64Word.create(high, low);
	        // },

	        /**
	         * Rotates this word n bits to the left.
	         *
	         * @param {number} n The number of bits to rotate.
	         *
	         * @return {X64Word} A new x64-Word object after rotating.
	         *
	         * @example
	         *
	         *     var rotated = x64Word.rotL(25);
	         */
	        // rotL: function (n) {
	            // return this.shiftL(n).or(this.shiftR(64 - n));
	        // },

	        /**
	         * Rotates this word n bits to the right.
	         *
	         * @param {number} n The number of bits to rotate.
	         *
	         * @return {X64Word} A new x64-Word object after rotating.
	         *
	         * @example
	         *
	         *     var rotated = x64Word.rotR(7);
	         */
	        // rotR: function (n) {
	            // return this.shiftR(n).or(this.shiftL(64 - n));
	        // },

	        /**
	         * Adds this word with the passed word.
	         *
	         * @param {X64Word} word The x64-Word to add with this word.
	         *
	         * @return {X64Word} A new x64-Word object after adding.
	         *
	         * @example
	         *
	         *     var added = x64Word.add(anotherX64Word);
	         */
	        // add: function (word) {
	            // var low = (this.low + word.low) | 0;
	            // var carry = (low >>> 0) < (this.low >>> 0) ? 1 : 0;
	            // var high = (this.high + word.high + carry) | 0;

	            // return X64Word.create(high, low);
	        // }
	    });

	    /**
	     * An array of 64-bit words.
	     *
	     * @property {Array} words The array of CryptoJS.x64.Word objects.
	     * @property {number} sigBytes The number of significant bytes in this word array.
	     */
	    var X64WordArray = C_x64.WordArray = Base.extend({
	        /**
	         * Initializes a newly created word array.
	         *
	         * @param {Array} words (Optional) An array of CryptoJS.x64.Word objects.
	         * @param {number} sigBytes (Optional) The number of significant bytes in the words.
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.x64.WordArray.create();
	         *
	         *     var wordArray = CryptoJS.x64.WordArray.create([
	         *         CryptoJS.x64.Word.create(0x00010203, 0x04050607),
	         *         CryptoJS.x64.Word.create(0x18191a1b, 0x1c1d1e1f)
	         *     ]);
	         *
	         *     var wordArray = CryptoJS.x64.WordArray.create([
	         *         CryptoJS.x64.Word.create(0x00010203, 0x04050607),
	         *         CryptoJS.x64.Word.create(0x18191a1b, 0x1c1d1e1f)
	         *     ], 10);
	         */
	        init: function (words, sigBytes) {
	            words = this.words = words || [];

	            if (sigBytes != undefined) {
	                this.sigBytes = sigBytes;
	            } else {
	                this.sigBytes = words.length * 8;
	            }
	        },

	        /**
	         * Converts this 64-bit word array to a 32-bit word array.
	         *
	         * @return {CryptoJS.lib.WordArray} This word array's data as a 32-bit word array.
	         *
	         * @example
	         *
	         *     var x32WordArray = x64WordArray.toX32();
	         */
	        toX32: function () {
	            // Shortcuts
	            var x64Words = this.words;
	            var x64WordsLength = x64Words.length;

	            // Convert
	            var x32Words = [];
	            for (var i = 0; i < x64WordsLength; i++) {
	                var x64Word = x64Words[i];
	                x32Words.push(x64Word.high);
	                x32Words.push(x64Word.low);
	            }

	            return X32WordArray.create(x32Words, this.sigBytes);
	        },

	        /**
	         * Creates a copy of this word array.
	         *
	         * @return {X64WordArray} The clone.
	         *
	         * @example
	         *
	         *     var clone = x64WordArray.clone();
	         */
	        clone: function () {
	            var clone = Base.clone.call(this);

	            // Clone "words" array
	            var words = clone.words = this.words.slice(0);

	            // Clone each X64Word object
	            var wordsLength = words.length;
	            for (var i = 0; i < wordsLength; i++) {
	                words[i] = words[i].clone();
	            }

	            return clone;
	        }
	    });
	}());


	return CryptoJS;

}));

/***/ }),

/***/ 7898:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

exports.UINT32 = __webpack_require__(741)
exports.UINT64 = __webpack_require__(174)

/***/ }),

/***/ 741:
/***/ (function(module, exports) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**
	C-like unsigned 32 bits integers in Javascript
	Copyright (C) 2013, Pierre Curto
	MIT license
 */
;(function (root) {

	// Local cache for typical radices
	var radixPowerCache = {
		36: UINT32( Math.pow(36, 5) )
	,	16: UINT32( Math.pow(16, 7) )
	,	10: UINT32( Math.pow(10, 9) )
	,	2:  UINT32( Math.pow(2, 30) )
	}
	var radixCache = {
		36: UINT32(36)
	,	16: UINT32(16)
	,	10: UINT32(10)
	,	2:  UINT32(2)
	}

	/**
	 *	Represents an unsigned 32 bits integer
	 * @constructor
	 * @param {Number|String|Number} low bits     | integer as a string 		 | integer as a number
	 * @param {Number|Number|Undefined} high bits | radix (optional, default=10)
	 * @return 
	 */
	function UINT32 (l, h) {
		if ( !(this instanceof UINT32) )
			return new UINT32(l, h)

		this._low = 0
		this._high = 0
		this.remainder = null
		if (typeof h == 'undefined')
			return fromNumber.call(this, l)

		if (typeof l == 'string')
			return fromString.call(this, l, h)

		fromBits.call(this, l, h)
	}

	/**
	 * Set the current _UINT32_ object with its low and high bits
	 * @method fromBits
	 * @param {Number} low bits
	 * @param {Number} high bits
	 * @return ThisExpression
	 */
	function fromBits (l, h) {
		this._low = l | 0
		this._high = h | 0

		return this
	}
	UINT32.prototype.fromBits = fromBits

	/**
	 * Set the current _UINT32_ object from a number
	 * @method fromNumber
	 * @param {Number} number
	 * @return ThisExpression
	 */
	function fromNumber (value) {
		this._low = value & 0xFFFF
		this._high = value >>> 16

		return this
	}
	UINT32.prototype.fromNumber = fromNumber

	/**
	 * Set the current _UINT32_ object from a string
	 * @method fromString
	 * @param {String} integer as a string
	 * @param {Number} radix (optional, default=10)
	 * @return ThisExpression
	 */
	function fromString (s, radix) {
		var value = parseInt(s, radix || 10)

		this._low = value & 0xFFFF
		this._high = value >>> 16

		return this
	}
	UINT32.prototype.fromString = fromString

	/**
	 * Convert this _UINT32_ to a number
	 * @method toNumber
	 * @return {Number} the converted UINT32
	 */
	UINT32.prototype.toNumber = function () {
		return (this._high * 65536) + this._low
	}

	/**
	 * Convert this _UINT32_ to a string
	 * @method toString
	 * @param {Number} radix (optional, default=10)
	 * @return {String} the converted UINT32
	 */
	UINT32.prototype.toString = function (radix) {
		return this.toNumber().toString(radix || 10)
	}

	/**
	 * Add two _UINT32_. The current _UINT32_ stores the result
	 * @method add
	 * @param {Object} other UINT32
	 * @return ThisExpression
	 */
	UINT32.prototype.add = function (other) {
		var a00 = this._low + other._low
		var a16 = a00 >>> 16

		a16 += this._high + other._high

		this._low = a00 & 0xFFFF
		this._high = a16 & 0xFFFF

		return this
	}

	/**
	 * Subtract two _UINT32_. The current _UINT32_ stores the result
	 * @method subtract
	 * @param {Object} other UINT32
	 * @return ThisExpression
	 */
	UINT32.prototype.subtract = function (other) {
		//TODO inline
		return this.add( other.clone().negate() )
	}

	/**
	 * Multiply two _UINT32_. The current _UINT32_ stores the result
	 * @method multiply
	 * @param {Object} other UINT32
	 * @return ThisExpression
	 */
	UINT32.prototype.multiply = function (other) {
		/*
			a = a00 + a16
			b = b00 + b16
			a*b = (a00 + a16)(b00 + b16)
				= a00b00 + a00b16 + a16b00 + a16b16

			a16b16 overflows the 32bits
		 */
		var a16 = this._high
		var a00 = this._low
		var b16 = other._high
		var b00 = other._low

/* Removed to increase speed under normal circumstances (i.e. not multiplying by 0 or 1)
		// this == 0 or other == 1: nothing to do
		if ((a00 == 0 && a16 == 0) || (b00 == 1 && b16 == 0)) return this

		// other == 0 or this == 1: this = other
		if ((b00 == 0 && b16 == 0) || (a00 == 1 && a16 == 0)) {
			this._low = other._low
			this._high = other._high
			return this
		}
*/

		var c16, c00
		c00 = a00 * b00
		c16 = c00 >>> 16

		c16 += a16 * b00
		c16 &= 0xFFFF		// Not required but improves performance
		c16 += a00 * b16

		this._low = c00 & 0xFFFF
		this._high = c16 & 0xFFFF

		return this
	}

	/**
	 * Divide two _UINT32_. The current _UINT32_ stores the result.
	 * The remainder is made available as the _remainder_ property on
	 * the _UINT32_ object. It can be null, meaning there are no remainder.
	 * @method div
	 * @param {Object} other UINT32
	 * @return ThisExpression
	 */
	UINT32.prototype.div = function (other) {
		if ( (other._low == 0) && (other._high == 0) ) throw Error('division by zero')

		// other == 1
		if (other._high == 0 && other._low == 1) {
			this.remainder = new UINT32(0)
			return this
		}

		// other > this: 0
		if ( other.gt(this) ) {
			this.remainder = this.clone()
			this._low = 0
			this._high = 0
			return this
		}
		// other == this: 1
		if ( this.eq(other) ) {
			this.remainder = new UINT32(0)
			this._low = 1
			this._high = 0
			return this
		}

		// Shift the divisor left until it is higher than the dividend
		var _other = other.clone()
		var i = -1
		while ( !this.lt(_other) ) {
			// High bit can overflow the default 16bits
			// Its ok since we right shift after this loop
			// The overflown bit must be kept though
			_other.shiftLeft(1, true)
			i++
		}

		// Set the remainder
		this.remainder = this.clone()
		// Initialize the current result to 0
		this._low = 0
		this._high = 0
		for (; i >= 0; i--) {
			_other.shiftRight(1)
			// If shifted divisor is smaller than the dividend
			// then subtract it from the dividend
			if ( !this.remainder.lt(_other) ) {
				this.remainder.subtract(_other)
				// Update the current result
				if (i >= 16) {
					this._high |= 1 << (i - 16)
				} else {
					this._low |= 1 << i
				}
			}
		}

		return this
	}

	/**
	 * Negate the current _UINT32_
	 * @method negate
	 * @return ThisExpression
	 */
	UINT32.prototype.negate = function () {
		var v = ( ~this._low & 0xFFFF ) + 1
		this._low = v & 0xFFFF
		this._high = (~this._high + (v >>> 16)) & 0xFFFF

		return this
	}

	/**
	 * Equals
	 * @method eq
	 * @param {Object} other UINT32
	 * @return {Boolean}
	 */
	UINT32.prototype.equals = UINT32.prototype.eq = function (other) {
		return (this._low == other._low) && (this._high == other._high)
	}

	/**
	 * Greater than (strict)
	 * @method gt
	 * @param {Object} other UINT32
	 * @return {Boolean}
	 */
	UINT32.prototype.greaterThan = UINT32.prototype.gt = function (other) {
		if (this._high > other._high) return true
		if (this._high < other._high) return false
		return this._low > other._low
	}

	/**
	 * Less than (strict)
	 * @method lt
	 * @param {Object} other UINT32
	 * @return {Boolean}
	 */
	UINT32.prototype.lessThan = UINT32.prototype.lt = function (other) {
		if (this._high < other._high) return true
		if (this._high > other._high) return false
		return this._low < other._low
	}

	/**
	 * Bitwise OR
	 * @method or
	 * @param {Object} other UINT32
	 * @return ThisExpression
	 */
	UINT32.prototype.or = function (other) {
		this._low |= other._low
		this._high |= other._high

		return this
	}

	/**
	 * Bitwise AND
	 * @method and
	 * @param {Object} other UINT32
	 * @return ThisExpression
	 */
	UINT32.prototype.and = function (other) {
		this._low &= other._low
		this._high &= other._high

		return this
	}

	/**
	 * Bitwise NOT
	 * @method not
	 * @return ThisExpression
	 */
	UINT32.prototype.not = function() {
		this._low = ~this._low & 0xFFFF
		this._high = ~this._high & 0xFFFF

		return this
	}

	/**
	 * Bitwise XOR
	 * @method xor
	 * @param {Object} other UINT32
	 * @return ThisExpression
	 */
	UINT32.prototype.xor = function (other) {
		this._low ^= other._low
		this._high ^= other._high

		return this
	}

	/**
	 * Bitwise shift right
	 * @method shiftRight
	 * @param {Number} number of bits to shift
	 * @return ThisExpression
	 */
	UINT32.prototype.shiftRight = UINT32.prototype.shiftr = function (n) {
		if (n > 16) {
			this._low = this._high >> (n - 16)
			this._high = 0
		} else if (n == 16) {
			this._low = this._high
			this._high = 0
		} else {
			this._low = (this._low >> n) | ( (this._high << (16-n)) & 0xFFFF )
			this._high >>= n
		}

		return this
	}

	/**
	 * Bitwise shift left
	 * @method shiftLeft
	 * @param {Number} number of bits to shift
	 * @param {Boolean} allow overflow
	 * @return ThisExpression
	 */
	UINT32.prototype.shiftLeft = UINT32.prototype.shiftl = function (n, allowOverflow) {
		if (n > 16) {
			this._high = this._low << (n - 16)
			this._low = 0
			if (!allowOverflow) {
				this._high &= 0xFFFF
			}
		} else if (n == 16) {
			this._high = this._low
			this._low = 0
		} else {
			this._high = (this._high << n) | (this._low >> (16-n))
			this._low = (this._low << n) & 0xFFFF
			if (!allowOverflow) {
				// Overflow only allowed on the high bits...
				this._high &= 0xFFFF
			}
		}

		return this
	}

	/**
	 * Bitwise rotate left
	 * @method rotl
	 * @param {Number} number of bits to rotate
	 * @return ThisExpression
	 */
	UINT32.prototype.rotateLeft = UINT32.prototype.rotl = function (n) {
		var v = (this._high << 16) | this._low
		v = (v << n) | (v >>> (32 - n))
		this._low = v & 0xFFFF
		this._high = v >>> 16

		return this
	}

	/**
	 * Bitwise rotate right
	 * @method rotr
	 * @param {Number} number of bits to rotate
	 * @return ThisExpression
	 */
	UINT32.prototype.rotateRight = UINT32.prototype.rotr = function (n) {
		var v = (this._high << 16) | this._low
		v = (v >>> n) | (v << (32 - n))
		this._low = v & 0xFFFF
		this._high = v >>> 16

		return this
	}

	/**
	 * Clone the current _UINT32_
	 * @method clone
	 * @return {Object} cloned UINT32
	 */
	UINT32.prototype.clone = function () {
		return new UINT32(this._low, this._high)
	}

	if (true) {
		// AMD / RequireJS
		!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function () {
			return UINT32
		}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
	} else {}

})(this)


/***/ }),

/***/ 174:
/***/ (function(module, exports) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**
	C-like unsigned 64 bits integers in Javascript
	Copyright (C) 2013, Pierre Curto
	MIT license
 */
;(function (root) {

	// Local cache for typical radices
	var radixPowerCache = {
		16: UINT64( Math.pow(16, 5) )
	,	10: UINT64( Math.pow(10, 5) )
	,	2:  UINT64( Math.pow(2, 5) )
	}
	var radixCache = {
		16: UINT64(16)
	,	10: UINT64(10)
	,	2:  UINT64(2)
	}

	/**
	 *	Represents an unsigned 64 bits integer
	 * @constructor
	 * @param {Number} first low bits (8)
	 * @param {Number} second low bits (8)
	 * @param {Number} first high bits (8)
	 * @param {Number} second high bits (8)
	 * or
	 * @param {Number} low bits (32)
	 * @param {Number} high bits (32)
	 * or
	 * @param {String|Number} integer as a string 		 | integer as a number
	 * @param {Number|Undefined} radix (optional, default=10)
	 * @return 
	 */
	function UINT64 (a00, a16, a32, a48) {
		if ( !(this instanceof UINT64) )
			return new UINT64(a00, a16, a32, a48)

		this.remainder = null
		if (typeof a00 == 'string')
			return fromString.call(this, a00, a16)

		if (typeof a16 == 'undefined')
			return fromNumber.call(this, a00)

		fromBits.apply(this, arguments)
	}

	/**
	 * Set the current _UINT64_ object with its low and high bits
	 * @method fromBits
	 * @param {Number} first low bits (8)
	 * @param {Number} second low bits (8)
	 * @param {Number} first high bits (8)
	 * @param {Number} second high bits (8)
	 * or
	 * @param {Number} low bits (32)
	 * @param {Number} high bits (32)
	 * @return ThisExpression
	 */
	function fromBits (a00, a16, a32, a48) {
		if (typeof a32 == 'undefined') {
			this._a00 = a00 & 0xFFFF
			this._a16 = a00 >>> 16
			this._a32 = a16 & 0xFFFF
			this._a48 = a16 >>> 16
			return this
		}

		this._a00 = a00 | 0
		this._a16 = a16 | 0
		this._a32 = a32 | 0
		this._a48 = a48 | 0

		return this
	}
	UINT64.prototype.fromBits = fromBits

	/**
	 * Set the current _UINT64_ object from a number
	 * @method fromNumber
	 * @param {Number} number
	 * @return ThisExpression
	 */
	function fromNumber (value) {
		this._a00 = value & 0xFFFF
		this._a16 = value >>> 16
		this._a32 = 0
		this._a48 = 0

		return this
	}
	UINT64.prototype.fromNumber = fromNumber

	/**
	 * Set the current _UINT64_ object from a string
	 * @method fromString
	 * @param {String} integer as a string
	 * @param {Number} radix (optional, default=10)
	 * @return ThisExpression
	 */
	function fromString (s, radix) {
		radix = radix || 10

		this._a00 = 0
		this._a16 = 0
		this._a32 = 0
		this._a48 = 0

		/*
			In Javascript, bitwise operators only operate on the first 32 bits 
			of a number, even though parseInt() encodes numbers with a 53 bits 
			mantissa.
			Therefore UINT64(<Number>) can only work on 32 bits.
			The radix maximum value is 36 (as per ECMA specs) (26 letters + 10 digits)
			maximum input value is m = 32bits as 1 = 2^32 - 1
			So the maximum substring length n is:
			36^(n+1) - 1 = 2^32 - 1
			36^(n+1) = 2^32
			(n+1)ln(36) = 32ln(2)
			n = 32ln(2)/ln(36) - 1
			n = 5.189644915687692
			n = 5
		 */
		var radixUint = radixPowerCache[radix] || new UINT64( Math.pow(radix, 5) )

		for (var i = 0, len = s.length; i < len; i += 5) {
			var size = Math.min(5, len - i)
			var value = parseInt( s.slice(i, i + size), radix )
			this.multiply(
					size < 5
						? new UINT64( Math.pow(radix, size) )
						: radixUint
				)
				.add( new UINT64(value) )
		}

		return this
	}
	UINT64.prototype.fromString = fromString

	/**
	 * Convert this _UINT64_ to a number (last 32 bits are dropped)
	 * @method toNumber
	 * @return {Number} the converted UINT64
	 */
	UINT64.prototype.toNumber = function () {
		return (this._a16 * 65536) + this._a00
	}

	/**
	 * Convert this _UINT64_ to a string
	 * @method toString
	 * @param {Number} radix (optional, default=10)
	 * @return {String} the converted UINT64
	 */
	UINT64.prototype.toString = function (radix) {
		radix = radix || 10
		var radixUint = radixCache[radix] || new UINT64(radix)

		if ( !this.gt(radixUint) ) return this.toNumber().toString(radix)

		var self = this.clone()
		var res = new Array(64)
		for (var i = 63; i >= 0; i--) {
			self.div(radixUint)
			res[i] = self.remainder.toNumber().toString(radix)
			if ( !self.gt(radixUint) ) break
		}
		res[i-1] = self.toNumber().toString(radix)

		return res.join('')
	}

	/**
	 * Add two _UINT64_. The current _UINT64_ stores the result
	 * @method add
	 * @param {Object} other UINT64
	 * @return ThisExpression
	 */
	UINT64.prototype.add = function (other) {
		var a00 = this._a00 + other._a00

		var a16 = a00 >>> 16
		a16 += this._a16 + other._a16

		var a32 = a16 >>> 16
		a32 += this._a32 + other._a32

		var a48 = a32 >>> 16
		a48 += this._a48 + other._a48

		this._a00 = a00 & 0xFFFF
		this._a16 = a16 & 0xFFFF
		this._a32 = a32 & 0xFFFF
		this._a48 = a48 & 0xFFFF

		return this
	}

	/**
	 * Subtract two _UINT64_. The current _UINT64_ stores the result
	 * @method subtract
	 * @param {Object} other UINT64
	 * @return ThisExpression
	 */
	UINT64.prototype.subtract = function (other) {
		return this.add( other.clone().negate() )
	}

	/**
	 * Multiply two _UINT64_. The current _UINT64_ stores the result
	 * @method multiply
	 * @param {Object} other UINT64
	 * @return ThisExpression
	 */
	UINT64.prototype.multiply = function (other) {
		/*
			a = a00 + a16 + a32 + a48
			b = b00 + b16 + b32 + b48
			a*b = (a00 + a16 + a32 + a48)(b00 + b16 + b32 + b48)
				= a00b00 + a00b16 + a00b32 + a00b48
				+ a16b00 + a16b16 + a16b32 + a16b48
				+ a32b00 + a32b16 + a32b32 + a32b48
				+ a48b00 + a48b16 + a48b32 + a48b48

			a16b48, a32b32, a48b16, a48b32 and a48b48 overflow the 64 bits
			so it comes down to:
			a*b	= a00b00 + a00b16 + a00b32 + a00b48
				+ a16b00 + a16b16 + a16b32
				+ a32b00 + a32b16
				+ a48b00
				= a00b00
				+ a00b16 + a16b00
				+ a00b32 + a16b16 + a32b00
				+ a00b48 + a16b32 + a32b16 + a48b00
		 */
		var a00 = this._a00
		var a16 = this._a16
		var a32 = this._a32
		var a48 = this._a48
		var b00 = other._a00
		var b16 = other._a16
		var b32 = other._a32
		var b48 = other._a48

		var c00 = a00 * b00

		var c16 = c00 >>> 16
		c16 += a00 * b16
		var c32 = c16 >>> 16
		c16 &= 0xFFFF
		c16 += a16 * b00

		c32 += c16 >>> 16
		c32 += a00 * b32
		var c48 = c32 >>> 16
		c32 &= 0xFFFF
		c32 += a16 * b16
		c48 += c32 >>> 16
		c32 &= 0xFFFF
		c32 += a32 * b00

		c48 += c32 >>> 16
		c48 += a00 * b48
		c48 &= 0xFFFF
		c48 += a16 * b32
		c48 &= 0xFFFF
		c48 += a32 * b16
		c48 &= 0xFFFF
		c48 += a48 * b00

		this._a00 = c00 & 0xFFFF
		this._a16 = c16 & 0xFFFF
		this._a32 = c32 & 0xFFFF
		this._a48 = c48 & 0xFFFF

		return this
	}

	/**
	 * Divide two _UINT64_. The current _UINT64_ stores the result.
	 * The remainder is made available as the _remainder_ property on
	 * the _UINT64_ object. It can be null, meaning there are no remainder.
	 * @method div
	 * @param {Object} other UINT64
	 * @return ThisExpression
	 */
	UINT64.prototype.div = function (other) {
		if ( (other._a16 == 0) && (other._a32 == 0) && (other._a48 == 0) ) {
			if (other._a00 == 0) throw Error('division by zero')

			// other == 1: this
			if (other._a00 == 1) {
				this.remainder = new UINT64(0)
				return this
			}
		}

		// other > this: 0
		if ( other.gt(this) ) {
			this.remainder = this.clone()
			this._a00 = 0
			this._a16 = 0
			this._a32 = 0
			this._a48 = 0
			return this
		}
		// other == this: 1
		if ( this.eq(other) ) {
			this.remainder = new UINT64(0)
			this._a00 = 1
			this._a16 = 0
			this._a32 = 0
			this._a48 = 0
			return this
		}

		// Shift the divisor left until it is higher than the dividend
		var _other = other.clone()
		var i = -1
		while ( !this.lt(_other) ) {
			// High bit can overflow the default 16bits
			// Its ok since we right shift after this loop
			// The overflown bit must be kept though
			_other.shiftLeft(1, true)
			i++
		}

		// Set the remainder
		this.remainder = this.clone()
		// Initialize the current result to 0
		this._a00 = 0
		this._a16 = 0
		this._a32 = 0
		this._a48 = 0
		for (; i >= 0; i--) {
			_other.shiftRight(1)
			// If shifted divisor is smaller than the dividend
			// then subtract it from the dividend
			if ( !this.remainder.lt(_other) ) {
				this.remainder.subtract(_other)
				// Update the current result
				if (i >= 48) {
					this._a48 |= 1 << (i - 48)
				} else if (i >= 32) {
					this._a32 |= 1 << (i - 32)
				} else if (i >= 16) {
					this._a16 |= 1 << (i - 16)
				} else {
					this._a00 |= 1 << i
				}
			}
		}

		return this
	}

	/**
	 * Negate the current _UINT64_
	 * @method negate
	 * @return ThisExpression
	 */
	UINT64.prototype.negate = function () {
		var v = ( ~this._a00 & 0xFFFF ) + 1
		this._a00 = v & 0xFFFF
		v = (~this._a16 & 0xFFFF) + (v >>> 16)
		this._a16 = v & 0xFFFF
		v = (~this._a32 & 0xFFFF) + (v >>> 16)
		this._a32 = v & 0xFFFF
		this._a48 = (~this._a48 + (v >>> 16)) & 0xFFFF

		return this
	}

	/**

	 * @method eq
	 * @param {Object} other UINT64
	 * @return {Boolean}
	 */
	UINT64.prototype.equals = UINT64.prototype.eq = function (other) {
		return (this._a48 == other._a48) && (this._a00 == other._a00)
			 && (this._a32 == other._a32) && (this._a16 == other._a16)
	}

	/**
	 * Greater than (strict)
	 * @method gt
	 * @param {Object} other UINT64
	 * @return {Boolean}
	 */
	UINT64.prototype.greaterThan = UINT64.prototype.gt = function (other) {
		if (this._a48 > other._a48) return true
		if (this._a48 < other._a48) return false
		if (this._a32 > other._a32) return true
		if (this._a32 < other._a32) return false
		if (this._a16 > other._a16) return true
		if (this._a16 < other._a16) return false
		return this._a00 > other._a00
	}

	/**
	 * Less than (strict)
	 * @method lt
	 * @param {Object} other UINT64
	 * @return {Boolean}
	 */
	UINT64.prototype.lessThan = UINT64.prototype.lt = function (other) {
		if (this._a48 < other._a48) return true
		if (this._a48 > other._a48) return false
		if (this._a32 < other._a32) return true
		if (this._a32 > other._a32) return false
		if (this._a16 < other._a16) return true
		if (this._a16 > other._a16) return false
		return this._a00 < other._a00
	}

	/**
	 * Bitwise OR
	 * @method or
	 * @param {Object} other UINT64
	 * @return ThisExpression
	 */
	UINT64.prototype.or = function (other) {
		this._a00 |= other._a00
		this._a16 |= other._a16
		this._a32 |= other._a32
		this._a48 |= other._a48

		return this
	}

	/**
	 * Bitwise AND
	 * @method and
	 * @param {Object} other UINT64
	 * @return ThisExpression
	 */
	UINT64.prototype.and = function (other) {
		this._a00 &= other._a00
		this._a16 &= other._a16
		this._a32 &= other._a32
		this._a48 &= other._a48

		return this
	}

	/**
	 * Bitwise XOR
	 * @method xor
	 * @param {Object} other UINT64
	 * @return ThisExpression
	 */
	UINT64.prototype.xor = function (other) {
		this._a00 ^= other._a00
		this._a16 ^= other._a16
		this._a32 ^= other._a32
		this._a48 ^= other._a48

		return this
	}

	/**
	 * Bitwise NOT
	 * @method not
	 * @return ThisExpression
	 */
	UINT64.prototype.not = function() {
		this._a00 = ~this._a00 & 0xFFFF
		this._a16 = ~this._a16 & 0xFFFF
		this._a32 = ~this._a32 & 0xFFFF
		this._a48 = ~this._a48 & 0xFFFF

		return this
	}

	/**
	 * Bitwise shift right
	 * @method shiftRight
	 * @param {Number} number of bits to shift
	 * @return ThisExpression
	 */
	UINT64.prototype.shiftRight = UINT64.prototype.shiftr = function (n) {
		n %= 64
		if (n >= 48) {
			this._a00 = this._a48 >> (n - 48)
			this._a16 = 0
			this._a32 = 0
			this._a48 = 0
		} else if (n >= 32) {
			n -= 32
			this._a00 = ( (this._a32 >> n) | (this._a48 << (16-n)) ) & 0xFFFF
			this._a16 = (this._a48 >> n) & 0xFFFF
			this._a32 = 0
			this._a48 = 0
		} else if (n >= 16) {
			n -= 16
			this._a00 = ( (this._a16 >> n) | (this._a32 << (16-n)) ) & 0xFFFF
			this._a16 = ( (this._a32 >> n) | (this._a48 << (16-n)) ) & 0xFFFF
			this._a32 = (this._a48 >> n) & 0xFFFF
			this._a48 = 0
		} else {
			this._a00 = ( (this._a00 >> n) | (this._a16 << (16-n)) ) & 0xFFFF
			this._a16 = ( (this._a16 >> n) | (this._a32 << (16-n)) ) & 0xFFFF
			this._a32 = ( (this._a32 >> n) | (this._a48 << (16-n)) ) & 0xFFFF
			this._a48 = (this._a48 >> n) & 0xFFFF
		}

		return this
	}

	/**
	 * Bitwise shift left
	 * @method shiftLeft
	 * @param {Number} number of bits to shift
	 * @param {Boolean} allow overflow
	 * @return ThisExpression
	 */
	UINT64.prototype.shiftLeft = UINT64.prototype.shiftl = function (n, allowOverflow) {
		n %= 64
		if (n >= 48) {
			this._a48 = this._a00 << (n - 48)
			this._a32 = 0
			this._a16 = 0
			this._a00 = 0
		} else if (n >= 32) {
			n -= 32
			this._a48 = (this._a16 << n) | (this._a00 >> (16-n))
			this._a32 = (this._a00 << n) & 0xFFFF
			this._a16 = 0
			this._a00 = 0
		} else if (n >= 16) {
			n -= 16
			this._a48 = (this._a32 << n) | (this._a16 >> (16-n))
			this._a32 = ( (this._a16 << n) | (this._a00 >> (16-n)) ) & 0xFFFF
			this._a16 = (this._a00 << n) & 0xFFFF
			this._a00 = 0
		} else {
			this._a48 = (this._a48 << n) | (this._a32 >> (16-n))
			this._a32 = ( (this._a32 << n) | (this._a16 >> (16-n)) ) & 0xFFFF
			this._a16 = ( (this._a16 << n) | (this._a00 >> (16-n)) ) & 0xFFFF
			this._a00 = (this._a00 << n) & 0xFFFF
		}
		if (!allowOverflow) {
			this._a48 &= 0xFFFF
		}

		return this
	}

	/**
	 * Bitwise rotate left
	 * @method rotl
	 * @param {Number} number of bits to rotate
	 * @return ThisExpression
	 */
	UINT64.prototype.rotateLeft = UINT64.prototype.rotl = function (n) {
		n %= 64
		if (n == 0) return this
		if (n >= 32) {
			// A.B.C.D
			// B.C.D.A rotl(16)
			// C.D.A.B rotl(32)
			var v = this._a00
			this._a00 = this._a32
			this._a32 = v
			v = this._a48
			this._a48 = this._a16
			this._a16 = v
			if (n == 32) return this
			n -= 32
		}

		var high = (this._a48 << 16) | this._a32
		var low = (this._a16 << 16) | this._a00

		var _high = (high << n) | (low >>> (32 - n))
		var _low = (low << n) | (high >>> (32 - n))

		this._a00 = _low & 0xFFFF
		this._a16 = _low >>> 16
		this._a32 = _high & 0xFFFF
		this._a48 = _high >>> 16

		return this
	}

	/**
	 * Bitwise rotate right
	 * @method rotr
	 * @param {Number} number of bits to rotate
	 * @return ThisExpression
	 */
	UINT64.prototype.rotateRight = UINT64.prototype.rotr = function (n) {
		n %= 64
		if (n == 0) return this
		if (n >= 32) {
			// A.B.C.D
			// D.A.B.C rotr(16)
			// C.D.A.B rotr(32)
			var v = this._a00
			this._a00 = this._a32
			this._a32 = v
			v = this._a48
			this._a48 = this._a16
			this._a16 = v
			if (n == 32) return this
			n -= 32
		}

		var high = (this._a48 << 16) | this._a32
		var low = (this._a16 << 16) | this._a00

		var _high = (high >>> n) | (low << (32 - n))
		var _low = (low >>> n) | (high << (32 - n))

		this._a00 = _low & 0xFFFF
		this._a16 = _low >>> 16
		this._a32 = _high & 0xFFFF
		this._a48 = _high >>> 16

		return this
	}

	/**
	 * Clone the current _UINT64_
	 * @method clone
	 * @return {Object} cloned UINT64
	 */
	UINT64.prototype.clone = function () {
		return new UINT64(this._a00, this._a16, this._a32, this._a48)
	}

	if (true) {
		// AMD / RequireJS
		!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function () {
			return UINT64
		}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
	} else {}

})(this)


/***/ }),

/***/ 5549:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.decrypt = exports.decryptWithSharedKey = exports.encrypt = exports.encryptWithSharedKey = void 0;
const iso_crypto_1 = __webpack_require__(9071);
const enc_utils_1 = __webpack_require__(9561);
const shared_1 = __webpack_require__(7);
function getEciesKeys(sharedKey) {
    return __awaiter(this, void 0, void 0, function* () {
        const hash = yield iso_crypto_1.sha512(sharedKey);
        return { encryptionKey: shared_1.getEncryptionKey(hash), macKey: shared_1.getMacKey(hash) };
    });
}
function encryptWithSharedKey(msg, sharedKey, publicKey, iv = iso_crypto_1.randomBytes(iso_crypto_1.IV_LENGTH)) {
    return __awaiter(this, void 0, void 0, function* () {
        const { encryptionKey, macKey } = yield getEciesKeys(sharedKey);
        const ciphertext = yield iso_crypto_1.aesCbcEncrypt(iv, encryptionKey, msg);
        const dataToMac = enc_utils_1.concatArrays(iv, publicKey, ciphertext);
        const mac = yield iso_crypto_1.hmacSha256Sign(macKey, dataToMac);
        return shared_1.serialize({ iv, publicKey, ciphertext, mac });
    });
}
exports.encryptWithSharedKey = encryptWithSharedKey;
function encrypt(msg, receiverPublicKey, opts) {
    return __awaiter(this, void 0, void 0, function* () {
        const { publicKey, privateKey } = shared_1.getSenderKeyPair(opts);
        const sharedKey = shared_1.getSharedKey(privateKey, receiverPublicKey);
        return encryptWithSharedKey(msg, sharedKey, publicKey, opts === null || opts === void 0 ? void 0 : opts.iv);
    });
}
exports.encrypt = encrypt;
function decryptWithSharedKey(encrypted, sharedKey) {
    return __awaiter(this, void 0, void 0, function* () {
        const { iv, publicKey, mac, ciphertext } = shared_1.deserialize(encrypted);
        const { encryptionKey, macKey } = yield getEciesKeys(sharedKey);
        const dataToMac = enc_utils_1.concatArrays(iv, publicKey, ciphertext);
        const macTest = yield iso_crypto_1.hmacSha256Verify(macKey, dataToMac, mac);
        iso_crypto_1.assert(macTest, iso_crypto_1.ERROR_BAD_MAC);
        const msg = yield iso_crypto_1.aesCbcDecrypt(iv, encryptionKey, ciphertext);
        return msg;
    });
}
exports.decryptWithSharedKey = decryptWithSharedKey;
function decrypt(encrypted, privateKey) {
    return __awaiter(this, void 0, void 0, function* () {
        const { publicKey } = shared_1.deserialize(encrypted);
        const sharedKey = shared_1.getSharedKey(privateKey, publicKey);
        return decryptWithSharedKey(encrypted, sharedKey);
    });
}
exports.decrypt = decrypt;
//# sourceMappingURL=async.js.map

/***/ }),

/***/ 3453:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !exports.hasOwnProperty(p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__webpack_require__(5549), exports);
__exportStar(__webpack_require__(1710), exports);
__exportStar(__webpack_require__(7), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 7:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.deserialize = exports.serialize = exports.getMacKey = exports.getEncryptionKey = exports.getSharedKey = exports.getSenderKeyPair = exports.generateKeyPair = exports.generatePnrgFromEntropy = exports.derive = void 0;
const x25519 = __importStar(__webpack_require__(774));
const enc_utils_1 = __webpack_require__(9561);
const iso_crypto_1 = __webpack_require__(9071);
function derive(privateKey, publicKey) {
    return x25519.sharedKey(privateKey, publicKey);
}
exports.derive = derive;
function generatePnrgFromEntropy(entropy) {
    return {
        isAvailable: true,
        randomBytes: () => entropy,
    };
}
exports.generatePnrgFromEntropy = generatePnrgFromEntropy;
function generateKeyPair(entropy) {
    const prng = typeof entropy !== 'undefined'
        ? generatePnrgFromEntropy(entropy)
        : undefined;
    const keyPair = x25519.generateKeyPair(prng);
    return {
        publicKey: keyPair.publicKey,
        privateKey: keyPair.secretKey,
    };
}
exports.generateKeyPair = generateKeyPair;
function getSenderKeyPair(opts) {
    const keyPair = (opts === null || opts === void 0 ? void 0 : opts.sender) || generateKeyPair();
    return {
        privateKey: keyPair.privateKey,
        publicKey: keyPair.publicKey,
    };
}
exports.getSenderKeyPair = getSenderKeyPair;
function getSharedKey(privateKey, publicKey) {
    return derive(privateKey, publicKey);
}
exports.getSharedKey = getSharedKey;
function getEncryptionKey(hash) {
    return new Uint8Array(hash.slice(iso_crypto_1.LENGTH_0, iso_crypto_1.KEY_LENGTH));
}
exports.getEncryptionKey = getEncryptionKey;
function getMacKey(hash) {
    return new Uint8Array(hash.slice(iso_crypto_1.KEY_LENGTH));
}
exports.getMacKey = getMacKey;
function serialize(opts) {
    return enc_utils_1.concatArrays(opts.iv, opts.publicKey, opts.mac, opts.ciphertext);
}
exports.serialize = serialize;
function deserialize(arr) {
    const slice0 = iso_crypto_1.LENGTH_0;
    const slice1 = slice0 + iso_crypto_1.IV_LENGTH;
    const slice2 = slice1 + iso_crypto_1.KEY_LENGTH;
    const slice3 = slice2 + iso_crypto_1.MAC_LENGTH;
    const slice4 = arr.length;
    return {
        iv: arr.slice(slice0, slice1),
        publicKey: arr.slice(slice1, slice2),
        mac: arr.slice(slice2, slice3),
        ciphertext: arr.slice(slice3, slice4),
    };
}
exports.deserialize = deserialize;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 1710:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.decryptSync = exports.decryptWithSharedKeySync = exports.encryptSync = exports.encryptWithSharedKeySync = void 0;
const iso_crypto_1 = __webpack_require__(9071);
const enc_utils_1 = __webpack_require__(9561);
const shared_1 = __webpack_require__(7);
function getEciesKeysSync(sharedKey) {
    const hash = iso_crypto_1.sha512Sync(sharedKey);
    return { encryptionKey: shared_1.getEncryptionKey(hash), macKey: shared_1.getMacKey(hash) };
}
function encryptWithSharedKeySync(msg, sharedKey, publicKey, iv = iso_crypto_1.randomBytes(iso_crypto_1.IV_LENGTH)) {
    const { encryptionKey, macKey } = getEciesKeysSync(sharedKey);
    const ciphertext = iso_crypto_1.aesCbcEncryptSync(iv, encryptionKey, msg);
    const dataToMac = enc_utils_1.concatArrays(iv, publicKey, ciphertext);
    const mac = iso_crypto_1.hmacSha256SignSync(macKey, dataToMac);
    return shared_1.serialize({ iv, publicKey, ciphertext, mac });
}
exports.encryptWithSharedKeySync = encryptWithSharedKeySync;
function encryptSync(msg, receiverPublicKey, opts) {
    const { publicKey, privateKey } = shared_1.getSenderKeyPair(opts);
    const sharedKey = shared_1.getSharedKey(privateKey, receiverPublicKey);
    return encryptWithSharedKeySync(msg, sharedKey, publicKey, opts === null || opts === void 0 ? void 0 : opts.iv);
}
exports.encryptSync = encryptSync;
function decryptWithSharedKeySync(encrypted, sharedKey) {
    const { iv, publicKey, mac, ciphertext } = shared_1.deserialize(encrypted);
    const { encryptionKey, macKey } = getEciesKeysSync(sharedKey);
    const dataToMac = enc_utils_1.concatArrays(iv, publicKey, ciphertext);
    const macTest = iso_crypto_1.hmacSha256VerifySync(macKey, dataToMac, mac);
    iso_crypto_1.assert(macTest, iso_crypto_1.ERROR_BAD_MAC);
    const msg = iso_crypto_1.aesCbcDecryptSync(iv, encryptionKey, ciphertext);
    return msg;
}
exports.decryptWithSharedKeySync = decryptWithSharedKeySync;
function decryptSync(encrypted, privateKey) {
    const { publicKey } = shared_1.deserialize(encrypted);
    const sharedKey = shared_1.getSharedKey(privateKey, publicKey);
    return decryptWithSharedKeySync(encrypted, sharedKey);
}
exports.decryptSync = decryptSync;
//# sourceMappingURL=sync.js.map

/***/ }),

/***/ 9625:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !exports.hasOwnProperty(p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__webpack_require__(9071), exports);
__exportStar(__webpack_require__(3453), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 5925:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

/*
MIT License

Copyright (c) 2019 Cyril Dever

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g = Object.create((typeof Iterator === "function" ? Iterator : Object).prototype);
    return g.next = verb(0), g["throw"] = verb(1), g["return"] = verb(2), typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.decrypt = exports.encrypt = exports.derive = exports.verify = exports.sign = exports.getPublic = exports.kdf = void 0;
/**
 * Browser ecies-geth implementation.
 * This is based off the `eccrypto` JS module.
 */
var elliptic_1 = __webpack_require__(6729);
/* eslint-disable @typescript-eslint/unbound-method */
var ec = new elliptic_1.ec('secp256k1');
/* eslint-disable @typescript-eslint/strict-boolean-expressions */
var crypto = window.crypto || window.msCrypto; // eslint-disable-line @typescript-eslint/no-non-null-assertion
var subtle = crypto.subtle || crypto.webkitSubtle;
/* eslint-enable @typescript-eslint/strict-boolean-expressions */
if (subtle === undefined || crypto === undefined) {
    throw new Error('crypto and/or subtle api unavailable');
}
// Use the browser RNG
var randomBytes = function (size) {
    return crypto.getRandomValues(Buffer.alloc(size));
};
// Get the browser SHA256 implementation
var sha256 = function (msg) {
    return subtle.digest({ name: 'SHA-256' }, msg).then(Buffer.from);
};
// The KDF as implemented in Parity mimics Geth's implementation
var kdf = function (secret, outputLength) {
    var ctr = 1;
    var written = 0;
    var willBeResult = Promise.resolve(Buffer.from(''));
    var _loop_1 = function () {
        var ctrs = Buffer.from([ctr >> 24, ctr >> 16, ctr >> 8, ctr]);
        var willBeHashResult = sha256(Buffer.concat([ctrs, secret]));
        willBeResult = willBeResult.then(function (result) { return willBeHashResult.then(function (hashResult) {
            return Buffer.concat([result, hashResult]);
        }); });
        written += 32;
        ctr += 1;
    };
    while (written < outputLength) {
        _loop_1();
    }
    return willBeResult;
};
exports.kdf = kdf;
var aesCtrEncrypt = function (counter, key, data) {
    return subtle
        .importKey('raw', key, 'AES-CTR', false, ['encrypt'])
        .then(function (cryptoKey) {
        return subtle.encrypt({ name: 'AES-CTR', counter: counter, length: 128 }, cryptoKey, data);
    }).then(Buffer.from);
};
var aesCtrDecrypt = function (counter, key, data) {
    return subtle
        .importKey('raw', key, 'AES-CTR', false, ['decrypt'])
        .then(function (cryptoKey) {
        return subtle.decrypt({ name: 'AES-CTR', counter: counter, length: 128 }, cryptoKey, data);
    }).then(Buffer.from);
};
var hmacSha256Sign = function (key, msg) {
    var algorithm = { name: 'HMAC', hash: { name: 'SHA-256' } };
    return subtle.importKey('raw', key, algorithm, false, ['sign'])
        .then(function (cryptoKey) { return subtle.sign(algorithm, cryptoKey, msg); })
        .then(Buffer.from);
};
var hmacSha256Verify = function (key, msg, sig) {
    var algorithm = { name: 'HMAC', hash: { name: 'SHA-256' } };
    var keyp = subtle.importKey('raw', key, algorithm, false, ['verify']);
    return keyp.then(function (cryptoKey) { return subtle.verify(algorithm, cryptoKey, sig, msg); });
};
/**
 * Compute the public key for a given private key.
 *
 * @param {Buffer} privateKey - A 32-byte private key
 * @return {Promise<Buffer>} A promise that resolve with the 65-byte public key or reject on wrong private key.
 * @function
 */
var getPublic = function (privateKey) { return new Promise(function (resolve, reject) {
    if (privateKey.length !== 32) {
        reject(new Error('Private key should be 32 bytes long'));
    }
    else {
        resolve(Buffer.from(ec.keyFromPrivate(privateKey).getPublic('array')));
    }
}); };
exports.getPublic = getPublic;
/**
 * Create an ECDSA signature.
 *
 * @param {Buffer} privateKey - A 32-byte private key
 * @param {Buffer} msg - The message being signed, no more than 32 bytes
 * @return {Promise.<Buffer>} A promise that resolves with the signature and rejects on bad key or message
 */
var sign = function (privateKey, msg) { return new Promise(function (resolve, reject) {
    if (privateKey.length !== 32) {
        reject(new Error('Private key should be 32 bytes long'));
    }
    else if (msg.length <= 0) {
        reject(new Error('Message should not be empty'));
    }
    else if (msg.length > 32) {
        reject(new Error('Message is too long (max 32 bytes)'));
    }
    else {
        resolve(Buffer.from(ec.sign(msg, privateKey, { canonical: true }).toDER('hex'), 'hex'));
    }
}); };
exports.sign = sign;
/**
 * Verify an ECDSA signature.
 *
 * @param {Buffer} publicKey - A 65-byte public key
 * @param {Buffer} msg - The message being verified
 * @param {Buffer} sig - The signature
 * @return {Promise.<true>} A promise that resolves on correct signature and rejects on bad key or signature
 */
var verify = function (publicKey, msg, sig) { return new Promise(function (resolve, reject) {
    try {
        if (publicKey.length !== 65 || publicKey[0] !== 4) {
            reject(new Error('Public key should 65 bytes long'));
        }
        else if (msg.length <= 0) {
            reject(new Error('Message should not be empty'));
        }
        else if (msg.length > 32) {
            reject(new Error('Message is too long (max 32 bytes)'));
        }
        else if (!ec.verify(msg, sig.toString('hex'), publicKey, 'hex')) { // eslint-disable-line @typescript-eslint/no-unsafe-argument
            reject(new Error('Bad signature'));
        }
        else {
            resolve(true);
        }
    }
    catch (_) { // eslint-disable-line @typescript-eslint/no-unused-vars
        reject(new Error('Invalid arguments'));
    }
}); };
exports.verify = verify;
/**
 * Derive shared secret for given private and public keys.
 *
 * @param {Buffer} privateKey - Sender's private key (32 bytes)
 * @param {Buffer} publicKey - Recipient's public key (65 bytes)
 * @return {Promise.<Buffer>} A promise that resolves with the derived shared secret (Px, 32 bytes) and rejects on bad key
 */
var derive = function (privateKeyA, publicKeyB) { return new Promise(function (resolve, reject) {
    if (privateKeyA.length !== 32) {
        reject(new Error("Bad private key, it should be 32 bytes but it's actually ".concat(privateKeyA.length, " bytes long")));
    }
    else if (publicKeyB.length !== 65) {
        reject(new Error("Bad public key, it should be 65 bytes but it's actually ".concat(publicKeyB.length, " bytes long")));
    }
    else if (publicKeyB[0] !== 4) {
        reject(new Error('Bad public key, a valid public key would begin with 4'));
    }
    else {
        var keyA = ec.keyFromPrivate(privateKeyA);
        var keyB = ec.keyFromPublic(publicKeyB);
        var Px = keyA.derive(keyB.getPublic()); // BN instance
        resolve(pad32(Buffer.from(Px.toArray())));
    }
}); };
exports.derive = derive;
/**
 * Encrypt message for given recepient's public key.
 *
 * @param {Buffer} publicKeyTo - Recipient's public key (65 bytes)
 * @param {Buffer} msg - The message being encrypted
 * @param {?{?iv: Buffer, ?ephemPrivateKey: Buffer}} opts - You may also specify initialization vector (16 bytes) and ephemeral private key (32 bytes) to get deterministic results.
 * @return {Promise.<Buffer>} - A promise that resolves with the ECIES structure serialized
 */
var encrypt = function (publicKeyTo, msg, opts) { return __awaiter(void 0, void 0, void 0, function () {
    var ephemPrivateKey;
    return __generator(this, function (_a) {
        opts = opts || {};
        ephemPrivateKey = opts.ephemPrivateKey || randomBytes(32);
        return [2 /*return*/, (0, exports.derive)(ephemPrivateKey, publicKeyTo)
                .then(function (sharedPx) { return (0, exports.kdf)(sharedPx, 32); })
                .then(function (hash) { return __awaiter(void 0, void 0, void 0, function () {
                var iv, encryptionKey;
                return __generator(this, function (_a) {
                    iv = opts.iv || randomBytes(16);
                    encryptionKey = hash.slice(0, 16);
                    return [2 /*return*/, aesCtrEncrypt(iv, encryptionKey, msg)
                            .then(function (cipherText) { return Buffer.concat([iv, cipherText]); })
                            .then(function (ivCipherText) {
                            return sha256(hash.slice(16))
                                .then(function (macKey) { return hmacSha256Sign(macKey, ivCipherText); })
                                .then(function (HMAC) {
                                return (0, exports.getPublic)(ephemPrivateKey)
                                    .then(function (ephemPublicKey) { return Buffer.concat([ephemPublicKey, ivCipherText, HMAC]); });
                            });
                        })];
                });
            }); })];
    });
}); };
exports.encrypt = encrypt;
var metaLength = 1 + 64 + 16 + 32;
/**
 * Decrypt message using given private key.
 *
 * @param {Buffer} privateKey - A 32-byte private key of recepient of the message
 * @param {Ecies} encrypted - ECIES serialized structure (result of ECIES encryption)
 * @return {Promise.<Buffer>} - A promise that resolves with the plaintext on successful decryption and rejects on failure
 */
var decrypt = function (privateKey, encrypted) { return new Promise(function (resolve, reject) {
    if (encrypted.length <= metaLength) {
        reject(new Error("Invalid Ciphertext. Data is too small. It should ba at least ".concat(metaLength, " bytes")));
    }
    else if (encrypted[0] !== 4) {
        reject(new Error("Not a valid ciphertext. It should begin with 4 but actually begin with ".concat(encrypted[0])));
    }
    else {
        // deserialize
        var ephemPublicKey = encrypted.slice(0, 65);
        var cipherTextLength = encrypted.length - metaLength;
        var iv_1 = encrypted.slice(65, 65 + 16);
        var cipherAndIv_1 = encrypted.slice(65, 65 + 16 + cipherTextLength);
        var ciphertext_1 = cipherAndIv_1.slice(16);
        var msgMac_1 = encrypted.slice(65 + 16 + cipherTextLength);
        // check HMAC
        resolve((0, exports.derive)(privateKey, ephemPublicKey)
            .then(function (px) { return (0, exports.kdf)(px, 32); })
            .then(function (hash) { return sha256(hash.slice(16)).then(function (macKey) { return [hash.slice(0, 16), macKey]; }); })
            .then(function (_a) {
            var encryptionKey = _a[0], macKey = _a[1];
            return hmacSha256Verify(macKey, cipherAndIv_1, msgMac_1)
                .then(function (isHmacGood) { return !isHmacGood
                ? Promise.reject(new Error('Incorrect MAC'))
                : aesCtrDecrypt(iv_1, encryptionKey, ciphertext_1); });
        }).then(Buffer.from));
    }
}); };
exports.decrypt = decrypt;
var pad32 = function (msg) {
    if (msg.length < 32) {
        var buff = Buffer.alloc(32).fill(0);
        msg.copy(buff, 32 - msg.length);
        return buff;
    }
    else
        return msg;
};
__exportStar(__webpack_require__(1824), exports);
/* eslint-enable @typescript-eslint/unbound-method */ 
//# sourceMappingURL=browser.js.map

/***/ }),

/***/ 341:
/***/ ((module, exports, __webpack_require__) => {

"use strict";

/*
MIT License

Copyright (c) 2019 Cyril Dever

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/
Object.defineProperty(exports, "__esModule", ({ value: true }));
// try to use secp256k1, fallback to browser implementation
try {
    module.exports = __webpack_require__(4029); // eslint-disable-line @typescript-eslint/no-unsafe-assignment,@typescript-eslint/no-require-imports
}
catch (e) {
    if (typeof process !== 'undefined' && process.env.ECCRYPTO_NO_FALLBACK) { // eslint-disable-line @typescript-eslint/strict-boolean-expressions
        throw e;
    }
    else {
        module.exports = __webpack_require__(5925); // eslint-disable-line @typescript-eslint/no-unsafe-assignment,@typescript-eslint/no-require-imports
    }
}
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 1824:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/*
MIT License

Copyright (c) 2021 Cyril Dever

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.KeyPath = exports.Path = void 0;
var Path = function (account, scope, keyIndex) { return ({
    account: account,
    scope: scope,
    keyIndex: keyIndex
}); };
exports.Path = Path;
var parse = function (value) {
    var parts = value.split('/');
    if (parts.length !== 4 || parts[0] !== 'm') {
        throw new Error('invalid value for path');
    }
    return (0, exports.Path)(parts[1], parts[2], parts[3]);
};
var next = function (value, increment) {
    var parsed = parse(value);
    var index = parseInt(parsed.keyIndex);
    var actualIncrement = increment !== undefined && increment > 1 ? increment : 1;
    var newValue = 'm/' + parsed.account + '/' + parsed.scope + '/' + (index + actualIncrement).toString(10);
    return (0, exports.KeyPath)(newValue);
};
var setValue = function (value) {
    var parsed = parse(value);
    if (parseInt(parsed.account) > Math.pow(2, 16) - 1 || parseInt(parsed.scope) > Math.pow(2, 16) - 1 || parseInt(parsed.keyIndex) > Math.pow(2, 21) - 1) {
        throw new Error('invalid path with value exceeding its limits');
    }
    return value;
};
var valueOf = function (value) { return function () {
    var parsed = parse(value);
    return parseInt(parsed.account) * Math.pow(2, 37) + parseInt(parsed.scope) * Math.pow(2, 21) + parseInt(parsed.keyIndex);
}; };
/**
 * Build an immutable key path
 *
 * @param {string} value - The path string
 * @returns an instance of KeyPath
 * @throws invalid value for path
 * @throws invalid path with value exceeding its limits
 */
var KeyPath = function (value) { return ({
    value: setValue(value),
    parse: function () { return parse(value); },
    next: function (increment) { return next(value, increment); },
    valueOf: valueOf(value)
}); };
exports.KeyPath = KeyPath;
//# sourceMappingURL=model.js.map

/***/ }),

/***/ 4029:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

/*
MIT License

Copyright (c) 2019 Cyril Dever

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g = Object.create((typeof Iterator === "function" ? Iterator : Object).prototype);
    return g.next = verb(0), g["throw"] = verb(1), g["return"] = verb(2), typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.decrypt = exports.encrypt = exports.derive = exports.verify = exports.sign = exports.getPublic = exports.kdf = void 0;
/**
 * Note: This module is based off the original eccrypto module.
 */
var crypto_1 = __webpack_require__(6982);
var elliptic_1 = __webpack_require__(6729);
var secp256k1_1 = __importDefault(__webpack_require__(560));
var ec = new elliptic_1.ec('secp256k1');
var sha256 = function (msg) {
    return (0, crypto_1.createHash)('sha256').update(msg).digest();
};
var hmacSha256 = function (key, msg) {
    return (0, crypto_1.createHmac)('sha256', key).update(msg).digest();
};
var aes128CtrEncrypt = function (iv, key, plaintext) {
    var cipher = (0, crypto_1.createCipheriv)('aes-128-ctr', key, iv);
    var firstChunk = cipher.update(plaintext);
    var secondChunk = cipher.final();
    return Buffer.concat([iv, firstChunk, secondChunk]);
};
var aes128CtrDecrypt = function (iv, key, ciphertext) {
    var cipher = (0, crypto_1.createDecipheriv)('aes-128-ctr', key, iv);
    var firstChunk = cipher.update(ciphertext);
    var secondChunk = cipher.final();
    return Buffer.concat([firstChunk, secondChunk]);
};
// Compare two buffers in constant time to prevent timing attacks
var equalConstTime = function (b1, b2) {
    if (b1.length !== b2.length) {
        return false;
    }
    var res = 0;
    for (var i = 0; i < b1.length; i++) { // eslint-disable-line no-loops/no-loops
        res |= b1[i] ^ b2[i];
    }
    return res === 0;
};
var pad32 = function (msg) {
    if (msg.length < 32) {
        var buff = Buffer.alloc(32).fill(0);
        msg.copy(buff, 32 - msg.length);
        return buff;
    }
    else
        return msg;
};
// The KDF as implemented in Parity mimics Geth's implementation
var kdf = function (secret, outputLength) { return new Promise(function (resolve) {
    var ctr = 1;
    var written = 0;
    var result = Buffer.from('');
    while (written < outputLength) { // eslint-disable-line no-loops/no-loops
        var ctrs = Buffer.from([ctr >> 24, ctr >> 16, ctr >> 8, ctr]);
        var hashResult = sha256(Buffer.concat([ctrs, secret]));
        result = Buffer.concat([result, hashResult]);
        written += 32;
        ctr += 1;
    }
    resolve(result);
}); };
exports.kdf = kdf;
/**
 * Compute the public key for a given private key.
 *
 * @param {Buffer} privateKey - A 32-byte private key
 * @return {Promise<Buffer>} A promise that resolve with the 65-byte public key or reject on wrong private key.
 * @function
 */
var getPublic = function (privateKey) { return new Promise(function (resolve, reject) {
    return privateKey.length !== 32
        ? reject(new Error('Private key should be 32 bytes long'))
        : resolve(Buffer.from(secp256k1_1.default.publicKeyConvert(secp256k1_1.default.publicKeyCreate(privateKey), false)));
} // See https://github.com/wanderer/secp256k1-node/issues/46
); };
exports.getPublic = getPublic;
/**
 * Create an ECDSA signature.
 *
 * @param {Buffer} privateKey - A 32-byte private key
 * @param {Buffer} msg - The message being signed, no more than 32 bytes
 * @return {Promise.<Buffer>} A promise that resolves with the signature and rejects on bad key or message.
 */
var sign = function (privateKey, msg) { return new Promise(function (resolve, reject) {
    if (privateKey.length !== 32) {
        reject(new Error('Private key should be 32 bytes long'));
    }
    else if (msg.length <= 0) {
        reject(new Error('Message should not be empty'));
    }
    else if (msg.length > 32) {
        reject(new Error('Message is too long (max 32 bytes)'));
    }
    else {
        var padded = pad32(msg);
        var signed = secp256k1_1.default.ecdsaSign(padded, privateKey).signature;
        resolve(Buffer.from(secp256k1_1.default.signatureExport(signed)));
    }
}); };
exports.sign = sign;
/**
 * Verify an ECDSA signature.
 *
 * @param {Buffer} publicKey - A 65-byte public key
 * @param {Buffer} msg - The message being verified
 * @param {Buffer} sig - The signature
 * @return {Promise.<true>} A promise that resolves on correct signature and rejects on bad key or signature
 */
var verify = function (publicKey, msg, sig) { return new Promise(function (resolve, reject) {
    if (publicKey.length !== 65) {
        reject(new Error('Public key should 65 bytes long'));
    }
    else if (msg.length <= 0) {
        reject(new Error('Message should not be empty'));
    }
    else if (msg.length > 32) {
        reject(new Error('Message is too long (max 32 bytes)'));
    }
    else {
        var passed = pad32(msg);
        try {
            var signed = secp256k1_1.default.signatureImport(sig);
            if (secp256k1_1.default.ecdsaVerify(signed, passed, publicKey)) {
                resolve(true);
            }
            else {
                reject(new Error('Bad signature'));
            }
        }
        catch (_) { // eslint-disable-line @typescript-eslint/no-unused-vars
            reject(new Error('Invalid signature'));
        }
    }
}); };
exports.verify = verify;
/**
 * Derive shared secret for given private and public keys.
 *
 * @param {Buffer} privateKey - Sender's private key (32 bytes)
 * @param {Buffer} publicKey - Recipient's public key (65 bytes)
 * @return {Promise.<Buffer>} A promise that resolves with the derived shared secret (Px, 32 bytes) and rejects on bad key
 */
var derive = function (privateKey, publicKey) { return new Promise(function (resolve, reject) {
    if (privateKey.length !== 32) {
        reject(new Error("Bad private key, it should be 32 bytes but it's actually ".concat(privateKey.length, " bytes long")));
    }
    else if (publicKey.length !== 65) {
        reject(new Error("Bad public key, it should be 65 bytes but it's actually ".concat(publicKey.length, " bytes long")));
    }
    else if (publicKey[0] !== 4) {
        reject(new Error('Bad public key, a valid public key would begin with 4'));
    }
    else {
        var keyA = ec.keyFromPrivate(privateKey);
        var keyB = ec.keyFromPublic(publicKey);
        var Px = keyA.derive(keyB.getPublic()); // BN instance
        resolve(pad32(Buffer.from(Px.toArray())));
    }
}); };
exports.derive = derive;
/**
 * Encrypt message for given recepient's public key.
 *
 * @param {Buffer} publicKeyTo - Recipient's public key (65 bytes)
 * @param {Buffer} msg - The message being encrypted
 * @param {?{?iv: Buffer, ?ephemPrivateKey: Buffer}} opts - You may also specify initialization vector (16 bytes) and ephemeral private key (32 bytes) to get deterministic results.
 * @return {Promise.<Buffer>} - A promise that resolves with the ECIES structure serialized
 */
var encrypt = function (publicKeyTo, msg, opts) { return __awaiter(void 0, void 0, void 0, function () {
    var ephemPrivateKey;
    return __generator(this, function (_a) {
        opts = opts || {};
        ephemPrivateKey = opts.ephemPrivateKey || (0, crypto_1.randomBytes)(32);
        return [2 /*return*/, (0, exports.derive)(ephemPrivateKey, publicKeyTo)
                .then(function (sharedPx) { return (0, exports.kdf)(sharedPx, 32); })
                .then(function (hash) { return __awaiter(void 0, void 0, void 0, function () {
                var encryptionKey, iv, macKey, cipherText, HMAC;
                return __generator(this, function (_a) {
                    encryptionKey = hash.slice(0, 16);
                    iv = opts.iv || (0, crypto_1.randomBytes)(16);
                    macKey = sha256(hash.slice(16));
                    cipherText = aes128CtrEncrypt(iv, encryptionKey, msg);
                    HMAC = hmacSha256(macKey, cipherText);
                    return [2 /*return*/, (0, exports.getPublic)(ephemPrivateKey).then(function (ephemPublicKey) {
                            return Buffer.concat([ephemPublicKey, cipherText, HMAC]);
                        })];
                });
            }); })];
    });
}); };
exports.encrypt = encrypt;
var metaLength = 1 + 64 + 16 + 32;
/**
 * Decrypt message using given private key.
 *
 * @param {Buffer} privateKey - A 32-byte private key of recepient of the message
 * @param {Ecies} encrypted - ECIES serialized structure (result of ECIES encryption)
 * @return {Promise.<Buffer>} - A promise that resolves with the plaintext on successful decryption and rejects on failure
 */
var decrypt = function (privateKey, encrypted) { return new Promise(function (resolve, reject) {
    if (encrypted.length < metaLength) {
        reject(new Error("Invalid Ciphertext. Data is too small. It should ba at least ".concat(metaLength)));
    }
    else if (encrypted[0] !== 4) {
        reject(new Error("Not a valid ciphertext. It should begin with 4 but actually begin with ".concat(encrypted[0])));
    }
    else {
        // deserialize
        var ephemPublicKey = encrypted.slice(0, 65);
        var cipherTextLength = encrypted.length - metaLength;
        var iv_1 = encrypted.slice(65, 65 + 16);
        var cipherAndIv_1 = encrypted.slice(65, 65 + 16 + cipherTextLength);
        var ciphertext_1 = cipherAndIv_1.slice(16);
        var msgMac_1 = encrypted.slice(65 + 16 + cipherTextLength);
        // check HMAC
        resolve((0, exports.derive)(privateKey, ephemPublicKey)
            .then(function (sharedPx) { return (0, exports.kdf)(sharedPx, 32); })
            .then(function (hash) {
            var encryptionKey = hash.slice(0, 16);
            var macKey = sha256(hash.slice(16));
            var currentHMAC = hmacSha256(macKey, cipherAndIv_1);
            if (!equalConstTime(currentHMAC, msgMac_1)) {
                return Promise.reject(new Error('Incorrect MAC'));
            }
            // decrypt message
            var plainText = aes128CtrDecrypt(iv_1, encryptionKey, ciphertext_1);
            return Buffer.from(new Uint8Array(plainText));
        }));
    }
}); };
exports.decrypt = decrypt;
__exportStar(__webpack_require__(1824), exports);
//# sourceMappingURL=node.js.map

/***/ }),

/***/ 6729:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var elliptic = exports;

elliptic.version = (__webpack_require__(1636)/* .version */ .rE);
elliptic.utils = __webpack_require__(7011);
elliptic.rand = __webpack_require__(5037);
elliptic.curve = __webpack_require__(894);
elliptic.curves = __webpack_require__(480);

// Protocols
elliptic.ec = __webpack_require__(7447);
elliptic.eddsa = __webpack_require__(8650);


/***/ }),

/***/ 6677:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var BN = __webpack_require__(8490);
var utils = __webpack_require__(7011);
var getNAF = utils.getNAF;
var getJSF = utils.getJSF;
var assert = utils.assert;

function BaseCurve(type, conf) {
  this.type = type;
  this.p = new BN(conf.p, 16);

  // Use Montgomery, when there is no fast reduction for the prime
  this.red = conf.prime ? BN.red(conf.prime) : BN.mont(this.p);

  // Useful for many curves
  this.zero = new BN(0).toRed(this.red);
  this.one = new BN(1).toRed(this.red);
  this.two = new BN(2).toRed(this.red);

  // Curve configuration, optional
  this.n = conf.n && new BN(conf.n, 16);
  this.g = conf.g && this.pointFromJSON(conf.g, conf.gRed);

  // Temporary arrays
  this._wnafT1 = new Array(4);
  this._wnafT2 = new Array(4);
  this._wnafT3 = new Array(4);
  this._wnafT4 = new Array(4);

  this._bitLength = this.n ? this.n.bitLength() : 0;

  // Generalized Greg Maxwell's trick
  var adjustCount = this.n && this.p.div(this.n);
  if (!adjustCount || adjustCount.cmpn(100) > 0) {
    this.redN = null;
  } else {
    this._maxwellTrick = true;
    this.redN = this.n.toRed(this.red);
  }
}
module.exports = BaseCurve;

BaseCurve.prototype.point = function point() {
  throw new Error('Not implemented');
};

BaseCurve.prototype.validate = function validate() {
  throw new Error('Not implemented');
};

BaseCurve.prototype._fixedNafMul = function _fixedNafMul(p, k) {
  assert(p.precomputed);
  var doubles = p._getDoubles();

  var naf = getNAF(k, 1, this._bitLength);
  var I = (1 << (doubles.step + 1)) - (doubles.step % 2 === 0 ? 2 : 1);
  I /= 3;

  // Translate into more windowed form
  var repr = [];
  var j;
  var nafW;
  for (j = 0; j < naf.length; j += doubles.step) {
    nafW = 0;
    for (var l = j + doubles.step - 1; l >= j; l--)
      nafW = (nafW << 1) + naf[l];
    repr.push(nafW);
  }

  var a = this.jpoint(null, null, null);
  var b = this.jpoint(null, null, null);
  for (var i = I; i > 0; i--) {
    for (j = 0; j < repr.length; j++) {
      nafW = repr[j];
      if (nafW === i)
        b = b.mixedAdd(doubles.points[j]);
      else if (nafW === -i)
        b = b.mixedAdd(doubles.points[j].neg());
    }
    a = a.add(b);
  }
  return a.toP();
};

BaseCurve.prototype._wnafMul = function _wnafMul(p, k) {
  var w = 4;

  // Precompute window
  var nafPoints = p._getNAFPoints(w);
  w = nafPoints.wnd;
  var wnd = nafPoints.points;

  // Get NAF form
  var naf = getNAF(k, w, this._bitLength);

  // Add `this`*(N+1) for every w-NAF index
  var acc = this.jpoint(null, null, null);
  for (var i = naf.length - 1; i >= 0; i--) {
    // Count zeroes
    for (var l = 0; i >= 0 && naf[i] === 0; i--)
      l++;
    if (i >= 0)
      l++;
    acc = acc.dblp(l);

    if (i < 0)
      break;
    var z = naf[i];
    assert(z !== 0);
    if (p.type === 'affine') {
      // J +- P
      if (z > 0)
        acc = acc.mixedAdd(wnd[(z - 1) >> 1]);
      else
        acc = acc.mixedAdd(wnd[(-z - 1) >> 1].neg());
    } else {
      // J +- J
      if (z > 0)
        acc = acc.add(wnd[(z - 1) >> 1]);
      else
        acc = acc.add(wnd[(-z - 1) >> 1].neg());
    }
  }
  return p.type === 'affine' ? acc.toP() : acc;
};

BaseCurve.prototype._wnafMulAdd = function _wnafMulAdd(defW,
  points,
  coeffs,
  len,
  jacobianResult) {
  var wndWidth = this._wnafT1;
  var wnd = this._wnafT2;
  var naf = this._wnafT3;

  // Fill all arrays
  var max = 0;
  var i;
  var j;
  var p;
  for (i = 0; i < len; i++) {
    p = points[i];
    var nafPoints = p._getNAFPoints(defW);
    wndWidth[i] = nafPoints.wnd;
    wnd[i] = nafPoints.points;
  }

  // Comb small window NAFs
  for (i = len - 1; i >= 1; i -= 2) {
    var a = i - 1;
    var b = i;
    if (wndWidth[a] !== 1 || wndWidth[b] !== 1) {
      naf[a] = getNAF(coeffs[a], wndWidth[a], this._bitLength);
      naf[b] = getNAF(coeffs[b], wndWidth[b], this._bitLength);
      max = Math.max(naf[a].length, max);
      max = Math.max(naf[b].length, max);
      continue;
    }

    var comb = [
      points[a], /* 1 */
      null, /* 3 */
      null, /* 5 */
      points[b], /* 7 */
    ];

    // Try to avoid Projective points, if possible
    if (points[a].y.cmp(points[b].y) === 0) {
      comb[1] = points[a].add(points[b]);
      comb[2] = points[a].toJ().mixedAdd(points[b].neg());
    } else if (points[a].y.cmp(points[b].y.redNeg()) === 0) {
      comb[1] = points[a].toJ().mixedAdd(points[b]);
      comb[2] = points[a].add(points[b].neg());
    } else {
      comb[1] = points[a].toJ().mixedAdd(points[b]);
      comb[2] = points[a].toJ().mixedAdd(points[b].neg());
    }

    var index = [
      -3, /* -1 -1 */
      -1, /* -1 0 */
      -5, /* -1 1 */
      -7, /* 0 -1 */
      0, /* 0 0 */
      7, /* 0 1 */
      5, /* 1 -1 */
      1, /* 1 0 */
      3,  /* 1 1 */
    ];

    var jsf = getJSF(coeffs[a], coeffs[b]);
    max = Math.max(jsf[0].length, max);
    naf[a] = new Array(max);
    naf[b] = new Array(max);
    for (j = 0; j < max; j++) {
      var ja = jsf[0][j] | 0;
      var jb = jsf[1][j] | 0;

      naf[a][j] = index[(ja + 1) * 3 + (jb + 1)];
      naf[b][j] = 0;
      wnd[a] = comb;
    }
  }

  var acc = this.jpoint(null, null, null);
  var tmp = this._wnafT4;
  for (i = max; i >= 0; i--) {
    var k = 0;

    while (i >= 0) {
      var zero = true;
      for (j = 0; j < len; j++) {
        tmp[j] = naf[j][i] | 0;
        if (tmp[j] !== 0)
          zero = false;
      }
      if (!zero)
        break;
      k++;
      i--;
    }
    if (i >= 0)
      k++;
    acc = acc.dblp(k);
    if (i < 0)
      break;

    for (j = 0; j < len; j++) {
      var z = tmp[j];
      p;
      if (z === 0)
        continue;
      else if (z > 0)
        p = wnd[j][(z - 1) >> 1];
      else if (z < 0)
        p = wnd[j][(-z - 1) >> 1].neg();

      if (p.type === 'affine')
        acc = acc.mixedAdd(p);
      else
        acc = acc.add(p);
    }
  }
  // Zeroify references
  for (i = 0; i < len; i++)
    wnd[i] = null;

  if (jacobianResult)
    return acc;
  else
    return acc.toP();
};

function BasePoint(curve, type) {
  this.curve = curve;
  this.type = type;
  this.precomputed = null;
}
BaseCurve.BasePoint = BasePoint;

BasePoint.prototype.eq = function eq(/*other*/) {
  throw new Error('Not implemented');
};

BasePoint.prototype.validate = function validate() {
  return this.curve.validate(this);
};

BaseCurve.prototype.decodePoint = function decodePoint(bytes, enc) {
  bytes = utils.toArray(bytes, enc);

  var len = this.p.byteLength();

  // uncompressed, hybrid-odd, hybrid-even
  if ((bytes[0] === 0x04 || bytes[0] === 0x06 || bytes[0] === 0x07) &&
      bytes.length - 1 === 2 * len) {
    if (bytes[0] === 0x06)
      assert(bytes[bytes.length - 1] % 2 === 0);
    else if (bytes[0] === 0x07)
      assert(bytes[bytes.length - 1] % 2 === 1);

    var res =  this.point(bytes.slice(1, 1 + len),
      bytes.slice(1 + len, 1 + 2 * len));

    return res;
  } else if ((bytes[0] === 0x02 || bytes[0] === 0x03) &&
              bytes.length - 1 === len) {
    return this.pointFromX(bytes.slice(1, 1 + len), bytes[0] === 0x03);
  }
  throw new Error('Unknown point format');
};

BasePoint.prototype.encodeCompressed = function encodeCompressed(enc) {
  return this.encode(enc, true);
};

BasePoint.prototype._encode = function _encode(compact) {
  var len = this.curve.p.byteLength();
  var x = this.getX().toArray('be', len);

  if (compact)
    return [ this.getY().isEven() ? 0x02 : 0x03 ].concat(x);

  return [ 0x04 ].concat(x, this.getY().toArray('be', len));
};

BasePoint.prototype.encode = function encode(enc, compact) {
  return utils.encode(this._encode(compact), enc);
};

BasePoint.prototype.precompute = function precompute(power) {
  if (this.precomputed)
    return this;

  var precomputed = {
    doubles: null,
    naf: null,
    beta: null,
  };
  precomputed.naf = this._getNAFPoints(8);
  precomputed.doubles = this._getDoubles(4, power);
  precomputed.beta = this._getBeta();
  this.precomputed = precomputed;

  return this;
};

BasePoint.prototype._hasDoubles = function _hasDoubles(k) {
  if (!this.precomputed)
    return false;

  var doubles = this.precomputed.doubles;
  if (!doubles)
    return false;

  return doubles.points.length >= Math.ceil((k.bitLength() + 1) / doubles.step);
};

BasePoint.prototype._getDoubles = function _getDoubles(step, power) {
  if (this.precomputed && this.precomputed.doubles)
    return this.precomputed.doubles;

  var doubles = [ this ];
  var acc = this;
  for (var i = 0; i < power; i += step) {
    for (var j = 0; j < step; j++)
      acc = acc.dbl();
    doubles.push(acc);
  }
  return {
    step: step,
    points: doubles,
  };
};

BasePoint.prototype._getNAFPoints = function _getNAFPoints(wnd) {
  if (this.precomputed && this.precomputed.naf)
    return this.precomputed.naf;

  var res = [ this ];
  var max = (1 << wnd) - 1;
  var dbl = max === 1 ? null : this.dbl();
  for (var i = 1; i < max; i++)
    res[i] = res[i - 1].add(dbl);
  return {
    wnd: wnd,
    points: res,
  };
};

BasePoint.prototype._getBeta = function _getBeta() {
  return null;
};

BasePoint.prototype.dblp = function dblp(k) {
  var r = this;
  for (var i = 0; i < k; i++)
    r = r.dbl();
  return r;
};


/***/ }),

/***/ 1298:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(7011);
var BN = __webpack_require__(8490);
var inherits = __webpack_require__(2017);
var Base = __webpack_require__(6677);

var assert = utils.assert;

function EdwardsCurve(conf) {
  // NOTE: Important as we are creating point in Base.call()
  this.twisted = (conf.a | 0) !== 1;
  this.mOneA = this.twisted && (conf.a | 0) === -1;
  this.extended = this.mOneA;

  Base.call(this, 'edwards', conf);

  this.a = new BN(conf.a, 16).umod(this.red.m);
  this.a = this.a.toRed(this.red);
  this.c = new BN(conf.c, 16).toRed(this.red);
  this.c2 = this.c.redSqr();
  this.d = new BN(conf.d, 16).toRed(this.red);
  this.dd = this.d.redAdd(this.d);

  assert(!this.twisted || this.c.fromRed().cmpn(1) === 0);
  this.oneC = (conf.c | 0) === 1;
}
inherits(EdwardsCurve, Base);
module.exports = EdwardsCurve;

EdwardsCurve.prototype._mulA = function _mulA(num) {
  if (this.mOneA)
    return num.redNeg();
  else
    return this.a.redMul(num);
};

EdwardsCurve.prototype._mulC = function _mulC(num) {
  if (this.oneC)
    return num;
  else
    return this.c.redMul(num);
};

// Just for compatibility with Short curve
EdwardsCurve.prototype.jpoint = function jpoint(x, y, z, t) {
  return this.point(x, y, z, t);
};

EdwardsCurve.prototype.pointFromX = function pointFromX(x, odd) {
  x = new BN(x, 16);
  if (!x.red)
    x = x.toRed(this.red);

  var x2 = x.redSqr();
  var rhs = this.c2.redSub(this.a.redMul(x2));
  var lhs = this.one.redSub(this.c2.redMul(this.d).redMul(x2));

  var y2 = rhs.redMul(lhs.redInvm());
  var y = y2.redSqrt();
  if (y.redSqr().redSub(y2).cmp(this.zero) !== 0)
    throw new Error('invalid point');

  var isOdd = y.fromRed().isOdd();
  if (odd && !isOdd || !odd && isOdd)
    y = y.redNeg();

  return this.point(x, y);
};

EdwardsCurve.prototype.pointFromY = function pointFromY(y, odd) {
  y = new BN(y, 16);
  if (!y.red)
    y = y.toRed(this.red);

  // x^2 = (y^2 - c^2) / (c^2 d y^2 - a)
  var y2 = y.redSqr();
  var lhs = y2.redSub(this.c2);
  var rhs = y2.redMul(this.d).redMul(this.c2).redSub(this.a);
  var x2 = lhs.redMul(rhs.redInvm());

  if (x2.cmp(this.zero) === 0) {
    if (odd)
      throw new Error('invalid point');
    else
      return this.point(this.zero, y);
  }

  var x = x2.redSqrt();
  if (x.redSqr().redSub(x2).cmp(this.zero) !== 0)
    throw new Error('invalid point');

  if (x.fromRed().isOdd() !== odd)
    x = x.redNeg();

  return this.point(x, y);
};

EdwardsCurve.prototype.validate = function validate(point) {
  if (point.isInfinity())
    return true;

  // Curve: A * X^2 + Y^2 = C^2 * (1 + D * X^2 * Y^2)
  point.normalize();

  var x2 = point.x.redSqr();
  var y2 = point.y.redSqr();
  var lhs = x2.redMul(this.a).redAdd(y2);
  var rhs = this.c2.redMul(this.one.redAdd(this.d.redMul(x2).redMul(y2)));

  return lhs.cmp(rhs) === 0;
};

function Point(curve, x, y, z, t) {
  Base.BasePoint.call(this, curve, 'projective');
  if (x === null && y === null && z === null) {
    this.x = this.curve.zero;
    this.y = this.curve.one;
    this.z = this.curve.one;
    this.t = this.curve.zero;
    this.zOne = true;
  } else {
    this.x = new BN(x, 16);
    this.y = new BN(y, 16);
    this.z = z ? new BN(z, 16) : this.curve.one;
    this.t = t && new BN(t, 16);
    if (!this.x.red)
      this.x = this.x.toRed(this.curve.red);
    if (!this.y.red)
      this.y = this.y.toRed(this.curve.red);
    if (!this.z.red)
      this.z = this.z.toRed(this.curve.red);
    if (this.t && !this.t.red)
      this.t = this.t.toRed(this.curve.red);
    this.zOne = this.z === this.curve.one;

    // Use extended coordinates
    if (this.curve.extended && !this.t) {
      this.t = this.x.redMul(this.y);
      if (!this.zOne)
        this.t = this.t.redMul(this.z.redInvm());
    }
  }
}
inherits(Point, Base.BasePoint);

EdwardsCurve.prototype.pointFromJSON = function pointFromJSON(obj) {
  return Point.fromJSON(this, obj);
};

EdwardsCurve.prototype.point = function point(x, y, z, t) {
  return new Point(this, x, y, z, t);
};

Point.fromJSON = function fromJSON(curve, obj) {
  return new Point(curve, obj[0], obj[1], obj[2]);
};

Point.prototype.inspect = function inspect() {
  if (this.isInfinity())
    return '<EC Point Infinity>';
  return '<EC Point x: ' + this.x.fromRed().toString(16, 2) +
      ' y: ' + this.y.fromRed().toString(16, 2) +
      ' z: ' + this.z.fromRed().toString(16, 2) + '>';
};

Point.prototype.isInfinity = function isInfinity() {
  // XXX This code assumes that zero is always zero in red
  return this.x.cmpn(0) === 0 &&
    (this.y.cmp(this.z) === 0 ||
    (this.zOne && this.y.cmp(this.curve.c) === 0));
};

Point.prototype._extDbl = function _extDbl() {
  // hyperelliptic.org/EFD/g1p/auto-twisted-extended-1.html
  //     #doubling-dbl-2008-hwcd
  // 4M + 4S

  // A = X1^2
  var a = this.x.redSqr();
  // B = Y1^2
  var b = this.y.redSqr();
  // C = 2 * Z1^2
  var c = this.z.redSqr();
  c = c.redIAdd(c);
  // D = a * A
  var d = this.curve._mulA(a);
  // E = (X1 + Y1)^2 - A - B
  var e = this.x.redAdd(this.y).redSqr().redISub(a).redISub(b);
  // G = D + B
  var g = d.redAdd(b);
  // F = G - C
  var f = g.redSub(c);
  // H = D - B
  var h = d.redSub(b);
  // X3 = E * F
  var nx = e.redMul(f);
  // Y3 = G * H
  var ny = g.redMul(h);
  // T3 = E * H
  var nt = e.redMul(h);
  // Z3 = F * G
  var nz = f.redMul(g);
  return this.curve.point(nx, ny, nz, nt);
};

Point.prototype._projDbl = function _projDbl() {
  // hyperelliptic.org/EFD/g1p/auto-twisted-projective.html
  //     #doubling-dbl-2008-bbjlp
  //     #doubling-dbl-2007-bl
  // and others
  // Generally 3M + 4S or 2M + 4S

  // B = (X1 + Y1)^2
  var b = this.x.redAdd(this.y).redSqr();
  // C = X1^2
  var c = this.x.redSqr();
  // D = Y1^2
  var d = this.y.redSqr();

  var nx;
  var ny;
  var nz;
  var e;
  var h;
  var j;
  if (this.curve.twisted) {
    // E = a * C
    e = this.curve._mulA(c);
    // F = E + D
    var f = e.redAdd(d);
    if (this.zOne) {
      // X3 = (B - C - D) * (F - 2)
      nx = b.redSub(c).redSub(d).redMul(f.redSub(this.curve.two));
      // Y3 = F * (E - D)
      ny = f.redMul(e.redSub(d));
      // Z3 = F^2 - 2 * F
      nz = f.redSqr().redSub(f).redSub(f);
    } else {
      // H = Z1^2
      h = this.z.redSqr();
      // J = F - 2 * H
      j = f.redSub(h).redISub(h);
      // X3 = (B-C-D)*J
      nx = b.redSub(c).redISub(d).redMul(j);
      // Y3 = F * (E - D)
      ny = f.redMul(e.redSub(d));
      // Z3 = F * J
      nz = f.redMul(j);
    }
  } else {
    // E = C + D
    e = c.redAdd(d);
    // H = (c * Z1)^2
    h = this.curve._mulC(this.z).redSqr();
    // J = E - 2 * H
    j = e.redSub(h).redSub(h);
    // X3 = c * (B - E) * J
    nx = this.curve._mulC(b.redISub(e)).redMul(j);
    // Y3 = c * E * (C - D)
    ny = this.curve._mulC(e).redMul(c.redISub(d));
    // Z3 = E * J
    nz = e.redMul(j);
  }
  return this.curve.point(nx, ny, nz);
};

Point.prototype.dbl = function dbl() {
  if (this.isInfinity())
    return this;

  // Double in extended coordinates
  if (this.curve.extended)
    return this._extDbl();
  else
    return this._projDbl();
};

Point.prototype._extAdd = function _extAdd(p) {
  // hyperelliptic.org/EFD/g1p/auto-twisted-extended-1.html
  //     #addition-add-2008-hwcd-3
  // 8M

  // A = (Y1 - X1) * (Y2 - X2)
  var a = this.y.redSub(this.x).redMul(p.y.redSub(p.x));
  // B = (Y1 + X1) * (Y2 + X2)
  var b = this.y.redAdd(this.x).redMul(p.y.redAdd(p.x));
  // C = T1 * k * T2
  var c = this.t.redMul(this.curve.dd).redMul(p.t);
  // D = Z1 * 2 * Z2
  var d = this.z.redMul(p.z.redAdd(p.z));
  // E = B - A
  var e = b.redSub(a);
  // F = D - C
  var f = d.redSub(c);
  // G = D + C
  var g = d.redAdd(c);
  // H = B + A
  var h = b.redAdd(a);
  // X3 = E * F
  var nx = e.redMul(f);
  // Y3 = G * H
  var ny = g.redMul(h);
  // T3 = E * H
  var nt = e.redMul(h);
  // Z3 = F * G
  var nz = f.redMul(g);
  return this.curve.point(nx, ny, nz, nt);
};

Point.prototype._projAdd = function _projAdd(p) {
  // hyperelliptic.org/EFD/g1p/auto-twisted-projective.html
  //     #addition-add-2008-bbjlp
  //     #addition-add-2007-bl
  // 10M + 1S

  // A = Z1 * Z2
  var a = this.z.redMul(p.z);
  // B = A^2
  var b = a.redSqr();
  // C = X1 * X2
  var c = this.x.redMul(p.x);
  // D = Y1 * Y2
  var d = this.y.redMul(p.y);
  // E = d * C * D
  var e = this.curve.d.redMul(c).redMul(d);
  // F = B - E
  var f = b.redSub(e);
  // G = B + E
  var g = b.redAdd(e);
  // X3 = A * F * ((X1 + Y1) * (X2 + Y2) - C - D)
  var tmp = this.x.redAdd(this.y).redMul(p.x.redAdd(p.y)).redISub(c).redISub(d);
  var nx = a.redMul(f).redMul(tmp);
  var ny;
  var nz;
  if (this.curve.twisted) {
    // Y3 = A * G * (D - a * C)
    ny = a.redMul(g).redMul(d.redSub(this.curve._mulA(c)));
    // Z3 = F * G
    nz = f.redMul(g);
  } else {
    // Y3 = A * G * (D - C)
    ny = a.redMul(g).redMul(d.redSub(c));
    // Z3 = c * F * G
    nz = this.curve._mulC(f).redMul(g);
  }
  return this.curve.point(nx, ny, nz);
};

Point.prototype.add = function add(p) {
  if (this.isInfinity())
    return p;
  if (p.isInfinity())
    return this;

  if (this.curve.extended)
    return this._extAdd(p);
  else
    return this._projAdd(p);
};

Point.prototype.mul = function mul(k) {
  if (this._hasDoubles(k))
    return this.curve._fixedNafMul(this, k);
  else
    return this.curve._wnafMul(this, k);
};

Point.prototype.mulAdd = function mulAdd(k1, p, k2) {
  return this.curve._wnafMulAdd(1, [ this, p ], [ k1, k2 ], 2, false);
};

Point.prototype.jmulAdd = function jmulAdd(k1, p, k2) {
  return this.curve._wnafMulAdd(1, [ this, p ], [ k1, k2 ], 2, true);
};

Point.prototype.normalize = function normalize() {
  if (this.zOne)
    return this;

  // Normalize coordinates
  var zi = this.z.redInvm();
  this.x = this.x.redMul(zi);
  this.y = this.y.redMul(zi);
  if (this.t)
    this.t = this.t.redMul(zi);
  this.z = this.curve.one;
  this.zOne = true;
  return this;
};

Point.prototype.neg = function neg() {
  return this.curve.point(this.x.redNeg(),
    this.y,
    this.z,
    this.t && this.t.redNeg());
};

Point.prototype.getX = function getX() {
  this.normalize();
  return this.x.fromRed();
};

Point.prototype.getY = function getY() {
  this.normalize();
  return this.y.fromRed();
};

Point.prototype.eq = function eq(other) {
  return this === other ||
         this.getX().cmp(other.getX()) === 0 &&
         this.getY().cmp(other.getY()) === 0;
};

Point.prototype.eqXToP = function eqXToP(x) {
  var rx = x.toRed(this.curve.red).redMul(this.z);
  if (this.x.cmp(rx) === 0)
    return true;

  var xc = x.clone();
  var t = this.curve.redN.redMul(this.z);
  for (;;) {
    xc.iadd(this.curve.n);
    if (xc.cmp(this.curve.p) >= 0)
      return false;

    rx.redIAdd(t);
    if (this.x.cmp(rx) === 0)
      return true;
  }
};

// Compatibility with BaseCurve
Point.prototype.toP = Point.prototype.normalize;
Point.prototype.mixedAdd = Point.prototype.add;


/***/ }),

/***/ 894:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var curve = exports;

curve.base = __webpack_require__(6677);
curve.short = __webpack_require__(9188);
curve.mont = __webpack_require__(370);
curve.edwards = __webpack_require__(1298);


/***/ }),

/***/ 370:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var BN = __webpack_require__(8490);
var inherits = __webpack_require__(2017);
var Base = __webpack_require__(6677);

var utils = __webpack_require__(7011);

function MontCurve(conf) {
  Base.call(this, 'mont', conf);

  this.a = new BN(conf.a, 16).toRed(this.red);
  this.b = new BN(conf.b, 16).toRed(this.red);
  this.i4 = new BN(4).toRed(this.red).redInvm();
  this.two = new BN(2).toRed(this.red);
  this.a24 = this.i4.redMul(this.a.redAdd(this.two));
}
inherits(MontCurve, Base);
module.exports = MontCurve;

MontCurve.prototype.validate = function validate(point) {
  var x = point.normalize().x;
  var x2 = x.redSqr();
  var rhs = x2.redMul(x).redAdd(x2.redMul(this.a)).redAdd(x);
  var y = rhs.redSqrt();

  return y.redSqr().cmp(rhs) === 0;
};

function Point(curve, x, z) {
  Base.BasePoint.call(this, curve, 'projective');
  if (x === null && z === null) {
    this.x = this.curve.one;
    this.z = this.curve.zero;
  } else {
    this.x = new BN(x, 16);
    this.z = new BN(z, 16);
    if (!this.x.red)
      this.x = this.x.toRed(this.curve.red);
    if (!this.z.red)
      this.z = this.z.toRed(this.curve.red);
  }
}
inherits(Point, Base.BasePoint);

MontCurve.prototype.decodePoint = function decodePoint(bytes, enc) {
  return this.point(utils.toArray(bytes, enc), 1);
};

MontCurve.prototype.point = function point(x, z) {
  return new Point(this, x, z);
};

MontCurve.prototype.pointFromJSON = function pointFromJSON(obj) {
  return Point.fromJSON(this, obj);
};

Point.prototype.precompute = function precompute() {
  // No-op
};

Point.prototype._encode = function _encode() {
  return this.getX().toArray('be', this.curve.p.byteLength());
};

Point.fromJSON = function fromJSON(curve, obj) {
  return new Point(curve, obj[0], obj[1] || curve.one);
};

Point.prototype.inspect = function inspect() {
  if (this.isInfinity())
    return '<EC Point Infinity>';
  return '<EC Point x: ' + this.x.fromRed().toString(16, 2) +
      ' z: ' + this.z.fromRed().toString(16, 2) + '>';
};

Point.prototype.isInfinity = function isInfinity() {
  // XXX This code assumes that zero is always zero in red
  return this.z.cmpn(0) === 0;
};

Point.prototype.dbl = function dbl() {
  // http://hyperelliptic.org/EFD/g1p/auto-montgom-xz.html#doubling-dbl-1987-m-3
  // 2M + 2S + 4A

  // A = X1 + Z1
  var a = this.x.redAdd(this.z);
  // AA = A^2
  var aa = a.redSqr();
  // B = X1 - Z1
  var b = this.x.redSub(this.z);
  // BB = B^2
  var bb = b.redSqr();
  // C = AA - BB
  var c = aa.redSub(bb);
  // X3 = AA * BB
  var nx = aa.redMul(bb);
  // Z3 = C * (BB + A24 * C)
  var nz = c.redMul(bb.redAdd(this.curve.a24.redMul(c)));
  return this.curve.point(nx, nz);
};

Point.prototype.add = function add() {
  throw new Error('Not supported on Montgomery curve');
};

Point.prototype.diffAdd = function diffAdd(p, diff) {
  // http://hyperelliptic.org/EFD/g1p/auto-montgom-xz.html#diffadd-dadd-1987-m-3
  // 4M + 2S + 6A

  // A = X2 + Z2
  var a = this.x.redAdd(this.z);
  // B = X2 - Z2
  var b = this.x.redSub(this.z);
  // C = X3 + Z3
  var c = p.x.redAdd(p.z);
  // D = X3 - Z3
  var d = p.x.redSub(p.z);
  // DA = D * A
  var da = d.redMul(a);
  // CB = C * B
  var cb = c.redMul(b);
  // X5 = Z1 * (DA + CB)^2
  var nx = diff.z.redMul(da.redAdd(cb).redSqr());
  // Z5 = X1 * (DA - CB)^2
  var nz = diff.x.redMul(da.redISub(cb).redSqr());
  return this.curve.point(nx, nz);
};

Point.prototype.mul = function mul(k) {
  var t = k.clone();
  var a = this; // (N / 2) * Q + Q
  var b = this.curve.point(null, null); // (N / 2) * Q
  var c = this; // Q

  for (var bits = []; t.cmpn(0) !== 0; t.iushrn(1))
    bits.push(t.andln(1));

  for (var i = bits.length - 1; i >= 0; i--) {
    if (bits[i] === 0) {
      // N * Q + Q = ((N / 2) * Q + Q)) + (N / 2) * Q
      a = a.diffAdd(b, c);
      // N * Q = 2 * ((N / 2) * Q + Q))
      b = b.dbl();
    } else {
      // N * Q = ((N / 2) * Q + Q) + ((N / 2) * Q)
      b = a.diffAdd(b, c);
      // N * Q + Q = 2 * ((N / 2) * Q + Q)
      a = a.dbl();
    }
  }
  return b;
};

Point.prototype.mulAdd = function mulAdd() {
  throw new Error('Not supported on Montgomery curve');
};

Point.prototype.jumlAdd = function jumlAdd() {
  throw new Error('Not supported on Montgomery curve');
};

Point.prototype.eq = function eq(other) {
  return this.getX().cmp(other.getX()) === 0;
};

Point.prototype.normalize = function normalize() {
  this.x = this.x.redMul(this.z.redInvm());
  this.z = this.curve.one;
  return this;
};

Point.prototype.getX = function getX() {
  // Normalize coordinates
  this.normalize();

  return this.x.fromRed();
};


/***/ }),

/***/ 9188:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(7011);
var BN = __webpack_require__(8490);
var inherits = __webpack_require__(2017);
var Base = __webpack_require__(6677);

var assert = utils.assert;

function ShortCurve(conf) {
  Base.call(this, 'short', conf);

  this.a = new BN(conf.a, 16).toRed(this.red);
  this.b = new BN(conf.b, 16).toRed(this.red);
  this.tinv = this.two.redInvm();

  this.zeroA = this.a.fromRed().cmpn(0) === 0;
  this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0;

  // If the curve is endomorphic, precalculate beta and lambda
  this.endo = this._getEndomorphism(conf);
  this._endoWnafT1 = new Array(4);
  this._endoWnafT2 = new Array(4);
}
inherits(ShortCurve, Base);
module.exports = ShortCurve;

ShortCurve.prototype._getEndomorphism = function _getEndomorphism(conf) {
  // No efficient endomorphism
  if (!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)
    return;

  // Compute beta and lambda, that lambda * P = (beta * Px; Py)
  var beta;
  var lambda;
  if (conf.beta) {
    beta = new BN(conf.beta, 16).toRed(this.red);
  } else {
    var betas = this._getEndoRoots(this.p);
    // Choose the smallest beta
    beta = betas[0].cmp(betas[1]) < 0 ? betas[0] : betas[1];
    beta = beta.toRed(this.red);
  }
  if (conf.lambda) {
    lambda = new BN(conf.lambda, 16);
  } else {
    // Choose the lambda that is matching selected beta
    var lambdas = this._getEndoRoots(this.n);
    if (this.g.mul(lambdas[0]).x.cmp(this.g.x.redMul(beta)) === 0) {
      lambda = lambdas[0];
    } else {
      lambda = lambdas[1];
      assert(this.g.mul(lambda).x.cmp(this.g.x.redMul(beta)) === 0);
    }
  }

  // Get basis vectors, used for balanced length-two representation
  var basis;
  if (conf.basis) {
    basis = conf.basis.map(function(vec) {
      return {
        a: new BN(vec.a, 16),
        b: new BN(vec.b, 16),
      };
    });
  } else {
    basis = this._getEndoBasis(lambda);
  }

  return {
    beta: beta,
    lambda: lambda,
    basis: basis,
  };
};

ShortCurve.prototype._getEndoRoots = function _getEndoRoots(num) {
  // Find roots of for x^2 + x + 1 in F
  // Root = (-1 +- Sqrt(-3)) / 2
  //
  var red = num === this.p ? this.red : BN.mont(num);
  var tinv = new BN(2).toRed(red).redInvm();
  var ntinv = tinv.redNeg();

  var s = new BN(3).toRed(red).redNeg().redSqrt().redMul(tinv);

  var l1 = ntinv.redAdd(s).fromRed();
  var l2 = ntinv.redSub(s).fromRed();
  return [ l1, l2 ];
};

ShortCurve.prototype._getEndoBasis = function _getEndoBasis(lambda) {
  // aprxSqrt >= sqrt(this.n)
  var aprxSqrt = this.n.ushrn(Math.floor(this.n.bitLength() / 2));

  // 3.74
  // Run EGCD, until r(L + 1) < aprxSqrt
  var u = lambda;
  var v = this.n.clone();
  var x1 = new BN(1);
  var y1 = new BN(0);
  var x2 = new BN(0);
  var y2 = new BN(1);

  // NOTE: all vectors are roots of: a + b * lambda = 0 (mod n)
  var a0;
  var b0;
  // First vector
  var a1;
  var b1;
  // Second vector
  var a2;
  var b2;

  var prevR;
  var i = 0;
  var r;
  var x;
  while (u.cmpn(0) !== 0) {
    var q = v.div(u);
    r = v.sub(q.mul(u));
    x = x2.sub(q.mul(x1));
    var y = y2.sub(q.mul(y1));

    if (!a1 && r.cmp(aprxSqrt) < 0) {
      a0 = prevR.neg();
      b0 = x1;
      a1 = r.neg();
      b1 = x;
    } else if (a1 && ++i === 2) {
      break;
    }
    prevR = r;

    v = u;
    u = r;
    x2 = x1;
    x1 = x;
    y2 = y1;
    y1 = y;
  }
  a2 = r.neg();
  b2 = x;

  var len1 = a1.sqr().add(b1.sqr());
  var len2 = a2.sqr().add(b2.sqr());
  if (len2.cmp(len1) >= 0) {
    a2 = a0;
    b2 = b0;
  }

  // Normalize signs
  if (a1.negative) {
    a1 = a1.neg();
    b1 = b1.neg();
  }
  if (a2.negative) {
    a2 = a2.neg();
    b2 = b2.neg();
  }

  return [
    { a: a1, b: b1 },
    { a: a2, b: b2 },
  ];
};

ShortCurve.prototype._endoSplit = function _endoSplit(k) {
  var basis = this.endo.basis;
  var v1 = basis[0];
  var v2 = basis[1];

  var c1 = v2.b.mul(k).divRound(this.n);
  var c2 = v1.b.neg().mul(k).divRound(this.n);

  var p1 = c1.mul(v1.a);
  var p2 = c2.mul(v2.a);
  var q1 = c1.mul(v1.b);
  var q2 = c2.mul(v2.b);

  // Calculate answer
  var k1 = k.sub(p1).sub(p2);
  var k2 = q1.add(q2).neg();
  return { k1: k1, k2: k2 };
};

ShortCurve.prototype.pointFromX = function pointFromX(x, odd) {
  x = new BN(x, 16);
  if (!x.red)
    x = x.toRed(this.red);

  var y2 = x.redSqr().redMul(x).redIAdd(x.redMul(this.a)).redIAdd(this.b);
  var y = y2.redSqrt();
  if (y.redSqr().redSub(y2).cmp(this.zero) !== 0)
    throw new Error('invalid point');

  // XXX Is there any way to tell if the number is odd without converting it
  // to non-red form?
  var isOdd = y.fromRed().isOdd();
  if (odd && !isOdd || !odd && isOdd)
    y = y.redNeg();

  return this.point(x, y);
};

ShortCurve.prototype.validate = function validate(point) {
  if (point.inf)
    return true;

  var x = point.x;
  var y = point.y;

  var ax = this.a.redMul(x);
  var rhs = x.redSqr().redMul(x).redIAdd(ax).redIAdd(this.b);
  return y.redSqr().redISub(rhs).cmpn(0) === 0;
};

ShortCurve.prototype._endoWnafMulAdd =
    function _endoWnafMulAdd(points, coeffs, jacobianResult) {
      var npoints = this._endoWnafT1;
      var ncoeffs = this._endoWnafT2;
      for (var i = 0; i < points.length; i++) {
        var split = this._endoSplit(coeffs[i]);
        var p = points[i];
        var beta = p._getBeta();

        if (split.k1.negative) {
          split.k1.ineg();
          p = p.neg(true);
        }
        if (split.k2.negative) {
          split.k2.ineg();
          beta = beta.neg(true);
        }

        npoints[i * 2] = p;
        npoints[i * 2 + 1] = beta;
        ncoeffs[i * 2] = split.k1;
        ncoeffs[i * 2 + 1] = split.k2;
      }
      var res = this._wnafMulAdd(1, npoints, ncoeffs, i * 2, jacobianResult);

      // Clean-up references to points and coefficients
      for (var j = 0; j < i * 2; j++) {
        npoints[j] = null;
        ncoeffs[j] = null;
      }
      return res;
    };

function Point(curve, x, y, isRed) {
  Base.BasePoint.call(this, curve, 'affine');
  if (x === null && y === null) {
    this.x = null;
    this.y = null;
    this.inf = true;
  } else {
    this.x = new BN(x, 16);
    this.y = new BN(y, 16);
    // Force redgomery representation when loading from JSON
    if (isRed) {
      this.x.forceRed(this.curve.red);
      this.y.forceRed(this.curve.red);
    }
    if (!this.x.red)
      this.x = this.x.toRed(this.curve.red);
    if (!this.y.red)
      this.y = this.y.toRed(this.curve.red);
    this.inf = false;
  }
}
inherits(Point, Base.BasePoint);

ShortCurve.prototype.point = function point(x, y, isRed) {
  return new Point(this, x, y, isRed);
};

ShortCurve.prototype.pointFromJSON = function pointFromJSON(obj, red) {
  return Point.fromJSON(this, obj, red);
};

Point.prototype._getBeta = function _getBeta() {
  if (!this.curve.endo)
    return;

  var pre = this.precomputed;
  if (pre && pre.beta)
    return pre.beta;

  var beta = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
  if (pre) {
    var curve = this.curve;
    var endoMul = function(p) {
      return curve.point(p.x.redMul(curve.endo.beta), p.y);
    };
    pre.beta = beta;
    beta.precomputed = {
      beta: null,
      naf: pre.naf && {
        wnd: pre.naf.wnd,
        points: pre.naf.points.map(endoMul),
      },
      doubles: pre.doubles && {
        step: pre.doubles.step,
        points: pre.doubles.points.map(endoMul),
      },
    };
  }
  return beta;
};

Point.prototype.toJSON = function toJSON() {
  if (!this.precomputed)
    return [ this.x, this.y ];

  return [ this.x, this.y, this.precomputed && {
    doubles: this.precomputed.doubles && {
      step: this.precomputed.doubles.step,
      points: this.precomputed.doubles.points.slice(1),
    },
    naf: this.precomputed.naf && {
      wnd: this.precomputed.naf.wnd,
      points: this.precomputed.naf.points.slice(1),
    },
  } ];
};

Point.fromJSON = function fromJSON(curve, obj, red) {
  if (typeof obj === 'string')
    obj = JSON.parse(obj);
  var res = curve.point(obj[0], obj[1], red);
  if (!obj[2])
    return res;

  function obj2point(obj) {
    return curve.point(obj[0], obj[1], red);
  }

  var pre = obj[2];
  res.precomputed = {
    beta: null,
    doubles: pre.doubles && {
      step: pre.doubles.step,
      points: [ res ].concat(pre.doubles.points.map(obj2point)),
    },
    naf: pre.naf && {
      wnd: pre.naf.wnd,
      points: [ res ].concat(pre.naf.points.map(obj2point)),
    },
  };
  return res;
};

Point.prototype.inspect = function inspect() {
  if (this.isInfinity())
    return '<EC Point Infinity>';
  return '<EC Point x: ' + this.x.fromRed().toString(16, 2) +
      ' y: ' + this.y.fromRed().toString(16, 2) + '>';
};

Point.prototype.isInfinity = function isInfinity() {
  return this.inf;
};

Point.prototype.add = function add(p) {
  // O + P = P
  if (this.inf)
    return p;

  // P + O = P
  if (p.inf)
    return this;

  // P + P = 2P
  if (this.eq(p))
    return this.dbl();

  // P + (-P) = O
  if (this.neg().eq(p))
    return this.curve.point(null, null);

  // P + Q = O
  if (this.x.cmp(p.x) === 0)
    return this.curve.point(null, null);

  var c = this.y.redSub(p.y);
  if (c.cmpn(0) !== 0)
    c = c.redMul(this.x.redSub(p.x).redInvm());
  var nx = c.redSqr().redISub(this.x).redISub(p.x);
  var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
  return this.curve.point(nx, ny);
};

Point.prototype.dbl = function dbl() {
  if (this.inf)
    return this;

  // 2P = O
  var ys1 = this.y.redAdd(this.y);
  if (ys1.cmpn(0) === 0)
    return this.curve.point(null, null);

  var a = this.curve.a;

  var x2 = this.x.redSqr();
  var dyinv = ys1.redInvm();
  var c = x2.redAdd(x2).redIAdd(x2).redIAdd(a).redMul(dyinv);

  var nx = c.redSqr().redISub(this.x.redAdd(this.x));
  var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
  return this.curve.point(nx, ny);
};

Point.prototype.getX = function getX() {
  return this.x.fromRed();
};

Point.prototype.getY = function getY() {
  return this.y.fromRed();
};

Point.prototype.mul = function mul(k) {
  k = new BN(k, 16);
  if (this.isInfinity())
    return this;
  else if (this._hasDoubles(k))
    return this.curve._fixedNafMul(this, k);
  else if (this.curve.endo)
    return this.curve._endoWnafMulAdd([ this ], [ k ]);
  else
    return this.curve._wnafMul(this, k);
};

Point.prototype.mulAdd = function mulAdd(k1, p2, k2) {
  var points = [ this, p2 ];
  var coeffs = [ k1, k2 ];
  if (this.curve.endo)
    return this.curve._endoWnafMulAdd(points, coeffs);
  else
    return this.curve._wnafMulAdd(1, points, coeffs, 2);
};

Point.prototype.jmulAdd = function jmulAdd(k1, p2, k2) {
  var points = [ this, p2 ];
  var coeffs = [ k1, k2 ];
  if (this.curve.endo)
    return this.curve._endoWnafMulAdd(points, coeffs, true);
  else
    return this.curve._wnafMulAdd(1, points, coeffs, 2, true);
};

Point.prototype.eq = function eq(p) {
  return this === p ||
         this.inf === p.inf &&
             (this.inf || this.x.cmp(p.x) === 0 && this.y.cmp(p.y) === 0);
};

Point.prototype.neg = function neg(_precompute) {
  if (this.inf)
    return this;

  var res = this.curve.point(this.x, this.y.redNeg());
  if (_precompute && this.precomputed) {
    var pre = this.precomputed;
    var negate = function(p) {
      return p.neg();
    };
    res.precomputed = {
      naf: pre.naf && {
        wnd: pre.naf.wnd,
        points: pre.naf.points.map(negate),
      },
      doubles: pre.doubles && {
        step: pre.doubles.step,
        points: pre.doubles.points.map(negate),
      },
    };
  }
  return res;
};

Point.prototype.toJ = function toJ() {
  if (this.inf)
    return this.curve.jpoint(null, null, null);

  var res = this.curve.jpoint(this.x, this.y, this.curve.one);
  return res;
};

function JPoint(curve, x, y, z) {
  Base.BasePoint.call(this, curve, 'jacobian');
  if (x === null && y === null && z === null) {
    this.x = this.curve.one;
    this.y = this.curve.one;
    this.z = new BN(0);
  } else {
    this.x = new BN(x, 16);
    this.y = new BN(y, 16);
    this.z = new BN(z, 16);
  }
  if (!this.x.red)
    this.x = this.x.toRed(this.curve.red);
  if (!this.y.red)
    this.y = this.y.toRed(this.curve.red);
  if (!this.z.red)
    this.z = this.z.toRed(this.curve.red);

  this.zOne = this.z === this.curve.one;
}
inherits(JPoint, Base.BasePoint);

ShortCurve.prototype.jpoint = function jpoint(x, y, z) {
  return new JPoint(this, x, y, z);
};

JPoint.prototype.toP = function toP() {
  if (this.isInfinity())
    return this.curve.point(null, null);

  var zinv = this.z.redInvm();
  var zinv2 = zinv.redSqr();
  var ax = this.x.redMul(zinv2);
  var ay = this.y.redMul(zinv2).redMul(zinv);

  return this.curve.point(ax, ay);
};

JPoint.prototype.neg = function neg() {
  return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
};

JPoint.prototype.add = function add(p) {
  // O + P = P
  if (this.isInfinity())
    return p;

  // P + O = P
  if (p.isInfinity())
    return this;

  // 12M + 4S + 7A
  var pz2 = p.z.redSqr();
  var z2 = this.z.redSqr();
  var u1 = this.x.redMul(pz2);
  var u2 = p.x.redMul(z2);
  var s1 = this.y.redMul(pz2.redMul(p.z));
  var s2 = p.y.redMul(z2.redMul(this.z));

  var h = u1.redSub(u2);
  var r = s1.redSub(s2);
  if (h.cmpn(0) === 0) {
    if (r.cmpn(0) !== 0)
      return this.curve.jpoint(null, null, null);
    else
      return this.dbl();
  }

  var h2 = h.redSqr();
  var h3 = h2.redMul(h);
  var v = u1.redMul(h2);

  var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);
  var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));
  var nz = this.z.redMul(p.z).redMul(h);

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype.mixedAdd = function mixedAdd(p) {
  // O + P = P
  if (this.isInfinity())
    return p.toJ();

  // P + O = P
  if (p.isInfinity())
    return this;

  // 8M + 3S + 7A
  var z2 = this.z.redSqr();
  var u1 = this.x;
  var u2 = p.x.redMul(z2);
  var s1 = this.y;
  var s2 = p.y.redMul(z2).redMul(this.z);

  var h = u1.redSub(u2);
  var r = s1.redSub(s2);
  if (h.cmpn(0) === 0) {
    if (r.cmpn(0) !== 0)
      return this.curve.jpoint(null, null, null);
    else
      return this.dbl();
  }

  var h2 = h.redSqr();
  var h3 = h2.redMul(h);
  var v = u1.redMul(h2);

  var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);
  var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));
  var nz = this.z.redMul(h);

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype.dblp = function dblp(pow) {
  if (pow === 0)
    return this;
  if (this.isInfinity())
    return this;
  if (!pow)
    return this.dbl();

  var i;
  if (this.curve.zeroA || this.curve.threeA) {
    var r = this;
    for (i = 0; i < pow; i++)
      r = r.dbl();
    return r;
  }

  // 1M + 2S + 1A + N * (4S + 5M + 8A)
  // N = 1 => 6M + 6S + 9A
  var a = this.curve.a;
  var tinv = this.curve.tinv;

  var jx = this.x;
  var jy = this.y;
  var jz = this.z;
  var jz4 = jz.redSqr().redSqr();

  // Reuse results
  var jyd = jy.redAdd(jy);
  for (i = 0; i < pow; i++) {
    var jx2 = jx.redSqr();
    var jyd2 = jyd.redSqr();
    var jyd4 = jyd2.redSqr();
    var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));

    var t1 = jx.redMul(jyd2);
    var nx = c.redSqr().redISub(t1.redAdd(t1));
    var t2 = t1.redISub(nx);
    var dny = c.redMul(t2);
    dny = dny.redIAdd(dny).redISub(jyd4);
    var nz = jyd.redMul(jz);
    if (i + 1 < pow)
      jz4 = jz4.redMul(jyd4);

    jx = nx;
    jz = nz;
    jyd = dny;
  }

  return this.curve.jpoint(jx, jyd.redMul(tinv), jz);
};

JPoint.prototype.dbl = function dbl() {
  if (this.isInfinity())
    return this;

  if (this.curve.zeroA)
    return this._zeroDbl();
  else if (this.curve.threeA)
    return this._threeDbl();
  else
    return this._dbl();
};

JPoint.prototype._zeroDbl = function _zeroDbl() {
  var nx;
  var ny;
  var nz;
  // Z = 1
  if (this.zOne) {
    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html
    //     #doubling-mdbl-2007-bl
    // 1M + 5S + 14A

    // XX = X1^2
    var xx = this.x.redSqr();
    // YY = Y1^2
    var yy = this.y.redSqr();
    // YYYY = YY^2
    var yyyy = yy.redSqr();
    // S = 2 * ((X1 + YY)^2 - XX - YYYY)
    var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
    s = s.redIAdd(s);
    // M = 3 * XX + a; a = 0
    var m = xx.redAdd(xx).redIAdd(xx);
    // T = M ^ 2 - 2*S
    var t = m.redSqr().redISub(s).redISub(s);

    // 8 * YYYY
    var yyyy8 = yyyy.redIAdd(yyyy);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    yyyy8 = yyyy8.redIAdd(yyyy8);

    // X3 = T
    nx = t;
    // Y3 = M * (S - T) - 8 * YYYY
    ny = m.redMul(s.redISub(t)).redISub(yyyy8);
    // Z3 = 2*Y1
    nz = this.y.redAdd(this.y);
  } else {
    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html
    //     #doubling-dbl-2009-l
    // 2M + 5S + 13A

    // A = X1^2
    var a = this.x.redSqr();
    // B = Y1^2
    var b = this.y.redSqr();
    // C = B^2
    var c = b.redSqr();
    // D = 2 * ((X1 + B)^2 - A - C)
    var d = this.x.redAdd(b).redSqr().redISub(a).redISub(c);
    d = d.redIAdd(d);
    // E = 3 * A
    var e = a.redAdd(a).redIAdd(a);
    // F = E^2
    var f = e.redSqr();

    // 8 * C
    var c8 = c.redIAdd(c);
    c8 = c8.redIAdd(c8);
    c8 = c8.redIAdd(c8);

    // X3 = F - 2 * D
    nx = f.redISub(d).redISub(d);
    // Y3 = E * (D - X3) - 8 * C
    ny = e.redMul(d.redISub(nx)).redISub(c8);
    // Z3 = 2 * Y1 * Z1
    nz = this.y.redMul(this.z);
    nz = nz.redIAdd(nz);
  }

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype._threeDbl = function _threeDbl() {
  var nx;
  var ny;
  var nz;
  // Z = 1
  if (this.zOne) {
    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-3.html
    //     #doubling-mdbl-2007-bl
    // 1M + 5S + 15A

    // XX = X1^2
    var xx = this.x.redSqr();
    // YY = Y1^2
    var yy = this.y.redSqr();
    // YYYY = YY^2
    var yyyy = yy.redSqr();
    // S = 2 * ((X1 + YY)^2 - XX - YYYY)
    var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
    s = s.redIAdd(s);
    // M = 3 * XX + a
    var m = xx.redAdd(xx).redIAdd(xx).redIAdd(this.curve.a);
    // T = M^2 - 2 * S
    var t = m.redSqr().redISub(s).redISub(s);
    // X3 = T
    nx = t;
    // Y3 = M * (S - T) - 8 * YYYY
    var yyyy8 = yyyy.redIAdd(yyyy);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    ny = m.redMul(s.redISub(t)).redISub(yyyy8);
    // Z3 = 2 * Y1
    nz = this.y.redAdd(this.y);
  } else {
    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-3.html#doubling-dbl-2001-b
    // 3M + 5S

    // delta = Z1^2
    var delta = this.z.redSqr();
    // gamma = Y1^2
    var gamma = this.y.redSqr();
    // beta = X1 * gamma
    var beta = this.x.redMul(gamma);
    // alpha = 3 * (X1 - delta) * (X1 + delta)
    var alpha = this.x.redSub(delta).redMul(this.x.redAdd(delta));
    alpha = alpha.redAdd(alpha).redIAdd(alpha);
    // X3 = alpha^2 - 8 * beta
    var beta4 = beta.redIAdd(beta);
    beta4 = beta4.redIAdd(beta4);
    var beta8 = beta4.redAdd(beta4);
    nx = alpha.redSqr().redISub(beta8);
    // Z3 = (Y1 + Z1)^2 - gamma - delta
    nz = this.y.redAdd(this.z).redSqr().redISub(gamma).redISub(delta);
    // Y3 = alpha * (4 * beta - X3) - 8 * gamma^2
    var ggamma8 = gamma.redSqr();
    ggamma8 = ggamma8.redIAdd(ggamma8);
    ggamma8 = ggamma8.redIAdd(ggamma8);
    ggamma8 = ggamma8.redIAdd(ggamma8);
    ny = alpha.redMul(beta4.redISub(nx)).redISub(ggamma8);
  }

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype._dbl = function _dbl() {
  var a = this.curve.a;

  // 4M + 6S + 10A
  var jx = this.x;
  var jy = this.y;
  var jz = this.z;
  var jz4 = jz.redSqr().redSqr();

  var jx2 = jx.redSqr();
  var jy2 = jy.redSqr();

  var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));

  var jxd4 = jx.redAdd(jx);
  jxd4 = jxd4.redIAdd(jxd4);
  var t1 = jxd4.redMul(jy2);
  var nx = c.redSqr().redISub(t1.redAdd(t1));
  var t2 = t1.redISub(nx);

  var jyd8 = jy2.redSqr();
  jyd8 = jyd8.redIAdd(jyd8);
  jyd8 = jyd8.redIAdd(jyd8);
  jyd8 = jyd8.redIAdd(jyd8);
  var ny = c.redMul(t2).redISub(jyd8);
  var nz = jy.redAdd(jy).redMul(jz);

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype.trpl = function trpl() {
  if (!this.curve.zeroA)
    return this.dbl().add(this);

  // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html#tripling-tpl-2007-bl
  // 5M + 10S + ...

  // XX = X1^2
  var xx = this.x.redSqr();
  // YY = Y1^2
  var yy = this.y.redSqr();
  // ZZ = Z1^2
  var zz = this.z.redSqr();
  // YYYY = YY^2
  var yyyy = yy.redSqr();
  // M = 3 * XX + a * ZZ2; a = 0
  var m = xx.redAdd(xx).redIAdd(xx);
  // MM = M^2
  var mm = m.redSqr();
  // E = 6 * ((X1 + YY)^2 - XX - YYYY) - MM
  var e = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
  e = e.redIAdd(e);
  e = e.redAdd(e).redIAdd(e);
  e = e.redISub(mm);
  // EE = E^2
  var ee = e.redSqr();
  // T = 16*YYYY
  var t = yyyy.redIAdd(yyyy);
  t = t.redIAdd(t);
  t = t.redIAdd(t);
  t = t.redIAdd(t);
  // U = (M + E)^2 - MM - EE - T
  var u = m.redIAdd(e).redSqr().redISub(mm).redISub(ee).redISub(t);
  // X3 = 4 * (X1 * EE - 4 * YY * U)
  var yyu4 = yy.redMul(u);
  yyu4 = yyu4.redIAdd(yyu4);
  yyu4 = yyu4.redIAdd(yyu4);
  var nx = this.x.redMul(ee).redISub(yyu4);
  nx = nx.redIAdd(nx);
  nx = nx.redIAdd(nx);
  // Y3 = 8 * Y1 * (U * (T - U) - E * EE)
  var ny = this.y.redMul(u.redMul(t.redISub(u)).redISub(e.redMul(ee)));
  ny = ny.redIAdd(ny);
  ny = ny.redIAdd(ny);
  ny = ny.redIAdd(ny);
  // Z3 = (Z1 + E)^2 - ZZ - EE
  var nz = this.z.redAdd(e).redSqr().redISub(zz).redISub(ee);

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype.mul = function mul(k, kbase) {
  k = new BN(k, kbase);

  return this.curve._wnafMul(this, k);
};

JPoint.prototype.eq = function eq(p) {
  if (p.type === 'affine')
    return this.eq(p.toJ());

  if (this === p)
    return true;

  // x1 * z2^2 == x2 * z1^2
  var z2 = this.z.redSqr();
  var pz2 = p.z.redSqr();
  if (this.x.redMul(pz2).redISub(p.x.redMul(z2)).cmpn(0) !== 0)
    return false;

  // y1 * z2^3 == y2 * z1^3
  var z3 = z2.redMul(this.z);
  var pz3 = pz2.redMul(p.z);
  return this.y.redMul(pz3).redISub(p.y.redMul(z3)).cmpn(0) === 0;
};

JPoint.prototype.eqXToP = function eqXToP(x) {
  var zs = this.z.redSqr();
  var rx = x.toRed(this.curve.red).redMul(zs);
  if (this.x.cmp(rx) === 0)
    return true;

  var xc = x.clone();
  var t = this.curve.redN.redMul(zs);
  for (;;) {
    xc.iadd(this.curve.n);
    if (xc.cmp(this.curve.p) >= 0)
      return false;

    rx.redIAdd(t);
    if (this.x.cmp(rx) === 0)
      return true;
  }
};

JPoint.prototype.inspect = function inspect() {
  if (this.isInfinity())
    return '<EC JPoint Infinity>';
  return '<EC JPoint x: ' + this.x.toString(16, 2) +
      ' y: ' + this.y.toString(16, 2) +
      ' z: ' + this.z.toString(16, 2) + '>';
};

JPoint.prototype.isInfinity = function isInfinity() {
  // XXX This code assumes that zero is always zero in red
  return this.z.cmpn(0) === 0;
};


/***/ }),

/***/ 480:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var curves = exports;

var hash = __webpack_require__(7952);
var curve = __webpack_require__(894);
var utils = __webpack_require__(7011);

var assert = utils.assert;

function PresetCurve(options) {
  if (options.type === 'short')
    this.curve = new curve.short(options);
  else if (options.type === 'edwards')
    this.curve = new curve.edwards(options);
  else
    this.curve = new curve.mont(options);
  this.g = this.curve.g;
  this.n = this.curve.n;
  this.hash = options.hash;

  assert(this.g.validate(), 'Invalid curve');
  assert(this.g.mul(this.n).isInfinity(), 'Invalid curve, G*N != O');
}
curves.PresetCurve = PresetCurve;

function defineCurve(name, options) {
  Object.defineProperty(curves, name, {
    configurable: true,
    enumerable: true,
    get: function() {
      var curve = new PresetCurve(options);
      Object.defineProperty(curves, name, {
        configurable: true,
        enumerable: true,
        value: curve,
      });
      return curve;
    },
  });
}

defineCurve('p192', {
  type: 'short',
  prime: 'p192',
  p: 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff',
  a: 'ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc',
  b: '64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1',
  n: 'ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831',
  hash: hash.sha256,
  gRed: false,
  g: [
    '188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012',
    '07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811',
  ],
});

defineCurve('p224', {
  type: 'short',
  prime: 'p224',
  p: 'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001',
  a: 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe',
  b: 'b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4',
  n: 'ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d',
  hash: hash.sha256,
  gRed: false,
  g: [
    'b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21',
    'bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34',
  ],
});

defineCurve('p256', {
  type: 'short',
  prime: null,
  p: 'ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff',
  a: 'ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc',
  b: '5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b',
  n: 'ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551',
  hash: hash.sha256,
  gRed: false,
  g: [
    '6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296',
    '4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5',
  ],
});

defineCurve('p384', {
  type: 'short',
  prime: null,
  p: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'fffffffe ffffffff 00000000 00000000 ffffffff',
  a: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'fffffffe ffffffff 00000000 00000000 fffffffc',
  b: 'b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f ' +
     '5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef',
  n: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 ' +
     'f4372ddf 581a0db2 48b0a77a ecec196a ccc52973',
  hash: hash.sha384,
  gRed: false,
  g: [
    'aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 ' +
    '5502f25d bf55296c 3a545e38 72760ab7',
    '3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 ' +
    '0a60b1ce 1d7e819d 7a431d7c 90ea0e5f',
  ],
});

defineCurve('p521', {
  type: 'short',
  prime: null,
  p: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'ffffffff ffffffff ffffffff ffffffff ffffffff',
  a: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'ffffffff ffffffff ffffffff ffffffff fffffffc',
  b: '00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b ' +
     '99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd ' +
     '3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00',
  n: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 ' +
     'f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409',
  hash: hash.sha512,
  gRed: false,
  g: [
    '000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 ' +
    '053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 ' +
    'a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66',
    '00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 ' +
    '579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 ' +
    '3fad0761 353c7086 a272c240 88be9476 9fd16650',
  ],
});

defineCurve('curve25519', {
  type: 'mont',
  prime: 'p25519',
  p: '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed',
  a: '76d06',
  b: '1',
  n: '1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed',
  hash: hash.sha256,
  gRed: false,
  g: [
    '9',
  ],
});

defineCurve('ed25519', {
  type: 'edwards',
  prime: 'p25519',
  p: '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed',
  a: '-1',
  c: '1',
  // -121665 * (121666^(-1)) (mod P)
  d: '52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3',
  n: '1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed',
  hash: hash.sha256,
  gRed: false,
  g: [
    '216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a',

    // 4/5
    '6666666666666666666666666666666666666666666666666666666666666658',
  ],
});

var pre;
try {
  pre = __webpack_require__(4011);
} catch (e) {
  pre = undefined;
}

defineCurve('secp256k1', {
  type: 'short',
  prime: 'k256',
  p: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f',
  a: '0',
  b: '7',
  n: 'ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141',
  h: '1',
  hash: hash.sha256,

  // Precomputed endomorphism
  beta: '7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee',
  lambda: '5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72',
  basis: [
    {
      a: '3086d221a7d46bcde86c90e49284eb15',
      b: '-e4437ed6010e88286f547fa90abfe4c3',
    },
    {
      a: '114ca50f7a8e2f3f657c1108d9d44cfd8',
      b: '3086d221a7d46bcde86c90e49284eb15',
    },
  ],

  gRed: false,
  g: [
    '79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798',
    '483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8',
    pre,
  ],
});


/***/ }),

/***/ 7447:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var BN = __webpack_require__(8490);
var HmacDRBG = __webpack_require__(2723);
var utils = __webpack_require__(7011);
var curves = __webpack_require__(480);
var rand = __webpack_require__(5037);
var assert = utils.assert;

var KeyPair = __webpack_require__(1200);
var Signature = __webpack_require__(8545);

function EC(options) {
  if (!(this instanceof EC))
    return new EC(options);

  // Shortcut `elliptic.ec(curve-name)`
  if (typeof options === 'string') {
    assert(Object.prototype.hasOwnProperty.call(curves, options),
      'Unknown curve ' + options);

    options = curves[options];
  }

  // Shortcut for `elliptic.ec(elliptic.curves.curveName)`
  if (options instanceof curves.PresetCurve)
    options = { curve: options };

  this.curve = options.curve.curve;
  this.n = this.curve.n;
  this.nh = this.n.ushrn(1);
  this.g = this.curve.g;

  // Point on curve
  this.g = options.curve.g;
  this.g.precompute(options.curve.n.bitLength() + 1);

  // Hash for function for DRBG
  this.hash = options.hash || options.curve.hash;
}
module.exports = EC;

EC.prototype.keyPair = function keyPair(options) {
  return new KeyPair(this, options);
};

EC.prototype.keyFromPrivate = function keyFromPrivate(priv, enc) {
  return KeyPair.fromPrivate(this, priv, enc);
};

EC.prototype.keyFromPublic = function keyFromPublic(pub, enc) {
  return KeyPair.fromPublic(this, pub, enc);
};

EC.prototype.genKeyPair = function genKeyPair(options) {
  if (!options)
    options = {};

  // Instantiate Hmac_DRBG
  var drbg = new HmacDRBG({
    hash: this.hash,
    pers: options.pers,
    persEnc: options.persEnc || 'utf8',
    entropy: options.entropy || rand(this.hash.hmacStrength),
    entropyEnc: options.entropy && options.entropyEnc || 'utf8',
    nonce: this.n.toArray(),
  });

  var bytes = this.n.byteLength();
  var ns2 = this.n.sub(new BN(2));
  for (;;) {
    var priv = new BN(drbg.generate(bytes));
    if (priv.cmp(ns2) > 0)
      continue;

    priv.iaddn(1);
    return this.keyFromPrivate(priv);
  }
};

EC.prototype._truncateToN = function _truncateToN(msg, truncOnly, bitLength) {
  var byteLength;
  if (BN.isBN(msg) || typeof msg === 'number') {
    msg = new BN(msg, 16);
    byteLength = msg.byteLength();
  } else if (typeof msg === 'object') {
    // BN assumes an array-like input and asserts length
    byteLength = msg.length;
    msg = new BN(msg, 16);
  } else {
    // BN converts the value to string
    var str = msg.toString();
    // HEX encoding
    byteLength = (str.length + 1) >>> 1;
    msg = new BN(str, 16);
  }
  // Allow overriding
  if (typeof bitLength !== 'number') {
    bitLength = byteLength * 8;
  }
  var delta = bitLength - this.n.bitLength();
  if (delta > 0)
    msg = msg.ushrn(delta);
  if (!truncOnly && msg.cmp(this.n) >= 0)
    return msg.sub(this.n);
  else
    return msg;
};

EC.prototype.sign = function sign(msg, key, enc, options) {
  if (typeof enc === 'object') {
    options = enc;
    enc = null;
  }
  if (!options)
    options = {};

  if (typeof msg !== 'string' && typeof msg !== 'number' && !BN.isBN(msg)) {
    assert(typeof msg === 'object' && msg && typeof msg.length === 'number',
      'Expected message to be an array-like, a hex string, or a BN instance');
    assert((msg.length >>> 0) === msg.length); // non-negative 32-bit integer
    for (var i = 0; i < msg.length; i++) assert((msg[i] & 255) === msg[i]);
  }

  key = this.keyFromPrivate(key, enc);
  msg = this._truncateToN(msg, false, options.msgBitLength);

  // Would fail further checks, but let's make the error message clear
  assert(!msg.isNeg(), 'Can not sign a negative message');

  // Zero-extend key to provide enough entropy
  var bytes = this.n.byteLength();
  var bkey = key.getPrivate().toArray('be', bytes);

  // Zero-extend nonce to have the same byte size as N
  var nonce = msg.toArray('be', bytes);

  // Recheck nonce to be bijective to msg
  assert((new BN(nonce)).eq(msg), 'Can not sign message');

  // Instantiate Hmac_DRBG
  var drbg = new HmacDRBG({
    hash: this.hash,
    entropy: bkey,
    nonce: nonce,
    pers: options.pers,
    persEnc: options.persEnc || 'utf8',
  });

  // Number of bytes to generate
  var ns1 = this.n.sub(new BN(1));

  for (var iter = 0; ; iter++) {
    var k = options.k ?
      options.k(iter) :
      new BN(drbg.generate(this.n.byteLength()));
    k = this._truncateToN(k, true);
    if (k.cmpn(1) <= 0 || k.cmp(ns1) >= 0)
      continue;

    var kp = this.g.mul(k);
    if (kp.isInfinity())
      continue;

    var kpX = kp.getX();
    var r = kpX.umod(this.n);
    if (r.cmpn(0) === 0)
      continue;

    var s = k.invm(this.n).mul(r.mul(key.getPrivate()).iadd(msg));
    s = s.umod(this.n);
    if (s.cmpn(0) === 0)
      continue;

    var recoveryParam = (kp.getY().isOdd() ? 1 : 0) |
                        (kpX.cmp(r) !== 0 ? 2 : 0);

    // Use complement of `s`, if it is > `n / 2`
    if (options.canonical && s.cmp(this.nh) > 0) {
      s = this.n.sub(s);
      recoveryParam ^= 1;
    }

    return new Signature({ r: r, s: s, recoveryParam: recoveryParam });
  }
};

EC.prototype.verify = function verify(msg, signature, key, enc, options) {
  if (!options)
    options = {};

  msg = this._truncateToN(msg, false, options.msgBitLength);
  key = this.keyFromPublic(key, enc);
  signature = new Signature(signature, 'hex');

  // Perform primitive values validation
  var r = signature.r;
  var s = signature.s;
  if (r.cmpn(1) < 0 || r.cmp(this.n) >= 0)
    return false;
  if (s.cmpn(1) < 0 || s.cmp(this.n) >= 0)
    return false;

  // Validate signature
  var sinv = s.invm(this.n);
  var u1 = sinv.mul(msg).umod(this.n);
  var u2 = sinv.mul(r).umod(this.n);
  var p;

  if (!this.curve._maxwellTrick) {
    p = this.g.mulAdd(u1, key.getPublic(), u2);
    if (p.isInfinity())
      return false;

    return p.getX().umod(this.n).cmp(r) === 0;
  }

  // NOTE: Greg Maxwell's trick, inspired by:
  // https://git.io/vad3K

  p = this.g.jmulAdd(u1, key.getPublic(), u2);
  if (p.isInfinity())
    return false;

  // Compare `p.x` of Jacobian point with `r`,
  // this will do `p.x == r * p.z^2` instead of multiplying `p.x` by the
  // inverse of `p.z^2`
  return p.eqXToP(r);
};

EC.prototype.recoverPubKey = function(msg, signature, j, enc) {
  assert((3 & j) === j, 'The recovery param is more than two bits');
  signature = new Signature(signature, enc);

  var n = this.n;
  var e = new BN(msg);
  var r = signature.r;
  var s = signature.s;

  // A set LSB signifies that the y-coordinate is odd
  var isYOdd = j & 1;
  var isSecondKey = j >> 1;
  if (r.cmp(this.curve.p.umod(this.curve.n)) >= 0 && isSecondKey)
    throw new Error('Unable to find sencond key candinate');

  // 1.1. Let x = r + jn.
  if (isSecondKey)
    r = this.curve.pointFromX(r.add(this.curve.n), isYOdd);
  else
    r = this.curve.pointFromX(r, isYOdd);

  var rInv = signature.r.invm(n);
  var s1 = n.sub(e).mul(rInv).umod(n);
  var s2 = s.mul(rInv).umod(n);

  // 1.6.1 Compute Q = r^-1 (sR -  eG)
  //               Q = r^-1 (sR + -eG)
  return this.g.mulAdd(s1, r, s2);
};

EC.prototype.getKeyRecoveryParam = function(e, signature, Q, enc) {
  signature = new Signature(signature, enc);
  if (signature.recoveryParam !== null)
    return signature.recoveryParam;

  for (var i = 0; i < 4; i++) {
    var Qprime;
    try {
      Qprime = this.recoverPubKey(e, signature, i);
    } catch (e) {
      continue;
    }

    if (Qprime.eq(Q))
      return i;
  }
  throw new Error('Unable to find valid recovery factor');
};


/***/ }),

/***/ 1200:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var BN = __webpack_require__(8490);
var utils = __webpack_require__(7011);
var assert = utils.assert;

function KeyPair(ec, options) {
  this.ec = ec;
  this.priv = null;
  this.pub = null;

  // KeyPair(ec, { priv: ..., pub: ... })
  if (options.priv)
    this._importPrivate(options.priv, options.privEnc);
  if (options.pub)
    this._importPublic(options.pub, options.pubEnc);
}
module.exports = KeyPair;

KeyPair.fromPublic = function fromPublic(ec, pub, enc) {
  if (pub instanceof KeyPair)
    return pub;

  return new KeyPair(ec, {
    pub: pub,
    pubEnc: enc,
  });
};

KeyPair.fromPrivate = function fromPrivate(ec, priv, enc) {
  if (priv instanceof KeyPair)
    return priv;

  return new KeyPair(ec, {
    priv: priv,
    privEnc: enc,
  });
};

KeyPair.prototype.validate = function validate() {
  var pub = this.getPublic();

  if (pub.isInfinity())
    return { result: false, reason: 'Invalid public key' };
  if (!pub.validate())
    return { result: false, reason: 'Public key is not a point' };
  if (!pub.mul(this.ec.curve.n).isInfinity())
    return { result: false, reason: 'Public key * N != O' };

  return { result: true, reason: null };
};

KeyPair.prototype.getPublic = function getPublic(compact, enc) {
  // compact is optional argument
  if (typeof compact === 'string') {
    enc = compact;
    compact = null;
  }

  if (!this.pub)
    this.pub = this.ec.g.mul(this.priv);

  if (!enc)
    return this.pub;

  return this.pub.encode(enc, compact);
};

KeyPair.prototype.getPrivate = function getPrivate(enc) {
  if (enc === 'hex')
    return this.priv.toString(16, 2);
  else
    return this.priv;
};

KeyPair.prototype._importPrivate = function _importPrivate(key, enc) {
  this.priv = new BN(key, enc || 16);

  // Ensure that the priv won't be bigger than n, otherwise we may fail
  // in fixed multiplication method
  this.priv = this.priv.umod(this.ec.curve.n);
};

KeyPair.prototype._importPublic = function _importPublic(key, enc) {
  if (key.x || key.y) {
    // Montgomery points only have an `x` coordinate.
    // Weierstrass/Edwards points on the other hand have both `x` and
    // `y` coordinates.
    if (this.ec.curve.type === 'mont') {
      assert(key.x, 'Need x coordinate');
    } else if (this.ec.curve.type === 'short' ||
               this.ec.curve.type === 'edwards') {
      assert(key.x && key.y, 'Need both x and y coordinate');
    }
    this.pub = this.ec.curve.point(key.x, key.y);
    return;
  }
  this.pub = this.ec.curve.decodePoint(key, enc);
};

// ECDH
KeyPair.prototype.derive = function derive(pub) {
  if(!pub.validate()) {
    assert(pub.validate(), 'public point not validated');
  }
  return pub.mul(this.priv).getX();
};

// ECDSA
KeyPair.prototype.sign = function sign(msg, enc, options) {
  return this.ec.sign(msg, this, enc, options);
};

KeyPair.prototype.verify = function verify(msg, signature, options) {
  return this.ec.verify(msg, signature, this, undefined, options);
};

KeyPair.prototype.inspect = function inspect() {
  return '<Key priv: ' + (this.priv && this.priv.toString(16, 2)) +
         ' pub: ' + (this.pub && this.pub.inspect()) + ' >';
};


/***/ }),

/***/ 8545:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var BN = __webpack_require__(8490);

var utils = __webpack_require__(7011);
var assert = utils.assert;

function Signature(options, enc) {
  if (options instanceof Signature)
    return options;

  if (this._importDER(options, enc))
    return;

  assert(options.r && options.s, 'Signature without r or s');
  this.r = new BN(options.r, 16);
  this.s = new BN(options.s, 16);
  if (options.recoveryParam === undefined)
    this.recoveryParam = null;
  else
    this.recoveryParam = options.recoveryParam;
}
module.exports = Signature;

function Position() {
  this.place = 0;
}

function getLength(buf, p) {
  var initial = buf[p.place++];
  if (!(initial & 0x80)) {
    return initial;
  }
  var octetLen = initial & 0xf;

  // Indefinite length or overflow
  if (octetLen === 0 || octetLen > 4) {
    return false;
  }

  if(buf[p.place] === 0x00) {
    return false;
  }

  var val = 0;
  for (var i = 0, off = p.place; i < octetLen; i++, off++) {
    val <<= 8;
    val |= buf[off];
    val >>>= 0;
  }

  // Leading zeroes
  if (val <= 0x7f) {
    return false;
  }

  p.place = off;
  return val;
}

function rmPadding(buf) {
  var i = 0;
  var len = buf.length - 1;
  while (!buf[i] && !(buf[i + 1] & 0x80) && i < len) {
    i++;
  }
  if (i === 0) {
    return buf;
  }
  return buf.slice(i);
}

Signature.prototype._importDER = function _importDER(data, enc) {
  data = utils.toArray(data, enc);
  var p = new Position();
  if (data[p.place++] !== 0x30) {
    return false;
  }
  var len = getLength(data, p);
  if (len === false) {
    return false;
  }
  if ((len + p.place) !== data.length) {
    return false;
  }
  if (data[p.place++] !== 0x02) {
    return false;
  }
  var rlen = getLength(data, p);
  if (rlen === false) {
    return false;
  }
  if ((data[p.place] & 128) !== 0) {
    return false;
  }
  var r = data.slice(p.place, rlen + p.place);
  p.place += rlen;
  if (data[p.place++] !== 0x02) {
    return false;
  }
  var slen = getLength(data, p);
  if (slen === false) {
    return false;
  }
  if (data.length !== slen + p.place) {
    return false;
  }
  if ((data[p.place] & 128) !== 0) {
    return false;
  }
  var s = data.slice(p.place, slen + p.place);
  if (r[0] === 0) {
    if (r[1] & 0x80) {
      r = r.slice(1);
    } else {
      // Leading zeroes
      return false;
    }
  }
  if (s[0] === 0) {
    if (s[1] & 0x80) {
      s = s.slice(1);
    } else {
      // Leading zeroes
      return false;
    }
  }

  this.r = new BN(r);
  this.s = new BN(s);
  this.recoveryParam = null;

  return true;
};

function constructLength(arr, len) {
  if (len < 0x80) {
    arr.push(len);
    return;
  }
  var octets = 1 + (Math.log(len) / Math.LN2 >>> 3);
  arr.push(octets | 0x80);
  while (--octets) {
    arr.push((len >>> (octets << 3)) & 0xff);
  }
  arr.push(len);
}

Signature.prototype.toDER = function toDER(enc) {
  var r = this.r.toArray();
  var s = this.s.toArray();

  // Pad values
  if (r[0] & 0x80)
    r = [ 0 ].concat(r);
  // Pad values
  if (s[0] & 0x80)
    s = [ 0 ].concat(s);

  r = rmPadding(r);
  s = rmPadding(s);

  while (!s[0] && !(s[1] & 0x80)) {
    s = s.slice(1);
  }
  var arr = [ 0x02 ];
  constructLength(arr, r.length);
  arr = arr.concat(r);
  arr.push(0x02);
  constructLength(arr, s.length);
  var backHalf = arr.concat(s);
  var res = [ 0x30 ];
  constructLength(res, backHalf.length);
  res = res.concat(backHalf);
  return utils.encode(res, enc);
};


/***/ }),

/***/ 8650:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var hash = __webpack_require__(7952);
var curves = __webpack_require__(480);
var utils = __webpack_require__(7011);
var assert = utils.assert;
var parseBytes = utils.parseBytes;
var KeyPair = __webpack_require__(6661);
var Signature = __webpack_require__(220);

function EDDSA(curve) {
  assert(curve === 'ed25519', 'only tested with ed25519 so far');

  if (!(this instanceof EDDSA))
    return new EDDSA(curve);

  curve = curves[curve].curve;
  this.curve = curve;
  this.g = curve.g;
  this.g.precompute(curve.n.bitLength() + 1);

  this.pointClass = curve.point().constructor;
  this.encodingLength = Math.ceil(curve.n.bitLength() / 8);
  this.hash = hash.sha512;
}

module.exports = EDDSA;

/**
* @param {Array|String} message - message bytes
* @param {Array|String|KeyPair} secret - secret bytes or a keypair
* @returns {Signature} - signature
*/
EDDSA.prototype.sign = function sign(message, secret) {
  message = parseBytes(message);
  var key = this.keyFromSecret(secret);
  var r = this.hashInt(key.messagePrefix(), message);
  var R = this.g.mul(r);
  var Rencoded = this.encodePoint(R);
  var s_ = this.hashInt(Rencoded, key.pubBytes(), message)
    .mul(key.priv());
  var S = r.add(s_).umod(this.curve.n);
  return this.makeSignature({ R: R, S: S, Rencoded: Rencoded });
};

/**
* @param {Array} message - message bytes
* @param {Array|String|Signature} sig - sig bytes
* @param {Array|String|Point|KeyPair} pub - public key
* @returns {Boolean} - true if public key matches sig of message
*/
EDDSA.prototype.verify = function verify(message, sig, pub) {
  message = parseBytes(message);
  sig = this.makeSignature(sig);
  if (sig.S().gte(sig.eddsa.curve.n) || sig.S().isNeg()) {
    return false;
  }
  var key = this.keyFromPublic(pub);
  var h = this.hashInt(sig.Rencoded(), key.pubBytes(), message);
  var SG = this.g.mul(sig.S());
  var RplusAh = sig.R().add(key.pub().mul(h));
  return RplusAh.eq(SG);
};

EDDSA.prototype.hashInt = function hashInt() {
  var hash = this.hash();
  for (var i = 0; i < arguments.length; i++)
    hash.update(arguments[i]);
  return utils.intFromLE(hash.digest()).umod(this.curve.n);
};

EDDSA.prototype.keyFromPublic = function keyFromPublic(pub) {
  return KeyPair.fromPublic(this, pub);
};

EDDSA.prototype.keyFromSecret = function keyFromSecret(secret) {
  return KeyPair.fromSecret(this, secret);
};

EDDSA.prototype.makeSignature = function makeSignature(sig) {
  if (sig instanceof Signature)
    return sig;
  return new Signature(this, sig);
};

/**
* * https://tools.ietf.org/html/draft-josefsson-eddsa-ed25519-03#section-5.2
*
* EDDSA defines methods for encoding and decoding points and integers. These are
* helper convenience methods, that pass along to utility functions implied
* parameters.
*
*/
EDDSA.prototype.encodePoint = function encodePoint(point) {
  var enc = point.getY().toArray('le', this.encodingLength);
  enc[this.encodingLength - 1] |= point.getX().isOdd() ? 0x80 : 0;
  return enc;
};

EDDSA.prototype.decodePoint = function decodePoint(bytes) {
  bytes = utils.parseBytes(bytes);

  var lastIx = bytes.length - 1;
  var normed = bytes.slice(0, lastIx).concat(bytes[lastIx] & ~0x80);
  var xIsOdd = (bytes[lastIx] & 0x80) !== 0;

  var y = utils.intFromLE(normed);
  return this.curve.pointFromY(y, xIsOdd);
};

EDDSA.prototype.encodeInt = function encodeInt(num) {
  return num.toArray('le', this.encodingLength);
};

EDDSA.prototype.decodeInt = function decodeInt(bytes) {
  return utils.intFromLE(bytes);
};

EDDSA.prototype.isPoint = function isPoint(val) {
  return val instanceof this.pointClass;
};


/***/ }),

/***/ 6661:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(7011);
var assert = utils.assert;
var parseBytes = utils.parseBytes;
var cachedProperty = utils.cachedProperty;

/**
* @param {EDDSA} eddsa - instance
* @param {Object} params - public/private key parameters
*
* @param {Array<Byte>} [params.secret] - secret seed bytes
* @param {Point} [params.pub] - public key point (aka `A` in eddsa terms)
* @param {Array<Byte>} [params.pub] - public key point encoded as bytes
*
*/
function KeyPair(eddsa, params) {
  this.eddsa = eddsa;
  this._secret = parseBytes(params.secret);
  if (eddsa.isPoint(params.pub))
    this._pub = params.pub;
  else
    this._pubBytes = parseBytes(params.pub);
}

KeyPair.fromPublic = function fromPublic(eddsa, pub) {
  if (pub instanceof KeyPair)
    return pub;
  return new KeyPair(eddsa, { pub: pub });
};

KeyPair.fromSecret = function fromSecret(eddsa, secret) {
  if (secret instanceof KeyPair)
    return secret;
  return new KeyPair(eddsa, { secret: secret });
};

KeyPair.prototype.secret = function secret() {
  return this._secret;
};

cachedProperty(KeyPair, 'pubBytes', function pubBytes() {
  return this.eddsa.encodePoint(this.pub());
});

cachedProperty(KeyPair, 'pub', function pub() {
  if (this._pubBytes)
    return this.eddsa.decodePoint(this._pubBytes);
  return this.eddsa.g.mul(this.priv());
});

cachedProperty(KeyPair, 'privBytes', function privBytes() {
  var eddsa = this.eddsa;
  var hash = this.hash();
  var lastIx = eddsa.encodingLength - 1;

  var a = hash.slice(0, eddsa.encodingLength);
  a[0] &= 248;
  a[lastIx] &= 127;
  a[lastIx] |= 64;

  return a;
});

cachedProperty(KeyPair, 'priv', function priv() {
  return this.eddsa.decodeInt(this.privBytes());
});

cachedProperty(KeyPair, 'hash', function hash() {
  return this.eddsa.hash().update(this.secret()).digest();
});

cachedProperty(KeyPair, 'messagePrefix', function messagePrefix() {
  return this.hash().slice(this.eddsa.encodingLength);
});

KeyPair.prototype.sign = function sign(message) {
  assert(this._secret, 'KeyPair can only verify');
  return this.eddsa.sign(message, this);
};

KeyPair.prototype.verify = function verify(message, sig) {
  return this.eddsa.verify(message, sig, this);
};

KeyPair.prototype.getSecret = function getSecret(enc) {
  assert(this._secret, 'KeyPair is public only');
  return utils.encode(this.secret(), enc);
};

KeyPair.prototype.getPublic = function getPublic(enc) {
  return utils.encode(this.pubBytes(), enc);
};

module.exports = KeyPair;


/***/ }),

/***/ 220:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var BN = __webpack_require__(8490);
var utils = __webpack_require__(7011);
var assert = utils.assert;
var cachedProperty = utils.cachedProperty;
var parseBytes = utils.parseBytes;

/**
* @param {EDDSA} eddsa - eddsa instance
* @param {Array<Bytes>|Object} sig -
* @param {Array<Bytes>|Point} [sig.R] - R point as Point or bytes
* @param {Array<Bytes>|bn} [sig.S] - S scalar as bn or bytes
* @param {Array<Bytes>} [sig.Rencoded] - R point encoded
* @param {Array<Bytes>} [sig.Sencoded] - S scalar encoded
*/
function Signature(eddsa, sig) {
  this.eddsa = eddsa;

  if (typeof sig !== 'object')
    sig = parseBytes(sig);

  if (Array.isArray(sig)) {
    assert(sig.length === eddsa.encodingLength * 2, 'Signature has invalid size');
    sig = {
      R: sig.slice(0, eddsa.encodingLength),
      S: sig.slice(eddsa.encodingLength),
    };
  }

  assert(sig.R && sig.S, 'Signature without R or S');

  if (eddsa.isPoint(sig.R))
    this._R = sig.R;
  if (sig.S instanceof BN)
    this._S = sig.S;

  this._Rencoded = Array.isArray(sig.R) ? sig.R : sig.Rencoded;
  this._Sencoded = Array.isArray(sig.S) ? sig.S : sig.Sencoded;
}

cachedProperty(Signature, 'S', function S() {
  return this.eddsa.decodeInt(this.Sencoded());
});

cachedProperty(Signature, 'R', function R() {
  return this.eddsa.decodePoint(this.Rencoded());
});

cachedProperty(Signature, 'Rencoded', function Rencoded() {
  return this.eddsa.encodePoint(this.R());
});

cachedProperty(Signature, 'Sencoded', function Sencoded() {
  return this.eddsa.encodeInt(this.S());
});

Signature.prototype.toBytes = function toBytes() {
  return this.Rencoded().concat(this.Sencoded());
};

Signature.prototype.toHex = function toHex() {
  return utils.encode(this.toBytes(), 'hex').toUpperCase();
};

module.exports = Signature;


/***/ }),

/***/ 4011:
/***/ ((module) => {

module.exports = {
  doubles: {
    step: 4,
    points: [
      [
        'e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a',
        'f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821',
      ],
      [
        '8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508',
        '11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf',
      ],
      [
        '175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739',
        'd3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695',
      ],
      [
        '363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640',
        '4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9',
      ],
      [
        '8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c',
        '4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36',
      ],
      [
        '723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda',
        '96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f',
      ],
      [
        'eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa',
        '5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999',
      ],
      [
        '100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0',
        'cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09',
      ],
      [
        'e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d',
        '9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d',
      ],
      [
        'feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d',
        'e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088',
      ],
      [
        'da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1',
        '9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d',
      ],
      [
        '53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0',
        '5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8',
      ],
      [
        '8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047',
        '10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a',
      ],
      [
        '385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862',
        '283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453',
      ],
      [
        '6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7',
        '7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160',
      ],
      [
        '3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd',
        '56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0',
      ],
      [
        '85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83',
        '7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6',
      ],
      [
        '948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a',
        '53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589',
      ],
      [
        '6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8',
        'bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17',
      ],
      [
        'e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d',
        '4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda',
      ],
      [
        'e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725',
        '7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd',
      ],
      [
        '213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754',
        '4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2',
      ],
      [
        '4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c',
        '17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6',
      ],
      [
        'fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6',
        '6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f',
      ],
      [
        '76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39',
        'c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01',
      ],
      [
        'c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891',
        '893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3',
      ],
      [
        'd895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b',
        'febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f',
      ],
      [
        'b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03',
        '2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7',
      ],
      [
        'e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d',
        'eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78',
      ],
      [
        'a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070',
        '7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1',
      ],
      [
        '90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4',
        'e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150',
      ],
      [
        '8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da',
        '662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82',
      ],
      [
        'e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11',
        '1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc',
      ],
      [
        '8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e',
        'efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b',
      ],
      [
        'e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41',
        '2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51',
      ],
      [
        'b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef',
        '67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45',
      ],
      [
        'd68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8',
        'db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120',
      ],
      [
        '324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d',
        '648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84',
      ],
      [
        '4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96',
        '35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d',
      ],
      [
        '9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd',
        'ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d',
      ],
      [
        '6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5',
        '9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8',
      ],
      [
        'a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266',
        '40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8',
      ],
      [
        '7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71',
        '34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac',
      ],
      [
        '928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac',
        'c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f',
      ],
      [
        '85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751',
        '1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962',
      ],
      [
        'ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e',
        '493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907',
      ],
      [
        '827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241',
        'c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec',
      ],
      [
        'eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3',
        'be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d',
      ],
      [
        'e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f',
        '4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414',
      ],
      [
        '1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19',
        'aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd',
      ],
      [
        '146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be',
        'b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0',
      ],
      [
        'fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9',
        '6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811',
      ],
      [
        'da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2',
        '8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1',
      ],
      [
        'a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13',
        '7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c',
      ],
      [
        '174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c',
        'ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73',
      ],
      [
        '959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba',
        '2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd',
      ],
      [
        'd2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151',
        'e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405',
      ],
      [
        '64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073',
        'd99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589',
      ],
      [
        '8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458',
        '38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e',
      ],
      [
        '13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b',
        '69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27',
      ],
      [
        'bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366',
        'd3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1',
      ],
      [
        '8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa',
        '40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482',
      ],
      [
        '8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0',
        '620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945',
      ],
      [
        'dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787',
        '7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573',
      ],
      [
        'f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e',
        'ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82',
      ],
    ],
  },
  naf: {
    wnd: 7,
    points: [
      [
        'f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9',
        '388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672',
      ],
      [
        '2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4',
        'd8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6',
      ],
      [
        '5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc',
        '6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da',
      ],
      [
        'acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe',
        'cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37',
      ],
      [
        '774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb',
        'd984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b',
      ],
      [
        'f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8',
        'ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81',
      ],
      [
        'd7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e',
        '581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58',
      ],
      [
        'defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34',
        '4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77',
      ],
      [
        '2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c',
        '85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a',
      ],
      [
        '352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5',
        '321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c',
      ],
      [
        '2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f',
        '2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67',
      ],
      [
        '9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714',
        '73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402',
      ],
      [
        'daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729',
        'a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55',
      ],
      [
        'c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db',
        '2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482',
      ],
      [
        '6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4',
        'e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82',
      ],
      [
        '1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5',
        'b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396',
      ],
      [
        '605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479',
        '2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49',
      ],
      [
        '62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d',
        '80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf',
      ],
      [
        '80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f',
        '1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a',
      ],
      [
        '7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb',
        'd0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7',
      ],
      [
        'd528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9',
        'eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933',
      ],
      [
        '49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963',
        '758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a',
      ],
      [
        '77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74',
        '958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6',
      ],
      [
        'f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530',
        'e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37',
      ],
      [
        '463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b',
        '5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e',
      ],
      [
        'f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247',
        'cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6',
      ],
      [
        'caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1',
        'cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476',
      ],
      [
        '2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120',
        '4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40',
      ],
      [
        '7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435',
        '91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61',
      ],
      [
        '754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18',
        '673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683',
      ],
      [
        'e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8',
        '59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5',
      ],
      [
        '186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb',
        '3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b',
      ],
      [
        'df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f',
        '55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417',
      ],
      [
        '5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143',
        'efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868',
      ],
      [
        '290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba',
        'e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a',
      ],
      [
        'af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45',
        'f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6',
      ],
      [
        '766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a',
        '744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996',
      ],
      [
        '59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e',
        'c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e',
      ],
      [
        'f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8',
        'e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d',
      ],
      [
        '7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c',
        '30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2',
      ],
      [
        '948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519',
        'e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e',
      ],
      [
        '7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab',
        '100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437',
      ],
      [
        '3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca',
        'ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311',
      ],
      [
        'd3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf',
        '8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4',
      ],
      [
        '1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610',
        '68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575',
      ],
      [
        '733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4',
        'f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d',
      ],
      [
        '15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c',
        'd56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d',
      ],
      [
        'a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940',
        'edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629',
      ],
      [
        'e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980',
        'a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06',
      ],
      [
        '311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3',
        '66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374',
      ],
      [
        '34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf',
        '9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee',
      ],
      [
        'f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63',
        '4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1',
      ],
      [
        'd7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448',
        'fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b',
      ],
      [
        '32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf',
        '5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661',
      ],
      [
        '7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5',
        '8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6',
      ],
      [
        'ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6',
        '8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e',
      ],
      [
        '16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5',
        '5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d',
      ],
      [
        'eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99',
        'f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc',
      ],
      [
        '78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51',
        'f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4',
      ],
      [
        '494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5',
        '42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c',
      ],
      [
        'a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5',
        '204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b',
      ],
      [
        'c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997',
        '4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913',
      ],
      [
        '841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881',
        '73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154',
      ],
      [
        '5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5',
        '39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865',
      ],
      [
        '36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66',
        'd2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc',
      ],
      [
        '336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726',
        'ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224',
      ],
      [
        '8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede',
        '6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e',
      ],
      [
        '1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94',
        '60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6',
      ],
      [
        '85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31',
        '3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511',
      ],
      [
        '29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51',
        'b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b',
      ],
      [
        'a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252',
        'ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2',
      ],
      [
        '4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5',
        'cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c',
      ],
      [
        'd24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b',
        '6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3',
      ],
      [
        'ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4',
        '322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d',
      ],
      [
        'af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f',
        '6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700',
      ],
      [
        'e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889',
        '2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4',
      ],
      [
        '591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246',
        'b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196',
      ],
      [
        '11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984',
        '998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4',
      ],
      [
        '3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a',
        'b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257',
      ],
      [
        'cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030',
        'bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13',
      ],
      [
        'c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197',
        '6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096',
      ],
      [
        'c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593',
        'c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38',
      ],
      [
        'a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef',
        '21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f',
      ],
      [
        '347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38',
        '60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448',
      ],
      [
        'da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a',
        '49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a',
      ],
      [
        'c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111',
        '5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4',
      ],
      [
        '4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502',
        '7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437',
      ],
      [
        '3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea',
        'be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7',
      ],
      [
        'cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26',
        '8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d',
      ],
      [
        'b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986',
        '39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a',
      ],
      [
        'd4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e',
        '62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54',
      ],
      [
        '48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4',
        '25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77',
      ],
      [
        'dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda',
        'ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517',
      ],
      [
        '6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859',
        'cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10',
      ],
      [
        'e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f',
        'f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125',
      ],
      [
        'eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c',
        '6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e',
      ],
      [
        '13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942',
        'fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1',
      ],
      [
        'ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a',
        '1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2',
      ],
      [
        'b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80',
        '5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423',
      ],
      [
        'ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d',
        '438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8',
      ],
      [
        '8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1',
        'cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758',
      ],
      [
        '52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63',
        'c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375',
      ],
      [
        'e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352',
        '6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d',
      ],
      [
        '7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193',
        'ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec',
      ],
      [
        '5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00',
        '9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0',
      ],
      [
        '32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58',
        'ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c',
      ],
      [
        'e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7',
        'd3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4',
      ],
      [
        '8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8',
        'c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f',
      ],
      [
        '4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e',
        '67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649',
      ],
      [
        '3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d',
        'cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826',
      ],
      [
        '674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b',
        '299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5',
      ],
      [
        'd32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f',
        'f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87',
      ],
      [
        '30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6',
        '462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b',
      ],
      [
        'be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297',
        '62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc',
      ],
      [
        '93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a',
        '7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c',
      ],
      [
        'b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c',
        'ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f',
      ],
      [
        'd5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52',
        '4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a',
      ],
      [
        'd3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb',
        'bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46',
      ],
      [
        '463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065',
        'bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f',
      ],
      [
        '7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917',
        '603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03',
      ],
      [
        '74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9',
        'cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08',
      ],
      [
        '30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3',
        '553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8',
      ],
      [
        '9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57',
        '712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373',
      ],
      [
        '176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66',
        'ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3',
      ],
      [
        '75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8',
        '9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8',
      ],
      [
        '809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721',
        '9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1',
      ],
      [
        '1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180',
        '4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9',
      ],
    ],
  },
};


/***/ }),

/***/ 7011:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var utils = exports;
var BN = __webpack_require__(8490);
var minAssert = __webpack_require__(3349);
var minUtils = __webpack_require__(4367);

utils.assert = minAssert;
utils.toArray = minUtils.toArray;
utils.zero2 = minUtils.zero2;
utils.toHex = minUtils.toHex;
utils.encode = minUtils.encode;

// Represent num in a w-NAF form
function getNAF(num, w, bits) {
  var naf = new Array(Math.max(num.bitLength(), bits) + 1);
  var i;
  for (i = 0; i < naf.length; i += 1) {
    naf[i] = 0;
  }

  var ws = 1 << (w + 1);
  var k = num.clone();

  for (i = 0; i < naf.length; i++) {
    var z;
    var mod = k.andln(ws - 1);
    if (k.isOdd()) {
      if (mod > (ws >> 1) - 1)
        z = (ws >> 1) - mod;
      else
        z = mod;
      k.isubn(z);
    } else {
      z = 0;
    }

    naf[i] = z;
    k.iushrn(1);
  }

  return naf;
}
utils.getNAF = getNAF;

// Represent k1, k2 in a Joint Sparse Form
function getJSF(k1, k2) {
  var jsf = [
    [],
    [],
  ];

  k1 = k1.clone();
  k2 = k2.clone();
  var d1 = 0;
  var d2 = 0;
  var m8;
  while (k1.cmpn(-d1) > 0 || k2.cmpn(-d2) > 0) {
    // First phase
    var m14 = (k1.andln(3) + d1) & 3;
    var m24 = (k2.andln(3) + d2) & 3;
    if (m14 === 3)
      m14 = -1;
    if (m24 === 3)
      m24 = -1;
    var u1;
    if ((m14 & 1) === 0) {
      u1 = 0;
    } else {
      m8 = (k1.andln(7) + d1) & 7;
      if ((m8 === 3 || m8 === 5) && m24 === 2)
        u1 = -m14;
      else
        u1 = m14;
    }
    jsf[0].push(u1);

    var u2;
    if ((m24 & 1) === 0) {
      u2 = 0;
    } else {
      m8 = (k2.andln(7) + d2) & 7;
      if ((m8 === 3 || m8 === 5) && m14 === 2)
        u2 = -m24;
      else
        u2 = m24;
    }
    jsf[1].push(u2);

    // Second phase
    if (2 * d1 === u1 + 1)
      d1 = 1 - d1;
    if (2 * d2 === u2 + 1)
      d2 = 1 - d2;
    k1.iushrn(1);
    k2.iushrn(1);
  }

  return jsf;
}
utils.getJSF = getJSF;

function cachedProperty(obj, name, computer) {
  var key = '_' + name;
  obj.prototype[name] = function cachedProperty() {
    return this[key] !== undefined ? this[key] :
      this[key] = computer.call(this);
  };
}
utils.cachedProperty = cachedProperty;

function parseBytes(bytes) {
  return typeof bytes === 'string' ? utils.toArray(bytes, 'hex') :
    bytes;
}
utils.parseBytes = parseBytes;

function intFromLE(bytes) {
  return new BN(bytes, 'hex', 'le');
}
utils.intFromLE = intFromLE;



/***/ }),

/***/ 8490:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

/* module decorator */ module = __webpack_require__.nmd(module);
(function (module, exports) {
  'use strict';

  // Utils
  function assert (val, msg) {
    if (!val) throw new Error(msg || 'Assertion failed');
  }

  // Could use `inherits` module, but don't want to move from single file
  // architecture yet.
  function inherits (ctor, superCtor) {
    ctor.super_ = superCtor;
    var TempCtor = function () {};
    TempCtor.prototype = superCtor.prototype;
    ctor.prototype = new TempCtor();
    ctor.prototype.constructor = ctor;
  }

  // BN

  function BN (number, base, endian) {
    if (BN.isBN(number)) {
      return number;
    }

    this.negative = 0;
    this.words = null;
    this.length = 0;

    // Reduction context
    this.red = null;

    if (number !== null) {
      if (base === 'le' || base === 'be') {
        endian = base;
        base = 10;
      }

      this._init(number || 0, base || 10, endian || 'be');
    }
  }
  if (typeof module === 'object') {
    module.exports = BN;
  } else {
    exports.BN = BN;
  }

  BN.BN = BN;
  BN.wordSize = 26;

  var Buffer;
  try {
    if (typeof window !== 'undefined' && typeof window.Buffer !== 'undefined') {
      Buffer = window.Buffer;
    } else {
      Buffer = (__webpack_require__(181).Buffer);
    }
  } catch (e) {
  }

  BN.isBN = function isBN (num) {
    if (num instanceof BN) {
      return true;
    }

    return num !== null && typeof num === 'object' &&
      num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
  };

  BN.max = function max (left, right) {
    if (left.cmp(right) > 0) return left;
    return right;
  };

  BN.min = function min (left, right) {
    if (left.cmp(right) < 0) return left;
    return right;
  };

  BN.prototype._init = function init (number, base, endian) {
    if (typeof number === 'number') {
      return this._initNumber(number, base, endian);
    }

    if (typeof number === 'object') {
      return this._initArray(number, base, endian);
    }

    if (base === 'hex') {
      base = 16;
    }
    assert(base === (base | 0) && base >= 2 && base <= 36);

    number = number.toString().replace(/\s+/g, '');
    var start = 0;
    if (number[0] === '-') {
      start++;
      this.negative = 1;
    }

    if (start < number.length) {
      if (base === 16) {
        this._parseHex(number, start, endian);
      } else {
        this._parseBase(number, base, start);
        if (endian === 'le') {
          this._initArray(this.toArray(), base, endian);
        }
      }
    }
  };

  BN.prototype._initNumber = function _initNumber (number, base, endian) {
    if (number < 0) {
      this.negative = 1;
      number = -number;
    }
    if (number < 0x4000000) {
      this.words = [ number & 0x3ffffff ];
      this.length = 1;
    } else if (number < 0x10000000000000) {
      this.words = [
        number & 0x3ffffff,
        (number / 0x4000000) & 0x3ffffff
      ];
      this.length = 2;
    } else {
      assert(number < 0x20000000000000); // 2 ^ 53 (unsafe)
      this.words = [
        number & 0x3ffffff,
        (number / 0x4000000) & 0x3ffffff,
        1
      ];
      this.length = 3;
    }

    if (endian !== 'le') return;

    // Reverse the bytes
    this._initArray(this.toArray(), base, endian);
  };

  BN.prototype._initArray = function _initArray (number, base, endian) {
    // Perhaps a Uint8Array
    assert(typeof number.length === 'number');
    if (number.length <= 0) {
      this.words = [ 0 ];
      this.length = 1;
      return this;
    }

    this.length = Math.ceil(number.length / 3);
    this.words = new Array(this.length);
    for (var i = 0; i < this.length; i++) {
      this.words[i] = 0;
    }

    var j, w;
    var off = 0;
    if (endian === 'be') {
      for (i = number.length - 1, j = 0; i >= 0; i -= 3) {
        w = number[i] | (number[i - 1] << 8) | (number[i - 2] << 16);
        this.words[j] |= (w << off) & 0x3ffffff;
        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
        off += 24;
        if (off >= 26) {
          off -= 26;
          j++;
        }
      }
    } else if (endian === 'le') {
      for (i = 0, j = 0; i < number.length; i += 3) {
        w = number[i] | (number[i + 1] << 8) | (number[i + 2] << 16);
        this.words[j] |= (w << off) & 0x3ffffff;
        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
        off += 24;
        if (off >= 26) {
          off -= 26;
          j++;
        }
      }
    }
    return this.strip();
  };

  function parseHex4Bits (string, index) {
    var c = string.charCodeAt(index);
    // 'A' - 'F'
    if (c >= 65 && c <= 70) {
      return c - 55;
    // 'a' - 'f'
    } else if (c >= 97 && c <= 102) {
      return c - 87;
    // '0' - '9'
    } else {
      return (c - 48) & 0xf;
    }
  }

  function parseHexByte (string, lowerBound, index) {
    var r = parseHex4Bits(string, index);
    if (index - 1 >= lowerBound) {
      r |= parseHex4Bits(string, index - 1) << 4;
    }
    return r;
  }

  BN.prototype._parseHex = function _parseHex (number, start, endian) {
    // Create possibly bigger array to ensure that it fits the number
    this.length = Math.ceil((number.length - start) / 6);
    this.words = new Array(this.length);
    for (var i = 0; i < this.length; i++) {
      this.words[i] = 0;
    }

    // 24-bits chunks
    var off = 0;
    var j = 0;

    var w;
    if (endian === 'be') {
      for (i = number.length - 1; i >= start; i -= 2) {
        w = parseHexByte(number, start, i) << off;
        this.words[j] |= w & 0x3ffffff;
        if (off >= 18) {
          off -= 18;
          j += 1;
          this.words[j] |= w >>> 26;
        } else {
          off += 8;
        }
      }
    } else {
      var parseLength = number.length - start;
      for (i = parseLength % 2 === 0 ? start + 1 : start; i < number.length; i += 2) {
        w = parseHexByte(number, start, i) << off;
        this.words[j] |= w & 0x3ffffff;
        if (off >= 18) {
          off -= 18;
          j += 1;
          this.words[j] |= w >>> 26;
        } else {
          off += 8;
        }
      }
    }

    this.strip();
  };

  function parseBase (str, start, end, mul) {
    var r = 0;
    var len = Math.min(str.length, end);
    for (var i = start; i < len; i++) {
      var c = str.charCodeAt(i) - 48;

      r *= mul;

      // 'a'
      if (c >= 49) {
        r += c - 49 + 0xa;

      // 'A'
      } else if (c >= 17) {
        r += c - 17 + 0xa;

      // '0' - '9'
      } else {
        r += c;
      }
    }
    return r;
  }

  BN.prototype._parseBase = function _parseBase (number, base, start) {
    // Initialize as zero
    this.words = [ 0 ];
    this.length = 1;

    // Find length of limb in base
    for (var limbLen = 0, limbPow = 1; limbPow <= 0x3ffffff; limbPow *= base) {
      limbLen++;
    }
    limbLen--;
    limbPow = (limbPow / base) | 0;

    var total = number.length - start;
    var mod = total % limbLen;
    var end = Math.min(total, total - mod) + start;

    var word = 0;
    for (var i = start; i < end; i += limbLen) {
      word = parseBase(number, i, i + limbLen, base);

      this.imuln(limbPow);
      if (this.words[0] + word < 0x4000000) {
        this.words[0] += word;
      } else {
        this._iaddn(word);
      }
    }

    if (mod !== 0) {
      var pow = 1;
      word = parseBase(number, i, number.length, base);

      for (i = 0; i < mod; i++) {
        pow *= base;
      }

      this.imuln(pow);
      if (this.words[0] + word < 0x4000000) {
        this.words[0] += word;
      } else {
        this._iaddn(word);
      }
    }

    this.strip();
  };

  BN.prototype.copy = function copy (dest) {
    dest.words = new Array(this.length);
    for (var i = 0; i < this.length; i++) {
      dest.words[i] = this.words[i];
    }
    dest.length = this.length;
    dest.negative = this.negative;
    dest.red = this.red;
  };

  BN.prototype.clone = function clone () {
    var r = new BN(null);
    this.copy(r);
    return r;
  };

  BN.prototype._expand = function _expand (size) {
    while (this.length < size) {
      this.words[this.length++] = 0;
    }
    return this;
  };

  // Remove leading `0` from `this`
  BN.prototype.strip = function strip () {
    while (this.length > 1 && this.words[this.length - 1] === 0) {
      this.length--;
    }
    return this._normSign();
  };

  BN.prototype._normSign = function _normSign () {
    // -0 = 0
    if (this.length === 1 && this.words[0] === 0) {
      this.negative = 0;
    }
    return this;
  };

  BN.prototype.inspect = function inspect () {
    return (this.red ? '<BN-R: ' : '<BN: ') + this.toString(16) + '>';
  };

  /*

  var zeros = [];
  var groupSizes = [];
  var groupBases = [];

  var s = '';
  var i = -1;
  while (++i < BN.wordSize) {
    zeros[i] = s;
    s += '0';
  }
  groupSizes[0] = 0;
  groupSizes[1] = 0;
  groupBases[0] = 0;
  groupBases[1] = 0;
  var base = 2 - 1;
  while (++base < 36 + 1) {
    var groupSize = 0;
    var groupBase = 1;
    while (groupBase < (1 << BN.wordSize) / base) {
      groupBase *= base;
      groupSize += 1;
    }
    groupSizes[base] = groupSize;
    groupBases[base] = groupBase;
  }

  */

  var zeros = [
    '',
    '0',
    '00',
    '000',
    '0000',
    '00000',
    '000000',
    '0000000',
    '00000000',
    '000000000',
    '0000000000',
    '00000000000',
    '000000000000',
    '0000000000000',
    '00000000000000',
    '000000000000000',
    '0000000000000000',
    '00000000000000000',
    '000000000000000000',
    '0000000000000000000',
    '00000000000000000000',
    '000000000000000000000',
    '0000000000000000000000',
    '00000000000000000000000',
    '000000000000000000000000',
    '0000000000000000000000000'
  ];

  var groupSizes = [
    0, 0,
    25, 16, 12, 11, 10, 9, 8,
    8, 7, 7, 7, 7, 6, 6,
    6, 6, 6, 6, 6, 5, 5,
    5, 5, 5, 5, 5, 5, 5,
    5, 5, 5, 5, 5, 5, 5
  ];

  var groupBases = [
    0, 0,
    33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216,
    43046721, 10000000, 19487171, 35831808, 62748517, 7529536, 11390625,
    16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632,
    6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149,
    24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176
  ];

  BN.prototype.toString = function toString (base, padding) {
    base = base || 10;
    padding = padding | 0 || 1;

    var out;
    if (base === 16 || base === 'hex') {
      out = '';
      var off = 0;
      var carry = 0;
      for (var i = 0; i < this.length; i++) {
        var w = this.words[i];
        var word = (((w << off) | carry) & 0xffffff).toString(16);
        carry = (w >>> (24 - off)) & 0xffffff;
        off += 2;
        if (off >= 26) {
          off -= 26;
          i--;
        }
        if (carry !== 0 || i !== this.length - 1) {
          out = zeros[6 - word.length] + word + out;
        } else {
          out = word + out;
        }
      }
      if (carry !== 0) {
        out = carry.toString(16) + out;
      }
      while (out.length % padding !== 0) {
        out = '0' + out;
      }
      if (this.negative !== 0) {
        out = '-' + out;
      }
      return out;
    }

    if (base === (base | 0) && base >= 2 && base <= 36) {
      // var groupSize = Math.floor(BN.wordSize * Math.LN2 / Math.log(base));
      var groupSize = groupSizes[base];
      // var groupBase = Math.pow(base, groupSize);
      var groupBase = groupBases[base];
      out = '';
      var c = this.clone();
      c.negative = 0;
      while (!c.isZero()) {
        var r = c.modn(groupBase).toString(base);
        c = c.idivn(groupBase);

        if (!c.isZero()) {
          out = zeros[groupSize - r.length] + r + out;
        } else {
          out = r + out;
        }
      }
      if (this.isZero()) {
        out = '0' + out;
      }
      while (out.length % padding !== 0) {
        out = '0' + out;
      }
      if (this.negative !== 0) {
        out = '-' + out;
      }
      return out;
    }

    assert(false, 'Base should be between 2 and 36');
  };

  BN.prototype.toNumber = function toNumber () {
    var ret = this.words[0];
    if (this.length === 2) {
      ret += this.words[1] * 0x4000000;
    } else if (this.length === 3 && this.words[2] === 0x01) {
      // NOTE: at this stage it is known that the top bit is set
      ret += 0x10000000000000 + (this.words[1] * 0x4000000);
    } else if (this.length > 2) {
      assert(false, 'Number can only safely store up to 53 bits');
    }
    return (this.negative !== 0) ? -ret : ret;
  };

  BN.prototype.toJSON = function toJSON () {
    return this.toString(16);
  };

  BN.prototype.toBuffer = function toBuffer (endian, length) {
    assert(typeof Buffer !== 'undefined');
    return this.toArrayLike(Buffer, endian, length);
  };

  BN.prototype.toArray = function toArray (endian, length) {
    return this.toArrayLike(Array, endian, length);
  };

  BN.prototype.toArrayLike = function toArrayLike (ArrayType, endian, length) {
    var byteLength = this.byteLength();
    var reqLength = length || Math.max(1, byteLength);
    assert(byteLength <= reqLength, 'byte array longer than desired length');
    assert(reqLength > 0, 'Requested array length <= 0');

    this.strip();
    var littleEndian = endian === 'le';
    var res = new ArrayType(reqLength);

    var b, i;
    var q = this.clone();
    if (!littleEndian) {
      // Assume big-endian
      for (i = 0; i < reqLength - byteLength; i++) {
        res[i] = 0;
      }

      for (i = 0; !q.isZero(); i++) {
        b = q.andln(0xff);
        q.iushrn(8);

        res[reqLength - i - 1] = b;
      }
    } else {
      for (i = 0; !q.isZero(); i++) {
        b = q.andln(0xff);
        q.iushrn(8);

        res[i] = b;
      }

      for (; i < reqLength; i++) {
        res[i] = 0;
      }
    }

    return res;
  };

  if (Math.clz32) {
    BN.prototype._countBits = function _countBits (w) {
      return 32 - Math.clz32(w);
    };
  } else {
    BN.prototype._countBits = function _countBits (w) {
      var t = w;
      var r = 0;
      if (t >= 0x1000) {
        r += 13;
        t >>>= 13;
      }
      if (t >= 0x40) {
        r += 7;
        t >>>= 7;
      }
      if (t >= 0x8) {
        r += 4;
        t >>>= 4;
      }
      if (t >= 0x02) {
        r += 2;
        t >>>= 2;
      }
      return r + t;
    };
  }

  BN.prototype._zeroBits = function _zeroBits (w) {
    // Short-cut
    if (w === 0) return 26;

    var t = w;
    var r = 0;
    if ((t & 0x1fff) === 0) {
      r += 13;
      t >>>= 13;
    }
    if ((t & 0x7f) === 0) {
      r += 7;
      t >>>= 7;
    }
    if ((t & 0xf) === 0) {
      r += 4;
      t >>>= 4;
    }
    if ((t & 0x3) === 0) {
      r += 2;
      t >>>= 2;
    }
    if ((t & 0x1) === 0) {
      r++;
    }
    return r;
  };

  // Return number of used bits in a BN
  BN.prototype.bitLength = function bitLength () {
    var w = this.words[this.length - 1];
    var hi = this._countBits(w);
    return (this.length - 1) * 26 + hi;
  };

  function toBitArray (num) {
    var w = new Array(num.bitLength());

    for (var bit = 0; bit < w.length; bit++) {
      var off = (bit / 26) | 0;
      var wbit = bit % 26;

      w[bit] = (num.words[off] & (1 << wbit)) >>> wbit;
    }

    return w;
  }

  // Number of trailing zero bits
  BN.prototype.zeroBits = function zeroBits () {
    if (this.isZero()) return 0;

    var r = 0;
    for (var i = 0; i < this.length; i++) {
      var b = this._zeroBits(this.words[i]);
      r += b;
      if (b !== 26) break;
    }
    return r;
  };

  BN.prototype.byteLength = function byteLength () {
    return Math.ceil(this.bitLength() / 8);
  };

  BN.prototype.toTwos = function toTwos (width) {
    if (this.negative !== 0) {
      return this.abs().inotn(width).iaddn(1);
    }
    return this.clone();
  };

  BN.prototype.fromTwos = function fromTwos (width) {
    if (this.testn(width - 1)) {
      return this.notn(width).iaddn(1).ineg();
    }
    return this.clone();
  };

  BN.prototype.isNeg = function isNeg () {
    return this.negative !== 0;
  };

  // Return negative clone of `this`
  BN.prototype.neg = function neg () {
    return this.clone().ineg();
  };

  BN.prototype.ineg = function ineg () {
    if (!this.isZero()) {
      this.negative ^= 1;
    }

    return this;
  };

  // Or `num` with `this` in-place
  BN.prototype.iuor = function iuor (num) {
    while (this.length < num.length) {
      this.words[this.length++] = 0;
    }

    for (var i = 0; i < num.length; i++) {
      this.words[i] = this.words[i] | num.words[i];
    }

    return this.strip();
  };

  BN.prototype.ior = function ior (num) {
    assert((this.negative | num.negative) === 0);
    return this.iuor(num);
  };

  // Or `num` with `this`
  BN.prototype.or = function or (num) {
    if (this.length > num.length) return this.clone().ior(num);
    return num.clone().ior(this);
  };

  BN.prototype.uor = function uor (num) {
    if (this.length > num.length) return this.clone().iuor(num);
    return num.clone().iuor(this);
  };

  // And `num` with `this` in-place
  BN.prototype.iuand = function iuand (num) {
    // b = min-length(num, this)
    var b;
    if (this.length > num.length) {
      b = num;
    } else {
      b = this;
    }

    for (var i = 0; i < b.length; i++) {
      this.words[i] = this.words[i] & num.words[i];
    }

    this.length = b.length;

    return this.strip();
  };

  BN.prototype.iand = function iand (num) {
    assert((this.negative | num.negative) === 0);
    return this.iuand(num);
  };

  // And `num` with `this`
  BN.prototype.and = function and (num) {
    if (this.length > num.length) return this.clone().iand(num);
    return num.clone().iand(this);
  };

  BN.prototype.uand = function uand (num) {
    if (this.length > num.length) return this.clone().iuand(num);
    return num.clone().iuand(this);
  };

  // Xor `num` with `this` in-place
  BN.prototype.iuxor = function iuxor (num) {
    // a.length > b.length
    var a;
    var b;
    if (this.length > num.length) {
      a = this;
      b = num;
    } else {
      a = num;
      b = this;
    }

    for (var i = 0; i < b.length; i++) {
      this.words[i] = a.words[i] ^ b.words[i];
    }

    if (this !== a) {
      for (; i < a.length; i++) {
        this.words[i] = a.words[i];
      }
    }

    this.length = a.length;

    return this.strip();
  };

  BN.prototype.ixor = function ixor (num) {
    assert((this.negative | num.negative) === 0);
    return this.iuxor(num);
  };

  // Xor `num` with `this`
  BN.prototype.xor = function xor (num) {
    if (this.length > num.length) return this.clone().ixor(num);
    return num.clone().ixor(this);
  };

  BN.prototype.uxor = function uxor (num) {
    if (this.length > num.length) return this.clone().iuxor(num);
    return num.clone().iuxor(this);
  };

  // Not ``this`` with ``width`` bitwidth
  BN.prototype.inotn = function inotn (width) {
    assert(typeof width === 'number' && width >= 0);

    var bytesNeeded = Math.ceil(width / 26) | 0;
    var bitsLeft = width % 26;

    // Extend the buffer with leading zeroes
    this._expand(bytesNeeded);

    if (bitsLeft > 0) {
      bytesNeeded--;
    }

    // Handle complete words
    for (var i = 0; i < bytesNeeded; i++) {
      this.words[i] = ~this.words[i] & 0x3ffffff;
    }

    // Handle the residue
    if (bitsLeft > 0) {
      this.words[i] = ~this.words[i] & (0x3ffffff >> (26 - bitsLeft));
    }

    // And remove leading zeroes
    return this.strip();
  };

  BN.prototype.notn = function notn (width) {
    return this.clone().inotn(width);
  };

  // Set `bit` of `this`
  BN.prototype.setn = function setn (bit, val) {
    assert(typeof bit === 'number' && bit >= 0);

    var off = (bit / 26) | 0;
    var wbit = bit % 26;

    this._expand(off + 1);

    if (val) {
      this.words[off] = this.words[off] | (1 << wbit);
    } else {
      this.words[off] = this.words[off] & ~(1 << wbit);
    }

    return this.strip();
  };

  // Add `num` to `this` in-place
  BN.prototype.iadd = function iadd (num) {
    var r;

    // negative + positive
    if (this.negative !== 0 && num.negative === 0) {
      this.negative = 0;
      r = this.isub(num);
      this.negative ^= 1;
      return this._normSign();

    // positive + negative
    } else if (this.negative === 0 && num.negative !== 0) {
      num.negative = 0;
      r = this.isub(num);
      num.negative = 1;
      return r._normSign();
    }

    // a.length > b.length
    var a, b;
    if (this.length > num.length) {
      a = this;
      b = num;
    } else {
      a = num;
      b = this;
    }

    var carry = 0;
    for (var i = 0; i < b.length; i++) {
      r = (a.words[i] | 0) + (b.words[i] | 0) + carry;
      this.words[i] = r & 0x3ffffff;
      carry = r >>> 26;
    }
    for (; carry !== 0 && i < a.length; i++) {
      r = (a.words[i] | 0) + carry;
      this.words[i] = r & 0x3ffffff;
      carry = r >>> 26;
    }

    this.length = a.length;
    if (carry !== 0) {
      this.words[this.length] = carry;
      this.length++;
    // Copy the rest of the words
    } else if (a !== this) {
      for (; i < a.length; i++) {
        this.words[i] = a.words[i];
      }
    }

    return this;
  };

  // Add `num` to `this`
  BN.prototype.add = function add (num) {
    var res;
    if (num.negative !== 0 && this.negative === 0) {
      num.negative = 0;
      res = this.sub(num);
      num.negative ^= 1;
      return res;
    } else if (num.negative === 0 && this.negative !== 0) {
      this.negative = 0;
      res = num.sub(this);
      this.negative = 1;
      return res;
    }

    if (this.length > num.length) return this.clone().iadd(num);

    return num.clone().iadd(this);
  };

  // Subtract `num` from `this` in-place
  BN.prototype.isub = function isub (num) {
    // this - (-num) = this + num
    if (num.negative !== 0) {
      num.negative = 0;
      var r = this.iadd(num);
      num.negative = 1;
      return r._normSign();

    // -this - num = -(this + num)
    } else if (this.negative !== 0) {
      this.negative = 0;
      this.iadd(num);
      this.negative = 1;
      return this._normSign();
    }

    // At this point both numbers are positive
    var cmp = this.cmp(num);

    // Optimization - zeroify
    if (cmp === 0) {
      this.negative = 0;
      this.length = 1;
      this.words[0] = 0;
      return this;
    }

    // a > b
    var a, b;
    if (cmp > 0) {
      a = this;
      b = num;
    } else {
      a = num;
      b = this;
    }

    var carry = 0;
    for (var i = 0; i < b.length; i++) {
      r = (a.words[i] | 0) - (b.words[i] | 0) + carry;
      carry = r >> 26;
      this.words[i] = r & 0x3ffffff;
    }
    for (; carry !== 0 && i < a.length; i++) {
      r = (a.words[i] | 0) + carry;
      carry = r >> 26;
      this.words[i] = r & 0x3ffffff;
    }

    // Copy rest of the words
    if (carry === 0 && i < a.length && a !== this) {
      for (; i < a.length; i++) {
        this.words[i] = a.words[i];
      }
    }

    this.length = Math.max(this.length, i);

    if (a !== this) {
      this.negative = 1;
    }

    return this.strip();
  };

  // Subtract `num` from `this`
  BN.prototype.sub = function sub (num) {
    return this.clone().isub(num);
  };

  function smallMulTo (self, num, out) {
    out.negative = num.negative ^ self.negative;
    var len = (self.length + num.length) | 0;
    out.length = len;
    len = (len - 1) | 0;

    // Peel one iteration (compiler can't do it, because of code complexity)
    var a = self.words[0] | 0;
    var b = num.words[0] | 0;
    var r = a * b;

    var lo = r & 0x3ffffff;
    var carry = (r / 0x4000000) | 0;
    out.words[0] = lo;

    for (var k = 1; k < len; k++) {
      // Sum all words with the same `i + j = k` and accumulate `ncarry`,
      // note that ncarry could be >= 0x3ffffff
      var ncarry = carry >>> 26;
      var rword = carry & 0x3ffffff;
      var maxJ = Math.min(k, num.length - 1);
      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
        var i = (k - j) | 0;
        a = self.words[i] | 0;
        b = num.words[j] | 0;
        r = a * b + rword;
        ncarry += (r / 0x4000000) | 0;
        rword = r & 0x3ffffff;
      }
      out.words[k] = rword | 0;
      carry = ncarry | 0;
    }
    if (carry !== 0) {
      out.words[k] = carry | 0;
    } else {
      out.length--;
    }

    return out.strip();
  }

  // TODO(indutny): it may be reasonable to omit it for users who don't need
  // to work with 256-bit numbers, otherwise it gives 20% improvement for 256-bit
  // multiplication (like elliptic secp256k1).
  var comb10MulTo = function comb10MulTo (self, num, out) {
    var a = self.words;
    var b = num.words;
    var o = out.words;
    var c = 0;
    var lo;
    var mid;
    var hi;
    var a0 = a[0] | 0;
    var al0 = a0 & 0x1fff;
    var ah0 = a0 >>> 13;
    var a1 = a[1] | 0;
    var al1 = a1 & 0x1fff;
    var ah1 = a1 >>> 13;
    var a2 = a[2] | 0;
    var al2 = a2 & 0x1fff;
    var ah2 = a2 >>> 13;
    var a3 = a[3] | 0;
    var al3 = a3 & 0x1fff;
    var ah3 = a3 >>> 13;
    var a4 = a[4] | 0;
    var al4 = a4 & 0x1fff;
    var ah4 = a4 >>> 13;
    var a5 = a[5] | 0;
    var al5 = a5 & 0x1fff;
    var ah5 = a5 >>> 13;
    var a6 = a[6] | 0;
    var al6 = a6 & 0x1fff;
    var ah6 = a6 >>> 13;
    var a7 = a[7] | 0;
    var al7 = a7 & 0x1fff;
    var ah7 = a7 >>> 13;
    var a8 = a[8] | 0;
    var al8 = a8 & 0x1fff;
    var ah8 = a8 >>> 13;
    var a9 = a[9] | 0;
    var al9 = a9 & 0x1fff;
    var ah9 = a9 >>> 13;
    var b0 = b[0] | 0;
    var bl0 = b0 & 0x1fff;
    var bh0 = b0 >>> 13;
    var b1 = b[1] | 0;
    var bl1 = b1 & 0x1fff;
    var bh1 = b1 >>> 13;
    var b2 = b[2] | 0;
    var bl2 = b2 & 0x1fff;
    var bh2 = b2 >>> 13;
    var b3 = b[3] | 0;
    var bl3 = b3 & 0x1fff;
    var bh3 = b3 >>> 13;
    var b4 = b[4] | 0;
    var bl4 = b4 & 0x1fff;
    var bh4 = b4 >>> 13;
    var b5 = b[5] | 0;
    var bl5 = b5 & 0x1fff;
    var bh5 = b5 >>> 13;
    var b6 = b[6] | 0;
    var bl6 = b6 & 0x1fff;
    var bh6 = b6 >>> 13;
    var b7 = b[7] | 0;
    var bl7 = b7 & 0x1fff;
    var bh7 = b7 >>> 13;
    var b8 = b[8] | 0;
    var bl8 = b8 & 0x1fff;
    var bh8 = b8 >>> 13;
    var b9 = b[9] | 0;
    var bl9 = b9 & 0x1fff;
    var bh9 = b9 >>> 13;

    out.negative = self.negative ^ num.negative;
    out.length = 19;
    /* k = 0 */
    lo = Math.imul(al0, bl0);
    mid = Math.imul(al0, bh0);
    mid = (mid + Math.imul(ah0, bl0)) | 0;
    hi = Math.imul(ah0, bh0);
    var w0 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w0 >>> 26)) | 0;
    w0 &= 0x3ffffff;
    /* k = 1 */
    lo = Math.imul(al1, bl0);
    mid = Math.imul(al1, bh0);
    mid = (mid + Math.imul(ah1, bl0)) | 0;
    hi = Math.imul(ah1, bh0);
    lo = (lo + Math.imul(al0, bl1)) | 0;
    mid = (mid + Math.imul(al0, bh1)) | 0;
    mid = (mid + Math.imul(ah0, bl1)) | 0;
    hi = (hi + Math.imul(ah0, bh1)) | 0;
    var w1 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w1 >>> 26)) | 0;
    w1 &= 0x3ffffff;
    /* k = 2 */
    lo = Math.imul(al2, bl0);
    mid = Math.imul(al2, bh0);
    mid = (mid + Math.imul(ah2, bl0)) | 0;
    hi = Math.imul(ah2, bh0);
    lo = (lo + Math.imul(al1, bl1)) | 0;
    mid = (mid + Math.imul(al1, bh1)) | 0;
    mid = (mid + Math.imul(ah1, bl1)) | 0;
    hi = (hi + Math.imul(ah1, bh1)) | 0;
    lo = (lo + Math.imul(al0, bl2)) | 0;
    mid = (mid + Math.imul(al0, bh2)) | 0;
    mid = (mid + Math.imul(ah0, bl2)) | 0;
    hi = (hi + Math.imul(ah0, bh2)) | 0;
    var w2 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w2 >>> 26)) | 0;
    w2 &= 0x3ffffff;
    /* k = 3 */
    lo = Math.imul(al3, bl0);
    mid = Math.imul(al3, bh0);
    mid = (mid + Math.imul(ah3, bl0)) | 0;
    hi = Math.imul(ah3, bh0);
    lo = (lo + Math.imul(al2, bl1)) | 0;
    mid = (mid + Math.imul(al2, bh1)) | 0;
    mid = (mid + Math.imul(ah2, bl1)) | 0;
    hi = (hi + Math.imul(ah2, bh1)) | 0;
    lo = (lo + Math.imul(al1, bl2)) | 0;
    mid = (mid + Math.imul(al1, bh2)) | 0;
    mid = (mid + Math.imul(ah1, bl2)) | 0;
    hi = (hi + Math.imul(ah1, bh2)) | 0;
    lo = (lo + Math.imul(al0, bl3)) | 0;
    mid = (mid + Math.imul(al0, bh3)) | 0;
    mid = (mid + Math.imul(ah0, bl3)) | 0;
    hi = (hi + Math.imul(ah0, bh3)) | 0;
    var w3 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w3 >>> 26)) | 0;
    w3 &= 0x3ffffff;
    /* k = 4 */
    lo = Math.imul(al4, bl0);
    mid = Math.imul(al4, bh0);
    mid = (mid + Math.imul(ah4, bl0)) | 0;
    hi = Math.imul(ah4, bh0);
    lo = (lo + Math.imul(al3, bl1)) | 0;
    mid = (mid + Math.imul(al3, bh1)) | 0;
    mid = (mid + Math.imul(ah3, bl1)) | 0;
    hi = (hi + Math.imul(ah3, bh1)) | 0;
    lo = (lo + Math.imul(al2, bl2)) | 0;
    mid = (mid + Math.imul(al2, bh2)) | 0;
    mid = (mid + Math.imul(ah2, bl2)) | 0;
    hi = (hi + Math.imul(ah2, bh2)) | 0;
    lo = (lo + Math.imul(al1, bl3)) | 0;
    mid = (mid + Math.imul(al1, bh3)) | 0;
    mid = (mid + Math.imul(ah1, bl3)) | 0;
    hi = (hi + Math.imul(ah1, bh3)) | 0;
    lo = (lo + Math.imul(al0, bl4)) | 0;
    mid = (mid + Math.imul(al0, bh4)) | 0;
    mid = (mid + Math.imul(ah0, bl4)) | 0;
    hi = (hi + Math.imul(ah0, bh4)) | 0;
    var w4 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w4 >>> 26)) | 0;
    w4 &= 0x3ffffff;
    /* k = 5 */
    lo = Math.imul(al5, bl0);
    mid = Math.imul(al5, bh0);
    mid = (mid + Math.imul(ah5, bl0)) | 0;
    hi = Math.imul(ah5, bh0);
    lo = (lo + Math.imul(al4, bl1)) | 0;
    mid = (mid + Math.imul(al4, bh1)) | 0;
    mid = (mid + Math.imul(ah4, bl1)) | 0;
    hi = (hi + Math.imul(ah4, bh1)) | 0;
    lo = (lo + Math.imul(al3, bl2)) | 0;
    mid = (mid + Math.imul(al3, bh2)) | 0;
    mid = (mid + Math.imul(ah3, bl2)) | 0;
    hi = (hi + Math.imul(ah3, bh2)) | 0;
    lo = (lo + Math.imul(al2, bl3)) | 0;
    mid = (mid + Math.imul(al2, bh3)) | 0;
    mid = (mid + Math.imul(ah2, bl3)) | 0;
    hi = (hi + Math.imul(ah2, bh3)) | 0;
    lo = (lo + Math.imul(al1, bl4)) | 0;
    mid = (mid + Math.imul(al1, bh4)) | 0;
    mid = (mid + Math.imul(ah1, bl4)) | 0;
    hi = (hi + Math.imul(ah1, bh4)) | 0;
    lo = (lo + Math.imul(al0, bl5)) | 0;
    mid = (mid + Math.imul(al0, bh5)) | 0;
    mid = (mid + Math.imul(ah0, bl5)) | 0;
    hi = (hi + Math.imul(ah0, bh5)) | 0;
    var w5 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w5 >>> 26)) | 0;
    w5 &= 0x3ffffff;
    /* k = 6 */
    lo = Math.imul(al6, bl0);
    mid = Math.imul(al6, bh0);
    mid = (mid + Math.imul(ah6, bl0)) | 0;
    hi = Math.imul(ah6, bh0);
    lo = (lo + Math.imul(al5, bl1)) | 0;
    mid = (mid + Math.imul(al5, bh1)) | 0;
    mid = (mid + Math.imul(ah5, bl1)) | 0;
    hi = (hi + Math.imul(ah5, bh1)) | 0;
    lo = (lo + Math.imul(al4, bl2)) | 0;
    mid = (mid + Math.imul(al4, bh2)) | 0;
    mid = (mid + Math.imul(ah4, bl2)) | 0;
    hi = (hi + Math.imul(ah4, bh2)) | 0;
    lo = (lo + Math.imul(al3, bl3)) | 0;
    mid = (mid + Math.imul(al3, bh3)) | 0;
    mid = (mid + Math.imul(ah3, bl3)) | 0;
    hi = (hi + Math.imul(ah3, bh3)) | 0;
    lo = (lo + Math.imul(al2, bl4)) | 0;
    mid = (mid + Math.imul(al2, bh4)) | 0;
    mid = (mid + Math.imul(ah2, bl4)) | 0;
    hi = (hi + Math.imul(ah2, bh4)) | 0;
    lo = (lo + Math.imul(al1, bl5)) | 0;
    mid = (mid + Math.imul(al1, bh5)) | 0;
    mid = (mid + Math.imul(ah1, bl5)) | 0;
    hi = (hi + Math.imul(ah1, bh5)) | 0;
    lo = (lo + Math.imul(al0, bl6)) | 0;
    mid = (mid + Math.imul(al0, bh6)) | 0;
    mid = (mid + Math.imul(ah0, bl6)) | 0;
    hi = (hi + Math.imul(ah0, bh6)) | 0;
    var w6 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w6 >>> 26)) | 0;
    w6 &= 0x3ffffff;
    /* k = 7 */
    lo = Math.imul(al7, bl0);
    mid = Math.imul(al7, bh0);
    mid = (mid + Math.imul(ah7, bl0)) | 0;
    hi = Math.imul(ah7, bh0);
    lo = (lo + Math.imul(al6, bl1)) | 0;
    mid = (mid + Math.imul(al6, bh1)) | 0;
    mid = (mid + Math.imul(ah6, bl1)) | 0;
    hi = (hi + Math.imul(ah6, bh1)) | 0;
    lo = (lo + Math.imul(al5, bl2)) | 0;
    mid = (mid + Math.imul(al5, bh2)) | 0;
    mid = (mid + Math.imul(ah5, bl2)) | 0;
    hi = (hi + Math.imul(ah5, bh2)) | 0;
    lo = (lo + Math.imul(al4, bl3)) | 0;
    mid = (mid + Math.imul(al4, bh3)) | 0;
    mid = (mid + Math.imul(ah4, bl3)) | 0;
    hi = (hi + Math.imul(ah4, bh3)) | 0;
    lo = (lo + Math.imul(al3, bl4)) | 0;
    mid = (mid + Math.imul(al3, bh4)) | 0;
    mid = (mid + Math.imul(ah3, bl4)) | 0;
    hi = (hi + Math.imul(ah3, bh4)) | 0;
    lo = (lo + Math.imul(al2, bl5)) | 0;
    mid = (mid + Math.imul(al2, bh5)) | 0;
    mid = (mid + Math.imul(ah2, bl5)) | 0;
    hi = (hi + Math.imul(ah2, bh5)) | 0;
    lo = (lo + Math.imul(al1, bl6)) | 0;
    mid = (mid + Math.imul(al1, bh6)) | 0;
    mid = (mid + Math.imul(ah1, bl6)) | 0;
    hi = (hi + Math.imul(ah1, bh6)) | 0;
    lo = (lo + Math.imul(al0, bl7)) | 0;
    mid = (mid + Math.imul(al0, bh7)) | 0;
    mid = (mid + Math.imul(ah0, bl7)) | 0;
    hi = (hi + Math.imul(ah0, bh7)) | 0;
    var w7 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w7 >>> 26)) | 0;
    w7 &= 0x3ffffff;
    /* k = 8 */
    lo = Math.imul(al8, bl0);
    mid = Math.imul(al8, bh0);
    mid = (mid + Math.imul(ah8, bl0)) | 0;
    hi = Math.imul(ah8, bh0);
    lo = (lo + Math.imul(al7, bl1)) | 0;
    mid = (mid + Math.imul(al7, bh1)) | 0;
    mid = (mid + Math.imul(ah7, bl1)) | 0;
    hi = (hi + Math.imul(ah7, bh1)) | 0;
    lo = (lo + Math.imul(al6, bl2)) | 0;
    mid = (mid + Math.imul(al6, bh2)) | 0;
    mid = (mid + Math.imul(ah6, bl2)) | 0;
    hi = (hi + Math.imul(ah6, bh2)) | 0;
    lo = (lo + Math.imul(al5, bl3)) | 0;
    mid = (mid + Math.imul(al5, bh3)) | 0;
    mid = (mid + Math.imul(ah5, bl3)) | 0;
    hi = (hi + Math.imul(ah5, bh3)) | 0;
    lo = (lo + Math.imul(al4, bl4)) | 0;
    mid = (mid + Math.imul(al4, bh4)) | 0;
    mid = (mid + Math.imul(ah4, bl4)) | 0;
    hi = (hi + Math.imul(ah4, bh4)) | 0;
    lo = (lo + Math.imul(al3, bl5)) | 0;
    mid = (mid + Math.imul(al3, bh5)) | 0;
    mid = (mid + Math.imul(ah3, bl5)) | 0;
    hi = (hi + Math.imul(ah3, bh5)) | 0;
    lo = (lo + Math.imul(al2, bl6)) | 0;
    mid = (mid + Math.imul(al2, bh6)) | 0;
    mid = (mid + Math.imul(ah2, bl6)) | 0;
    hi = (hi + Math.imul(ah2, bh6)) | 0;
    lo = (lo + Math.imul(al1, bl7)) | 0;
    mid = (mid + Math.imul(al1, bh7)) | 0;
    mid = (mid + Math.imul(ah1, bl7)) | 0;
    hi = (hi + Math.imul(ah1, bh7)) | 0;
    lo = (lo + Math.imul(al0, bl8)) | 0;
    mid = (mid + Math.imul(al0, bh8)) | 0;
    mid = (mid + Math.imul(ah0, bl8)) | 0;
    hi = (hi + Math.imul(ah0, bh8)) | 0;
    var w8 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w8 >>> 26)) | 0;
    w8 &= 0x3ffffff;
    /* k = 9 */
    lo = Math.imul(al9, bl0);
    mid = Math.imul(al9, bh0);
    mid = (mid + Math.imul(ah9, bl0)) | 0;
    hi = Math.imul(ah9, bh0);
    lo = (lo + Math.imul(al8, bl1)) | 0;
    mid = (mid + Math.imul(al8, bh1)) | 0;
    mid = (mid + Math.imul(ah8, bl1)) | 0;
    hi = (hi + Math.imul(ah8, bh1)) | 0;
    lo = (lo + Math.imul(al7, bl2)) | 0;
    mid = (mid + Math.imul(al7, bh2)) | 0;
    mid = (mid + Math.imul(ah7, bl2)) | 0;
    hi = (hi + Math.imul(ah7, bh2)) | 0;
    lo = (lo + Math.imul(al6, bl3)) | 0;
    mid = (mid + Math.imul(al6, bh3)) | 0;
    mid = (mid + Math.imul(ah6, bl3)) | 0;
    hi = (hi + Math.imul(ah6, bh3)) | 0;
    lo = (lo + Math.imul(al5, bl4)) | 0;
    mid = (mid + Math.imul(al5, bh4)) | 0;
    mid = (mid + Math.imul(ah5, bl4)) | 0;
    hi = (hi + Math.imul(ah5, bh4)) | 0;
    lo = (lo + Math.imul(al4, bl5)) | 0;
    mid = (mid + Math.imul(al4, bh5)) | 0;
    mid = (mid + Math.imul(ah4, bl5)) | 0;
    hi = (hi + Math.imul(ah4, bh5)) | 0;
    lo = (lo + Math.imul(al3, bl6)) | 0;
    mid = (mid + Math.imul(al3, bh6)) | 0;
    mid = (mid + Math.imul(ah3, bl6)) | 0;
    hi = (hi + Math.imul(ah3, bh6)) | 0;
    lo = (lo + Math.imul(al2, bl7)) | 0;
    mid = (mid + Math.imul(al2, bh7)) | 0;
    mid = (mid + Math.imul(ah2, bl7)) | 0;
    hi = (hi + Math.imul(ah2, bh7)) | 0;
    lo = (lo + Math.imul(al1, bl8)) | 0;
    mid = (mid + Math.imul(al1, bh8)) | 0;
    mid = (mid + Math.imul(ah1, bl8)) | 0;
    hi = (hi + Math.imul(ah1, bh8)) | 0;
    lo = (lo + Math.imul(al0, bl9)) | 0;
    mid = (mid + Math.imul(al0, bh9)) | 0;
    mid = (mid + Math.imul(ah0, bl9)) | 0;
    hi = (hi + Math.imul(ah0, bh9)) | 0;
    var w9 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w9 >>> 26)) | 0;
    w9 &= 0x3ffffff;
    /* k = 10 */
    lo = Math.imul(al9, bl1);
    mid = Math.imul(al9, bh1);
    mid = (mid + Math.imul(ah9, bl1)) | 0;
    hi = Math.imul(ah9, bh1);
    lo = (lo + Math.imul(al8, bl2)) | 0;
    mid = (mid + Math.imul(al8, bh2)) | 0;
    mid = (mid + Math.imul(ah8, bl2)) | 0;
    hi = (hi + Math.imul(ah8, bh2)) | 0;
    lo = (lo + Math.imul(al7, bl3)) | 0;
    mid = (mid + Math.imul(al7, bh3)) | 0;
    mid = (mid + Math.imul(ah7, bl3)) | 0;
    hi = (hi + Math.imul(ah7, bh3)) | 0;
    lo = (lo + Math.imul(al6, bl4)) | 0;
    mid = (mid + Math.imul(al6, bh4)) | 0;
    mid = (mid + Math.imul(ah6, bl4)) | 0;
    hi = (hi + Math.imul(ah6, bh4)) | 0;
    lo = (lo + Math.imul(al5, bl5)) | 0;
    mid = (mid + Math.imul(al5, bh5)) | 0;
    mid = (mid + Math.imul(ah5, bl5)) | 0;
    hi = (hi + Math.imul(ah5, bh5)) | 0;
    lo = (lo + Math.imul(al4, bl6)) | 0;
    mid = (mid + Math.imul(al4, bh6)) | 0;
    mid = (mid + Math.imul(ah4, bl6)) | 0;
    hi = (hi + Math.imul(ah4, bh6)) | 0;
    lo = (lo + Math.imul(al3, bl7)) | 0;
    mid = (mid + Math.imul(al3, bh7)) | 0;
    mid = (mid + Math.imul(ah3, bl7)) | 0;
    hi = (hi + Math.imul(ah3, bh7)) | 0;
    lo = (lo + Math.imul(al2, bl8)) | 0;
    mid = (mid + Math.imul(al2, bh8)) | 0;
    mid = (mid + Math.imul(ah2, bl8)) | 0;
    hi = (hi + Math.imul(ah2, bh8)) | 0;
    lo = (lo + Math.imul(al1, bl9)) | 0;
    mid = (mid + Math.imul(al1, bh9)) | 0;
    mid = (mid + Math.imul(ah1, bl9)) | 0;
    hi = (hi + Math.imul(ah1, bh9)) | 0;
    var w10 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w10 >>> 26)) | 0;
    w10 &= 0x3ffffff;
    /* k = 11 */
    lo = Math.imul(al9, bl2);
    mid = Math.imul(al9, bh2);
    mid = (mid + Math.imul(ah9, bl2)) | 0;
    hi = Math.imul(ah9, bh2);
    lo = (lo + Math.imul(al8, bl3)) | 0;
    mid = (mid + Math.imul(al8, bh3)) | 0;
    mid = (mid + Math.imul(ah8, bl3)) | 0;
    hi = (hi + Math.imul(ah8, bh3)) | 0;
    lo = (lo + Math.imul(al7, bl4)) | 0;
    mid = (mid + Math.imul(al7, bh4)) | 0;
    mid = (mid + Math.imul(ah7, bl4)) | 0;
    hi = (hi + Math.imul(ah7, bh4)) | 0;
    lo = (lo + Math.imul(al6, bl5)) | 0;
    mid = (mid + Math.imul(al6, bh5)) | 0;
    mid = (mid + Math.imul(ah6, bl5)) | 0;
    hi = (hi + Math.imul(ah6, bh5)) | 0;
    lo = (lo + Math.imul(al5, bl6)) | 0;
    mid = (mid + Math.imul(al5, bh6)) | 0;
    mid = (mid + Math.imul(ah5, bl6)) | 0;
    hi = (hi + Math.imul(ah5, bh6)) | 0;
    lo = (lo + Math.imul(al4, bl7)) | 0;
    mid = (mid + Math.imul(al4, bh7)) | 0;
    mid = (mid + Math.imul(ah4, bl7)) | 0;
    hi = (hi + Math.imul(ah4, bh7)) | 0;
    lo = (lo + Math.imul(al3, bl8)) | 0;
    mid = (mid + Math.imul(al3, bh8)) | 0;
    mid = (mid + Math.imul(ah3, bl8)) | 0;
    hi = (hi + Math.imul(ah3, bh8)) | 0;
    lo = (lo + Math.imul(al2, bl9)) | 0;
    mid = (mid + Math.imul(al2, bh9)) | 0;
    mid = (mid + Math.imul(ah2, bl9)) | 0;
    hi = (hi + Math.imul(ah2, bh9)) | 0;
    var w11 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w11 >>> 26)) | 0;
    w11 &= 0x3ffffff;
    /* k = 12 */
    lo = Math.imul(al9, bl3);
    mid = Math.imul(al9, bh3);
    mid = (mid + Math.imul(ah9, bl3)) | 0;
    hi = Math.imul(ah9, bh3);
    lo = (lo + Math.imul(al8, bl4)) | 0;
    mid = (mid + Math.imul(al8, bh4)) | 0;
    mid = (mid + Math.imul(ah8, bl4)) | 0;
    hi = (hi + Math.imul(ah8, bh4)) | 0;
    lo = (lo + Math.imul(al7, bl5)) | 0;
    mid = (mid + Math.imul(al7, bh5)) | 0;
    mid = (mid + Math.imul(ah7, bl5)) | 0;
    hi = (hi + Math.imul(ah7, bh5)) | 0;
    lo = (lo + Math.imul(al6, bl6)) | 0;
    mid = (mid + Math.imul(al6, bh6)) | 0;
    mid = (mid + Math.imul(ah6, bl6)) | 0;
    hi = (hi + Math.imul(ah6, bh6)) | 0;
    lo = (lo + Math.imul(al5, bl7)) | 0;
    mid = (mid + Math.imul(al5, bh7)) | 0;
    mid = (mid + Math.imul(ah5, bl7)) | 0;
    hi = (hi + Math.imul(ah5, bh7)) | 0;
    lo = (lo + Math.imul(al4, bl8)) | 0;
    mid = (mid + Math.imul(al4, bh8)) | 0;
    mid = (mid + Math.imul(ah4, bl8)) | 0;
    hi = (hi + Math.imul(ah4, bh8)) | 0;
    lo = (lo + Math.imul(al3, bl9)) | 0;
    mid = (mid + Math.imul(al3, bh9)) | 0;
    mid = (mid + Math.imul(ah3, bl9)) | 0;
    hi = (hi + Math.imul(ah3, bh9)) | 0;
    var w12 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w12 >>> 26)) | 0;
    w12 &= 0x3ffffff;
    /* k = 13 */
    lo = Math.imul(al9, bl4);
    mid = Math.imul(al9, bh4);
    mid = (mid + Math.imul(ah9, bl4)) | 0;
    hi = Math.imul(ah9, bh4);
    lo = (lo + Math.imul(al8, bl5)) | 0;
    mid = (mid + Math.imul(al8, bh5)) | 0;
    mid = (mid + Math.imul(ah8, bl5)) | 0;
    hi = (hi + Math.imul(ah8, bh5)) | 0;
    lo = (lo + Math.imul(al7, bl6)) | 0;
    mid = (mid + Math.imul(al7, bh6)) | 0;
    mid = (mid + Math.imul(ah7, bl6)) | 0;
    hi = (hi + Math.imul(ah7, bh6)) | 0;
    lo = (lo + Math.imul(al6, bl7)) | 0;
    mid = (mid + Math.imul(al6, bh7)) | 0;
    mid = (mid + Math.imul(ah6, bl7)) | 0;
    hi = (hi + Math.imul(ah6, bh7)) | 0;
    lo = (lo + Math.imul(al5, bl8)) | 0;
    mid = (mid + Math.imul(al5, bh8)) | 0;
    mid = (mid + Math.imul(ah5, bl8)) | 0;
    hi = (hi + Math.imul(ah5, bh8)) | 0;
    lo = (lo + Math.imul(al4, bl9)) | 0;
    mid = (mid + Math.imul(al4, bh9)) | 0;
    mid = (mid + Math.imul(ah4, bl9)) | 0;
    hi = (hi + Math.imul(ah4, bh9)) | 0;
    var w13 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w13 >>> 26)) | 0;
    w13 &= 0x3ffffff;
    /* k = 14 */
    lo = Math.imul(al9, bl5);
    mid = Math.imul(al9, bh5);
    mid = (mid + Math.imul(ah9, bl5)) | 0;
    hi = Math.imul(ah9, bh5);
    lo = (lo + Math.imul(al8, bl6)) | 0;
    mid = (mid + Math.imul(al8, bh6)) | 0;
    mid = (mid + Math.imul(ah8, bl6)) | 0;
    hi = (hi + Math.imul(ah8, bh6)) | 0;
    lo = (lo + Math.imul(al7, bl7)) | 0;
    mid = (mid + Math.imul(al7, bh7)) | 0;
    mid = (mid + Math.imul(ah7, bl7)) | 0;
    hi = (hi + Math.imul(ah7, bh7)) | 0;
    lo = (lo + Math.imul(al6, bl8)) | 0;
    mid = (mid + Math.imul(al6, bh8)) | 0;
    mid = (mid + Math.imul(ah6, bl8)) | 0;
    hi = (hi + Math.imul(ah6, bh8)) | 0;
    lo = (lo + Math.imul(al5, bl9)) | 0;
    mid = (mid + Math.imul(al5, bh9)) | 0;
    mid = (mid + Math.imul(ah5, bl9)) | 0;
    hi = (hi + Math.imul(ah5, bh9)) | 0;
    var w14 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w14 >>> 26)) | 0;
    w14 &= 0x3ffffff;
    /* k = 15 */
    lo = Math.imul(al9, bl6);
    mid = Math.imul(al9, bh6);
    mid = (mid + Math.imul(ah9, bl6)) | 0;
    hi = Math.imul(ah9, bh6);
    lo = (lo + Math.imul(al8, bl7)) | 0;
    mid = (mid + Math.imul(al8, bh7)) | 0;
    mid = (mid + Math.imul(ah8, bl7)) | 0;
    hi = (hi + Math.imul(ah8, bh7)) | 0;
    lo = (lo + Math.imul(al7, bl8)) | 0;
    mid = (mid + Math.imul(al7, bh8)) | 0;
    mid = (mid + Math.imul(ah7, bl8)) | 0;
    hi = (hi + Math.imul(ah7, bh8)) | 0;
    lo = (lo + Math.imul(al6, bl9)) | 0;
    mid = (mid + Math.imul(al6, bh9)) | 0;
    mid = (mid + Math.imul(ah6, bl9)) | 0;
    hi = (hi + Math.imul(ah6, bh9)) | 0;
    var w15 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w15 >>> 26)) | 0;
    w15 &= 0x3ffffff;
    /* k = 16 */
    lo = Math.imul(al9, bl7);
    mid = Math.imul(al9, bh7);
    mid = (mid + Math.imul(ah9, bl7)) | 0;
    hi = Math.imul(ah9, bh7);
    lo = (lo + Math.imul(al8, bl8)) | 0;
    mid = (mid + Math.imul(al8, bh8)) | 0;
    mid = (mid + Math.imul(ah8, bl8)) | 0;
    hi = (hi + Math.imul(ah8, bh8)) | 0;
    lo = (lo + Math.imul(al7, bl9)) | 0;
    mid = (mid + Math.imul(al7, bh9)) | 0;
    mid = (mid + Math.imul(ah7, bl9)) | 0;
    hi = (hi + Math.imul(ah7, bh9)) | 0;
    var w16 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w16 >>> 26)) | 0;
    w16 &= 0x3ffffff;
    /* k = 17 */
    lo = Math.imul(al9, bl8);
    mid = Math.imul(al9, bh8);
    mid = (mid + Math.imul(ah9, bl8)) | 0;
    hi = Math.imul(ah9, bh8);
    lo = (lo + Math.imul(al8, bl9)) | 0;
    mid = (mid + Math.imul(al8, bh9)) | 0;
    mid = (mid + Math.imul(ah8, bl9)) | 0;
    hi = (hi + Math.imul(ah8, bh9)) | 0;
    var w17 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w17 >>> 26)) | 0;
    w17 &= 0x3ffffff;
    /* k = 18 */
    lo = Math.imul(al9, bl9);
    mid = Math.imul(al9, bh9);
    mid = (mid + Math.imul(ah9, bl9)) | 0;
    hi = Math.imul(ah9, bh9);
    var w18 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w18 >>> 26)) | 0;
    w18 &= 0x3ffffff;
    o[0] = w0;
    o[1] = w1;
    o[2] = w2;
    o[3] = w3;
    o[4] = w4;
    o[5] = w5;
    o[6] = w6;
    o[7] = w7;
    o[8] = w8;
    o[9] = w9;
    o[10] = w10;
    o[11] = w11;
    o[12] = w12;
    o[13] = w13;
    o[14] = w14;
    o[15] = w15;
    o[16] = w16;
    o[17] = w17;
    o[18] = w18;
    if (c !== 0) {
      o[19] = c;
      out.length++;
    }
    return out;
  };

  // Polyfill comb
  if (!Math.imul) {
    comb10MulTo = smallMulTo;
  }

  function bigMulTo (self, num, out) {
    out.negative = num.negative ^ self.negative;
    out.length = self.length + num.length;

    var carry = 0;
    var hncarry = 0;
    for (var k = 0; k < out.length - 1; k++) {
      // Sum all words with the same `i + j = k` and accumulate `ncarry`,
      // note that ncarry could be >= 0x3ffffff
      var ncarry = hncarry;
      hncarry = 0;
      var rword = carry & 0x3ffffff;
      var maxJ = Math.min(k, num.length - 1);
      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
        var i = k - j;
        var a = self.words[i] | 0;
        var b = num.words[j] | 0;
        var r = a * b;

        var lo = r & 0x3ffffff;
        ncarry = (ncarry + ((r / 0x4000000) | 0)) | 0;
        lo = (lo + rword) | 0;
        rword = lo & 0x3ffffff;
        ncarry = (ncarry + (lo >>> 26)) | 0;

        hncarry += ncarry >>> 26;
        ncarry &= 0x3ffffff;
      }
      out.words[k] = rword;
      carry = ncarry;
      ncarry = hncarry;
    }
    if (carry !== 0) {
      out.words[k] = carry;
    } else {
      out.length--;
    }

    return out.strip();
  }

  function jumboMulTo (self, num, out) {
    var fftm = new FFTM();
    return fftm.mulp(self, num, out);
  }

  BN.prototype.mulTo = function mulTo (num, out) {
    var res;
    var len = this.length + num.length;
    if (this.length === 10 && num.length === 10) {
      res = comb10MulTo(this, num, out);
    } else if (len < 63) {
      res = smallMulTo(this, num, out);
    } else if (len < 1024) {
      res = bigMulTo(this, num, out);
    } else {
      res = jumboMulTo(this, num, out);
    }

    return res;
  };

  // Cooley-Tukey algorithm for FFT
  // slightly revisited to rely on looping instead of recursion

  function FFTM (x, y) {
    this.x = x;
    this.y = y;
  }

  FFTM.prototype.makeRBT = function makeRBT (N) {
    var t = new Array(N);
    var l = BN.prototype._countBits(N) - 1;
    for (var i = 0; i < N; i++) {
      t[i] = this.revBin(i, l, N);
    }

    return t;
  };

  // Returns binary-reversed representation of `x`
  FFTM.prototype.revBin = function revBin (x, l, N) {
    if (x === 0 || x === N - 1) return x;

    var rb = 0;
    for (var i = 0; i < l; i++) {
      rb |= (x & 1) << (l - i - 1);
      x >>= 1;
    }

    return rb;
  };

  // Performs "tweedling" phase, therefore 'emulating'
  // behaviour of the recursive algorithm
  FFTM.prototype.permute = function permute (rbt, rws, iws, rtws, itws, N) {
    for (var i = 0; i < N; i++) {
      rtws[i] = rws[rbt[i]];
      itws[i] = iws[rbt[i]];
    }
  };

  FFTM.prototype.transform = function transform (rws, iws, rtws, itws, N, rbt) {
    this.permute(rbt, rws, iws, rtws, itws, N);

    for (var s = 1; s < N; s <<= 1) {
      var l = s << 1;

      var rtwdf = Math.cos(2 * Math.PI / l);
      var itwdf = Math.sin(2 * Math.PI / l);

      for (var p = 0; p < N; p += l) {
        var rtwdf_ = rtwdf;
        var itwdf_ = itwdf;

        for (var j = 0; j < s; j++) {
          var re = rtws[p + j];
          var ie = itws[p + j];

          var ro = rtws[p + j + s];
          var io = itws[p + j + s];

          var rx = rtwdf_ * ro - itwdf_ * io;

          io = rtwdf_ * io + itwdf_ * ro;
          ro = rx;

          rtws[p + j] = re + ro;
          itws[p + j] = ie + io;

          rtws[p + j + s] = re - ro;
          itws[p + j + s] = ie - io;

          /* jshint maxdepth : false */
          if (j !== l) {
            rx = rtwdf * rtwdf_ - itwdf * itwdf_;

            itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
            rtwdf_ = rx;
          }
        }
      }
    }
  };

  FFTM.prototype.guessLen13b = function guessLen13b (n, m) {
    var N = Math.max(m, n) | 1;
    var odd = N & 1;
    var i = 0;
    for (N = N / 2 | 0; N; N = N >>> 1) {
      i++;
    }

    return 1 << i + 1 + odd;
  };

  FFTM.prototype.conjugate = function conjugate (rws, iws, N) {
    if (N <= 1) return;

    for (var i = 0; i < N / 2; i++) {
      var t = rws[i];

      rws[i] = rws[N - i - 1];
      rws[N - i - 1] = t;

      t = iws[i];

      iws[i] = -iws[N - i - 1];
      iws[N - i - 1] = -t;
    }
  };

  FFTM.prototype.normalize13b = function normalize13b (ws, N) {
    var carry = 0;
    for (var i = 0; i < N / 2; i++) {
      var w = Math.round(ws[2 * i + 1] / N) * 0x2000 +
        Math.round(ws[2 * i] / N) +
        carry;

      ws[i] = w & 0x3ffffff;

      if (w < 0x4000000) {
        carry = 0;
      } else {
        carry = w / 0x4000000 | 0;
      }
    }

    return ws;
  };

  FFTM.prototype.convert13b = function convert13b (ws, len, rws, N) {
    var carry = 0;
    for (var i = 0; i < len; i++) {
      carry = carry + (ws[i] | 0);

      rws[2 * i] = carry & 0x1fff; carry = carry >>> 13;
      rws[2 * i + 1] = carry & 0x1fff; carry = carry >>> 13;
    }

    // Pad with zeroes
    for (i = 2 * len; i < N; ++i) {
      rws[i] = 0;
    }

    assert(carry === 0);
    assert((carry & ~0x1fff) === 0);
  };

  FFTM.prototype.stub = function stub (N) {
    var ph = new Array(N);
    for (var i = 0; i < N; i++) {
      ph[i] = 0;
    }

    return ph;
  };

  FFTM.prototype.mulp = function mulp (x, y, out) {
    var N = 2 * this.guessLen13b(x.length, y.length);

    var rbt = this.makeRBT(N);

    var _ = this.stub(N);

    var rws = new Array(N);
    var rwst = new Array(N);
    var iwst = new Array(N);

    var nrws = new Array(N);
    var nrwst = new Array(N);
    var niwst = new Array(N);

    var rmws = out.words;
    rmws.length = N;

    this.convert13b(x.words, x.length, rws, N);
    this.convert13b(y.words, y.length, nrws, N);

    this.transform(rws, _, rwst, iwst, N, rbt);
    this.transform(nrws, _, nrwst, niwst, N, rbt);

    for (var i = 0; i < N; i++) {
      var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];
      iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];
      rwst[i] = rx;
    }

    this.conjugate(rwst, iwst, N);
    this.transform(rwst, iwst, rmws, _, N, rbt);
    this.conjugate(rmws, _, N);
    this.normalize13b(rmws, N);

    out.negative = x.negative ^ y.negative;
    out.length = x.length + y.length;
    return out.strip();
  };

  // Multiply `this` by `num`
  BN.prototype.mul = function mul (num) {
    var out = new BN(null);
    out.words = new Array(this.length + num.length);
    return this.mulTo(num, out);
  };

  // Multiply employing FFT
  BN.prototype.mulf = function mulf (num) {
    var out = new BN(null);
    out.words = new Array(this.length + num.length);
    return jumboMulTo(this, num, out);
  };

  // In-place Multiplication
  BN.prototype.imul = function imul (num) {
    return this.clone().mulTo(num, this);
  };

  BN.prototype.imuln = function imuln (num) {
    assert(typeof num === 'number');
    assert(num < 0x4000000);

    // Carry
    var carry = 0;
    for (var i = 0; i < this.length; i++) {
      var w = (this.words[i] | 0) * num;
      var lo = (w & 0x3ffffff) + (carry & 0x3ffffff);
      carry >>= 26;
      carry += (w / 0x4000000) | 0;
      // NOTE: lo is 27bit maximum
      carry += lo >>> 26;
      this.words[i] = lo & 0x3ffffff;
    }

    if (carry !== 0) {
      this.words[i] = carry;
      this.length++;
    }

    return this;
  };

  BN.prototype.muln = function muln (num) {
    return this.clone().imuln(num);
  };

  // `this` * `this`
  BN.prototype.sqr = function sqr () {
    return this.mul(this);
  };

  // `this` * `this` in-place
  BN.prototype.isqr = function isqr () {
    return this.imul(this.clone());
  };

  // Math.pow(`this`, `num`)
  BN.prototype.pow = function pow (num) {
    var w = toBitArray(num);
    if (w.length === 0) return new BN(1);

    // Skip leading zeroes
    var res = this;
    for (var i = 0; i < w.length; i++, res = res.sqr()) {
      if (w[i] !== 0) break;
    }

    if (++i < w.length) {
      for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {
        if (w[i] === 0) continue;

        res = res.mul(q);
      }
    }

    return res;
  };

  // Shift-left in-place
  BN.prototype.iushln = function iushln (bits) {
    assert(typeof bits === 'number' && bits >= 0);
    var r = bits % 26;
    var s = (bits - r) / 26;
    var carryMask = (0x3ffffff >>> (26 - r)) << (26 - r);
    var i;

    if (r !== 0) {
      var carry = 0;

      for (i = 0; i < this.length; i++) {
        var newCarry = this.words[i] & carryMask;
        var c = ((this.words[i] | 0) - newCarry) << r;
        this.words[i] = c | carry;
        carry = newCarry >>> (26 - r);
      }

      if (carry) {
        this.words[i] = carry;
        this.length++;
      }
    }

    if (s !== 0) {
      for (i = this.length - 1; i >= 0; i--) {
        this.words[i + s] = this.words[i];
      }

      for (i = 0; i < s; i++) {
        this.words[i] = 0;
      }

      this.length += s;
    }

    return this.strip();
  };

  BN.prototype.ishln = function ishln (bits) {
    // TODO(indutny): implement me
    assert(this.negative === 0);
    return this.iushln(bits);
  };

  // Shift-right in-place
  // NOTE: `hint` is a lowest bit before trailing zeroes
  // NOTE: if `extended` is present - it will be filled with destroyed bits
  BN.prototype.iushrn = function iushrn (bits, hint, extended) {
    assert(typeof bits === 'number' && bits >= 0);
    var h;
    if (hint) {
      h = (hint - (hint % 26)) / 26;
    } else {
      h = 0;
    }

    var r = bits % 26;
    var s = Math.min((bits - r) / 26, this.length);
    var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);
    var maskedWords = extended;

    h -= s;
    h = Math.max(0, h);

    // Extended mode, copy masked part
    if (maskedWords) {
      for (var i = 0; i < s; i++) {
        maskedWords.words[i] = this.words[i];
      }
      maskedWords.length = s;
    }

    if (s === 0) {
      // No-op, we should not move anything at all
    } else if (this.length > s) {
      this.length -= s;
      for (i = 0; i < this.length; i++) {
        this.words[i] = this.words[i + s];
      }
    } else {
      this.words[0] = 0;
      this.length = 1;
    }

    var carry = 0;
    for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {
      var word = this.words[i] | 0;
      this.words[i] = (carry << (26 - r)) | (word >>> r);
      carry = word & mask;
    }

    // Push carried bits as a mask
    if (maskedWords && carry !== 0) {
      maskedWords.words[maskedWords.length++] = carry;
    }

    if (this.length === 0) {
      this.words[0] = 0;
      this.length = 1;
    }

    return this.strip();
  };

  BN.prototype.ishrn = function ishrn (bits, hint, extended) {
    // TODO(indutny): implement me
    assert(this.negative === 0);
    return this.iushrn(bits, hint, extended);
  };

  // Shift-left
  BN.prototype.shln = function shln (bits) {
    return this.clone().ishln(bits);
  };

  BN.prototype.ushln = function ushln (bits) {
    return this.clone().iushln(bits);
  };

  // Shift-right
  BN.prototype.shrn = function shrn (bits) {
    return this.clone().ishrn(bits);
  };

  BN.prototype.ushrn = function ushrn (bits) {
    return this.clone().iushrn(bits);
  };

  // Test if n bit is set
  BN.prototype.testn = function testn (bit) {
    assert(typeof bit === 'number' && bit >= 0);
    var r = bit % 26;
    var s = (bit - r) / 26;
    var q = 1 << r;

    // Fast case: bit is much higher than all existing words
    if (this.length <= s) return false;

    // Check bit and return
    var w = this.words[s];

    return !!(w & q);
  };

  // Return only lowers bits of number (in-place)
  BN.prototype.imaskn = function imaskn (bits) {
    assert(typeof bits === 'number' && bits >= 0);
    var r = bits % 26;
    var s = (bits - r) / 26;

    assert(this.negative === 0, 'imaskn works only with positive numbers');

    if (this.length <= s) {
      return this;
    }

    if (r !== 0) {
      s++;
    }
    this.length = Math.min(s, this.length);

    if (r !== 0) {
      var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);
      this.words[this.length - 1] &= mask;
    }

    return this.strip();
  };

  // Return only lowers bits of number
  BN.prototype.maskn = function maskn (bits) {
    return this.clone().imaskn(bits);
  };

  // Add plain number `num` to `this`
  BN.prototype.iaddn = function iaddn (num) {
    assert(typeof num === 'number');
    assert(num < 0x4000000);
    if (num < 0) return this.isubn(-num);

    // Possible sign change
    if (this.negative !== 0) {
      if (this.length === 1 && (this.words[0] | 0) < num) {
        this.words[0] = num - (this.words[0] | 0);
        this.negative = 0;
        return this;
      }

      this.negative = 0;
      this.isubn(num);
      this.negative = 1;
      return this;
    }

    // Add without checks
    return this._iaddn(num);
  };

  BN.prototype._iaddn = function _iaddn (num) {
    this.words[0] += num;

    // Carry
    for (var i = 0; i < this.length && this.words[i] >= 0x4000000; i++) {
      this.words[i] -= 0x4000000;
      if (i === this.length - 1) {
        this.words[i + 1] = 1;
      } else {
        this.words[i + 1]++;
      }
    }
    this.length = Math.max(this.length, i + 1);

    return this;
  };

  // Subtract plain number `num` from `this`
  BN.prototype.isubn = function isubn (num) {
    assert(typeof num === 'number');
    assert(num < 0x4000000);
    if (num < 0) return this.iaddn(-num);

    if (this.negative !== 0) {
      this.negative = 0;
      this.iaddn(num);
      this.negative = 1;
      return this;
    }

    this.words[0] -= num;

    if (this.length === 1 && this.words[0] < 0) {
      this.words[0] = -this.words[0];
      this.negative = 1;
    } else {
      // Carry
      for (var i = 0; i < this.length && this.words[i] < 0; i++) {
        this.words[i] += 0x4000000;
        this.words[i + 1] -= 1;
      }
    }

    return this.strip();
  };

  BN.prototype.addn = function addn (num) {
    return this.clone().iaddn(num);
  };

  BN.prototype.subn = function subn (num) {
    return this.clone().isubn(num);
  };

  BN.prototype.iabs = function iabs () {
    this.negative = 0;

    return this;
  };

  BN.prototype.abs = function abs () {
    return this.clone().iabs();
  };

  BN.prototype._ishlnsubmul = function _ishlnsubmul (num, mul, shift) {
    var len = num.length + shift;
    var i;

    this._expand(len);

    var w;
    var carry = 0;
    for (i = 0; i < num.length; i++) {
      w = (this.words[i + shift] | 0) + carry;
      var right = (num.words[i] | 0) * mul;
      w -= right & 0x3ffffff;
      carry = (w >> 26) - ((right / 0x4000000) | 0);
      this.words[i + shift] = w & 0x3ffffff;
    }
    for (; i < this.length - shift; i++) {
      w = (this.words[i + shift] | 0) + carry;
      carry = w >> 26;
      this.words[i + shift] = w & 0x3ffffff;
    }

    if (carry === 0) return this.strip();

    // Subtraction overflow
    assert(carry === -1);
    carry = 0;
    for (i = 0; i < this.length; i++) {
      w = -(this.words[i] | 0) + carry;
      carry = w >> 26;
      this.words[i] = w & 0x3ffffff;
    }
    this.negative = 1;

    return this.strip();
  };

  BN.prototype._wordDiv = function _wordDiv (num, mode) {
    var shift = this.length - num.length;

    var a = this.clone();
    var b = num;

    // Normalize
    var bhi = b.words[b.length - 1] | 0;
    var bhiBits = this._countBits(bhi);
    shift = 26 - bhiBits;
    if (shift !== 0) {
      b = b.ushln(shift);
      a.iushln(shift);
      bhi = b.words[b.length - 1] | 0;
    }

    // Initialize quotient
    var m = a.length - b.length;
    var q;

    if (mode !== 'mod') {
      q = new BN(null);
      q.length = m + 1;
      q.words = new Array(q.length);
      for (var i = 0; i < q.length; i++) {
        q.words[i] = 0;
      }
    }

    var diff = a.clone()._ishlnsubmul(b, 1, m);
    if (diff.negative === 0) {
      a = diff;
      if (q) {
        q.words[m] = 1;
      }
    }

    for (var j = m - 1; j >= 0; j--) {
      var qj = (a.words[b.length + j] | 0) * 0x4000000 +
        (a.words[b.length + j - 1] | 0);

      // NOTE: (qj / bhi) is (0x3ffffff * 0x4000000 + 0x3ffffff) / 0x2000000 max
      // (0x7ffffff)
      qj = Math.min((qj / bhi) | 0, 0x3ffffff);

      a._ishlnsubmul(b, qj, j);
      while (a.negative !== 0) {
        qj--;
        a.negative = 0;
        a._ishlnsubmul(b, 1, j);
        if (!a.isZero()) {
          a.negative ^= 1;
        }
      }
      if (q) {
        q.words[j] = qj;
      }
    }
    if (q) {
      q.strip();
    }
    a.strip();

    // Denormalize
    if (mode !== 'div' && shift !== 0) {
      a.iushrn(shift);
    }

    return {
      div: q || null,
      mod: a
    };
  };

  // NOTE: 1) `mode` can be set to `mod` to request mod only,
  //       to `div` to request div only, or be absent to
  //       request both div & mod
  //       2) `positive` is true if unsigned mod is requested
  BN.prototype.divmod = function divmod (num, mode, positive) {
    assert(!num.isZero());

    if (this.isZero()) {
      return {
        div: new BN(0),
        mod: new BN(0)
      };
    }

    var div, mod, res;
    if (this.negative !== 0 && num.negative === 0) {
      res = this.neg().divmod(num, mode);

      if (mode !== 'mod') {
        div = res.div.neg();
      }

      if (mode !== 'div') {
        mod = res.mod.neg();
        if (positive && mod.negative !== 0) {
          mod.iadd(num);
        }
      }

      return {
        div: div,
        mod: mod
      };
    }

    if (this.negative === 0 && num.negative !== 0) {
      res = this.divmod(num.neg(), mode);

      if (mode !== 'mod') {
        div = res.div.neg();
      }

      return {
        div: div,
        mod: res.mod
      };
    }

    if ((this.negative & num.negative) !== 0) {
      res = this.neg().divmod(num.neg(), mode);

      if (mode !== 'div') {
        mod = res.mod.neg();
        if (positive && mod.negative !== 0) {
          mod.isub(num);
        }
      }

      return {
        div: res.div,
        mod: mod
      };
    }

    // Both numbers are positive at this point

    // Strip both numbers to approximate shift value
    if (num.length > this.length || this.cmp(num) < 0) {
      return {
        div: new BN(0),
        mod: this
      };
    }

    // Very short reduction
    if (num.length === 1) {
      if (mode === 'div') {
        return {
          div: this.divn(num.words[0]),
          mod: null
        };
      }

      if (mode === 'mod') {
        return {
          div: null,
          mod: new BN(this.modn(num.words[0]))
        };
      }

      return {
        div: this.divn(num.words[0]),
        mod: new BN(this.modn(num.words[0]))
      };
    }

    return this._wordDiv(num, mode);
  };

  // Find `this` / `num`
  BN.prototype.div = function div (num) {
    return this.divmod(num, 'div', false).div;
  };

  // Find `this` % `num`
  BN.prototype.mod = function mod (num) {
    return this.divmod(num, 'mod', false).mod;
  };

  BN.prototype.umod = function umod (num) {
    return this.divmod(num, 'mod', true).mod;
  };

  // Find Round(`this` / `num`)
  BN.prototype.divRound = function divRound (num) {
    var dm = this.divmod(num);

    // Fast case - exact division
    if (dm.mod.isZero()) return dm.div;

    var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;

    var half = num.ushrn(1);
    var r2 = num.andln(1);
    var cmp = mod.cmp(half);

    // Round down
    if (cmp < 0 || r2 === 1 && cmp === 0) return dm.div;

    // Round up
    return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
  };

  BN.prototype.modn = function modn (num) {
    assert(num <= 0x3ffffff);
    var p = (1 << 26) % num;

    var acc = 0;
    for (var i = this.length - 1; i >= 0; i--) {
      acc = (p * acc + (this.words[i] | 0)) % num;
    }

    return acc;
  };

  // In-place division by number
  BN.prototype.idivn = function idivn (num) {
    assert(num <= 0x3ffffff);

    var carry = 0;
    for (var i = this.length - 1; i >= 0; i--) {
      var w = (this.words[i] | 0) + carry * 0x4000000;
      this.words[i] = (w / num) | 0;
      carry = w % num;
    }

    return this.strip();
  };

  BN.prototype.divn = function divn (num) {
    return this.clone().idivn(num);
  };

  BN.prototype.egcd = function egcd (p) {
    assert(p.negative === 0);
    assert(!p.isZero());

    var x = this;
    var y = p.clone();

    if (x.negative !== 0) {
      x = x.umod(p);
    } else {
      x = x.clone();
    }

    // A * x + B * y = x
    var A = new BN(1);
    var B = new BN(0);

    // C * x + D * y = y
    var C = new BN(0);
    var D = new BN(1);

    var g = 0;

    while (x.isEven() && y.isEven()) {
      x.iushrn(1);
      y.iushrn(1);
      ++g;
    }

    var yp = y.clone();
    var xp = x.clone();

    while (!x.isZero()) {
      for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
      if (i > 0) {
        x.iushrn(i);
        while (i-- > 0) {
          if (A.isOdd() || B.isOdd()) {
            A.iadd(yp);
            B.isub(xp);
          }

          A.iushrn(1);
          B.iushrn(1);
        }
      }

      for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
      if (j > 0) {
        y.iushrn(j);
        while (j-- > 0) {
          if (C.isOdd() || D.isOdd()) {
            C.iadd(yp);
            D.isub(xp);
          }

          C.iushrn(1);
          D.iushrn(1);
        }
      }

      if (x.cmp(y) >= 0) {
        x.isub(y);
        A.isub(C);
        B.isub(D);
      } else {
        y.isub(x);
        C.isub(A);
        D.isub(B);
      }
    }

    return {
      a: C,
      b: D,
      gcd: y.iushln(g)
    };
  };

  // This is reduced incarnation of the binary EEA
  // above, designated to invert members of the
  // _prime_ fields F(p) at a maximal speed
  BN.prototype._invmp = function _invmp (p) {
    assert(p.negative === 0);
    assert(!p.isZero());

    var a = this;
    var b = p.clone();

    if (a.negative !== 0) {
      a = a.umod(p);
    } else {
      a = a.clone();
    }

    var x1 = new BN(1);
    var x2 = new BN(0);

    var delta = b.clone();

    while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
      for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
      if (i > 0) {
        a.iushrn(i);
        while (i-- > 0) {
          if (x1.isOdd()) {
            x1.iadd(delta);
          }

          x1.iushrn(1);
        }
      }

      for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
      if (j > 0) {
        b.iushrn(j);
        while (j-- > 0) {
          if (x2.isOdd()) {
            x2.iadd(delta);
          }

          x2.iushrn(1);
        }
      }

      if (a.cmp(b) >= 0) {
        a.isub(b);
        x1.isub(x2);
      } else {
        b.isub(a);
        x2.isub(x1);
      }
    }

    var res;
    if (a.cmpn(1) === 0) {
      res = x1;
    } else {
      res = x2;
    }

    if (res.cmpn(0) < 0) {
      res.iadd(p);
    }

    return res;
  };

  BN.prototype.gcd = function gcd (num) {
    if (this.isZero()) return num.abs();
    if (num.isZero()) return this.abs();

    var a = this.clone();
    var b = num.clone();
    a.negative = 0;
    b.negative = 0;

    // Remove common factor of two
    for (var shift = 0; a.isEven() && b.isEven(); shift++) {
      a.iushrn(1);
      b.iushrn(1);
    }

    do {
      while (a.isEven()) {
        a.iushrn(1);
      }
      while (b.isEven()) {
        b.iushrn(1);
      }

      var r = a.cmp(b);
      if (r < 0) {
        // Swap `a` and `b` to make `a` always bigger than `b`
        var t = a;
        a = b;
        b = t;
      } else if (r === 0 || b.cmpn(1) === 0) {
        break;
      }

      a.isub(b);
    } while (true);

    return b.iushln(shift);
  };

  // Invert number in the field F(num)
  BN.prototype.invm = function invm (num) {
    return this.egcd(num).a.umod(num);
  };

  BN.prototype.isEven = function isEven () {
    return (this.words[0] & 1) === 0;
  };

  BN.prototype.isOdd = function isOdd () {
    return (this.words[0] & 1) === 1;
  };

  // And first word and num
  BN.prototype.andln = function andln (num) {
    return this.words[0] & num;
  };

  // Increment at the bit position in-line
  BN.prototype.bincn = function bincn (bit) {
    assert(typeof bit === 'number');
    var r = bit % 26;
    var s = (bit - r) / 26;
    var q = 1 << r;

    // Fast case: bit is much higher than all existing words
    if (this.length <= s) {
      this._expand(s + 1);
      this.words[s] |= q;
      return this;
    }

    // Add bit and propagate, if needed
    var carry = q;
    for (var i = s; carry !== 0 && i < this.length; i++) {
      var w = this.words[i] | 0;
      w += carry;
      carry = w >>> 26;
      w &= 0x3ffffff;
      this.words[i] = w;
    }
    if (carry !== 0) {
      this.words[i] = carry;
      this.length++;
    }
    return this;
  };

  BN.prototype.isZero = function isZero () {
    return this.length === 1 && this.words[0] === 0;
  };

  BN.prototype.cmpn = function cmpn (num) {
    var negative = num < 0;

    if (this.negative !== 0 && !negative) return -1;
    if (this.negative === 0 && negative) return 1;

    this.strip();

    var res;
    if (this.length > 1) {
      res = 1;
    } else {
      if (negative) {
        num = -num;
      }

      assert(num <= 0x3ffffff, 'Number is too big');

      var w = this.words[0] | 0;
      res = w === num ? 0 : w < num ? -1 : 1;
    }
    if (this.negative !== 0) return -res | 0;
    return res;
  };

  // Compare two numbers and return:
  // 1 - if `this` > `num`
  // 0 - if `this` == `num`
  // -1 - if `this` < `num`
  BN.prototype.cmp = function cmp (num) {
    if (this.negative !== 0 && num.negative === 0) return -1;
    if (this.negative === 0 && num.negative !== 0) return 1;

    var res = this.ucmp(num);
    if (this.negative !== 0) return -res | 0;
    return res;
  };

  // Unsigned comparison
  BN.prototype.ucmp = function ucmp (num) {
    // At this point both numbers have the same sign
    if (this.length > num.length) return 1;
    if (this.length < num.length) return -1;

    var res = 0;
    for (var i = this.length - 1; i >= 0; i--) {
      var a = this.words[i] | 0;
      var b = num.words[i] | 0;

      if (a === b) continue;
      if (a < b) {
        res = -1;
      } else if (a > b) {
        res = 1;
      }
      break;
    }
    return res;
  };

  BN.prototype.gtn = function gtn (num) {
    return this.cmpn(num) === 1;
  };

  BN.prototype.gt = function gt (num) {
    return this.cmp(num) === 1;
  };

  BN.prototype.gten = function gten (num) {
    return this.cmpn(num) >= 0;
  };

  BN.prototype.gte = function gte (num) {
    return this.cmp(num) >= 0;
  };

  BN.prototype.ltn = function ltn (num) {
    return this.cmpn(num) === -1;
  };

  BN.prototype.lt = function lt (num) {
    return this.cmp(num) === -1;
  };

  BN.prototype.lten = function lten (num) {
    return this.cmpn(num) <= 0;
  };

  BN.prototype.lte = function lte (num) {
    return this.cmp(num) <= 0;
  };

  BN.prototype.eqn = function eqn (num) {
    return this.cmpn(num) === 0;
  };

  BN.prototype.eq = function eq (num) {
    return this.cmp(num) === 0;
  };

  //
  // A reduce context, could be using montgomery or something better, depending
  // on the `m` itself.
  //
  BN.red = function red (num) {
    return new Red(num);
  };

  BN.prototype.toRed = function toRed (ctx) {
    assert(!this.red, 'Already a number in reduction context');
    assert(this.negative === 0, 'red works only with positives');
    return ctx.convertTo(this)._forceRed(ctx);
  };

  BN.prototype.fromRed = function fromRed () {
    assert(this.red, 'fromRed works only with numbers in reduction context');
    return this.red.convertFrom(this);
  };

  BN.prototype._forceRed = function _forceRed (ctx) {
    this.red = ctx;
    return this;
  };

  BN.prototype.forceRed = function forceRed (ctx) {
    assert(!this.red, 'Already a number in reduction context');
    return this._forceRed(ctx);
  };

  BN.prototype.redAdd = function redAdd (num) {
    assert(this.red, 'redAdd works only with red numbers');
    return this.red.add(this, num);
  };

  BN.prototype.redIAdd = function redIAdd (num) {
    assert(this.red, 'redIAdd works only with red numbers');
    return this.red.iadd(this, num);
  };

  BN.prototype.redSub = function redSub (num) {
    assert(this.red, 'redSub works only with red numbers');
    return this.red.sub(this, num);
  };

  BN.prototype.redISub = function redISub (num) {
    assert(this.red, 'redISub works only with red numbers');
    return this.red.isub(this, num);
  };

  BN.prototype.redShl = function redShl (num) {
    assert(this.red, 'redShl works only with red numbers');
    return this.red.shl(this, num);
  };

  BN.prototype.redMul = function redMul (num) {
    assert(this.red, 'redMul works only with red numbers');
    this.red._verify2(this, num);
    return this.red.mul(this, num);
  };

  BN.prototype.redIMul = function redIMul (num) {
    assert(this.red, 'redMul works only with red numbers');
    this.red._verify2(this, num);
    return this.red.imul(this, num);
  };

  BN.prototype.redSqr = function redSqr () {
    assert(this.red, 'redSqr works only with red numbers');
    this.red._verify1(this);
    return this.red.sqr(this);
  };

  BN.prototype.redISqr = function redISqr () {
    assert(this.red, 'redISqr works only with red numbers');
    this.red._verify1(this);
    return this.red.isqr(this);
  };

  // Square root over p
  BN.prototype.redSqrt = function redSqrt () {
    assert(this.red, 'redSqrt works only with red numbers');
    this.red._verify1(this);
    return this.red.sqrt(this);
  };

  BN.prototype.redInvm = function redInvm () {
    assert(this.red, 'redInvm works only with red numbers');
    this.red._verify1(this);
    return this.red.invm(this);
  };

  // Return negative clone of `this` % `red modulo`
  BN.prototype.redNeg = function redNeg () {
    assert(this.red, 'redNeg works only with red numbers');
    this.red._verify1(this);
    return this.red.neg(this);
  };

  BN.prototype.redPow = function redPow (num) {
    assert(this.red && !num.red, 'redPow(normalNum)');
    this.red._verify1(this);
    return this.red.pow(this, num);
  };

  // Prime numbers with efficient reduction
  var primes = {
    k256: null,
    p224: null,
    p192: null,
    p25519: null
  };

  // Pseudo-Mersenne prime
  function MPrime (name, p) {
    // P = 2 ^ N - K
    this.name = name;
    this.p = new BN(p, 16);
    this.n = this.p.bitLength();
    this.k = new BN(1).iushln(this.n).isub(this.p);

    this.tmp = this._tmp();
  }

  MPrime.prototype._tmp = function _tmp () {
    var tmp = new BN(null);
    tmp.words = new Array(Math.ceil(this.n / 13));
    return tmp;
  };

  MPrime.prototype.ireduce = function ireduce (num) {
    // Assumes that `num` is less than `P^2`
    // num = HI * (2 ^ N - K) + HI * K + LO = HI * K + LO (mod P)
    var r = num;
    var rlen;

    do {
      this.split(r, this.tmp);
      r = this.imulK(r);
      r = r.iadd(this.tmp);
      rlen = r.bitLength();
    } while (rlen > this.n);

    var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
    if (cmp === 0) {
      r.words[0] = 0;
      r.length = 1;
    } else if (cmp > 0) {
      r.isub(this.p);
    } else {
      if (r.strip !== undefined) {
        // r is BN v4 instance
        r.strip();
      } else {
        // r is BN v5 instance
        r._strip();
      }
    }

    return r;
  };

  MPrime.prototype.split = function split (input, out) {
    input.iushrn(this.n, 0, out);
  };

  MPrime.prototype.imulK = function imulK (num) {
    return num.imul(this.k);
  };

  function K256 () {
    MPrime.call(
      this,
      'k256',
      'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f');
  }
  inherits(K256, MPrime);

  K256.prototype.split = function split (input, output) {
    // 256 = 9 * 26 + 22
    var mask = 0x3fffff;

    var outLen = Math.min(input.length, 9);
    for (var i = 0; i < outLen; i++) {
      output.words[i] = input.words[i];
    }
    output.length = outLen;

    if (input.length <= 9) {
      input.words[0] = 0;
      input.length = 1;
      return;
    }

    // Shift by 9 limbs
    var prev = input.words[9];
    output.words[output.length++] = prev & mask;

    for (i = 10; i < input.length; i++) {
      var next = input.words[i] | 0;
      input.words[i - 10] = ((next & mask) << 4) | (prev >>> 22);
      prev = next;
    }
    prev >>>= 22;
    input.words[i - 10] = prev;
    if (prev === 0 && input.length > 10) {
      input.length -= 10;
    } else {
      input.length -= 9;
    }
  };

  K256.prototype.imulK = function imulK (num) {
    // K = 0x1000003d1 = [ 0x40, 0x3d1 ]
    num.words[num.length] = 0;
    num.words[num.length + 1] = 0;
    num.length += 2;

    // bounded at: 0x40 * 0x3ffffff + 0x3d0 = 0x100000390
    var lo = 0;
    for (var i = 0; i < num.length; i++) {
      var w = num.words[i] | 0;
      lo += w * 0x3d1;
      num.words[i] = lo & 0x3ffffff;
      lo = w * 0x40 + ((lo / 0x4000000) | 0);
    }

    // Fast length reduction
    if (num.words[num.length - 1] === 0) {
      num.length--;
      if (num.words[num.length - 1] === 0) {
        num.length--;
      }
    }
    return num;
  };

  function P224 () {
    MPrime.call(
      this,
      'p224',
      'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001');
  }
  inherits(P224, MPrime);

  function P192 () {
    MPrime.call(
      this,
      'p192',
      'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff');
  }
  inherits(P192, MPrime);

  function P25519 () {
    // 2 ^ 255 - 19
    MPrime.call(
      this,
      '25519',
      '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed');
  }
  inherits(P25519, MPrime);

  P25519.prototype.imulK = function imulK (num) {
    // K = 0x13
    var carry = 0;
    for (var i = 0; i < num.length; i++) {
      var hi = (num.words[i] | 0) * 0x13 + carry;
      var lo = hi & 0x3ffffff;
      hi >>>= 26;

      num.words[i] = lo;
      carry = hi;
    }
    if (carry !== 0) {
      num.words[num.length++] = carry;
    }
    return num;
  };

  // Exported mostly for testing purposes, use plain name instead
  BN._prime = function prime (name) {
    // Cached version of prime
    if (primes[name]) return primes[name];

    var prime;
    if (name === 'k256') {
      prime = new K256();
    } else if (name === 'p224') {
      prime = new P224();
    } else if (name === 'p192') {
      prime = new P192();
    } else if (name === 'p25519') {
      prime = new P25519();
    } else {
      throw new Error('Unknown prime ' + name);
    }
    primes[name] = prime;

    return prime;
  };

  //
  // Base reduction engine
  //
  function Red (m) {
    if (typeof m === 'string') {
      var prime = BN._prime(m);
      this.m = prime.p;
      this.prime = prime;
    } else {
      assert(m.gtn(1), 'modulus must be greater than 1');
      this.m = m;
      this.prime = null;
    }
  }

  Red.prototype._verify1 = function _verify1 (a) {
    assert(a.negative === 0, 'red works only with positives');
    assert(a.red, 'red works only with red numbers');
  };

  Red.prototype._verify2 = function _verify2 (a, b) {
    assert((a.negative | b.negative) === 0, 'red works only with positives');
    assert(a.red && a.red === b.red,
      'red works only with red numbers');
  };

  Red.prototype.imod = function imod (a) {
    if (this.prime) return this.prime.ireduce(a)._forceRed(this);
    return a.umod(this.m)._forceRed(this);
  };

  Red.prototype.neg = function neg (a) {
    if (a.isZero()) {
      return a.clone();
    }

    return this.m.sub(a)._forceRed(this);
  };

  Red.prototype.add = function add (a, b) {
    this._verify2(a, b);

    var res = a.add(b);
    if (res.cmp(this.m) >= 0) {
      res.isub(this.m);
    }
    return res._forceRed(this);
  };

  Red.prototype.iadd = function iadd (a, b) {
    this._verify2(a, b);

    var res = a.iadd(b);
    if (res.cmp(this.m) >= 0) {
      res.isub(this.m);
    }
    return res;
  };

  Red.prototype.sub = function sub (a, b) {
    this._verify2(a, b);

    var res = a.sub(b);
    if (res.cmpn(0) < 0) {
      res.iadd(this.m);
    }
    return res._forceRed(this);
  };

  Red.prototype.isub = function isub (a, b) {
    this._verify2(a, b);

    var res = a.isub(b);
    if (res.cmpn(0) < 0) {
      res.iadd(this.m);
    }
    return res;
  };

  Red.prototype.shl = function shl (a, num) {
    this._verify1(a);
    return this.imod(a.ushln(num));
  };

  Red.prototype.imul = function imul (a, b) {
    this._verify2(a, b);
    return this.imod(a.imul(b));
  };

  Red.prototype.mul = function mul (a, b) {
    this._verify2(a, b);
    return this.imod(a.mul(b));
  };

  Red.prototype.isqr = function isqr (a) {
    return this.imul(a, a.clone());
  };

  Red.prototype.sqr = function sqr (a) {
    return this.mul(a, a);
  };

  Red.prototype.sqrt = function sqrt (a) {
    if (a.isZero()) return a.clone();

    var mod3 = this.m.andln(3);
    assert(mod3 % 2 === 1);

    // Fast case
    if (mod3 === 3) {
      var pow = this.m.add(new BN(1)).iushrn(2);
      return this.pow(a, pow);
    }

    // Tonelli-Shanks algorithm (Totally unoptimized and slow)
    //
    // Find Q and S, that Q * 2 ^ S = (P - 1)
    var q = this.m.subn(1);
    var s = 0;
    while (!q.isZero() && q.andln(1) === 0) {
      s++;
      q.iushrn(1);
    }
    assert(!q.isZero());

    var one = new BN(1).toRed(this);
    var nOne = one.redNeg();

    // Find quadratic non-residue
    // NOTE: Max is such because of generalized Riemann hypothesis.
    var lpow = this.m.subn(1).iushrn(1);
    var z = this.m.bitLength();
    z = new BN(2 * z * z).toRed(this);

    while (this.pow(z, lpow).cmp(nOne) !== 0) {
      z.redIAdd(nOne);
    }

    var c = this.pow(z, q);
    var r = this.pow(a, q.addn(1).iushrn(1));
    var t = this.pow(a, q);
    var m = s;
    while (t.cmp(one) !== 0) {
      var tmp = t;
      for (var i = 0; tmp.cmp(one) !== 0; i++) {
        tmp = tmp.redSqr();
      }
      assert(i < m);
      var b = this.pow(c, new BN(1).iushln(m - i - 1));

      r = r.redMul(b);
      c = b.redSqr();
      t = t.redMul(c);
      m = i;
    }

    return r;
  };

  Red.prototype.invm = function invm (a) {
    var inv = a._invmp(this.m);
    if (inv.negative !== 0) {
      inv.negative = 0;
      return this.imod(inv).redNeg();
    } else {
      return this.imod(inv);
    }
  };

  Red.prototype.pow = function pow (a, num) {
    if (num.isZero()) return new BN(1).toRed(this);
    if (num.cmpn(1) === 0) return a.clone();

    var windowSize = 4;
    var wnd = new Array(1 << windowSize);
    wnd[0] = new BN(1).toRed(this);
    wnd[1] = a;
    for (var i = 2; i < wnd.length; i++) {
      wnd[i] = this.mul(wnd[i - 1], a);
    }

    var res = wnd[0];
    var current = 0;
    var currentLen = 0;
    var start = num.bitLength() % 26;
    if (start === 0) {
      start = 26;
    }

    for (i = num.length - 1; i >= 0; i--) {
      var word = num.words[i];
      for (var j = start - 1; j >= 0; j--) {
        var bit = (word >> j) & 1;
        if (res !== wnd[0]) {
          res = this.sqr(res);
        }

        if (bit === 0 && current === 0) {
          currentLen = 0;
          continue;
        }

        current <<= 1;
        current |= bit;
        currentLen++;
        if (currentLen !== windowSize && (i !== 0 || j !== 0)) continue;

        res = this.mul(res, wnd[current]);
        currentLen = 0;
        current = 0;
      }
      start = 26;
    }

    return res;
  };

  Red.prototype.convertTo = function convertTo (num) {
    var r = num.umod(this.m);

    return r === num ? r.clone() : r;
  };

  Red.prototype.convertFrom = function convertFrom (num) {
    var res = num.clone();
    res.red = null;
    return res;
  };

  //
  // Montgomery method engine
  //

  BN.mont = function mont (num) {
    return new Mont(num);
  };

  function Mont (m) {
    Red.call(this, m);

    this.shift = this.m.bitLength();
    if (this.shift % 26 !== 0) {
      this.shift += 26 - (this.shift % 26);
    }

    this.r = new BN(1).iushln(this.shift);
    this.r2 = this.imod(this.r.sqr());
    this.rinv = this.r._invmp(this.m);

    this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
    this.minv = this.minv.umod(this.r);
    this.minv = this.r.sub(this.minv);
  }
  inherits(Mont, Red);

  Mont.prototype.convertTo = function convertTo (num) {
    return this.imod(num.ushln(this.shift));
  };

  Mont.prototype.convertFrom = function convertFrom (num) {
    var r = this.imod(num.mul(this.rinv));
    r.red = null;
    return r;
  };

  Mont.prototype.imul = function imul (a, b) {
    if (a.isZero() || b.isZero()) {
      a.words[0] = 0;
      a.length = 1;
      return a;
    }

    var t = a.imul(b);
    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
    var u = t.isub(c).iushrn(this.shift);
    var res = u;

    if (u.cmp(this.m) >= 0) {
      res = u.isub(this.m);
    } else if (u.cmpn(0) < 0) {
      res = u.iadd(this.m);
    }

    return res._forceRed(this);
  };

  Mont.prototype.mul = function mul (a, b) {
    if (a.isZero() || b.isZero()) return new BN(0)._forceRed(this);

    var t = a.mul(b);
    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
    var u = t.isub(c).iushrn(this.shift);
    var res = u;
    if (u.cmp(this.m) >= 0) {
      res = u.isub(this.m);
    } else if (u.cmpn(0) < 0) {
      res = u.iadd(this.m);
    }

    return res._forceRed(this);
  };

  Mont.prototype.invm = function invm (a) {
    // (AR)^-1 * R^2 = (A^-1 * R^-1) * R^2 = A^-1 * R
    var res = this.imod(a._invmp(this.m).mul(this.r2));
    return res._forceRed(this);
  };
})( false || module, this);


/***/ }),

/***/ 9561:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const is_typedarray_1 = __importDefault(__webpack_require__(9225));
const typedarray_to_buffer_1 = __importDefault(__webpack_require__(4527));
const ENC_HEX = 'hex';
const ENC_UTF8 = 'utf8';
const ENC_BIN = 'binary';
const TYPE_BUFFER = 'buffer';
const TYPE_ARRAY = 'array';
const TYPE_TYPED_ARRAY = 'typed-array';
const TYPE_ARRAY_BUFFER = 'array-buffer';
const STRING_ZERO = '0';
function bufferToArray(buf) {
    return new Uint8Array(buf);
}
exports.bufferToArray = bufferToArray;
function bufferToHex(buf, prefixed = false) {
    const hex = buf.toString(ENC_HEX);
    return prefixed ? addHexPrefix(hex) : hex;
}
exports.bufferToHex = bufferToHex;
function bufferToUtf8(buf) {
    return buf.toString(ENC_UTF8);
}
exports.bufferToUtf8 = bufferToUtf8;
function bufferToNumber(buf) {
    return buf.readUIntBE(0, buf.length);
}
exports.bufferToNumber = bufferToNumber;
function bufferToBinary(buf) {
    return arrayToBinary(bufferToArray(buf));
}
exports.bufferToBinary = bufferToBinary;
function arrayToBuffer(arr) {
    return typedarray_to_buffer_1.default(arr);
}
exports.arrayToBuffer = arrayToBuffer;
function arrayToHex(arr, prefixed = false) {
    return bufferToHex(arrayToBuffer(arr), prefixed);
}
exports.arrayToHex = arrayToHex;
function arrayToUtf8(arr) {
    return bufferToUtf8(arrayToBuffer(arr));
}
exports.arrayToUtf8 = arrayToUtf8;
function arrayToNumber(arr) {
    return bufferToNumber(arrayToBuffer(arr));
}
exports.arrayToNumber = arrayToNumber;
function arrayToBinary(arr) {
    return Array.from(arr)
        .map(numberToBinary)
        .join('');
}
exports.arrayToBinary = arrayToBinary;
function hexToBuffer(hex) {
    return Buffer.from(removeHexPrefix(hex), ENC_HEX);
}
exports.hexToBuffer = hexToBuffer;
function hexToArray(hex) {
    return bufferToArray(hexToBuffer(hex));
}
exports.hexToArray = hexToArray;
function hexToUtf8(hex) {
    return bufferToUtf8(hexToBuffer(hex));
}
exports.hexToUtf8 = hexToUtf8;
function hexToNumber(hex) {
    return arrayToNumber(hexToArray(hex));
}
exports.hexToNumber = hexToNumber;
function hexToBinary(hex) {
    return arrayToBinary(hexToArray(hex));
}
exports.hexToBinary = hexToBinary;
function utf8ToBuffer(utf8) {
    return Buffer.from(utf8, ENC_UTF8);
}
exports.utf8ToBuffer = utf8ToBuffer;
function utf8ToArray(utf8) {
    return bufferToArray(utf8ToBuffer(utf8));
}
exports.utf8ToArray = utf8ToArray;
function utf8ToHex(utf8, prefixed = false) {
    return bufferToHex(utf8ToBuffer(utf8), prefixed);
}
exports.utf8ToHex = utf8ToHex;
function utf8ToNumber(utf8) {
    const num = parseInt(utf8, 10);
    assert(isDefined(num), 'Number can only safely store up to 53 bits');
    return num;
}
exports.utf8ToNumber = utf8ToNumber;
function utf8ToBinary(utf8) {
    return arrayToBinary(utf8ToArray(utf8));
}
exports.utf8ToBinary = utf8ToBinary;
function numberToBuffer(num) {
    return binaryToBuffer(numberToBinary(num));
}
exports.numberToBuffer = numberToBuffer;
function numberToArray(num) {
    return binaryToArray(numberToBinary(num));
}
exports.numberToArray = numberToArray;
function numberToHex(num, prefixed) {
    return binaryToHex(numberToBinary(num), prefixed);
}
exports.numberToHex = numberToHex;
function numberToUtf8(num) {
    return `${num}`;
}
exports.numberToUtf8 = numberToUtf8;
function numberToBinary(num) {
    const bin = (num >>> 0).toString(2);
    return sanitizeBytes(bin);
}
exports.numberToBinary = numberToBinary;
function binaryToBuffer(bin) {
    return arrayToBuffer(binaryToArray(bin));
}
exports.binaryToBuffer = binaryToBuffer;
function binaryToArray(bin) {
    return new Uint8Array(splitBytes(bin).map(x => parseInt(x, 2)));
}
exports.binaryToArray = binaryToArray;
function binaryToHex(bin, prefixed) {
    return arrayToHex(binaryToArray(bin), prefixed);
}
exports.binaryToHex = binaryToHex;
function binaryToUtf8(bin) {
    return arrayToUtf8(binaryToArray(bin));
}
exports.binaryToUtf8 = binaryToUtf8;
function binaryToNumber(bin) {
    return arrayToNumber(binaryToArray(bin));
}
exports.binaryToNumber = binaryToNumber;
function isBinaryString(str) {
    if (typeof str !== 'string' || !new RegExp(/^[01]+$/).test(str)) {
        return false;
    }
    if (str.length % 8 !== 0) {
        return false;
    }
    return true;
}
exports.isBinaryString = isBinaryString;
function isHexString(str, length) {
    if (typeof str !== 'string' || !str.match(/^0x[0-9A-Fa-f]*$/)) {
        return false;
    }
    if (length && str.length !== 2 + 2 * length) {
        return false;
    }
    return true;
}
exports.isHexString = isHexString;
function isBuffer(val) {
    return Buffer.isBuffer(val);
}
exports.isBuffer = isBuffer;
function isTypedArray(val) {
    return is_typedarray_1.default.strict(val) && !isBuffer(val);
}
exports.isTypedArray = isTypedArray;
function isArrayBuffer(val) {
    return (!isTypedArray(val) &&
        !isBuffer(val) &&
        typeof val.byteLength !== 'undefined');
}
exports.isArrayBuffer = isArrayBuffer;
function getType(val) {
    if (isBuffer(val)) {
        return TYPE_BUFFER;
    }
    else if (isTypedArray(val)) {
        return TYPE_TYPED_ARRAY;
    }
    else if (isArrayBuffer(val)) {
        return TYPE_ARRAY_BUFFER;
    }
    else if (Array.isArray(val)) {
        return TYPE_ARRAY;
    }
    else {
        return typeof val;
    }
}
exports.getType = getType;
function getEncoding(str) {
    if (isBinaryString(str)) {
        return ENC_BIN;
    }
    if (isHexString(str)) {
        return ENC_HEX;
    }
    return ENC_UTF8;
}
exports.getEncoding = getEncoding;
function concatBuffers(...args) {
    const result = Buffer.concat(args);
    return result;
}
exports.concatBuffers = concatBuffers;
function concatArrays(...args) {
    let result = [];
    args.forEach(arg => (result = result.concat(Array.from(arg))));
    return new Uint8Array([...result]);
}
exports.concatArrays = concatArrays;
function trimLeft(data, length) {
    const diff = data.length - length;
    if (diff > 0) {
        data = data.slice(diff);
    }
    return data;
}
exports.trimLeft = trimLeft;
function trimRight(data, length) {
    return data.slice(0, length);
}
exports.trimRight = trimRight;
function calcByteLength(length, byteSize = 8) {
    const remainder = length % byteSize;
    return remainder
        ? ((length - remainder) / byteSize) * byteSize + byteSize
        : length;
}
exports.calcByteLength = calcByteLength;
function splitBytes(str, byteSize = 8) {
    const bytes = sanitizeBytes(str).match(new RegExp(`.{${byteSize}}`, 'gi'));
    return Array.from(bytes || []);
}
exports.splitBytes = splitBytes;
function swapBytes(str) {
    return splitBytes(str)
        .map(reverseString)
        .join('');
}
exports.swapBytes = swapBytes;
function swapHex(str) {
    return binaryToHex(swapBytes(hexToBinary(str)));
}
exports.swapHex = swapHex;
function sanitizeBytes(str, byteSize = 8, padding = STRING_ZERO) {
    return padLeft(str, calcByteLength(str.length, byteSize), padding);
}
exports.sanitizeBytes = sanitizeBytes;
function padLeft(str, length, padding = STRING_ZERO) {
    return padString(str, length, true, padding);
}
exports.padLeft = padLeft;
function padRight(str, length, padding = STRING_ZERO) {
    return padString(str, length, false, padding);
}
exports.padRight = padRight;
function removeHexPrefix(hex) {
    return hex.replace(/^0x/, '');
}
exports.removeHexPrefix = removeHexPrefix;
function addHexPrefix(hex) {
    return hex.startsWith('0x') ? hex : `0x${hex}`;
}
exports.addHexPrefix = addHexPrefix;
function sanitizeHex(hex) {
    hex = removeHexPrefix(hex);
    hex = sanitizeBytes(hex, 2);
    if (hex) {
        hex = addHexPrefix(hex);
    }
    return hex;
}
exports.sanitizeHex = sanitizeHex;
function removeHexLeadingZeros(hex) {
    const prefixed = hex.startsWith('0x');
    hex = removeHexPrefix(hex);
    hex = hex.startsWith(STRING_ZERO) ? hex.substring(1) : hex;
    return prefixed ? addHexPrefix(hex) : hex;
}
exports.removeHexLeadingZeros = removeHexLeadingZeros;
function isUndefined(value) {
    return typeof value === 'undefined';
}
function isDefined(value) {
    return !isUndefined(value);
}
function assert(assertion, errorMessage) {
    if (!assertion) {
        throw new Error(errorMessage);
    }
}
function reverseString(str) {
    return str
        .split('')
        .reverse()
        .join('');
}
function padString(str, length, left, padding = STRING_ZERO) {
    const diff = length - str.length;
    let result = str;
    if (diff > 0) {
        const pad = padding.repeat(diff);
        result = left ? pad + str : str + pad;
    }
    return result;
}
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 6871:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


/**
 * @file
 *
 * Copyright 2018 FutoIn Project (https://futoin.org)
 * Copyright 2018 Andrey Galkin <andrey@futoin.org>
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

const { Buffer } = __webpack_require__( 181 );
const { createHash, createHmac } = __webpack_require__( 6982 );

const g_digestLenCache = {};

/**
 * Get expected hash length.
 *
 * @func
 * @alias hkdf.hash_length
 * @param {string} hash - Hash algorithm (as in underlying Node.js crypto library)
 * @returns {integer} hash digest byte length
 *
 * @note Values are hardcoded with fallback for unknown algorithms.
 */
const hash_length = ( hash ) => {
    switch ( hash ) {
    case 'sha256': return 32;
    case 'sha512': return 64;
    case 'sha224': return 28;
    case 'sha384': return 48;
    case 'sha3-256': return 32;
    case 'sha3-512': return 64;
    case 'sha3-224': return 28;
    case 'sha3-384': return 48;
    case 'blake2s256': return 32;
    case 'blake2b512': return 64;
    case 'sha1': return 20;
    case 'md5': return 16;
    default: {
        let len = g_digestLenCache[hash];

        if ( len === undefined ) {
            len = createHash( hash ).digest().length;
            g_digestLenCache[hash] = len;
        }

        return len;
    }
    }
};

/**
 * HKDF extract action.
 *
 * @func
 * @alias hkdf.extract
 * @param {string} hash - Hash algorithm (as in underlying Node.js crypto library)
 * @param {integer} hash_len - Hash digest length
 * @param {Buffer|string} ikm - Initial Keying Material
 * @param {Buffer|string} salt - Optional salt (recommended)
 * @returns {Buffer} A buffer with pseudorandom key
 *
 * @note Values are hardcoded with fallback for unknown algorithms.
 */
const hkdf_extract = ( hash, hash_len, ikm, salt ) => {
    const b_ikm = Buffer.isBuffer( ikm ) ? ikm : Buffer.from( ikm );
    const b_salt = ( salt && salt.length ) ? Buffer.from( salt ) : Buffer.alloc( hash_len, 0 );

    return createHmac( hash, b_salt ).update( b_ikm ).digest();
};

/**
 * HKDF expand action.
 *
 * @func
 * @alias hkdf.expand
 * @param {string} hash - Hash algorithm (as in underlying Node.js crypto library)
 * @param {integer} hash_len - Hash digest length
 * @param {Buffer|string} prk - A buffer with pseudorandom key
 * @param {integer} length - length of output keying material in octets
 * @param {Buffer|string} info - Optional context (safe to skip)
 * @returns {Buffer} A buffer with output keying material
 *
 * @note Values are hardcoded with fallback for unknown algorithms.
 */
const hkdf_expand = ( hash, hash_len, prk, length, info ) => {
    const b_info = Buffer.isBuffer( info ) ? info : Buffer.from( info || '' );
    const info_len = b_info.length;

    const steps = Math.ceil( length / hash_len );

    if ( steps > 0xFF ) {
        throw new Error( `OKM length ${length} is too long for ${hash} hash` );
    }

    // use single buffer with unnecessary create/copy/move operations
    const t = Buffer.alloc( hash_len * steps + info_len + 1 );

    for ( let c = 1, start = 0, end = 0; c <= steps; ++c ) {
        // add info
        b_info.copy( t, end );
        // add counter
        t[ end + info_len ] = c;

        createHmac( hash, prk )
            // use view: T(C) = T(C-1) | info | C
            .update( t.slice( start, end + info_len + 1 ) )
            .digest()
            // put back to the same buffer
            .copy( t, end );

        start = end; // used for T(C-1) start
        end += hash_len; // used for T(C-1) end & overall end
    }

    return t.slice( 0, length );
};

/**
 * HMAC-based Extract-and-Expand Key Derivation Function (HKDF)
 *
 * @param {Buffer|string} ikm - Initial Keying Material
 * @param {integer} length - Required byte length of output
 * @param {Buffer|string} salt='' - Optional salt (recommended)
 * @param {Buffer|string} info='' - Optional context (safe to skip)
 * @param {string} hash='SHA-256' - HMAC hash function to use
 * @returns {Buffer} Raw buffer with derived key of @p length bytes
 */
function hkdf( ikm, length, { salt='', info='', hash='SHA-256' } = {} ) {
    hash = hash.toLowerCase().replace( '-', '' );

    // 0. Hash length
    const hash_len = hash_length( hash );

    // 1. extract
    const prk = hkdf_extract( hash, hash_len, ikm, salt );

    // 2. expand
    return hkdf_expand( hash, hash_len, prk, length, info );
}

Object.defineProperties( hkdf, {
    hash_length : {
        configurable: false,
        enumerable: false,
        writable: false,
        value: hash_length,
    },
    extract : {
        configurable: false,
        enumerable: false,
        writable: false,
        value: hkdf_extract,
    },
    expand : {
        configurable: false,
        enumerable: false,
        writable: false,
        value: hkdf_expand,
    },
} );

module.exports = hkdf;


/***/ }),

/***/ 7952:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var hash = exports;

hash.utils = __webpack_require__(7426);
hash.common = __webpack_require__(6166);
hash.sha = __webpack_require__(6229);
hash.ripemd = __webpack_require__(6784);
hash.hmac = __webpack_require__(8948);

// Proxy hash functions to the main object
hash.sha1 = hash.sha.sha1;
hash.sha256 = hash.sha.sha256;
hash.sha224 = hash.sha.sha224;
hash.sha384 = hash.sha.sha384;
hash.sha512 = hash.sha.sha512;
hash.ripemd160 = hash.ripemd.ripemd160;


/***/ }),

/***/ 6166:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(7426);
var assert = __webpack_require__(3349);

function BlockHash() {
  this.pending = null;
  this.pendingTotal = 0;
  this.blockSize = this.constructor.blockSize;
  this.outSize = this.constructor.outSize;
  this.hmacStrength = this.constructor.hmacStrength;
  this.padLength = this.constructor.padLength / 8;
  this.endian = 'big';

  this._delta8 = this.blockSize / 8;
  this._delta32 = this.blockSize / 32;
}
exports.BlockHash = BlockHash;

BlockHash.prototype.update = function update(msg, enc) {
  // Convert message to array, pad it, and join into 32bit blocks
  msg = utils.toArray(msg, enc);
  if (!this.pending)
    this.pending = msg;
  else
    this.pending = this.pending.concat(msg);
  this.pendingTotal += msg.length;

  // Enough data, try updating
  if (this.pending.length >= this._delta8) {
    msg = this.pending;

    // Process pending data in blocks
    var r = msg.length % this._delta8;
    this.pending = msg.slice(msg.length - r, msg.length);
    if (this.pending.length === 0)
      this.pending = null;

    msg = utils.join32(msg, 0, msg.length - r, this.endian);
    for (var i = 0; i < msg.length; i += this._delta32)
      this._update(msg, i, i + this._delta32);
  }

  return this;
};

BlockHash.prototype.digest = function digest(enc) {
  this.update(this._pad());
  assert(this.pending === null);

  return this._digest(enc);
};

BlockHash.prototype._pad = function pad() {
  var len = this.pendingTotal;
  var bytes = this._delta8;
  var k = bytes - ((len + this.padLength) % bytes);
  var res = new Array(k + this.padLength);
  res[0] = 0x80;
  for (var i = 1; i < k; i++)
    res[i] = 0;

  // Append length
  len <<= 3;
  if (this.endian === 'big') {
    for (var t = 8; t < this.padLength; t++)
      res[i++] = 0;

    res[i++] = 0;
    res[i++] = 0;
    res[i++] = 0;
    res[i++] = 0;
    res[i++] = (len >>> 24) & 0xff;
    res[i++] = (len >>> 16) & 0xff;
    res[i++] = (len >>> 8) & 0xff;
    res[i++] = len & 0xff;
  } else {
    res[i++] = len & 0xff;
    res[i++] = (len >>> 8) & 0xff;
    res[i++] = (len >>> 16) & 0xff;
    res[i++] = (len >>> 24) & 0xff;
    res[i++] = 0;
    res[i++] = 0;
    res[i++] = 0;
    res[i++] = 0;

    for (t = 8; t < this.padLength; t++)
      res[i++] = 0;
  }

  return res;
};


/***/ }),

/***/ 8948:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(7426);
var assert = __webpack_require__(3349);

function Hmac(hash, key, enc) {
  if (!(this instanceof Hmac))
    return new Hmac(hash, key, enc);
  this.Hash = hash;
  this.blockSize = hash.blockSize / 8;
  this.outSize = hash.outSize / 8;
  this.inner = null;
  this.outer = null;

  this._init(utils.toArray(key, enc));
}
module.exports = Hmac;

Hmac.prototype._init = function init(key) {
  // Shorten key, if needed
  if (key.length > this.blockSize)
    key = new this.Hash().update(key).digest();
  assert(key.length <= this.blockSize);

  // Add padding to key
  for (var i = key.length; i < this.blockSize; i++)
    key.push(0);

  for (i = 0; i < key.length; i++)
    key[i] ^= 0x36;
  this.inner = new this.Hash().update(key);

  // 0x36 ^ 0x5c = 0x6a
  for (i = 0; i < key.length; i++)
    key[i] ^= 0x6a;
  this.outer = new this.Hash().update(key);
};

Hmac.prototype.update = function update(msg, enc) {
  this.inner.update(msg, enc);
  return this;
};

Hmac.prototype.digest = function digest(enc) {
  this.outer.update(this.inner.digest());
  return this.outer.digest(enc);
};


/***/ }),

/***/ 6784:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(7426);
var common = __webpack_require__(6166);

var rotl32 = utils.rotl32;
var sum32 = utils.sum32;
var sum32_3 = utils.sum32_3;
var sum32_4 = utils.sum32_4;
var BlockHash = common.BlockHash;

function RIPEMD160() {
  if (!(this instanceof RIPEMD160))
    return new RIPEMD160();

  BlockHash.call(this);

  this.h = [ 0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0 ];
  this.endian = 'little';
}
utils.inherits(RIPEMD160, BlockHash);
exports.ripemd160 = RIPEMD160;

RIPEMD160.blockSize = 512;
RIPEMD160.outSize = 160;
RIPEMD160.hmacStrength = 192;
RIPEMD160.padLength = 64;

RIPEMD160.prototype._update = function update(msg, start) {
  var A = this.h[0];
  var B = this.h[1];
  var C = this.h[2];
  var D = this.h[3];
  var E = this.h[4];
  var Ah = A;
  var Bh = B;
  var Ch = C;
  var Dh = D;
  var Eh = E;
  for (var j = 0; j < 80; j++) {
    var T = sum32(
      rotl32(
        sum32_4(A, f(j, B, C, D), msg[r[j] + start], K(j)),
        s[j]),
      E);
    A = E;
    E = D;
    D = rotl32(C, 10);
    C = B;
    B = T;
    T = sum32(
      rotl32(
        sum32_4(Ah, f(79 - j, Bh, Ch, Dh), msg[rh[j] + start], Kh(j)),
        sh[j]),
      Eh);
    Ah = Eh;
    Eh = Dh;
    Dh = rotl32(Ch, 10);
    Ch = Bh;
    Bh = T;
  }
  T = sum32_3(this.h[1], C, Dh);
  this.h[1] = sum32_3(this.h[2], D, Eh);
  this.h[2] = sum32_3(this.h[3], E, Ah);
  this.h[3] = sum32_3(this.h[4], A, Bh);
  this.h[4] = sum32_3(this.h[0], B, Ch);
  this.h[0] = T;
};

RIPEMD160.prototype._digest = function digest(enc) {
  if (enc === 'hex')
    return utils.toHex32(this.h, 'little');
  else
    return utils.split32(this.h, 'little');
};

function f(j, x, y, z) {
  if (j <= 15)
    return x ^ y ^ z;
  else if (j <= 31)
    return (x & y) | ((~x) & z);
  else if (j <= 47)
    return (x | (~y)) ^ z;
  else if (j <= 63)
    return (x & z) | (y & (~z));
  else
    return x ^ (y | (~z));
}

function K(j) {
  if (j <= 15)
    return 0x00000000;
  else if (j <= 31)
    return 0x5a827999;
  else if (j <= 47)
    return 0x6ed9eba1;
  else if (j <= 63)
    return 0x8f1bbcdc;
  else
    return 0xa953fd4e;
}

function Kh(j) {
  if (j <= 15)
    return 0x50a28be6;
  else if (j <= 31)
    return 0x5c4dd124;
  else if (j <= 47)
    return 0x6d703ef3;
  else if (j <= 63)
    return 0x7a6d76e9;
  else
    return 0x00000000;
}

var r = [
  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
  7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8,
  3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12,
  1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2,
  4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13
];

var rh = [
  5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12,
  6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2,
  15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13,
  8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14,
  12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11
];

var s = [
  11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8,
  7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12,
  11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5,
  11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12,
  9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6
];

var sh = [
  8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6,
  9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11,
  9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5,
  15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8,
  8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11
];


/***/ }),

/***/ 6229:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


exports.sha1 = __webpack_require__(3917);
exports.sha224 = __webpack_require__(7714);
exports.sha256 = __webpack_require__(2287);
exports.sha384 = __webpack_require__(1911);
exports.sha512 = __webpack_require__(7766);


/***/ }),

/***/ 3917:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(7426);
var common = __webpack_require__(6166);
var shaCommon = __webpack_require__(6225);

var rotl32 = utils.rotl32;
var sum32 = utils.sum32;
var sum32_5 = utils.sum32_5;
var ft_1 = shaCommon.ft_1;
var BlockHash = common.BlockHash;

var sha1_K = [
  0x5A827999, 0x6ED9EBA1,
  0x8F1BBCDC, 0xCA62C1D6
];

function SHA1() {
  if (!(this instanceof SHA1))
    return new SHA1();

  BlockHash.call(this);
  this.h = [
    0x67452301, 0xefcdab89, 0x98badcfe,
    0x10325476, 0xc3d2e1f0 ];
  this.W = new Array(80);
}

utils.inherits(SHA1, BlockHash);
module.exports = SHA1;

SHA1.blockSize = 512;
SHA1.outSize = 160;
SHA1.hmacStrength = 80;
SHA1.padLength = 64;

SHA1.prototype._update = function _update(msg, start) {
  var W = this.W;

  for (var i = 0; i < 16; i++)
    W[i] = msg[start + i];

  for(; i < W.length; i++)
    W[i] = rotl32(W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16], 1);

  var a = this.h[0];
  var b = this.h[1];
  var c = this.h[2];
  var d = this.h[3];
  var e = this.h[4];

  for (i = 0; i < W.length; i++) {
    var s = ~~(i / 20);
    var t = sum32_5(rotl32(a, 5), ft_1(s, b, c, d), e, W[i], sha1_K[s]);
    e = d;
    d = c;
    c = rotl32(b, 30);
    b = a;
    a = t;
  }

  this.h[0] = sum32(this.h[0], a);
  this.h[1] = sum32(this.h[1], b);
  this.h[2] = sum32(this.h[2], c);
  this.h[3] = sum32(this.h[3], d);
  this.h[4] = sum32(this.h[4], e);
};

SHA1.prototype._digest = function digest(enc) {
  if (enc === 'hex')
    return utils.toHex32(this.h, 'big');
  else
    return utils.split32(this.h, 'big');
};


/***/ }),

/***/ 7714:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(7426);
var SHA256 = __webpack_require__(2287);

function SHA224() {
  if (!(this instanceof SHA224))
    return new SHA224();

  SHA256.call(this);
  this.h = [
    0xc1059ed8, 0x367cd507, 0x3070dd17, 0xf70e5939,
    0xffc00b31, 0x68581511, 0x64f98fa7, 0xbefa4fa4 ];
}
utils.inherits(SHA224, SHA256);
module.exports = SHA224;

SHA224.blockSize = 512;
SHA224.outSize = 224;
SHA224.hmacStrength = 192;
SHA224.padLength = 64;

SHA224.prototype._digest = function digest(enc) {
  // Just truncate output
  if (enc === 'hex')
    return utils.toHex32(this.h.slice(0, 7), 'big');
  else
    return utils.split32(this.h.slice(0, 7), 'big');
};



/***/ }),

/***/ 2287:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(7426);
var common = __webpack_require__(6166);
var shaCommon = __webpack_require__(6225);
var assert = __webpack_require__(3349);

var sum32 = utils.sum32;
var sum32_4 = utils.sum32_4;
var sum32_5 = utils.sum32_5;
var ch32 = shaCommon.ch32;
var maj32 = shaCommon.maj32;
var s0_256 = shaCommon.s0_256;
var s1_256 = shaCommon.s1_256;
var g0_256 = shaCommon.g0_256;
var g1_256 = shaCommon.g1_256;

var BlockHash = common.BlockHash;

var sha256_K = [
  0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5,
  0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
  0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3,
  0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
  0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc,
  0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
  0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7,
  0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
  0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13,
  0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
  0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3,
  0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
  0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5,
  0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
  0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,
  0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2
];

function SHA256() {
  if (!(this instanceof SHA256))
    return new SHA256();

  BlockHash.call(this);
  this.h = [
    0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a,
    0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19
  ];
  this.k = sha256_K;
  this.W = new Array(64);
}
utils.inherits(SHA256, BlockHash);
module.exports = SHA256;

SHA256.blockSize = 512;
SHA256.outSize = 256;
SHA256.hmacStrength = 192;
SHA256.padLength = 64;

SHA256.prototype._update = function _update(msg, start) {
  var W = this.W;

  for (var i = 0; i < 16; i++)
    W[i] = msg[start + i];
  for (; i < W.length; i++)
    W[i] = sum32_4(g1_256(W[i - 2]), W[i - 7], g0_256(W[i - 15]), W[i - 16]);

  var a = this.h[0];
  var b = this.h[1];
  var c = this.h[2];
  var d = this.h[3];
  var e = this.h[4];
  var f = this.h[5];
  var g = this.h[6];
  var h = this.h[7];

  assert(this.k.length === W.length);
  for (i = 0; i < W.length; i++) {
    var T1 = sum32_5(h, s1_256(e), ch32(e, f, g), this.k[i], W[i]);
    var T2 = sum32(s0_256(a), maj32(a, b, c));
    h = g;
    g = f;
    f = e;
    e = sum32(d, T1);
    d = c;
    c = b;
    b = a;
    a = sum32(T1, T2);
  }

  this.h[0] = sum32(this.h[0], a);
  this.h[1] = sum32(this.h[1], b);
  this.h[2] = sum32(this.h[2], c);
  this.h[3] = sum32(this.h[3], d);
  this.h[4] = sum32(this.h[4], e);
  this.h[5] = sum32(this.h[5], f);
  this.h[6] = sum32(this.h[6], g);
  this.h[7] = sum32(this.h[7], h);
};

SHA256.prototype._digest = function digest(enc) {
  if (enc === 'hex')
    return utils.toHex32(this.h, 'big');
  else
    return utils.split32(this.h, 'big');
};


/***/ }),

/***/ 1911:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(7426);

var SHA512 = __webpack_require__(7766);

function SHA384() {
  if (!(this instanceof SHA384))
    return new SHA384();

  SHA512.call(this);
  this.h = [
    0xcbbb9d5d, 0xc1059ed8,
    0x629a292a, 0x367cd507,
    0x9159015a, 0x3070dd17,
    0x152fecd8, 0xf70e5939,
    0x67332667, 0xffc00b31,
    0x8eb44a87, 0x68581511,
    0xdb0c2e0d, 0x64f98fa7,
    0x47b5481d, 0xbefa4fa4 ];
}
utils.inherits(SHA384, SHA512);
module.exports = SHA384;

SHA384.blockSize = 1024;
SHA384.outSize = 384;
SHA384.hmacStrength = 192;
SHA384.padLength = 128;

SHA384.prototype._digest = function digest(enc) {
  if (enc === 'hex')
    return utils.toHex32(this.h.slice(0, 12), 'big');
  else
    return utils.split32(this.h.slice(0, 12), 'big');
};


/***/ }),

/***/ 7766:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(7426);
var common = __webpack_require__(6166);
var assert = __webpack_require__(3349);

var rotr64_hi = utils.rotr64_hi;
var rotr64_lo = utils.rotr64_lo;
var shr64_hi = utils.shr64_hi;
var shr64_lo = utils.shr64_lo;
var sum64 = utils.sum64;
var sum64_hi = utils.sum64_hi;
var sum64_lo = utils.sum64_lo;
var sum64_4_hi = utils.sum64_4_hi;
var sum64_4_lo = utils.sum64_4_lo;
var sum64_5_hi = utils.sum64_5_hi;
var sum64_5_lo = utils.sum64_5_lo;

var BlockHash = common.BlockHash;

var sha512_K = [
  0x428a2f98, 0xd728ae22, 0x71374491, 0x23ef65cd,
  0xb5c0fbcf, 0xec4d3b2f, 0xe9b5dba5, 0x8189dbbc,
  0x3956c25b, 0xf348b538, 0x59f111f1, 0xb605d019,
  0x923f82a4, 0xaf194f9b, 0xab1c5ed5, 0xda6d8118,
  0xd807aa98, 0xa3030242, 0x12835b01, 0x45706fbe,
  0x243185be, 0x4ee4b28c, 0x550c7dc3, 0xd5ffb4e2,
  0x72be5d74, 0xf27b896f, 0x80deb1fe, 0x3b1696b1,
  0x9bdc06a7, 0x25c71235, 0xc19bf174, 0xcf692694,
  0xe49b69c1, 0x9ef14ad2, 0xefbe4786, 0x384f25e3,
  0x0fc19dc6, 0x8b8cd5b5, 0x240ca1cc, 0x77ac9c65,
  0x2de92c6f, 0x592b0275, 0x4a7484aa, 0x6ea6e483,
  0x5cb0a9dc, 0xbd41fbd4, 0x76f988da, 0x831153b5,
  0x983e5152, 0xee66dfab, 0xa831c66d, 0x2db43210,
  0xb00327c8, 0x98fb213f, 0xbf597fc7, 0xbeef0ee4,
  0xc6e00bf3, 0x3da88fc2, 0xd5a79147, 0x930aa725,
  0x06ca6351, 0xe003826f, 0x14292967, 0x0a0e6e70,
  0x27b70a85, 0x46d22ffc, 0x2e1b2138, 0x5c26c926,
  0x4d2c6dfc, 0x5ac42aed, 0x53380d13, 0x9d95b3df,
  0x650a7354, 0x8baf63de, 0x766a0abb, 0x3c77b2a8,
  0x81c2c92e, 0x47edaee6, 0x92722c85, 0x1482353b,
  0xa2bfe8a1, 0x4cf10364, 0xa81a664b, 0xbc423001,
  0xc24b8b70, 0xd0f89791, 0xc76c51a3, 0x0654be30,
  0xd192e819, 0xd6ef5218, 0xd6990624, 0x5565a910,
  0xf40e3585, 0x5771202a, 0x106aa070, 0x32bbd1b8,
  0x19a4c116, 0xb8d2d0c8, 0x1e376c08, 0x5141ab53,
  0x2748774c, 0xdf8eeb99, 0x34b0bcb5, 0xe19b48a8,
  0x391c0cb3, 0xc5c95a63, 0x4ed8aa4a, 0xe3418acb,
  0x5b9cca4f, 0x7763e373, 0x682e6ff3, 0xd6b2b8a3,
  0x748f82ee, 0x5defb2fc, 0x78a5636f, 0x43172f60,
  0x84c87814, 0xa1f0ab72, 0x8cc70208, 0x1a6439ec,
  0x90befffa, 0x23631e28, 0xa4506ceb, 0xde82bde9,
  0xbef9a3f7, 0xb2c67915, 0xc67178f2, 0xe372532b,
  0xca273ece, 0xea26619c, 0xd186b8c7, 0x21c0c207,
  0xeada7dd6, 0xcde0eb1e, 0xf57d4f7f, 0xee6ed178,
  0x06f067aa, 0x72176fba, 0x0a637dc5, 0xa2c898a6,
  0x113f9804, 0xbef90dae, 0x1b710b35, 0x131c471b,
  0x28db77f5, 0x23047d84, 0x32caab7b, 0x40c72493,
  0x3c9ebe0a, 0x15c9bebc, 0x431d67c4, 0x9c100d4c,
  0x4cc5d4be, 0xcb3e42b6, 0x597f299c, 0xfc657e2a,
  0x5fcb6fab, 0x3ad6faec, 0x6c44198c, 0x4a475817
];

function SHA512() {
  if (!(this instanceof SHA512))
    return new SHA512();

  BlockHash.call(this);
  this.h = [
    0x6a09e667, 0xf3bcc908,
    0xbb67ae85, 0x84caa73b,
    0x3c6ef372, 0xfe94f82b,
    0xa54ff53a, 0x5f1d36f1,
    0x510e527f, 0xade682d1,
    0x9b05688c, 0x2b3e6c1f,
    0x1f83d9ab, 0xfb41bd6b,
    0x5be0cd19, 0x137e2179 ];
  this.k = sha512_K;
  this.W = new Array(160);
}
utils.inherits(SHA512, BlockHash);
module.exports = SHA512;

SHA512.blockSize = 1024;
SHA512.outSize = 512;
SHA512.hmacStrength = 192;
SHA512.padLength = 128;

SHA512.prototype._prepareBlock = function _prepareBlock(msg, start) {
  var W = this.W;

  // 32 x 32bit words
  for (var i = 0; i < 32; i++)
    W[i] = msg[start + i];
  for (; i < W.length; i += 2) {
    var c0_hi = g1_512_hi(W[i - 4], W[i - 3]);  // i - 2
    var c0_lo = g1_512_lo(W[i - 4], W[i - 3]);
    var c1_hi = W[i - 14];  // i - 7
    var c1_lo = W[i - 13];
    var c2_hi = g0_512_hi(W[i - 30], W[i - 29]);  // i - 15
    var c2_lo = g0_512_lo(W[i - 30], W[i - 29]);
    var c3_hi = W[i - 32];  // i - 16
    var c3_lo = W[i - 31];

    W[i] = sum64_4_hi(
      c0_hi, c0_lo,
      c1_hi, c1_lo,
      c2_hi, c2_lo,
      c3_hi, c3_lo);
    W[i + 1] = sum64_4_lo(
      c0_hi, c0_lo,
      c1_hi, c1_lo,
      c2_hi, c2_lo,
      c3_hi, c3_lo);
  }
};

SHA512.prototype._update = function _update(msg, start) {
  this._prepareBlock(msg, start);

  var W = this.W;

  var ah = this.h[0];
  var al = this.h[1];
  var bh = this.h[2];
  var bl = this.h[3];
  var ch = this.h[4];
  var cl = this.h[5];
  var dh = this.h[6];
  var dl = this.h[7];
  var eh = this.h[8];
  var el = this.h[9];
  var fh = this.h[10];
  var fl = this.h[11];
  var gh = this.h[12];
  var gl = this.h[13];
  var hh = this.h[14];
  var hl = this.h[15];

  assert(this.k.length === W.length);
  for (var i = 0; i < W.length; i += 2) {
    var c0_hi = hh;
    var c0_lo = hl;
    var c1_hi = s1_512_hi(eh, el);
    var c1_lo = s1_512_lo(eh, el);
    var c2_hi = ch64_hi(eh, el, fh, fl, gh, gl);
    var c2_lo = ch64_lo(eh, el, fh, fl, gh, gl);
    var c3_hi = this.k[i];
    var c3_lo = this.k[i + 1];
    var c4_hi = W[i];
    var c4_lo = W[i + 1];

    var T1_hi = sum64_5_hi(
      c0_hi, c0_lo,
      c1_hi, c1_lo,
      c2_hi, c2_lo,
      c3_hi, c3_lo,
      c4_hi, c4_lo);
    var T1_lo = sum64_5_lo(
      c0_hi, c0_lo,
      c1_hi, c1_lo,
      c2_hi, c2_lo,
      c3_hi, c3_lo,
      c4_hi, c4_lo);

    c0_hi = s0_512_hi(ah, al);
    c0_lo = s0_512_lo(ah, al);
    c1_hi = maj64_hi(ah, al, bh, bl, ch, cl);
    c1_lo = maj64_lo(ah, al, bh, bl, ch, cl);

    var T2_hi = sum64_hi(c0_hi, c0_lo, c1_hi, c1_lo);
    var T2_lo = sum64_lo(c0_hi, c0_lo, c1_hi, c1_lo);

    hh = gh;
    hl = gl;

    gh = fh;
    gl = fl;

    fh = eh;
    fl = el;

    eh = sum64_hi(dh, dl, T1_hi, T1_lo);
    el = sum64_lo(dl, dl, T1_hi, T1_lo);

    dh = ch;
    dl = cl;

    ch = bh;
    cl = bl;

    bh = ah;
    bl = al;

    ah = sum64_hi(T1_hi, T1_lo, T2_hi, T2_lo);
    al = sum64_lo(T1_hi, T1_lo, T2_hi, T2_lo);
  }

  sum64(this.h, 0, ah, al);
  sum64(this.h, 2, bh, bl);
  sum64(this.h, 4, ch, cl);
  sum64(this.h, 6, dh, dl);
  sum64(this.h, 8, eh, el);
  sum64(this.h, 10, fh, fl);
  sum64(this.h, 12, gh, gl);
  sum64(this.h, 14, hh, hl);
};

SHA512.prototype._digest = function digest(enc) {
  if (enc === 'hex')
    return utils.toHex32(this.h, 'big');
  else
    return utils.split32(this.h, 'big');
};

function ch64_hi(xh, xl, yh, yl, zh) {
  var r = (xh & yh) ^ ((~xh) & zh);
  if (r < 0)
    r += 0x100000000;
  return r;
}

function ch64_lo(xh, xl, yh, yl, zh, zl) {
  var r = (xl & yl) ^ ((~xl) & zl);
  if (r < 0)
    r += 0x100000000;
  return r;
}

function maj64_hi(xh, xl, yh, yl, zh) {
  var r = (xh & yh) ^ (xh & zh) ^ (yh & zh);
  if (r < 0)
    r += 0x100000000;
  return r;
}

function maj64_lo(xh, xl, yh, yl, zh, zl) {
  var r = (xl & yl) ^ (xl & zl) ^ (yl & zl);
  if (r < 0)
    r += 0x100000000;
  return r;
}

function s0_512_hi(xh, xl) {
  var c0_hi = rotr64_hi(xh, xl, 28);
  var c1_hi = rotr64_hi(xl, xh, 2);  // 34
  var c2_hi = rotr64_hi(xl, xh, 7);  // 39

  var r = c0_hi ^ c1_hi ^ c2_hi;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function s0_512_lo(xh, xl) {
  var c0_lo = rotr64_lo(xh, xl, 28);
  var c1_lo = rotr64_lo(xl, xh, 2);  // 34
  var c2_lo = rotr64_lo(xl, xh, 7);  // 39

  var r = c0_lo ^ c1_lo ^ c2_lo;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function s1_512_hi(xh, xl) {
  var c0_hi = rotr64_hi(xh, xl, 14);
  var c1_hi = rotr64_hi(xh, xl, 18);
  var c2_hi = rotr64_hi(xl, xh, 9);  // 41

  var r = c0_hi ^ c1_hi ^ c2_hi;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function s1_512_lo(xh, xl) {
  var c0_lo = rotr64_lo(xh, xl, 14);
  var c1_lo = rotr64_lo(xh, xl, 18);
  var c2_lo = rotr64_lo(xl, xh, 9);  // 41

  var r = c0_lo ^ c1_lo ^ c2_lo;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function g0_512_hi(xh, xl) {
  var c0_hi = rotr64_hi(xh, xl, 1);
  var c1_hi = rotr64_hi(xh, xl, 8);
  var c2_hi = shr64_hi(xh, xl, 7);

  var r = c0_hi ^ c1_hi ^ c2_hi;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function g0_512_lo(xh, xl) {
  var c0_lo = rotr64_lo(xh, xl, 1);
  var c1_lo = rotr64_lo(xh, xl, 8);
  var c2_lo = shr64_lo(xh, xl, 7);

  var r = c0_lo ^ c1_lo ^ c2_lo;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function g1_512_hi(xh, xl) {
  var c0_hi = rotr64_hi(xh, xl, 19);
  var c1_hi = rotr64_hi(xl, xh, 29);  // 61
  var c2_hi = shr64_hi(xh, xl, 6);

  var r = c0_hi ^ c1_hi ^ c2_hi;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function g1_512_lo(xh, xl) {
  var c0_lo = rotr64_lo(xh, xl, 19);
  var c1_lo = rotr64_lo(xl, xh, 29);  // 61
  var c2_lo = shr64_lo(xh, xl, 6);

  var r = c0_lo ^ c1_lo ^ c2_lo;
  if (r < 0)
    r += 0x100000000;
  return r;
}


/***/ }),

/***/ 6225:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(7426);
var rotr32 = utils.rotr32;

function ft_1(s, x, y, z) {
  if (s === 0)
    return ch32(x, y, z);
  if (s === 1 || s === 3)
    return p32(x, y, z);
  if (s === 2)
    return maj32(x, y, z);
}
exports.ft_1 = ft_1;

function ch32(x, y, z) {
  return (x & y) ^ ((~x) & z);
}
exports.ch32 = ch32;

function maj32(x, y, z) {
  return (x & y) ^ (x & z) ^ (y & z);
}
exports.maj32 = maj32;

function p32(x, y, z) {
  return x ^ y ^ z;
}
exports.p32 = p32;

function s0_256(x) {
  return rotr32(x, 2) ^ rotr32(x, 13) ^ rotr32(x, 22);
}
exports.s0_256 = s0_256;

function s1_256(x) {
  return rotr32(x, 6) ^ rotr32(x, 11) ^ rotr32(x, 25);
}
exports.s1_256 = s1_256;

function g0_256(x) {
  return rotr32(x, 7) ^ rotr32(x, 18) ^ (x >>> 3);
}
exports.g0_256 = g0_256;

function g1_256(x) {
  return rotr32(x, 17) ^ rotr32(x, 19) ^ (x >>> 10);
}
exports.g1_256 = g1_256;


/***/ }),

/***/ 7426:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var assert = __webpack_require__(3349);
var inherits = __webpack_require__(2017);

exports.inherits = inherits;

function isSurrogatePair(msg, i) {
  if ((msg.charCodeAt(i) & 0xFC00) !== 0xD800) {
    return false;
  }
  if (i < 0 || i + 1 >= msg.length) {
    return false;
  }
  return (msg.charCodeAt(i + 1) & 0xFC00) === 0xDC00;
}

function toArray(msg, enc) {
  if (Array.isArray(msg))
    return msg.slice();
  if (!msg)
    return [];
  var res = [];
  if (typeof msg === 'string') {
    if (!enc) {
      // Inspired by stringToUtf8ByteArray() in closure-library by Google
      // https://github.com/google/closure-library/blob/8598d87242af59aac233270742c8984e2b2bdbe0/closure/goog/crypt/crypt.js#L117-L143
      // Apache License 2.0
      // https://github.com/google/closure-library/blob/master/LICENSE
      var p = 0;
      for (var i = 0; i < msg.length; i++) {
        var c = msg.charCodeAt(i);
        if (c < 128) {
          res[p++] = c;
        } else if (c < 2048) {
          res[p++] = (c >> 6) | 192;
          res[p++] = (c & 63) | 128;
        } else if (isSurrogatePair(msg, i)) {
          c = 0x10000 + ((c & 0x03FF) << 10) + (msg.charCodeAt(++i) & 0x03FF);
          res[p++] = (c >> 18) | 240;
          res[p++] = ((c >> 12) & 63) | 128;
          res[p++] = ((c >> 6) & 63) | 128;
          res[p++] = (c & 63) | 128;
        } else {
          res[p++] = (c >> 12) | 224;
          res[p++] = ((c >> 6) & 63) | 128;
          res[p++] = (c & 63) | 128;
        }
      }
    } else if (enc === 'hex') {
      msg = msg.replace(/[^a-z0-9]+/ig, '');
      if (msg.length % 2 !== 0)
        msg = '0' + msg;
      for (i = 0; i < msg.length; i += 2)
        res.push(parseInt(msg[i] + msg[i + 1], 16));
    }
  } else {
    for (i = 0; i < msg.length; i++)
      res[i] = msg[i] | 0;
  }
  return res;
}
exports.toArray = toArray;

function toHex(msg) {
  var res = '';
  for (var i = 0; i < msg.length; i++)
    res += zero2(msg[i].toString(16));
  return res;
}
exports.toHex = toHex;

function htonl(w) {
  var res = (w >>> 24) |
            ((w >>> 8) & 0xff00) |
            ((w << 8) & 0xff0000) |
            ((w & 0xff) << 24);
  return res >>> 0;
}
exports.htonl = htonl;

function toHex32(msg, endian) {
  var res = '';
  for (var i = 0; i < msg.length; i++) {
    var w = msg[i];
    if (endian === 'little')
      w = htonl(w);
    res += zero8(w.toString(16));
  }
  return res;
}
exports.toHex32 = toHex32;

function zero2(word) {
  if (word.length === 1)
    return '0' + word;
  else
    return word;
}
exports.zero2 = zero2;

function zero8(word) {
  if (word.length === 7)
    return '0' + word;
  else if (word.length === 6)
    return '00' + word;
  else if (word.length === 5)
    return '000' + word;
  else if (word.length === 4)
    return '0000' + word;
  else if (word.length === 3)
    return '00000' + word;
  else if (word.length === 2)
    return '000000' + word;
  else if (word.length === 1)
    return '0000000' + word;
  else
    return word;
}
exports.zero8 = zero8;

function join32(msg, start, end, endian) {
  var len = end - start;
  assert(len % 4 === 0);
  var res = new Array(len / 4);
  for (var i = 0, k = start; i < res.length; i++, k += 4) {
    var w;
    if (endian === 'big')
      w = (msg[k] << 24) | (msg[k + 1] << 16) | (msg[k + 2] << 8) | msg[k + 3];
    else
      w = (msg[k + 3] << 24) | (msg[k + 2] << 16) | (msg[k + 1] << 8) | msg[k];
    res[i] = w >>> 0;
  }
  return res;
}
exports.join32 = join32;

function split32(msg, endian) {
  var res = new Array(msg.length * 4);
  for (var i = 0, k = 0; i < msg.length; i++, k += 4) {
    var m = msg[i];
    if (endian === 'big') {
      res[k] = m >>> 24;
      res[k + 1] = (m >>> 16) & 0xff;
      res[k + 2] = (m >>> 8) & 0xff;
      res[k + 3] = m & 0xff;
    } else {
      res[k + 3] = m >>> 24;
      res[k + 2] = (m >>> 16) & 0xff;
      res[k + 1] = (m >>> 8) & 0xff;
      res[k] = m & 0xff;
    }
  }
  return res;
}
exports.split32 = split32;

function rotr32(w, b) {
  return (w >>> b) | (w << (32 - b));
}
exports.rotr32 = rotr32;

function rotl32(w, b) {
  return (w << b) | (w >>> (32 - b));
}
exports.rotl32 = rotl32;

function sum32(a, b) {
  return (a + b) >>> 0;
}
exports.sum32 = sum32;

function sum32_3(a, b, c) {
  return (a + b + c) >>> 0;
}
exports.sum32_3 = sum32_3;

function sum32_4(a, b, c, d) {
  return (a + b + c + d) >>> 0;
}
exports.sum32_4 = sum32_4;

function sum32_5(a, b, c, d, e) {
  return (a + b + c + d + e) >>> 0;
}
exports.sum32_5 = sum32_5;

function sum64(buf, pos, ah, al) {
  var bh = buf[pos];
  var bl = buf[pos + 1];

  var lo = (al + bl) >>> 0;
  var hi = (lo < al ? 1 : 0) + ah + bh;
  buf[pos] = hi >>> 0;
  buf[pos + 1] = lo;
}
exports.sum64 = sum64;

function sum64_hi(ah, al, bh, bl) {
  var lo = (al + bl) >>> 0;
  var hi = (lo < al ? 1 : 0) + ah + bh;
  return hi >>> 0;
}
exports.sum64_hi = sum64_hi;

function sum64_lo(ah, al, bh, bl) {
  var lo = al + bl;
  return lo >>> 0;
}
exports.sum64_lo = sum64_lo;

function sum64_4_hi(ah, al, bh, bl, ch, cl, dh, dl) {
  var carry = 0;
  var lo = al;
  lo = (lo + bl) >>> 0;
  carry += lo < al ? 1 : 0;
  lo = (lo + cl) >>> 0;
  carry += lo < cl ? 1 : 0;
  lo = (lo + dl) >>> 0;
  carry += lo < dl ? 1 : 0;

  var hi = ah + bh + ch + dh + carry;
  return hi >>> 0;
}
exports.sum64_4_hi = sum64_4_hi;

function sum64_4_lo(ah, al, bh, bl, ch, cl, dh, dl) {
  var lo = al + bl + cl + dl;
  return lo >>> 0;
}
exports.sum64_4_lo = sum64_4_lo;

function sum64_5_hi(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
  var carry = 0;
  var lo = al;
  lo = (lo + bl) >>> 0;
  carry += lo < al ? 1 : 0;
  lo = (lo + cl) >>> 0;
  carry += lo < cl ? 1 : 0;
  lo = (lo + dl) >>> 0;
  carry += lo < dl ? 1 : 0;
  lo = (lo + el) >>> 0;
  carry += lo < el ? 1 : 0;

  var hi = ah + bh + ch + dh + eh + carry;
  return hi >>> 0;
}
exports.sum64_5_hi = sum64_5_hi;

function sum64_5_lo(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
  var lo = al + bl + cl + dl + el;

  return lo >>> 0;
}
exports.sum64_5_lo = sum64_5_lo;

function rotr64_hi(ah, al, num) {
  var r = (al << (32 - num)) | (ah >>> num);
  return r >>> 0;
}
exports.rotr64_hi = rotr64_hi;

function rotr64_lo(ah, al, num) {
  var r = (ah << (32 - num)) | (al >>> num);
  return r >>> 0;
}
exports.rotr64_lo = rotr64_lo;

function shr64_hi(ah, al, num) {
  return ah >>> num;
}
exports.shr64_hi = shr64_hi;

function shr64_lo(ah, al, num) {
  var r = (ah << (32 - num)) | (al >>> num);
  return r >>> 0;
}
exports.shr64_lo = shr64_lo;


/***/ }),

/***/ 2723:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var hash = __webpack_require__(7952);
var utils = __webpack_require__(4367);
var assert = __webpack_require__(3349);

function HmacDRBG(options) {
  if (!(this instanceof HmacDRBG))
    return new HmacDRBG(options);
  this.hash = options.hash;
  this.predResist = !!options.predResist;

  this.outLen = this.hash.outSize;
  this.minEntropy = options.minEntropy || this.hash.hmacStrength;

  this._reseed = null;
  this.reseedInterval = null;
  this.K = null;
  this.V = null;

  var entropy = utils.toArray(options.entropy, options.entropyEnc || 'hex');
  var nonce = utils.toArray(options.nonce, options.nonceEnc || 'hex');
  var pers = utils.toArray(options.pers, options.persEnc || 'hex');
  assert(entropy.length >= (this.minEntropy / 8),
         'Not enough entropy. Minimum is: ' + this.minEntropy + ' bits');
  this._init(entropy, nonce, pers);
}
module.exports = HmacDRBG;

HmacDRBG.prototype._init = function init(entropy, nonce, pers) {
  var seed = entropy.concat(nonce).concat(pers);

  this.K = new Array(this.outLen / 8);
  this.V = new Array(this.outLen / 8);
  for (var i = 0; i < this.V.length; i++) {
    this.K[i] = 0x00;
    this.V[i] = 0x01;
  }

  this._update(seed);
  this._reseed = 1;
  this.reseedInterval = 0x1000000000000;  // 2^48
};

HmacDRBG.prototype._hmac = function hmac() {
  return new hash.hmac(this.hash, this.K);
};

HmacDRBG.prototype._update = function update(seed) {
  var kmac = this._hmac()
                 .update(this.V)
                 .update([ 0x00 ]);
  if (seed)
    kmac = kmac.update(seed);
  this.K = kmac.digest();
  this.V = this._hmac().update(this.V).digest();
  if (!seed)
    return;

  this.K = this._hmac()
               .update(this.V)
               .update([ 0x01 ])
               .update(seed)
               .digest();
  this.V = this._hmac().update(this.V).digest();
};

HmacDRBG.prototype.reseed = function reseed(entropy, entropyEnc, add, addEnc) {
  // Optional entropy enc
  if (typeof entropyEnc !== 'string') {
    addEnc = add;
    add = entropyEnc;
    entropyEnc = null;
  }

  entropy = utils.toArray(entropy, entropyEnc);
  add = utils.toArray(add, addEnc);

  assert(entropy.length >= (this.minEntropy / 8),
         'Not enough entropy. Minimum is: ' + this.minEntropy + ' bits');

  this._update(entropy.concat(add || []));
  this._reseed = 1;
};

HmacDRBG.prototype.generate = function generate(len, enc, add, addEnc) {
  if (this._reseed > this.reseedInterval)
    throw new Error('Reseed is required');

  // Optional encoding
  if (typeof enc !== 'string') {
    addEnc = add;
    add = enc;
    enc = null;
  }

  // Optional additional data
  if (add) {
    add = utils.toArray(add, addEnc || 'hex');
    this._update(add);
  }

  var temp = [];
  while (temp.length < len) {
    this.V = this._hmac().update(this.V).digest();
    temp = temp.concat(this.V);
  }

  var res = temp.slice(0, len);
  this._update(add);
  this._reseed++;
  return utils.encode(res, enc);
};


/***/ }),

/***/ 2017:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

try {
  var util = __webpack_require__(9023);
  /* istanbul ignore next */
  if (typeof util.inherits !== 'function') throw '';
  module.exports = util.inherits;
} catch (e) {
  /* istanbul ignore next */
  module.exports = __webpack_require__(6698);
}


/***/ }),

/***/ 6698:
/***/ ((module) => {

if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor
      ctor.prototype = Object.create(superCtor.prototype, {
        constructor: {
          value: ctor,
          enumerable: false,
          writable: true,
          configurable: true
        }
      })
    }
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor
      var TempCtor = function () {}
      TempCtor.prototype = superCtor.prototype
      ctor.prototype = new TempCtor()
      ctor.prototype.constructor = ctor
    }
  }
}


/***/ }),

/***/ 9225:
/***/ ((module) => {

module.exports      = isTypedArray
isTypedArray.strict = isStrictTypedArray
isTypedArray.loose  = isLooseTypedArray

var toString = Object.prototype.toString
var names = {
    '[object Int8Array]': true
  , '[object Int16Array]': true
  , '[object Int32Array]': true
  , '[object Uint8Array]': true
  , '[object Uint8ClampedArray]': true
  , '[object Uint16Array]': true
  , '[object Uint32Array]': true
  , '[object Float32Array]': true
  , '[object Float64Array]': true
}

function isTypedArray(arr) {
  return (
       isStrictTypedArray(arr)
    || isLooseTypedArray(arr)
  )
}

function isStrictTypedArray(arr) {
  return (
       arr instanceof Int8Array
    || arr instanceof Int16Array
    || arr instanceof Int32Array
    || arr instanceof Uint8Array
    || arr instanceof Uint8ClampedArray
    || arr instanceof Uint16Array
    || arr instanceof Uint32Array
    || arr instanceof Float32Array
    || arr instanceof Float64Array
  )
}

function isLooseTypedArray(arr) {
  return names[toString.call(arr)]
}


/***/ }),

/***/ 2465:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


module.exports = __webpack_require__(7699);

/***/ }),

/***/ 2543:
/***/ (function(module, exports, __webpack_require__) {

/* module decorator */ module = __webpack_require__.nmd(module);
var __WEBPACK_AMD_DEFINE_RESULT__;/**
 * @license
 * Lodash <https://lodash.com/>
 * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */
;(function() {

  /** Used as a safe reference for `undefined` in pre-ES5 environments. */
  var undefined;

  /** Used as the semantic version number. */
  var VERSION = '4.17.21';

  /** Used as the size to enable large array optimizations. */
  var LARGE_ARRAY_SIZE = 200;

  /** Error message constants. */
  var CORE_ERROR_TEXT = 'Unsupported core-js use. Try https://npms.io/search?q=ponyfill.',
      FUNC_ERROR_TEXT = 'Expected a function',
      INVALID_TEMPL_VAR_ERROR_TEXT = 'Invalid `variable` option passed into `_.template`';

  /** Used to stand-in for `undefined` hash values. */
  var HASH_UNDEFINED = '__lodash_hash_undefined__';

  /** Used as the maximum memoize cache size. */
  var MAX_MEMOIZE_SIZE = 500;

  /** Used as the internal argument placeholder. */
  var PLACEHOLDER = '__lodash_placeholder__';

  /** Used to compose bitmasks for cloning. */
  var CLONE_DEEP_FLAG = 1,
      CLONE_FLAT_FLAG = 2,
      CLONE_SYMBOLS_FLAG = 4;

  /** Used to compose bitmasks for value comparisons. */
  var COMPARE_PARTIAL_FLAG = 1,
      COMPARE_UNORDERED_FLAG = 2;

  /** Used to compose bitmasks for function metadata. */
  var WRAP_BIND_FLAG = 1,
      WRAP_BIND_KEY_FLAG = 2,
      WRAP_CURRY_BOUND_FLAG = 4,
      WRAP_CURRY_FLAG = 8,
      WRAP_CURRY_RIGHT_FLAG = 16,
      WRAP_PARTIAL_FLAG = 32,
      WRAP_PARTIAL_RIGHT_FLAG = 64,
      WRAP_ARY_FLAG = 128,
      WRAP_REARG_FLAG = 256,
      WRAP_FLIP_FLAG = 512;

  /** Used as default options for `_.truncate`. */
  var DEFAULT_TRUNC_LENGTH = 30,
      DEFAULT_TRUNC_OMISSION = '...';

  /** Used to detect hot functions by number of calls within a span of milliseconds. */
  var HOT_COUNT = 800,
      HOT_SPAN = 16;

  /** Used to indicate the type of lazy iteratees. */
  var LAZY_FILTER_FLAG = 1,
      LAZY_MAP_FLAG = 2,
      LAZY_WHILE_FLAG = 3;

  /** Used as references for various `Number` constants. */
  var INFINITY = 1 / 0,
      MAX_SAFE_INTEGER = 9007199254740991,
      MAX_INTEGER = 1.7976931348623157e+308,
      NAN = 0 / 0;

  /** Used as references for the maximum length and index of an array. */
  var MAX_ARRAY_LENGTH = 4294967295,
      MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1,
      HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;

  /** Used to associate wrap methods with their bit flags. */
  var wrapFlags = [
    ['ary', WRAP_ARY_FLAG],
    ['bind', WRAP_BIND_FLAG],
    ['bindKey', WRAP_BIND_KEY_FLAG],
    ['curry', WRAP_CURRY_FLAG],
    ['curryRight', WRAP_CURRY_RIGHT_FLAG],
    ['flip', WRAP_FLIP_FLAG],
    ['partial', WRAP_PARTIAL_FLAG],
    ['partialRight', WRAP_PARTIAL_RIGHT_FLAG],
    ['rearg', WRAP_REARG_FLAG]
  ];

  /** `Object#toString` result references. */
  var argsTag = '[object Arguments]',
      arrayTag = '[object Array]',
      asyncTag = '[object AsyncFunction]',
      boolTag = '[object Boolean]',
      dateTag = '[object Date]',
      domExcTag = '[object DOMException]',
      errorTag = '[object Error]',
      funcTag = '[object Function]',
      genTag = '[object GeneratorFunction]',
      mapTag = '[object Map]',
      numberTag = '[object Number]',
      nullTag = '[object Null]',
      objectTag = '[object Object]',
      promiseTag = '[object Promise]',
      proxyTag = '[object Proxy]',
      regexpTag = '[object RegExp]',
      setTag = '[object Set]',
      stringTag = '[object String]',
      symbolTag = '[object Symbol]',
      undefinedTag = '[object Undefined]',
      weakMapTag = '[object WeakMap]',
      weakSetTag = '[object WeakSet]';

  var arrayBufferTag = '[object ArrayBuffer]',
      dataViewTag = '[object DataView]',
      float32Tag = '[object Float32Array]',
      float64Tag = '[object Float64Array]',
      int8Tag = '[object Int8Array]',
      int16Tag = '[object Int16Array]',
      int32Tag = '[object Int32Array]',
      uint8Tag = '[object Uint8Array]',
      uint8ClampedTag = '[object Uint8ClampedArray]',
      uint16Tag = '[object Uint16Array]',
      uint32Tag = '[object Uint32Array]';

  /** Used to match empty string literals in compiled template source. */
  var reEmptyStringLeading = /\b__p \+= '';/g,
      reEmptyStringMiddle = /\b(__p \+=) '' \+/g,
      reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;

  /** Used to match HTML entities and HTML characters. */
  var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g,
      reUnescapedHtml = /[&<>"']/g,
      reHasEscapedHtml = RegExp(reEscapedHtml.source),
      reHasUnescapedHtml = RegExp(reUnescapedHtml.source);

  /** Used to match template delimiters. */
  var reEscape = /<%-([\s\S]+?)%>/g,
      reEvaluate = /<%([\s\S]+?)%>/g,
      reInterpolate = /<%=([\s\S]+?)%>/g;

  /** Used to match property names within property paths. */
  var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
      reIsPlainProp = /^\w*$/,
      rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;

  /**
   * Used to match `RegExp`
   * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
   */
  var reRegExpChar = /[\\^$.*+?()[\]{}|]/g,
      reHasRegExpChar = RegExp(reRegExpChar.source);

  /** Used to match leading whitespace. */
  var reTrimStart = /^\s+/;

  /** Used to match a single whitespace character. */
  var reWhitespace = /\s/;

  /** Used to match wrap detail comments. */
  var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/,
      reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/,
      reSplitDetails = /,? & /;

  /** Used to match words composed of alphanumeric characters. */
  var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;

  /**
   * Used to validate the `validate` option in `_.template` variable.
   *
   * Forbids characters which could potentially change the meaning of the function argument definition:
   * - "()," (modification of function parameters)
   * - "=" (default value)
   * - "[]{}" (destructuring of function parameters)
   * - "/" (beginning of a comment)
   * - whitespace
   */
  var reForbiddenIdentifierChars = /[()=,{}\[\]\/\s]/;

  /** Used to match backslashes in property paths. */
  var reEscapeChar = /\\(\\)?/g;

  /**
   * Used to match
   * [ES template delimiters](http://ecma-international.org/ecma-262/7.0/#sec-template-literal-lexical-components).
   */
  var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;

  /** Used to match `RegExp` flags from their coerced string values. */
  var reFlags = /\w*$/;

  /** Used to detect bad signed hexadecimal string values. */
  var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

  /** Used to detect binary string values. */
  var reIsBinary = /^0b[01]+$/i;

  /** Used to detect host constructors (Safari). */
  var reIsHostCtor = /^\[object .+?Constructor\]$/;

  /** Used to detect octal string values. */
  var reIsOctal = /^0o[0-7]+$/i;

  /** Used to detect unsigned integer values. */
  var reIsUint = /^(?:0|[1-9]\d*)$/;

  /** Used to match Latin Unicode letters (excluding mathematical operators). */
  var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;

  /** Used to ensure capturing order of template delimiters. */
  var reNoMatch = /($^)/;

  /** Used to match unescaped characters in compiled string literals. */
  var reUnescapedString = /['\n\r\u2028\u2029\\]/g;

  /** Used to compose unicode character classes. */
  var rsAstralRange = '\\ud800-\\udfff',
      rsComboMarksRange = '\\u0300-\\u036f',
      reComboHalfMarksRange = '\\ufe20-\\ufe2f',
      rsComboSymbolsRange = '\\u20d0-\\u20ff',
      rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange,
      rsDingbatRange = '\\u2700-\\u27bf',
      rsLowerRange = 'a-z\\xdf-\\xf6\\xf8-\\xff',
      rsMathOpRange = '\\xac\\xb1\\xd7\\xf7',
      rsNonCharRange = '\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf',
      rsPunctuationRange = '\\u2000-\\u206f',
      rsSpaceRange = ' \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000',
      rsUpperRange = 'A-Z\\xc0-\\xd6\\xd8-\\xde',
      rsVarRange = '\\ufe0e\\ufe0f',
      rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;

  /** Used to compose unicode capture groups. */
  var rsApos = "['\u2019]",
      rsAstral = '[' + rsAstralRange + ']',
      rsBreak = '[' + rsBreakRange + ']',
      rsCombo = '[' + rsComboRange + ']',
      rsDigits = '\\d+',
      rsDingbat = '[' + rsDingbatRange + ']',
      rsLower = '[' + rsLowerRange + ']',
      rsMisc = '[^' + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + ']',
      rsFitz = '\\ud83c[\\udffb-\\udfff]',
      rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')',
      rsNonAstral = '[^' + rsAstralRange + ']',
      rsRegional = '(?:\\ud83c[\\udde6-\\uddff]){2}',
      rsSurrPair = '[\\ud800-\\udbff][\\udc00-\\udfff]',
      rsUpper = '[' + rsUpperRange + ']',
      rsZWJ = '\\u200d';

  /** Used to compose unicode regexes. */
  var rsMiscLower = '(?:' + rsLower + '|' + rsMisc + ')',
      rsMiscUpper = '(?:' + rsUpper + '|' + rsMisc + ')',
      rsOptContrLower = '(?:' + rsApos + '(?:d|ll|m|re|s|t|ve))?',
      rsOptContrUpper = '(?:' + rsApos + '(?:D|LL|M|RE|S|T|VE))?',
      reOptMod = rsModifier + '?',
      rsOptVar = '[' + rsVarRange + ']?',
      rsOptJoin = '(?:' + rsZWJ + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*',
      rsOrdLower = '\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])',
      rsOrdUpper = '\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])',
      rsSeq = rsOptVar + reOptMod + rsOptJoin,
      rsEmoji = '(?:' + [rsDingbat, rsRegional, rsSurrPair].join('|') + ')' + rsSeq,
      rsSymbol = '(?:' + [rsNonAstral + rsCombo + '?', rsCombo, rsRegional, rsSurrPair, rsAstral].join('|') + ')';

  /** Used to match apostrophes. */
  var reApos = RegExp(rsApos, 'g');

  /**
   * Used to match [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks) and
   * [combining diacritical marks for symbols](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks_for_Symbols).
   */
  var reComboMark = RegExp(rsCombo, 'g');

  /** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */
  var reUnicode = RegExp(rsFitz + '(?=' + rsFitz + ')|' + rsSymbol + rsSeq, 'g');

  /** Used to match complex or compound words. */
  var reUnicodeWord = RegExp([
    rsUpper + '?' + rsLower + '+' + rsOptContrLower + '(?=' + [rsBreak, rsUpper, '$'].join('|') + ')',
    rsMiscUpper + '+' + rsOptContrUpper + '(?=' + [rsBreak, rsUpper + rsMiscLower, '$'].join('|') + ')',
    rsUpper + '?' + rsMiscLower + '+' + rsOptContrLower,
    rsUpper + '+' + rsOptContrUpper,
    rsOrdUpper,
    rsOrdLower,
    rsDigits,
    rsEmoji
  ].join('|'), 'g');

  /** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */
  var reHasUnicode = RegExp('[' + rsZWJ + rsAstralRange  + rsComboRange + rsVarRange + ']');

  /** Used to detect strings that need a more robust regexp to match words. */
  var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;

  /** Used to assign default `context` object properties. */
  var contextProps = [
    'Array', 'Buffer', 'DataView', 'Date', 'Error', 'Float32Array', 'Float64Array',
    'Function', 'Int8Array', 'Int16Array', 'Int32Array', 'Map', 'Math', 'Object',
    'Promise', 'RegExp', 'Set', 'String', 'Symbol', 'TypeError', 'Uint8Array',
    'Uint8ClampedArray', 'Uint16Array', 'Uint32Array', 'WeakMap',
    '_', 'clearTimeout', 'isFinite', 'parseInt', 'setTimeout'
  ];

  /** Used to make template sourceURLs easier to identify. */
  var templateCounter = -1;

  /** Used to identify `toStringTag` values of typed arrays. */
  var typedArrayTags = {};
  typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
  typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
  typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
  typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
  typedArrayTags[uint32Tag] = true;
  typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
  typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
  typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
  typedArrayTags[errorTag] = typedArrayTags[funcTag] =
  typedArrayTags[mapTag] = typedArrayTags[numberTag] =
  typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
  typedArrayTags[setTag] = typedArrayTags[stringTag] =
  typedArrayTags[weakMapTag] = false;

  /** Used to identify `toStringTag` values supported by `_.clone`. */
  var cloneableTags = {};
  cloneableTags[argsTag] = cloneableTags[arrayTag] =
  cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] =
  cloneableTags[boolTag] = cloneableTags[dateTag] =
  cloneableTags[float32Tag] = cloneableTags[float64Tag] =
  cloneableTags[int8Tag] = cloneableTags[int16Tag] =
  cloneableTags[int32Tag] = cloneableTags[mapTag] =
  cloneableTags[numberTag] = cloneableTags[objectTag] =
  cloneableTags[regexpTag] = cloneableTags[setTag] =
  cloneableTags[stringTag] = cloneableTags[symbolTag] =
  cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =
  cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
  cloneableTags[errorTag] = cloneableTags[funcTag] =
  cloneableTags[weakMapTag] = false;

  /** Used to map Latin Unicode letters to basic Latin letters. */
  var deburredLetters = {
    // Latin-1 Supplement block.
    '\xc0': 'A',  '\xc1': 'A', '\xc2': 'A', '\xc3': 'A', '\xc4': 'A', '\xc5': 'A',
    '\xe0': 'a',  '\xe1': 'a', '\xe2': 'a', '\xe3': 'a', '\xe4': 'a', '\xe5': 'a',
    '\xc7': 'C',  '\xe7': 'c',
    '\xd0': 'D',  '\xf0': 'd',
    '\xc8': 'E',  '\xc9': 'E', '\xca': 'E', '\xcb': 'E',
    '\xe8': 'e',  '\xe9': 'e', '\xea': 'e', '\xeb': 'e',
    '\xcc': 'I',  '\xcd': 'I', '\xce': 'I', '\xcf': 'I',
    '\xec': 'i',  '\xed': 'i', '\xee': 'i', '\xef': 'i',
    '\xd1': 'N',  '\xf1': 'n',
    '\xd2': 'O',  '\xd3': 'O', '\xd4': 'O', '\xd5': 'O', '\xd6': 'O', '\xd8': 'O',
    '\xf2': 'o',  '\xf3': 'o', '\xf4': 'o', '\xf5': 'o', '\xf6': 'o', '\xf8': 'o',
    '\xd9': 'U',  '\xda': 'U', '\xdb': 'U', '\xdc': 'U',
    '\xf9': 'u',  '\xfa': 'u', '\xfb': 'u', '\xfc': 'u',
    '\xdd': 'Y',  '\xfd': 'y', '\xff': 'y',
    '\xc6': 'Ae', '\xe6': 'ae',
    '\xde': 'Th', '\xfe': 'th',
    '\xdf': 'ss',
    // Latin Extended-A block.
    '\u0100': 'A',  '\u0102': 'A', '\u0104': 'A',
    '\u0101': 'a',  '\u0103': 'a', '\u0105': 'a',
    '\u0106': 'C',  '\u0108': 'C', '\u010a': 'C', '\u010c': 'C',
    '\u0107': 'c',  '\u0109': 'c', '\u010b': 'c', '\u010d': 'c',
    '\u010e': 'D',  '\u0110': 'D', '\u010f': 'd', '\u0111': 'd',
    '\u0112': 'E',  '\u0114': 'E', '\u0116': 'E', '\u0118': 'E', '\u011a': 'E',
    '\u0113': 'e',  '\u0115': 'e', '\u0117': 'e', '\u0119': 'e', '\u011b': 'e',
    '\u011c': 'G',  '\u011e': 'G', '\u0120': 'G', '\u0122': 'G',
    '\u011d': 'g',  '\u011f': 'g', '\u0121': 'g', '\u0123': 'g',
    '\u0124': 'H',  '\u0126': 'H', '\u0125': 'h', '\u0127': 'h',
    '\u0128': 'I',  '\u012a': 'I', '\u012c': 'I', '\u012e': 'I', '\u0130': 'I',
    '\u0129': 'i',  '\u012b': 'i', '\u012d': 'i', '\u012f': 'i', '\u0131': 'i',
    '\u0134': 'J',  '\u0135': 'j',
    '\u0136': 'K',  '\u0137': 'k', '\u0138': 'k',
    '\u0139': 'L',  '\u013b': 'L', '\u013d': 'L', '\u013f': 'L', '\u0141': 'L',
    '\u013a': 'l',  '\u013c': 'l', '\u013e': 'l', '\u0140': 'l', '\u0142': 'l',
    '\u0143': 'N',  '\u0145': 'N', '\u0147': 'N', '\u014a': 'N',
    '\u0144': 'n',  '\u0146': 'n', '\u0148': 'n', '\u014b': 'n',
    '\u014c': 'O',  '\u014e': 'O', '\u0150': 'O',
    '\u014d': 'o',  '\u014f': 'o', '\u0151': 'o',
    '\u0154': 'R',  '\u0156': 'R', '\u0158': 'R',
    '\u0155': 'r',  '\u0157': 'r', '\u0159': 'r',
    '\u015a': 'S',  '\u015c': 'S', '\u015e': 'S', '\u0160': 'S',
    '\u015b': 's',  '\u015d': 's', '\u015f': 's', '\u0161': 's',
    '\u0162': 'T',  '\u0164': 'T', '\u0166': 'T',
    '\u0163': 't',  '\u0165': 't', '\u0167': 't',
    '\u0168': 'U',  '\u016a': 'U', '\u016c': 'U', '\u016e': 'U', '\u0170': 'U', '\u0172': 'U',
    '\u0169': 'u',  '\u016b': 'u', '\u016d': 'u', '\u016f': 'u', '\u0171': 'u', '\u0173': 'u',
    '\u0174': 'W',  '\u0175': 'w',
    '\u0176': 'Y',  '\u0177': 'y', '\u0178': 'Y',
    '\u0179': 'Z',  '\u017b': 'Z', '\u017d': 'Z',
    '\u017a': 'z',  '\u017c': 'z', '\u017e': 'z',
    '\u0132': 'IJ', '\u0133': 'ij',
    '\u0152': 'Oe', '\u0153': 'oe',
    '\u0149': "'n", '\u017f': 's'
  };

  /** Used to map characters to HTML entities. */
  var htmlEscapes = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#39;'
  };

  /** Used to map HTML entities to characters. */
  var htmlUnescapes = {
    '&amp;': '&',
    '&lt;': '<',
    '&gt;': '>',
    '&quot;': '"',
    '&#39;': "'"
  };

  /** Used to escape characters for inclusion in compiled string literals. */
  var stringEscapes = {
    '\\': '\\',
    "'": "'",
    '\n': 'n',
    '\r': 'r',
    '\u2028': 'u2028',
    '\u2029': 'u2029'
  };

  /** Built-in method references without a dependency on `root`. */
  var freeParseFloat = parseFloat,
      freeParseInt = parseInt;

  /** Detect free variable `global` from Node.js. */
  var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

  /** Detect free variable `self`. */
  var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

  /** Used as a reference to the global object. */
  var root = freeGlobal || freeSelf || Function('return this')();

  /** Detect free variable `exports`. */
  var freeExports =  true && exports && !exports.nodeType && exports;

  /** Detect free variable `module`. */
  var freeModule = freeExports && "object" == 'object' && module && !module.nodeType && module;

  /** Detect the popular CommonJS extension `module.exports`. */
  var moduleExports = freeModule && freeModule.exports === freeExports;

  /** Detect free variable `process` from Node.js. */
  var freeProcess = moduleExports && freeGlobal.process;

  /** Used to access faster Node.js helpers. */
  var nodeUtil = (function() {
    try {
      // Use `util.types` for Node.js 10+.
      var types = freeModule && freeModule.require && freeModule.require('util').types;

      if (types) {
        return types;
      }

      // Legacy `process.binding('util')` for Node.js < 10.
      return freeProcess && freeProcess.binding && freeProcess.binding('util');
    } catch (e) {}
  }());

  /* Node.js helper references. */
  var nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer,
      nodeIsDate = nodeUtil && nodeUtil.isDate,
      nodeIsMap = nodeUtil && nodeUtil.isMap,
      nodeIsRegExp = nodeUtil && nodeUtil.isRegExp,
      nodeIsSet = nodeUtil && nodeUtil.isSet,
      nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

  /*--------------------------------------------------------------------------*/

  /**
   * A faster alternative to `Function#apply`, this function invokes `func`
   * with the `this` binding of `thisArg` and the arguments of `args`.
   *
   * @private
   * @param {Function} func The function to invoke.
   * @param {*} thisArg The `this` binding of `func`.
   * @param {Array} args The arguments to invoke `func` with.
   * @returns {*} Returns the result of `func`.
   */
  function apply(func, thisArg, args) {
    switch (args.length) {
      case 0: return func.call(thisArg);
      case 1: return func.call(thisArg, args[0]);
      case 2: return func.call(thisArg, args[0], args[1]);
      case 3: return func.call(thisArg, args[0], args[1], args[2]);
    }
    return func.apply(thisArg, args);
  }

  /**
   * A specialized version of `baseAggregator` for arrays.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} setter The function to set `accumulator` values.
   * @param {Function} iteratee The iteratee to transform keys.
   * @param {Object} accumulator The initial aggregated object.
   * @returns {Function} Returns `accumulator`.
   */
  function arrayAggregator(array, setter, iteratee, accumulator) {
    var index = -1,
        length = array == null ? 0 : array.length;

    while (++index < length) {
      var value = array[index];
      setter(accumulator, value, iteratee(value), array);
    }
    return accumulator;
  }

  /**
   * A specialized version of `_.forEach` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns `array`.
   */
  function arrayEach(array, iteratee) {
    var index = -1,
        length = array == null ? 0 : array.length;

    while (++index < length) {
      if (iteratee(array[index], index, array) === false) {
        break;
      }
    }
    return array;
  }

  /**
   * A specialized version of `_.forEachRight` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns `array`.
   */
  function arrayEachRight(array, iteratee) {
    var length = array == null ? 0 : array.length;

    while (length--) {
      if (iteratee(array[length], length, array) === false) {
        break;
      }
    }
    return array;
  }

  /**
   * A specialized version of `_.every` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} predicate The function invoked per iteration.
   * @returns {boolean} Returns `true` if all elements pass the predicate check,
   *  else `false`.
   */
  function arrayEvery(array, predicate) {
    var index = -1,
        length = array == null ? 0 : array.length;

    while (++index < length) {
      if (!predicate(array[index], index, array)) {
        return false;
      }
    }
    return true;
  }

  /**
   * A specialized version of `_.filter` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} predicate The function invoked per iteration.
   * @returns {Array} Returns the new filtered array.
   */
  function arrayFilter(array, predicate) {
    var index = -1,
        length = array == null ? 0 : array.length,
        resIndex = 0,
        result = [];

    while (++index < length) {
      var value = array[index];
      if (predicate(value, index, array)) {
        result[resIndex++] = value;
      }
    }
    return result;
  }

  /**
   * A specialized version of `_.includes` for arrays without support for
   * specifying an index to search from.
   *
   * @private
   * @param {Array} [array] The array to inspect.
   * @param {*} target The value to search for.
   * @returns {boolean} Returns `true` if `target` is found, else `false`.
   */
  function arrayIncludes(array, value) {
    var length = array == null ? 0 : array.length;
    return !!length && baseIndexOf(array, value, 0) > -1;
  }

  /**
   * This function is like `arrayIncludes` except that it accepts a comparator.
   *
   * @private
   * @param {Array} [array] The array to inspect.
   * @param {*} target The value to search for.
   * @param {Function} comparator The comparator invoked per element.
   * @returns {boolean} Returns `true` if `target` is found, else `false`.
   */
  function arrayIncludesWith(array, value, comparator) {
    var index = -1,
        length = array == null ? 0 : array.length;

    while (++index < length) {
      if (comparator(value, array[index])) {
        return true;
      }
    }
    return false;
  }

  /**
   * A specialized version of `_.map` for arrays without support for iteratee
   * shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns the new mapped array.
   */
  function arrayMap(array, iteratee) {
    var index = -1,
        length = array == null ? 0 : array.length,
        result = Array(length);

    while (++index < length) {
      result[index] = iteratee(array[index], index, array);
    }
    return result;
  }

  /**
   * Appends the elements of `values` to `array`.
   *
   * @private
   * @param {Array} array The array to modify.
   * @param {Array} values The values to append.
   * @returns {Array} Returns `array`.
   */
  function arrayPush(array, values) {
    var index = -1,
        length = values.length,
        offset = array.length;

    while (++index < length) {
      array[offset + index] = values[index];
    }
    return array;
  }

  /**
   * A specialized version of `_.reduce` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @param {*} [accumulator] The initial value.
   * @param {boolean} [initAccum] Specify using the first element of `array` as
   *  the initial value.
   * @returns {*} Returns the accumulated value.
   */
  function arrayReduce(array, iteratee, accumulator, initAccum) {
    var index = -1,
        length = array == null ? 0 : array.length;

    if (initAccum && length) {
      accumulator = array[++index];
    }
    while (++index < length) {
      accumulator = iteratee(accumulator, array[index], index, array);
    }
    return accumulator;
  }

  /**
   * A specialized version of `_.reduceRight` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @param {*} [accumulator] The initial value.
   * @param {boolean} [initAccum] Specify using the last element of `array` as
   *  the initial value.
   * @returns {*} Returns the accumulated value.
   */
  function arrayReduceRight(array, iteratee, accumulator, initAccum) {
    var length = array == null ? 0 : array.length;
    if (initAccum && length) {
      accumulator = array[--length];
    }
    while (length--) {
      accumulator = iteratee(accumulator, array[length], length, array);
    }
    return accumulator;
  }

  /**
   * A specialized version of `_.some` for arrays without support for iteratee
   * shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} predicate The function invoked per iteration.
   * @returns {boolean} Returns `true` if any element passes the predicate check,
   *  else `false`.
   */
  function arraySome(array, predicate) {
    var index = -1,
        length = array == null ? 0 : array.length;

    while (++index < length) {
      if (predicate(array[index], index, array)) {
        return true;
      }
    }
    return false;
  }

  /**
   * Gets the size of an ASCII `string`.
   *
   * @private
   * @param {string} string The string inspect.
   * @returns {number} Returns the string size.
   */
  var asciiSize = baseProperty('length');

  /**
   * Converts an ASCII `string` to an array.
   *
   * @private
   * @param {string} string The string to convert.
   * @returns {Array} Returns the converted array.
   */
  function asciiToArray(string) {
    return string.split('');
  }

  /**
   * Splits an ASCII `string` into an array of its words.
   *
   * @private
   * @param {string} The string to inspect.
   * @returns {Array} Returns the words of `string`.
   */
  function asciiWords(string) {
    return string.match(reAsciiWord) || [];
  }

  /**
   * The base implementation of methods like `_.findKey` and `_.findLastKey`,
   * without support for iteratee shorthands, which iterates over `collection`
   * using `eachFunc`.
   *
   * @private
   * @param {Array|Object} collection The collection to inspect.
   * @param {Function} predicate The function invoked per iteration.
   * @param {Function} eachFunc The function to iterate over `collection`.
   * @returns {*} Returns the found element or its key, else `undefined`.
   */
  function baseFindKey(collection, predicate, eachFunc) {
    var result;
    eachFunc(collection, function(value, key, collection) {
      if (predicate(value, key, collection)) {
        result = key;
        return false;
      }
    });
    return result;
  }

  /**
   * The base implementation of `_.findIndex` and `_.findLastIndex` without
   * support for iteratee shorthands.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {Function} predicate The function invoked per iteration.
   * @param {number} fromIndex The index to search from.
   * @param {boolean} [fromRight] Specify iterating from right to left.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function baseFindIndex(array, predicate, fromIndex, fromRight) {
    var length = array.length,
        index = fromIndex + (fromRight ? 1 : -1);

    while ((fromRight ? index-- : ++index < length)) {
      if (predicate(array[index], index, array)) {
        return index;
      }
    }
    return -1;
  }

  /**
   * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} value The value to search for.
   * @param {number} fromIndex The index to search from.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function baseIndexOf(array, value, fromIndex) {
    return value === value
      ? strictIndexOf(array, value, fromIndex)
      : baseFindIndex(array, baseIsNaN, fromIndex);
  }

  /**
   * This function is like `baseIndexOf` except that it accepts a comparator.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} value The value to search for.
   * @param {number} fromIndex The index to search from.
   * @param {Function} comparator The comparator invoked per element.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function baseIndexOfWith(array, value, fromIndex, comparator) {
    var index = fromIndex - 1,
        length = array.length;

    while (++index < length) {
      if (comparator(array[index], value)) {
        return index;
      }
    }
    return -1;
  }

  /**
   * The base implementation of `_.isNaN` without support for number objects.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
   */
  function baseIsNaN(value) {
    return value !== value;
  }

  /**
   * The base implementation of `_.mean` and `_.meanBy` without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} array The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {number} Returns the mean.
   */
  function baseMean(array, iteratee) {
    var length = array == null ? 0 : array.length;
    return length ? (baseSum(array, iteratee) / length) : NAN;
  }

  /**
   * The base implementation of `_.property` without support for deep paths.
   *
   * @private
   * @param {string} key The key of the property to get.
   * @returns {Function} Returns the new accessor function.
   */
  function baseProperty(key) {
    return function(object) {
      return object == null ? undefined : object[key];
    };
  }

  /**
   * The base implementation of `_.propertyOf` without support for deep paths.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Function} Returns the new accessor function.
   */
  function basePropertyOf(object) {
    return function(key) {
      return object == null ? undefined : object[key];
    };
  }

  /**
   * The base implementation of `_.reduce` and `_.reduceRight`, without support
   * for iteratee shorthands, which iterates over `collection` using `eachFunc`.
   *
   * @private
   * @param {Array|Object} collection The collection to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @param {*} accumulator The initial value.
   * @param {boolean} initAccum Specify using the first or last element of
   *  `collection` as the initial value.
   * @param {Function} eachFunc The function to iterate over `collection`.
   * @returns {*} Returns the accumulated value.
   */
  function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
    eachFunc(collection, function(value, index, collection) {
      accumulator = initAccum
        ? (initAccum = false, value)
        : iteratee(accumulator, value, index, collection);
    });
    return accumulator;
  }

  /**
   * The base implementation of `_.sortBy` which uses `comparer` to define the
   * sort order of `array` and replaces criteria objects with their corresponding
   * values.
   *
   * @private
   * @param {Array} array The array to sort.
   * @param {Function} comparer The function to define sort order.
   * @returns {Array} Returns `array`.
   */
  function baseSortBy(array, comparer) {
    var length = array.length;

    array.sort(comparer);
    while (length--) {
      array[length] = array[length].value;
    }
    return array;
  }

  /**
   * The base implementation of `_.sum` and `_.sumBy` without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} array The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {number} Returns the sum.
   */
  function baseSum(array, iteratee) {
    var result,
        index = -1,
        length = array.length;

    while (++index < length) {
      var current = iteratee(array[index]);
      if (current !== undefined) {
        result = result === undefined ? current : (result + current);
      }
    }
    return result;
  }

  /**
   * The base implementation of `_.times` without support for iteratee shorthands
   * or max array length checks.
   *
   * @private
   * @param {number} n The number of times to invoke `iteratee`.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns the array of results.
   */
  function baseTimes(n, iteratee) {
    var index = -1,
        result = Array(n);

    while (++index < n) {
      result[index] = iteratee(index);
    }
    return result;
  }

  /**
   * The base implementation of `_.toPairs` and `_.toPairsIn` which creates an array
   * of key-value pairs for `object` corresponding to the property names of `props`.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {Array} props The property names to get values for.
   * @returns {Object} Returns the key-value pairs.
   */
  function baseToPairs(object, props) {
    return arrayMap(props, function(key) {
      return [key, object[key]];
    });
  }

  /**
   * The base implementation of `_.trim`.
   *
   * @private
   * @param {string} string The string to trim.
   * @returns {string} Returns the trimmed string.
   */
  function baseTrim(string) {
    return string
      ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, '')
      : string;
  }

  /**
   * The base implementation of `_.unary` without support for storing metadata.
   *
   * @private
   * @param {Function} func The function to cap arguments for.
   * @returns {Function} Returns the new capped function.
   */
  function baseUnary(func) {
    return function(value) {
      return func(value);
    };
  }

  /**
   * The base implementation of `_.values` and `_.valuesIn` which creates an
   * array of `object` property values corresponding to the property names
   * of `props`.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {Array} props The property names to get values for.
   * @returns {Object} Returns the array of property values.
   */
  function baseValues(object, props) {
    return arrayMap(props, function(key) {
      return object[key];
    });
  }

  /**
   * Checks if a `cache` value for `key` exists.
   *
   * @private
   * @param {Object} cache The cache to query.
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */
  function cacheHas(cache, key) {
    return cache.has(key);
  }

  /**
   * Used by `_.trim` and `_.trimStart` to get the index of the first string symbol
   * that is not found in the character symbols.
   *
   * @private
   * @param {Array} strSymbols The string symbols to inspect.
   * @param {Array} chrSymbols The character symbols to find.
   * @returns {number} Returns the index of the first unmatched string symbol.
   */
  function charsStartIndex(strSymbols, chrSymbols) {
    var index = -1,
        length = strSymbols.length;

    while (++index < length && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}
    return index;
  }

  /**
   * Used by `_.trim` and `_.trimEnd` to get the index of the last string symbol
   * that is not found in the character symbols.
   *
   * @private
   * @param {Array} strSymbols The string symbols to inspect.
   * @param {Array} chrSymbols The character symbols to find.
   * @returns {number} Returns the index of the last unmatched string symbol.
   */
  function charsEndIndex(strSymbols, chrSymbols) {
    var index = strSymbols.length;

    while (index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}
    return index;
  }

  /**
   * Gets the number of `placeholder` occurrences in `array`.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} placeholder The placeholder to search for.
   * @returns {number} Returns the placeholder count.
   */
  function countHolders(array, placeholder) {
    var length = array.length,
        result = 0;

    while (length--) {
      if (array[length] === placeholder) {
        ++result;
      }
    }
    return result;
  }

  /**
   * Used by `_.deburr` to convert Latin-1 Supplement and Latin Extended-A
   * letters to basic Latin letters.
   *
   * @private
   * @param {string} letter The matched letter to deburr.
   * @returns {string} Returns the deburred letter.
   */
  var deburrLetter = basePropertyOf(deburredLetters);

  /**
   * Used by `_.escape` to convert characters to HTML entities.
   *
   * @private
   * @param {string} chr The matched character to escape.
   * @returns {string} Returns the escaped character.
   */
  var escapeHtmlChar = basePropertyOf(htmlEscapes);

  /**
   * Used by `_.template` to escape characters for inclusion in compiled string literals.
   *
   * @private
   * @param {string} chr The matched character to escape.
   * @returns {string} Returns the escaped character.
   */
  function escapeStringChar(chr) {
    return '\\' + stringEscapes[chr];
  }

  /**
   * Gets the value at `key` of `object`.
   *
   * @private
   * @param {Object} [object] The object to query.
   * @param {string} key The key of the property to get.
   * @returns {*} Returns the property value.
   */
  function getValue(object, key) {
    return object == null ? undefined : object[key];
  }

  /**
   * Checks if `string` contains Unicode symbols.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {boolean} Returns `true` if a symbol is found, else `false`.
   */
  function hasUnicode(string) {
    return reHasUnicode.test(string);
  }

  /**
   * Checks if `string` contains a word composed of Unicode symbols.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {boolean} Returns `true` if a word is found, else `false`.
   */
  function hasUnicodeWord(string) {
    return reHasUnicodeWord.test(string);
  }

  /**
   * Converts `iterator` to an array.
   *
   * @private
   * @param {Object} iterator The iterator to convert.
   * @returns {Array} Returns the converted array.
   */
  function iteratorToArray(iterator) {
    var data,
        result = [];

    while (!(data = iterator.next()).done) {
      result.push(data.value);
    }
    return result;
  }

  /**
   * Converts `map` to its key-value pairs.
   *
   * @private
   * @param {Object} map The map to convert.
   * @returns {Array} Returns the key-value pairs.
   */
  function mapToArray(map) {
    var index = -1,
        result = Array(map.size);

    map.forEach(function(value, key) {
      result[++index] = [key, value];
    });
    return result;
  }

  /**
   * Creates a unary function that invokes `func` with its argument transformed.
   *
   * @private
   * @param {Function} func The function to wrap.
   * @param {Function} transform The argument transform.
   * @returns {Function} Returns the new function.
   */
  function overArg(func, transform) {
    return function(arg) {
      return func(transform(arg));
    };
  }

  /**
   * Replaces all `placeholder` elements in `array` with an internal placeholder
   * and returns an array of their indexes.
   *
   * @private
   * @param {Array} array The array to modify.
   * @param {*} placeholder The placeholder to replace.
   * @returns {Array} Returns the new array of placeholder indexes.
   */
  function replaceHolders(array, placeholder) {
    var index = -1,
        length = array.length,
        resIndex = 0,
        result = [];

    while (++index < length) {
      var value = array[index];
      if (value === placeholder || value === PLACEHOLDER) {
        array[index] = PLACEHOLDER;
        result[resIndex++] = index;
      }
    }
    return result;
  }

  /**
   * Converts `set` to an array of its values.
   *
   * @private
   * @param {Object} set The set to convert.
   * @returns {Array} Returns the values.
   */
  function setToArray(set) {
    var index = -1,
        result = Array(set.size);

    set.forEach(function(value) {
      result[++index] = value;
    });
    return result;
  }

  /**
   * Converts `set` to its value-value pairs.
   *
   * @private
   * @param {Object} set The set to convert.
   * @returns {Array} Returns the value-value pairs.
   */
  function setToPairs(set) {
    var index = -1,
        result = Array(set.size);

    set.forEach(function(value) {
      result[++index] = [value, value];
    });
    return result;
  }

  /**
   * A specialized version of `_.indexOf` which performs strict equality
   * comparisons of values, i.e. `===`.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} value The value to search for.
   * @param {number} fromIndex The index to search from.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function strictIndexOf(array, value, fromIndex) {
    var index = fromIndex - 1,
        length = array.length;

    while (++index < length) {
      if (array[index] === value) {
        return index;
      }
    }
    return -1;
  }

  /**
   * A specialized version of `_.lastIndexOf` which performs strict equality
   * comparisons of values, i.e. `===`.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} value The value to search for.
   * @param {number} fromIndex The index to search from.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function strictLastIndexOf(array, value, fromIndex) {
    var index = fromIndex + 1;
    while (index--) {
      if (array[index] === value) {
        return index;
      }
    }
    return index;
  }

  /**
   * Gets the number of symbols in `string`.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {number} Returns the string size.
   */
  function stringSize(string) {
    return hasUnicode(string)
      ? unicodeSize(string)
      : asciiSize(string);
  }

  /**
   * Converts `string` to an array.
   *
   * @private
   * @param {string} string The string to convert.
   * @returns {Array} Returns the converted array.
   */
  function stringToArray(string) {
    return hasUnicode(string)
      ? unicodeToArray(string)
      : asciiToArray(string);
  }

  /**
   * Used by `_.trim` and `_.trimEnd` to get the index of the last non-whitespace
   * character of `string`.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {number} Returns the index of the last non-whitespace character.
   */
  function trimmedEndIndex(string) {
    var index = string.length;

    while (index-- && reWhitespace.test(string.charAt(index))) {}
    return index;
  }

  /**
   * Used by `_.unescape` to convert HTML entities to characters.
   *
   * @private
   * @param {string} chr The matched character to unescape.
   * @returns {string} Returns the unescaped character.
   */
  var unescapeHtmlChar = basePropertyOf(htmlUnescapes);

  /**
   * Gets the size of a Unicode `string`.
   *
   * @private
   * @param {string} string The string inspect.
   * @returns {number} Returns the string size.
   */
  function unicodeSize(string) {
    var result = reUnicode.lastIndex = 0;
    while (reUnicode.test(string)) {
      ++result;
    }
    return result;
  }

  /**
   * Converts a Unicode `string` to an array.
   *
   * @private
   * @param {string} string The string to convert.
   * @returns {Array} Returns the converted array.
   */
  function unicodeToArray(string) {
    return string.match(reUnicode) || [];
  }

  /**
   * Splits a Unicode `string` into an array of its words.
   *
   * @private
   * @param {string} The string to inspect.
   * @returns {Array} Returns the words of `string`.
   */
  function unicodeWords(string) {
    return string.match(reUnicodeWord) || [];
  }

  /*--------------------------------------------------------------------------*/

  /**
   * Create a new pristine `lodash` function using the `context` object.
   *
   * @static
   * @memberOf _
   * @since 1.1.0
   * @category Util
   * @param {Object} [context=root] The context object.
   * @returns {Function} Returns a new `lodash` function.
   * @example
   *
   * _.mixin({ 'foo': _.constant('foo') });
   *
   * var lodash = _.runInContext();
   * lodash.mixin({ 'bar': lodash.constant('bar') });
   *
   * _.isFunction(_.foo);
   * // => true
   * _.isFunction(_.bar);
   * // => false
   *
   * lodash.isFunction(lodash.foo);
   * // => false
   * lodash.isFunction(lodash.bar);
   * // => true
   *
   * // Create a suped-up `defer` in Node.js.
   * var defer = _.runInContext({ 'setTimeout': setImmediate }).defer;
   */
  var runInContext = (function runInContext(context) {
    context = context == null ? root : _.defaults(root.Object(), context, _.pick(root, contextProps));

    /** Built-in constructor references. */
    var Array = context.Array,
        Date = context.Date,
        Error = context.Error,
        Function = context.Function,
        Math = context.Math,
        Object = context.Object,
        RegExp = context.RegExp,
        String = context.String,
        TypeError = context.TypeError;

    /** Used for built-in method references. */
    var arrayProto = Array.prototype,
        funcProto = Function.prototype,
        objectProto = Object.prototype;

    /** Used to detect overreaching core-js shims. */
    var coreJsData = context['__core-js_shared__'];

    /** Used to resolve the decompiled source of functions. */
    var funcToString = funcProto.toString;

    /** Used to check objects for own properties. */
    var hasOwnProperty = objectProto.hasOwnProperty;

    /** Used to generate unique IDs. */
    var idCounter = 0;

    /** Used to detect methods masquerading as native. */
    var maskSrcKey = (function() {
      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
      return uid ? ('Symbol(src)_1.' + uid) : '';
    }());

    /**
     * Used to resolve the
     * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
     * of values.
     */
    var nativeObjectToString = objectProto.toString;

    /** Used to infer the `Object` constructor. */
    var objectCtorString = funcToString.call(Object);

    /** Used to restore the original `_` reference in `_.noConflict`. */
    var oldDash = root._;

    /** Used to detect if a method is native. */
    var reIsNative = RegExp('^' +
      funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
      .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
    );

    /** Built-in value references. */
    var Buffer = moduleExports ? context.Buffer : undefined,
        Symbol = context.Symbol,
        Uint8Array = context.Uint8Array,
        allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined,
        getPrototype = overArg(Object.getPrototypeOf, Object),
        objectCreate = Object.create,
        propertyIsEnumerable = objectProto.propertyIsEnumerable,
        splice = arrayProto.splice,
        spreadableSymbol = Symbol ? Symbol.isConcatSpreadable : undefined,
        symIterator = Symbol ? Symbol.iterator : undefined,
        symToStringTag = Symbol ? Symbol.toStringTag : undefined;

    var defineProperty = (function() {
      try {
        var func = getNative(Object, 'defineProperty');
        func({}, '', {});
        return func;
      } catch (e) {}
    }());

    /** Mocked built-ins. */
    var ctxClearTimeout = context.clearTimeout !== root.clearTimeout && context.clearTimeout,
        ctxNow = Date && Date.now !== root.Date.now && Date.now,
        ctxSetTimeout = context.setTimeout !== root.setTimeout && context.setTimeout;

    /* Built-in method references for those with the same name as other `lodash` methods. */
    var nativeCeil = Math.ceil,
        nativeFloor = Math.floor,
        nativeGetSymbols = Object.getOwnPropertySymbols,
        nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined,
        nativeIsFinite = context.isFinite,
        nativeJoin = arrayProto.join,
        nativeKeys = overArg(Object.keys, Object),
        nativeMax = Math.max,
        nativeMin = Math.min,
        nativeNow = Date.now,
        nativeParseInt = context.parseInt,
        nativeRandom = Math.random,
        nativeReverse = arrayProto.reverse;

    /* Built-in method references that are verified to be native. */
    var DataView = getNative(context, 'DataView'),
        Map = getNative(context, 'Map'),
        Promise = getNative(context, 'Promise'),
        Set = getNative(context, 'Set'),
        WeakMap = getNative(context, 'WeakMap'),
        nativeCreate = getNative(Object, 'create');

    /** Used to store function metadata. */
    var metaMap = WeakMap && new WeakMap;

    /** Used to lookup unminified function names. */
    var realNames = {};

    /** Used to detect maps, sets, and weakmaps. */
    var dataViewCtorString = toSource(DataView),
        mapCtorString = toSource(Map),
        promiseCtorString = toSource(Promise),
        setCtorString = toSource(Set),
        weakMapCtorString = toSource(WeakMap);

    /** Used to convert symbols to primitives and strings. */
    var symbolProto = Symbol ? Symbol.prototype : undefined,
        symbolValueOf = symbolProto ? symbolProto.valueOf : undefined,
        symbolToString = symbolProto ? symbolProto.toString : undefined;

    /*------------------------------------------------------------------------*/

    /**
     * Creates a `lodash` object which wraps `value` to enable implicit method
     * chain sequences. Methods that operate on and return arrays, collections,
     * and functions can be chained together. Methods that retrieve a single value
     * or may return a primitive value will automatically end the chain sequence
     * and return the unwrapped value. Otherwise, the value must be unwrapped
     * with `_#value`.
     *
     * Explicit chain sequences, which must be unwrapped with `_#value`, may be
     * enabled using `_.chain`.
     *
     * The execution of chained methods is lazy, that is, it's deferred until
     * `_#value` is implicitly or explicitly called.
     *
     * Lazy evaluation allows several methods to support shortcut fusion.
     * Shortcut fusion is an optimization to merge iteratee calls; this avoids
     * the creation of intermediate arrays and can greatly reduce the number of
     * iteratee executions. Sections of a chain sequence qualify for shortcut
     * fusion if the section is applied to an array and iteratees accept only
     * one argument. The heuristic for whether a section qualifies for shortcut
     * fusion is subject to change.
     *
     * Chaining is supported in custom builds as long as the `_#value` method is
     * directly or indirectly included in the build.
     *
     * In addition to lodash methods, wrappers have `Array` and `String` methods.
     *
     * The wrapper `Array` methods are:
     * `concat`, `join`, `pop`, `push`, `shift`, `sort`, `splice`, and `unshift`
     *
     * The wrapper `String` methods are:
     * `replace` and `split`
     *
     * The wrapper methods that support shortcut fusion are:
     * `at`, `compact`, `drop`, `dropRight`, `dropWhile`, `filter`, `find`,
     * `findLast`, `head`, `initial`, `last`, `map`, `reject`, `reverse`, `slice`,
     * `tail`, `take`, `takeRight`, `takeRightWhile`, `takeWhile`, and `toArray`
     *
     * The chainable wrapper methods are:
     * `after`, `ary`, `assign`, `assignIn`, `assignInWith`, `assignWith`, `at`,
     * `before`, `bind`, `bindAll`, `bindKey`, `castArray`, `chain`, `chunk`,
     * `commit`, `compact`, `concat`, `conforms`, `constant`, `countBy`, `create`,
     * `curry`, `debounce`, `defaults`, `defaultsDeep`, `defer`, `delay`,
     * `difference`, `differenceBy`, `differenceWith`, `drop`, `dropRight`,
     * `dropRightWhile`, `dropWhile`, `extend`, `extendWith`, `fill`, `filter`,
     * `flatMap`, `flatMapDeep`, `flatMapDepth`, `flatten`, `flattenDeep`,
     * `flattenDepth`, `flip`, `flow`, `flowRight`, `fromPairs`, `functions`,
     * `functionsIn`, `groupBy`, `initial`, `intersection`, `intersectionBy`,
     * `intersectionWith`, `invert`, `invertBy`, `invokeMap`, `iteratee`, `keyBy`,
     * `keys`, `keysIn`, `map`, `mapKeys`, `mapValues`, `matches`, `matchesProperty`,
     * `memoize`, `merge`, `mergeWith`, `method`, `methodOf`, `mixin`, `negate`,
     * `nthArg`, `omit`, `omitBy`, `once`, `orderBy`, `over`, `overArgs`,
     * `overEvery`, `overSome`, `partial`, `partialRight`, `partition`, `pick`,
     * `pickBy`, `plant`, `property`, `propertyOf`, `pull`, `pullAll`, `pullAllBy`,
     * `pullAllWith`, `pullAt`, `push`, `range`, `rangeRight`, `rearg`, `reject`,
     * `remove`, `rest`, `reverse`, `sampleSize`, `set`, `setWith`, `shuffle`,
     * `slice`, `sort`, `sortBy`, `splice`, `spread`, `tail`, `take`, `takeRight`,
     * `takeRightWhile`, `takeWhile`, `tap`, `throttle`, `thru`, `toArray`,
     * `toPairs`, `toPairsIn`, `toPath`, `toPlainObject`, `transform`, `unary`,
     * `union`, `unionBy`, `unionWith`, `uniq`, `uniqBy`, `uniqWith`, `unset`,
     * `unshift`, `unzip`, `unzipWith`, `update`, `updateWith`, `values`,
     * `valuesIn`, `without`, `wrap`, `xor`, `xorBy`, `xorWith`, `zip`,
     * `zipObject`, `zipObjectDeep`, and `zipWith`
     *
     * The wrapper methods that are **not** chainable by default are:
     * `add`, `attempt`, `camelCase`, `capitalize`, `ceil`, `clamp`, `clone`,
     * `cloneDeep`, `cloneDeepWith`, `cloneWith`, `conformsTo`, `deburr`,
     * `defaultTo`, `divide`, `each`, `eachRight`, `endsWith`, `eq`, `escape`,
     * `escapeRegExp`, `every`, `find`, `findIndex`, `findKey`, `findLast`,
     * `findLastIndex`, `findLastKey`, `first`, `floor`, `forEach`, `forEachRight`,
     * `forIn`, `forInRight`, `forOwn`, `forOwnRight`, `get`, `gt`, `gte`, `has`,
     * `hasIn`, `head`, `identity`, `includes`, `indexOf`, `inRange`, `invoke`,
     * `isArguments`, `isArray`, `isArrayBuffer`, `isArrayLike`, `isArrayLikeObject`,
     * `isBoolean`, `isBuffer`, `isDate`, `isElement`, `isEmpty`, `isEqual`,
     * `isEqualWith`, `isError`, `isFinite`, `isFunction`, `isInteger`, `isLength`,
     * `isMap`, `isMatch`, `isMatchWith`, `isNaN`, `isNative`, `isNil`, `isNull`,
     * `isNumber`, `isObject`, `isObjectLike`, `isPlainObject`, `isRegExp`,
     * `isSafeInteger`, `isSet`, `isString`, `isUndefined`, `isTypedArray`,
     * `isWeakMap`, `isWeakSet`, `join`, `kebabCase`, `last`, `lastIndexOf`,
     * `lowerCase`, `lowerFirst`, `lt`, `lte`, `max`, `maxBy`, `mean`, `meanBy`,
     * `min`, `minBy`, `multiply`, `noConflict`, `noop`, `now`, `nth`, `pad`,
     * `padEnd`, `padStart`, `parseInt`, `pop`, `random`, `reduce`, `reduceRight`,
     * `repeat`, `result`, `round`, `runInContext`, `sample`, `shift`, `size`,
     * `snakeCase`, `some`, `sortedIndex`, `sortedIndexBy`, `sortedLastIndex`,
     * `sortedLastIndexBy`, `startCase`, `startsWith`, `stubArray`, `stubFalse`,
     * `stubObject`, `stubString`, `stubTrue`, `subtract`, `sum`, `sumBy`,
     * `template`, `times`, `toFinite`, `toInteger`, `toJSON`, `toLength`,
     * `toLower`, `toNumber`, `toSafeInteger`, `toString`, `toUpper`, `trim`,
     * `trimEnd`, `trimStart`, `truncate`, `unescape`, `uniqueId`, `upperCase`,
     * `upperFirst`, `value`, and `words`
     *
     * @name _
     * @constructor
     * @category Seq
     * @param {*} value The value to wrap in a `lodash` instance.
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var wrapped = _([1, 2, 3]);
     *
     * // Returns an unwrapped value.
     * wrapped.reduce(_.add);
     * // => 6
     *
     * // Returns a wrapped value.
     * var squares = wrapped.map(square);
     *
     * _.isArray(squares);
     * // => false
     *
     * _.isArray(squares.value());
     * // => true
     */
    function lodash(value) {
      if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {
        if (value instanceof LodashWrapper) {
          return value;
        }
        if (hasOwnProperty.call(value, '__wrapped__')) {
          return wrapperClone(value);
        }
      }
      return new LodashWrapper(value);
    }

    /**
     * The base implementation of `_.create` without support for assigning
     * properties to the created object.
     *
     * @private
     * @param {Object} proto The object to inherit from.
     * @returns {Object} Returns the new object.
     */
    var baseCreate = (function() {
      function object() {}
      return function(proto) {
        if (!isObject(proto)) {
          return {};
        }
        if (objectCreate) {
          return objectCreate(proto);
        }
        object.prototype = proto;
        var result = new object;
        object.prototype = undefined;
        return result;
      };
    }());

    /**
     * The function whose prototype chain sequence wrappers inherit from.
     *
     * @private
     */
    function baseLodash() {
      // No operation performed.
    }

    /**
     * The base constructor for creating `lodash` wrapper objects.
     *
     * @private
     * @param {*} value The value to wrap.
     * @param {boolean} [chainAll] Enable explicit method chain sequences.
     */
    function LodashWrapper(value, chainAll) {
      this.__wrapped__ = value;
      this.__actions__ = [];
      this.__chain__ = !!chainAll;
      this.__index__ = 0;
      this.__values__ = undefined;
    }

    /**
     * By default, the template delimiters used by lodash are like those in
     * embedded Ruby (ERB) as well as ES2015 template strings. Change the
     * following template settings to use alternative delimiters.
     *
     * @static
     * @memberOf _
     * @type {Object}
     */
    lodash.templateSettings = {

      /**
       * Used to detect `data` property values to be HTML-escaped.
       *
       * @memberOf _.templateSettings
       * @type {RegExp}
       */
      'escape': reEscape,

      /**
       * Used to detect code to be evaluated.
       *
       * @memberOf _.templateSettings
       * @type {RegExp}
       */
      'evaluate': reEvaluate,

      /**
       * Used to detect `data` property values to inject.
       *
       * @memberOf _.templateSettings
       * @type {RegExp}
       */
      'interpolate': reInterpolate,

      /**
       * Used to reference the data object in the template text.
       *
       * @memberOf _.templateSettings
       * @type {string}
       */
      'variable': '',

      /**
       * Used to import variables into the compiled template.
       *
       * @memberOf _.templateSettings
       * @type {Object}
       */
      'imports': {

        /**
         * A reference to the `lodash` function.
         *
         * @memberOf _.templateSettings.imports
         * @type {Function}
         */
        '_': lodash
      }
    };

    // Ensure wrappers are instances of `baseLodash`.
    lodash.prototype = baseLodash.prototype;
    lodash.prototype.constructor = lodash;

    LodashWrapper.prototype = baseCreate(baseLodash.prototype);
    LodashWrapper.prototype.constructor = LodashWrapper;

    /*------------------------------------------------------------------------*/

    /**
     * Creates a lazy wrapper object which wraps `value` to enable lazy evaluation.
     *
     * @private
     * @constructor
     * @param {*} value The value to wrap.
     */
    function LazyWrapper(value) {
      this.__wrapped__ = value;
      this.__actions__ = [];
      this.__dir__ = 1;
      this.__filtered__ = false;
      this.__iteratees__ = [];
      this.__takeCount__ = MAX_ARRAY_LENGTH;
      this.__views__ = [];
    }

    /**
     * Creates a clone of the lazy wrapper object.
     *
     * @private
     * @name clone
     * @memberOf LazyWrapper
     * @returns {Object} Returns the cloned `LazyWrapper` object.
     */
    function lazyClone() {
      var result = new LazyWrapper(this.__wrapped__);
      result.__actions__ = copyArray(this.__actions__);
      result.__dir__ = this.__dir__;
      result.__filtered__ = this.__filtered__;
      result.__iteratees__ = copyArray(this.__iteratees__);
      result.__takeCount__ = this.__takeCount__;
      result.__views__ = copyArray(this.__views__);
      return result;
    }

    /**
     * Reverses the direction of lazy iteration.
     *
     * @private
     * @name reverse
     * @memberOf LazyWrapper
     * @returns {Object} Returns the new reversed `LazyWrapper` object.
     */
    function lazyReverse() {
      if (this.__filtered__) {
        var result = new LazyWrapper(this);
        result.__dir__ = -1;
        result.__filtered__ = true;
      } else {
        result = this.clone();
        result.__dir__ *= -1;
      }
      return result;
    }

    /**
     * Extracts the unwrapped value from its lazy wrapper.
     *
     * @private
     * @name value
     * @memberOf LazyWrapper
     * @returns {*} Returns the unwrapped value.
     */
    function lazyValue() {
      var array = this.__wrapped__.value(),
          dir = this.__dir__,
          isArr = isArray(array),
          isRight = dir < 0,
          arrLength = isArr ? array.length : 0,
          view = getView(0, arrLength, this.__views__),
          start = view.start,
          end = view.end,
          length = end - start,
          index = isRight ? end : (start - 1),
          iteratees = this.__iteratees__,
          iterLength = iteratees.length,
          resIndex = 0,
          takeCount = nativeMin(length, this.__takeCount__);

      if (!isArr || (!isRight && arrLength == length && takeCount == length)) {
        return baseWrapperValue(array, this.__actions__);
      }
      var result = [];

      outer:
      while (length-- && resIndex < takeCount) {
        index += dir;

        var iterIndex = -1,
            value = array[index];

        while (++iterIndex < iterLength) {
          var data = iteratees[iterIndex],
              iteratee = data.iteratee,
              type = data.type,
              computed = iteratee(value);

          if (type == LAZY_MAP_FLAG) {
            value = computed;
          } else if (!computed) {
            if (type == LAZY_FILTER_FLAG) {
              continue outer;
            } else {
              break outer;
            }
          }
        }
        result[resIndex++] = value;
      }
      return result;
    }

    // Ensure `LazyWrapper` is an instance of `baseLodash`.
    LazyWrapper.prototype = baseCreate(baseLodash.prototype);
    LazyWrapper.prototype.constructor = LazyWrapper;

    /*------------------------------------------------------------------------*/

    /**
     * Creates a hash object.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */
    function Hash(entries) {
      var index = -1,
          length = entries == null ? 0 : entries.length;

      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }

    /**
     * Removes all key-value entries from the hash.
     *
     * @private
     * @name clear
     * @memberOf Hash
     */
    function hashClear() {
      this.__data__ = nativeCreate ? nativeCreate(null) : {};
      this.size = 0;
    }

    /**
     * Removes `key` and its value from the hash.
     *
     * @private
     * @name delete
     * @memberOf Hash
     * @param {Object} hash The hash to modify.
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */
    function hashDelete(key) {
      var result = this.has(key) && delete this.__data__[key];
      this.size -= result ? 1 : 0;
      return result;
    }

    /**
     * Gets the hash value for `key`.
     *
     * @private
     * @name get
     * @memberOf Hash
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */
    function hashGet(key) {
      var data = this.__data__;
      if (nativeCreate) {
        var result = data[key];
        return result === HASH_UNDEFINED ? undefined : result;
      }
      return hasOwnProperty.call(data, key) ? data[key] : undefined;
    }

    /**
     * Checks if a hash value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf Hash
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */
    function hashHas(key) {
      var data = this.__data__;
      return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);
    }

    /**
     * Sets the hash `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf Hash
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the hash instance.
     */
    function hashSet(key, value) {
      var data = this.__data__;
      this.size += this.has(key) ? 0 : 1;
      data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
      return this;
    }

    // Add methods to `Hash`.
    Hash.prototype.clear = hashClear;
    Hash.prototype['delete'] = hashDelete;
    Hash.prototype.get = hashGet;
    Hash.prototype.has = hashHas;
    Hash.prototype.set = hashSet;

    /*------------------------------------------------------------------------*/

    /**
     * Creates an list cache object.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */
    function ListCache(entries) {
      var index = -1,
          length = entries == null ? 0 : entries.length;

      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }

    /**
     * Removes all key-value entries from the list cache.
     *
     * @private
     * @name clear
     * @memberOf ListCache
     */
    function listCacheClear() {
      this.__data__ = [];
      this.size = 0;
    }

    /**
     * Removes `key` and its value from the list cache.
     *
     * @private
     * @name delete
     * @memberOf ListCache
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */
    function listCacheDelete(key) {
      var data = this.__data__,
          index = assocIndexOf(data, key);

      if (index < 0) {
        return false;
      }
      var lastIndex = data.length - 1;
      if (index == lastIndex) {
        data.pop();
      } else {
        splice.call(data, index, 1);
      }
      --this.size;
      return true;
    }

    /**
     * Gets the list cache value for `key`.
     *
     * @private
     * @name get
     * @memberOf ListCache
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */
    function listCacheGet(key) {
      var data = this.__data__,
          index = assocIndexOf(data, key);

      return index < 0 ? undefined : data[index][1];
    }

    /**
     * Checks if a list cache value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf ListCache
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */
    function listCacheHas(key) {
      return assocIndexOf(this.__data__, key) > -1;
    }

    /**
     * Sets the list cache `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf ListCache
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the list cache instance.
     */
    function listCacheSet(key, value) {
      var data = this.__data__,
          index = assocIndexOf(data, key);

      if (index < 0) {
        ++this.size;
        data.push([key, value]);
      } else {
        data[index][1] = value;
      }
      return this;
    }

    // Add methods to `ListCache`.
    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype['delete'] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;

    /*------------------------------------------------------------------------*/

    /**
     * Creates a map cache object to store key-value pairs.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */
    function MapCache(entries) {
      var index = -1,
          length = entries == null ? 0 : entries.length;

      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }

    /**
     * Removes all key-value entries from the map.
     *
     * @private
     * @name clear
     * @memberOf MapCache
     */
    function mapCacheClear() {
      this.size = 0;
      this.__data__ = {
        'hash': new Hash,
        'map': new (Map || ListCache),
        'string': new Hash
      };
    }

    /**
     * Removes `key` and its value from the map.
     *
     * @private
     * @name delete
     * @memberOf MapCache
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */
    function mapCacheDelete(key) {
      var result = getMapData(this, key)['delete'](key);
      this.size -= result ? 1 : 0;
      return result;
    }

    /**
     * Gets the map value for `key`.
     *
     * @private
     * @name get
     * @memberOf MapCache
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */
    function mapCacheGet(key) {
      return getMapData(this, key).get(key);
    }

    /**
     * Checks if a map value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf MapCache
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */
    function mapCacheHas(key) {
      return getMapData(this, key).has(key);
    }

    /**
     * Sets the map `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf MapCache
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the map cache instance.
     */
    function mapCacheSet(key, value) {
      var data = getMapData(this, key),
          size = data.size;

      data.set(key, value);
      this.size += data.size == size ? 0 : 1;
      return this;
    }

    // Add methods to `MapCache`.
    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype['delete'] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;

    /*------------------------------------------------------------------------*/

    /**
     *
     * Creates an array cache object to store unique values.
     *
     * @private
     * @constructor
     * @param {Array} [values] The values to cache.
     */
    function SetCache(values) {
      var index = -1,
          length = values == null ? 0 : values.length;

      this.__data__ = new MapCache;
      while (++index < length) {
        this.add(values[index]);
      }
    }

    /**
     * Adds `value` to the array cache.
     *
     * @private
     * @name add
     * @memberOf SetCache
     * @alias push
     * @param {*} value The value to cache.
     * @returns {Object} Returns the cache instance.
     */
    function setCacheAdd(value) {
      this.__data__.set(value, HASH_UNDEFINED);
      return this;
    }

    /**
     * Checks if `value` is in the array cache.
     *
     * @private
     * @name has
     * @memberOf SetCache
     * @param {*} value The value to search for.
     * @returns {number} Returns `true` if `value` is found, else `false`.
     */
    function setCacheHas(value) {
      return this.__data__.has(value);
    }

    // Add methods to `SetCache`.
    SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
    SetCache.prototype.has = setCacheHas;

    /*------------------------------------------------------------------------*/

    /**
     * Creates a stack cache object to store key-value pairs.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */
    function Stack(entries) {
      var data = this.__data__ = new ListCache(entries);
      this.size = data.size;
    }

    /**
     * Removes all key-value entries from the stack.
     *
     * @private
     * @name clear
     * @memberOf Stack
     */
    function stackClear() {
      this.__data__ = new ListCache;
      this.size = 0;
    }

    /**
     * Removes `key` and its value from the stack.
     *
     * @private
     * @name delete
     * @memberOf Stack
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */
    function stackDelete(key) {
      var data = this.__data__,
          result = data['delete'](key);

      this.size = data.size;
      return result;
    }

    /**
     * Gets the stack value for `key`.
     *
     * @private
     * @name get
     * @memberOf Stack
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */
    function stackGet(key) {
      return this.__data__.get(key);
    }

    /**
     * Checks if a stack value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf Stack
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */
    function stackHas(key) {
      return this.__data__.has(key);
    }

    /**
     * Sets the stack `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf Stack
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the stack cache instance.
     */
    function stackSet(key, value) {
      var data = this.__data__;
      if (data instanceof ListCache) {
        var pairs = data.__data__;
        if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
          pairs.push([key, value]);
          this.size = ++data.size;
          return this;
        }
        data = this.__data__ = new MapCache(pairs);
      }
      data.set(key, value);
      this.size = data.size;
      return this;
    }

    // Add methods to `Stack`.
    Stack.prototype.clear = stackClear;
    Stack.prototype['delete'] = stackDelete;
    Stack.prototype.get = stackGet;
    Stack.prototype.has = stackHas;
    Stack.prototype.set = stackSet;

    /*------------------------------------------------------------------------*/

    /**
     * Creates an array of the enumerable property names of the array-like `value`.
     *
     * @private
     * @param {*} value The value to query.
     * @param {boolean} inherited Specify returning inherited property names.
     * @returns {Array} Returns the array of property names.
     */
    function arrayLikeKeys(value, inherited) {
      var isArr = isArray(value),
          isArg = !isArr && isArguments(value),
          isBuff = !isArr && !isArg && isBuffer(value),
          isType = !isArr && !isArg && !isBuff && isTypedArray(value),
          skipIndexes = isArr || isArg || isBuff || isType,
          result = skipIndexes ? baseTimes(value.length, String) : [],
          length = result.length;

      for (var key in value) {
        if ((inherited || hasOwnProperty.call(value, key)) &&
            !(skipIndexes && (
               // Safari 9 has enumerable `arguments.length` in strict mode.
               key == 'length' ||
               // Node.js 0.10 has enumerable non-index properties on buffers.
               (isBuff && (key == 'offset' || key == 'parent')) ||
               // PhantomJS 2 has enumerable non-index properties on typed arrays.
               (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
               // Skip index properties.
               isIndex(key, length)
            ))) {
          result.push(key);
        }
      }
      return result;
    }

    /**
     * A specialized version of `_.sample` for arrays.
     *
     * @private
     * @param {Array} array The array to sample.
     * @returns {*} Returns the random element.
     */
    function arraySample(array) {
      var length = array.length;
      return length ? array[baseRandom(0, length - 1)] : undefined;
    }

    /**
     * A specialized version of `_.sampleSize` for arrays.
     *
     * @private
     * @param {Array} array The array to sample.
     * @param {number} n The number of elements to sample.
     * @returns {Array} Returns the random elements.
     */
    function arraySampleSize(array, n) {
      return shuffleSelf(copyArray(array), baseClamp(n, 0, array.length));
    }

    /**
     * A specialized version of `_.shuffle` for arrays.
     *
     * @private
     * @param {Array} array The array to shuffle.
     * @returns {Array} Returns the new shuffled array.
     */
    function arrayShuffle(array) {
      return shuffleSelf(copyArray(array));
    }

    /**
     * This function is like `assignValue` except that it doesn't assign
     * `undefined` values.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {string} key The key of the property to assign.
     * @param {*} value The value to assign.
     */
    function assignMergeValue(object, key, value) {
      if ((value !== undefined && !eq(object[key], value)) ||
          (value === undefined && !(key in object))) {
        baseAssignValue(object, key, value);
      }
    }

    /**
     * Assigns `value` to `key` of `object` if the existing value is not equivalent
     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {string} key The key of the property to assign.
     * @param {*} value The value to assign.
     */
    function assignValue(object, key, value) {
      var objValue = object[key];
      if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||
          (value === undefined && !(key in object))) {
        baseAssignValue(object, key, value);
      }
    }

    /**
     * Gets the index at which the `key` is found in `array` of key-value pairs.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {*} key The key to search for.
     * @returns {number} Returns the index of the matched value, else `-1`.
     */
    function assocIndexOf(array, key) {
      var length = array.length;
      while (length--) {
        if (eq(array[length][0], key)) {
          return length;
        }
      }
      return -1;
    }

    /**
     * Aggregates elements of `collection` on `accumulator` with keys transformed
     * by `iteratee` and values set by `setter`.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} setter The function to set `accumulator` values.
     * @param {Function} iteratee The iteratee to transform keys.
     * @param {Object} accumulator The initial aggregated object.
     * @returns {Function} Returns `accumulator`.
     */
    function baseAggregator(collection, setter, iteratee, accumulator) {
      baseEach(collection, function(value, key, collection) {
        setter(accumulator, value, iteratee(value), collection);
      });
      return accumulator;
    }

    /**
     * The base implementation of `_.assign` without support for multiple sources
     * or `customizer` functions.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @returns {Object} Returns `object`.
     */
    function baseAssign(object, source) {
      return object && copyObject(source, keys(source), object);
    }

    /**
     * The base implementation of `_.assignIn` without support for multiple sources
     * or `customizer` functions.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @returns {Object} Returns `object`.
     */
    function baseAssignIn(object, source) {
      return object && copyObject(source, keysIn(source), object);
    }

    /**
     * The base implementation of `assignValue` and `assignMergeValue` without
     * value checks.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {string} key The key of the property to assign.
     * @param {*} value The value to assign.
     */
    function baseAssignValue(object, key, value) {
      if (key == '__proto__' && defineProperty) {
        defineProperty(object, key, {
          'configurable': true,
          'enumerable': true,
          'value': value,
          'writable': true
        });
      } else {
        object[key] = value;
      }
    }

    /**
     * The base implementation of `_.at` without support for individual paths.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {string[]} paths The property paths to pick.
     * @returns {Array} Returns the picked elements.
     */
    function baseAt(object, paths) {
      var index = -1,
          length = paths.length,
          result = Array(length),
          skip = object == null;

      while (++index < length) {
        result[index] = skip ? undefined : get(object, paths[index]);
      }
      return result;
    }

    /**
     * The base implementation of `_.clamp` which doesn't coerce arguments.
     *
     * @private
     * @param {number} number The number to clamp.
     * @param {number} [lower] The lower bound.
     * @param {number} upper The upper bound.
     * @returns {number} Returns the clamped number.
     */
    function baseClamp(number, lower, upper) {
      if (number === number) {
        if (upper !== undefined) {
          number = number <= upper ? number : upper;
        }
        if (lower !== undefined) {
          number = number >= lower ? number : lower;
        }
      }
      return number;
    }

    /**
     * The base implementation of `_.clone` and `_.cloneDeep` which tracks
     * traversed objects.
     *
     * @private
     * @param {*} value The value to clone.
     * @param {boolean} bitmask The bitmask flags.
     *  1 - Deep clone
     *  2 - Flatten inherited properties
     *  4 - Clone symbols
     * @param {Function} [customizer] The function to customize cloning.
     * @param {string} [key] The key of `value`.
     * @param {Object} [object] The parent object of `value`.
     * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
     * @returns {*} Returns the cloned value.
     */
    function baseClone(value, bitmask, customizer, key, object, stack) {
      var result,
          isDeep = bitmask & CLONE_DEEP_FLAG,
          isFlat = bitmask & CLONE_FLAT_FLAG,
          isFull = bitmask & CLONE_SYMBOLS_FLAG;

      if (customizer) {
        result = object ? customizer(value, key, object, stack) : customizer(value);
      }
      if (result !== undefined) {
        return result;
      }
      if (!isObject(value)) {
        return value;
      }
      var isArr = isArray(value);
      if (isArr) {
        result = initCloneArray(value);
        if (!isDeep) {
          return copyArray(value, result);
        }
      } else {
        var tag = getTag(value),
            isFunc = tag == funcTag || tag == genTag;

        if (isBuffer(value)) {
          return cloneBuffer(value, isDeep);
        }
        if (tag == objectTag || tag == argsTag || (isFunc && !object)) {
          result = (isFlat || isFunc) ? {} : initCloneObject(value);
          if (!isDeep) {
            return isFlat
              ? copySymbolsIn(value, baseAssignIn(result, value))
              : copySymbols(value, baseAssign(result, value));
          }
        } else {
          if (!cloneableTags[tag]) {
            return object ? value : {};
          }
          result = initCloneByTag(value, tag, isDeep);
        }
      }
      // Check for circular references and return its corresponding clone.
      stack || (stack = new Stack);
      var stacked = stack.get(value);
      if (stacked) {
        return stacked;
      }
      stack.set(value, result);

      if (isSet(value)) {
        value.forEach(function(subValue) {
          result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
        });
      } else if (isMap(value)) {
        value.forEach(function(subValue, key) {
          result.set(key, baseClone(subValue, bitmask, customizer, key, value, stack));
        });
      }

      var keysFunc = isFull
        ? (isFlat ? getAllKeysIn : getAllKeys)
        : (isFlat ? keysIn : keys);

      var props = isArr ? undefined : keysFunc(value);
      arrayEach(props || value, function(subValue, key) {
        if (props) {
          key = subValue;
          subValue = value[key];
        }
        // Recursively populate clone (susceptible to call stack limits).
        assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));
      });
      return result;
    }

    /**
     * The base implementation of `_.conforms` which doesn't clone `source`.
     *
     * @private
     * @param {Object} source The object of property predicates to conform to.
     * @returns {Function} Returns the new spec function.
     */
    function baseConforms(source) {
      var props = keys(source);
      return function(object) {
        return baseConformsTo(object, source, props);
      };
    }

    /**
     * The base implementation of `_.conformsTo` which accepts `props` to check.
     *
     * @private
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property predicates to conform to.
     * @returns {boolean} Returns `true` if `object` conforms, else `false`.
     */
    function baseConformsTo(object, source, props) {
      var length = props.length;
      if (object == null) {
        return !length;
      }
      object = Object(object);
      while (length--) {
        var key = props[length],
            predicate = source[key],
            value = object[key];

        if ((value === undefined && !(key in object)) || !predicate(value)) {
          return false;
        }
      }
      return true;
    }

    /**
     * The base implementation of `_.delay` and `_.defer` which accepts `args`
     * to provide to `func`.
     *
     * @private
     * @param {Function} func The function to delay.
     * @param {number} wait The number of milliseconds to delay invocation.
     * @param {Array} args The arguments to provide to `func`.
     * @returns {number|Object} Returns the timer id or timeout object.
     */
    function baseDelay(func, wait, args) {
      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      return setTimeout(function() { func.apply(undefined, args); }, wait);
    }

    /**
     * The base implementation of methods like `_.difference` without support
     * for excluding multiple arrays or iteratee shorthands.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {Array} values The values to exclude.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of filtered values.
     */
    function baseDifference(array, values, iteratee, comparator) {
      var index = -1,
          includes = arrayIncludes,
          isCommon = true,
          length = array.length,
          result = [],
          valuesLength = values.length;

      if (!length) {
        return result;
      }
      if (iteratee) {
        values = arrayMap(values, baseUnary(iteratee));
      }
      if (comparator) {
        includes = arrayIncludesWith;
        isCommon = false;
      }
      else if (values.length >= LARGE_ARRAY_SIZE) {
        includes = cacheHas;
        isCommon = false;
        values = new SetCache(values);
      }
      outer:
      while (++index < length) {
        var value = array[index],
            computed = iteratee == null ? value : iteratee(value);

        value = (comparator || value !== 0) ? value : 0;
        if (isCommon && computed === computed) {
          var valuesIndex = valuesLength;
          while (valuesIndex--) {
            if (values[valuesIndex] === computed) {
              continue outer;
            }
          }
          result.push(value);
        }
        else if (!includes(values, computed, comparator)) {
          result.push(value);
        }
      }
      return result;
    }

    /**
     * The base implementation of `_.forEach` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array|Object} Returns `collection`.
     */
    var baseEach = createBaseEach(baseForOwn);

    /**
     * The base implementation of `_.forEachRight` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array|Object} Returns `collection`.
     */
    var baseEachRight = createBaseEach(baseForOwnRight, true);

    /**
     * The base implementation of `_.every` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {boolean} Returns `true` if all elements pass the predicate check,
     *  else `false`
     */
    function baseEvery(collection, predicate) {
      var result = true;
      baseEach(collection, function(value, index, collection) {
        result = !!predicate(value, index, collection);
        return result;
      });
      return result;
    }

    /**
     * The base implementation of methods like `_.max` and `_.min` which accepts a
     * `comparator` to determine the extremum value.
     *
     * @private
     * @param {Array} array The array to iterate over.
     * @param {Function} iteratee The iteratee invoked per iteration.
     * @param {Function} comparator The comparator used to compare values.
     * @returns {*} Returns the extremum value.
     */
    function baseExtremum(array, iteratee, comparator) {
      var index = -1,
          length = array.length;

      while (++index < length) {
        var value = array[index],
            current = iteratee(value);

        if (current != null && (computed === undefined
              ? (current === current && !isSymbol(current))
              : comparator(current, computed)
            )) {
          var computed = current,
              result = value;
        }
      }
      return result;
    }

    /**
     * The base implementation of `_.fill` without an iteratee call guard.
     *
     * @private
     * @param {Array} array The array to fill.
     * @param {*} value The value to fill `array` with.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns `array`.
     */
    function baseFill(array, value, start, end) {
      var length = array.length;

      start = toInteger(start);
      if (start < 0) {
        start = -start > length ? 0 : (length + start);
      }
      end = (end === undefined || end > length) ? length : toInteger(end);
      if (end < 0) {
        end += length;
      }
      end = start > end ? 0 : toLength(end);
      while (start < end) {
        array[start++] = value;
      }
      return array;
    }

    /**
     * The base implementation of `_.filter` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {Array} Returns the new filtered array.
     */
    function baseFilter(collection, predicate) {
      var result = [];
      baseEach(collection, function(value, index, collection) {
        if (predicate(value, index, collection)) {
          result.push(value);
        }
      });
      return result;
    }

    /**
     * The base implementation of `_.flatten` with support for restricting flattening.
     *
     * @private
     * @param {Array} array The array to flatten.
     * @param {number} depth The maximum recursion depth.
     * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
     * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
     * @param {Array} [result=[]] The initial result value.
     * @returns {Array} Returns the new flattened array.
     */
    function baseFlatten(array, depth, predicate, isStrict, result) {
      var index = -1,
          length = array.length;

      predicate || (predicate = isFlattenable);
      result || (result = []);

      while (++index < length) {
        var value = array[index];
        if (depth > 0 && predicate(value)) {
          if (depth > 1) {
            // Recursively flatten arrays (susceptible to call stack limits).
            baseFlatten(value, depth - 1, predicate, isStrict, result);
          } else {
            arrayPush(result, value);
          }
        } else if (!isStrict) {
          result[result.length] = value;
        }
      }
      return result;
    }

    /**
     * The base implementation of `baseForOwn` which iterates over `object`
     * properties returned by `keysFunc` and invokes `iteratee` for each property.
     * Iteratee functions may exit iteration early by explicitly returning `false`.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {Function} keysFunc The function to get the keys of `object`.
     * @returns {Object} Returns `object`.
     */
    var baseFor = createBaseFor();

    /**
     * This function is like `baseFor` except that it iterates over properties
     * in the opposite order.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {Function} keysFunc The function to get the keys of `object`.
     * @returns {Object} Returns `object`.
     */
    var baseForRight = createBaseFor(true);

    /**
     * The base implementation of `_.forOwn` without support for iteratee shorthands.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Object} Returns `object`.
     */
    function baseForOwn(object, iteratee) {
      return object && baseFor(object, iteratee, keys);
    }

    /**
     * The base implementation of `_.forOwnRight` without support for iteratee shorthands.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Object} Returns `object`.
     */
    function baseForOwnRight(object, iteratee) {
      return object && baseForRight(object, iteratee, keys);
    }

    /**
     * The base implementation of `_.functions` which creates an array of
     * `object` function property names filtered from `props`.
     *
     * @private
     * @param {Object} object The object to inspect.
     * @param {Array} props The property names to filter.
     * @returns {Array} Returns the function names.
     */
    function baseFunctions(object, props) {
      return arrayFilter(props, function(key) {
        return isFunction(object[key]);
      });
    }

    /**
     * The base implementation of `_.get` without support for default values.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the property to get.
     * @returns {*} Returns the resolved value.
     */
    function baseGet(object, path) {
      path = castPath(path, object);

      var index = 0,
          length = path.length;

      while (object != null && index < length) {
        object = object[toKey(path[index++])];
      }
      return (index && index == length) ? object : undefined;
    }

    /**
     * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
     * `keysFunc` and `symbolsFunc` to get the enumerable property names and
     * symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Function} keysFunc The function to get the keys of `object`.
     * @param {Function} symbolsFunc The function to get the symbols of `object`.
     * @returns {Array} Returns the array of property names and symbols.
     */
    function baseGetAllKeys(object, keysFunc, symbolsFunc) {
      var result = keysFunc(object);
      return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
    }

    /**
     * The base implementation of `getTag` without fallbacks for buggy environments.
     *
     * @private
     * @param {*} value The value to query.
     * @returns {string} Returns the `toStringTag`.
     */
    function baseGetTag(value) {
      if (value == null) {
        return value === undefined ? undefinedTag : nullTag;
      }
      return (symToStringTag && symToStringTag in Object(value))
        ? getRawTag(value)
        : objectToString(value);
    }

    /**
     * The base implementation of `_.gt` which doesn't coerce arguments.
     *
     * @private
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is greater than `other`,
     *  else `false`.
     */
    function baseGt(value, other) {
      return value > other;
    }

    /**
     * The base implementation of `_.has` without support for deep paths.
     *
     * @private
     * @param {Object} [object] The object to query.
     * @param {Array|string} key The key to check.
     * @returns {boolean} Returns `true` if `key` exists, else `false`.
     */
    function baseHas(object, key) {
      return object != null && hasOwnProperty.call(object, key);
    }

    /**
     * The base implementation of `_.hasIn` without support for deep paths.
     *
     * @private
     * @param {Object} [object] The object to query.
     * @param {Array|string} key The key to check.
     * @returns {boolean} Returns `true` if `key` exists, else `false`.
     */
    function baseHasIn(object, key) {
      return object != null && key in Object(object);
    }

    /**
     * The base implementation of `_.inRange` which doesn't coerce arguments.
     *
     * @private
     * @param {number} number The number to check.
     * @param {number} start The start of the range.
     * @param {number} end The end of the range.
     * @returns {boolean} Returns `true` if `number` is in the range, else `false`.
     */
    function baseInRange(number, start, end) {
      return number >= nativeMin(start, end) && number < nativeMax(start, end);
    }

    /**
     * The base implementation of methods like `_.intersection`, without support
     * for iteratee shorthands, that accepts an array of arrays to inspect.
     *
     * @private
     * @param {Array} arrays The arrays to inspect.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of shared values.
     */
    function baseIntersection(arrays, iteratee, comparator) {
      var includes = comparator ? arrayIncludesWith : arrayIncludes,
          length = arrays[0].length,
          othLength = arrays.length,
          othIndex = othLength,
          caches = Array(othLength),
          maxLength = Infinity,
          result = [];

      while (othIndex--) {
        var array = arrays[othIndex];
        if (othIndex && iteratee) {
          array = arrayMap(array, baseUnary(iteratee));
        }
        maxLength = nativeMin(array.length, maxLength);
        caches[othIndex] = !comparator && (iteratee || (length >= 120 && array.length >= 120))
          ? new SetCache(othIndex && array)
          : undefined;
      }
      array = arrays[0];

      var index = -1,
          seen = caches[0];

      outer:
      while (++index < length && result.length < maxLength) {
        var value = array[index],
            computed = iteratee ? iteratee(value) : value;

        value = (comparator || value !== 0) ? value : 0;
        if (!(seen
              ? cacheHas(seen, computed)
              : includes(result, computed, comparator)
            )) {
          othIndex = othLength;
          while (--othIndex) {
            var cache = caches[othIndex];
            if (!(cache
                  ? cacheHas(cache, computed)
                  : includes(arrays[othIndex], computed, comparator))
                ) {
              continue outer;
            }
          }
          if (seen) {
            seen.push(computed);
          }
          result.push(value);
        }
      }
      return result;
    }

    /**
     * The base implementation of `_.invert` and `_.invertBy` which inverts
     * `object` with values transformed by `iteratee` and set by `setter`.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} setter The function to set `accumulator` values.
     * @param {Function} iteratee The iteratee to transform values.
     * @param {Object} accumulator The initial inverted object.
     * @returns {Function} Returns `accumulator`.
     */
    function baseInverter(object, setter, iteratee, accumulator) {
      baseForOwn(object, function(value, key, object) {
        setter(accumulator, iteratee(value), key, object);
      });
      return accumulator;
    }

    /**
     * The base implementation of `_.invoke` without support for individual
     * method arguments.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the method to invoke.
     * @param {Array} args The arguments to invoke the method with.
     * @returns {*} Returns the result of the invoked method.
     */
    function baseInvoke(object, path, args) {
      path = castPath(path, object);
      object = parent(object, path);
      var func = object == null ? object : object[toKey(last(path))];
      return func == null ? undefined : apply(func, object, args);
    }

    /**
     * The base implementation of `_.isArguments`.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an `arguments` object,
     */
    function baseIsArguments(value) {
      return isObjectLike(value) && baseGetTag(value) == argsTag;
    }

    /**
     * The base implementation of `_.isArrayBuffer` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array buffer, else `false`.
     */
    function baseIsArrayBuffer(value) {
      return isObjectLike(value) && baseGetTag(value) == arrayBufferTag;
    }

    /**
     * The base implementation of `_.isDate` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a date object, else `false`.
     */
    function baseIsDate(value) {
      return isObjectLike(value) && baseGetTag(value) == dateTag;
    }

    /**
     * The base implementation of `_.isEqual` which supports partial comparisons
     * and tracks traversed objects.
     *
     * @private
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @param {boolean} bitmask The bitmask flags.
     *  1 - Unordered comparison
     *  2 - Partial comparison
     * @param {Function} [customizer] The function to customize comparisons.
     * @param {Object} [stack] Tracks traversed `value` and `other` objects.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     */
    function baseIsEqual(value, other, bitmask, customizer, stack) {
      if (value === other) {
        return true;
      }
      if (value == null || other == null || (!isObjectLike(value) && !isObjectLike(other))) {
        return value !== value && other !== other;
      }
      return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
    }

    /**
     * A specialized version of `baseIsEqual` for arrays and objects which performs
     * deep comparisons and tracks traversed objects enabling objects with circular
     * references to be compared.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
     * @param {Function} customizer The function to customize comparisons.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Object} [stack] Tracks traversed `object` and `other` objects.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */
    function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
      var objIsArr = isArray(object),
          othIsArr = isArray(other),
          objTag = objIsArr ? arrayTag : getTag(object),
          othTag = othIsArr ? arrayTag : getTag(other);

      objTag = objTag == argsTag ? objectTag : objTag;
      othTag = othTag == argsTag ? objectTag : othTag;

      var objIsObj = objTag == objectTag,
          othIsObj = othTag == objectTag,
          isSameTag = objTag == othTag;

      if (isSameTag && isBuffer(object)) {
        if (!isBuffer(other)) {
          return false;
        }
        objIsArr = true;
        objIsObj = false;
      }
      if (isSameTag && !objIsObj) {
        stack || (stack = new Stack);
        return (objIsArr || isTypedArray(object))
          ? equalArrays(object, other, bitmask, customizer, equalFunc, stack)
          : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
      }
      if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
        var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
            othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

        if (objIsWrapped || othIsWrapped) {
          var objUnwrapped = objIsWrapped ? object.value() : object,
              othUnwrapped = othIsWrapped ? other.value() : other;

          stack || (stack = new Stack);
          return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
        }
      }
      if (!isSameTag) {
        return false;
      }
      stack || (stack = new Stack);
      return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
    }

    /**
     * The base implementation of `_.isMap` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a map, else `false`.
     */
    function baseIsMap(value) {
      return isObjectLike(value) && getTag(value) == mapTag;
    }

    /**
     * The base implementation of `_.isMatch` without support for iteratee shorthands.
     *
     * @private
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property values to match.
     * @param {Array} matchData The property names, values, and compare flags to match.
     * @param {Function} [customizer] The function to customize comparisons.
     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
     */
    function baseIsMatch(object, source, matchData, customizer) {
      var index = matchData.length,
          length = index,
          noCustomizer = !customizer;

      if (object == null) {
        return !length;
      }
      object = Object(object);
      while (index--) {
        var data = matchData[index];
        if ((noCustomizer && data[2])
              ? data[1] !== object[data[0]]
              : !(data[0] in object)
            ) {
          return false;
        }
      }
      while (++index < length) {
        data = matchData[index];
        var key = data[0],
            objValue = object[key],
            srcValue = data[1];

        if (noCustomizer && data[2]) {
          if (objValue === undefined && !(key in object)) {
            return false;
          }
        } else {
          var stack = new Stack;
          if (customizer) {
            var result = customizer(objValue, srcValue, key, object, source, stack);
          }
          if (!(result === undefined
                ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack)
                : result
              )) {
            return false;
          }
        }
      }
      return true;
    }

    /**
     * The base implementation of `_.isNative` without bad shim checks.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a native function,
     *  else `false`.
     */
    function baseIsNative(value) {
      if (!isObject(value) || isMasked(value)) {
        return false;
      }
      var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
      return pattern.test(toSource(value));
    }

    /**
     * The base implementation of `_.isRegExp` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.
     */
    function baseIsRegExp(value) {
      return isObjectLike(value) && baseGetTag(value) == regexpTag;
    }

    /**
     * The base implementation of `_.isSet` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a set, else `false`.
     */
    function baseIsSet(value) {
      return isObjectLike(value) && getTag(value) == setTag;
    }

    /**
     * The base implementation of `_.isTypedArray` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
     */
    function baseIsTypedArray(value) {
      return isObjectLike(value) &&
        isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
    }

    /**
     * The base implementation of `_.iteratee`.
     *
     * @private
     * @param {*} [value=_.identity] The value to convert to an iteratee.
     * @returns {Function} Returns the iteratee.
     */
    function baseIteratee(value) {
      // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
      // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
      if (typeof value == 'function') {
        return value;
      }
      if (value == null) {
        return identity;
      }
      if (typeof value == 'object') {
        return isArray(value)
          ? baseMatchesProperty(value[0], value[1])
          : baseMatches(value);
      }
      return property(value);
    }

    /**
     * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     */
    function baseKeys(object) {
      if (!isPrototype(object)) {
        return nativeKeys(object);
      }
      var result = [];
      for (var key in Object(object)) {
        if (hasOwnProperty.call(object, key) && key != 'constructor') {
          result.push(key);
        }
      }
      return result;
    }

    /**
     * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     */
    function baseKeysIn(object) {
      if (!isObject(object)) {
        return nativeKeysIn(object);
      }
      var isProto = isPrototype(object),
          result = [];

      for (var key in object) {
        if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
          result.push(key);
        }
      }
      return result;
    }

    /**
     * The base implementation of `_.lt` which doesn't coerce arguments.
     *
     * @private
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is less than `other`,
     *  else `false`.
     */
    function baseLt(value, other) {
      return value < other;
    }

    /**
     * The base implementation of `_.map` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array} Returns the new mapped array.
     */
    function baseMap(collection, iteratee) {
      var index = -1,
          result = isArrayLike(collection) ? Array(collection.length) : [];

      baseEach(collection, function(value, key, collection) {
        result[++index] = iteratee(value, key, collection);
      });
      return result;
    }

    /**
     * The base implementation of `_.matches` which doesn't clone `source`.
     *
     * @private
     * @param {Object} source The object of property values to match.
     * @returns {Function} Returns the new spec function.
     */
    function baseMatches(source) {
      var matchData = getMatchData(source);
      if (matchData.length == 1 && matchData[0][2]) {
        return matchesStrictComparable(matchData[0][0], matchData[0][1]);
      }
      return function(object) {
        return object === source || baseIsMatch(object, source, matchData);
      };
    }

    /**
     * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
     *
     * @private
     * @param {string} path The path of the property to get.
     * @param {*} srcValue The value to match.
     * @returns {Function} Returns the new spec function.
     */
    function baseMatchesProperty(path, srcValue) {
      if (isKey(path) && isStrictComparable(srcValue)) {
        return matchesStrictComparable(toKey(path), srcValue);
      }
      return function(object) {
        var objValue = get(object, path);
        return (objValue === undefined && objValue === srcValue)
          ? hasIn(object, path)
          : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
      };
    }

    /**
     * The base implementation of `_.merge` without support for multiple sources.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @param {number} srcIndex The index of `source`.
     * @param {Function} [customizer] The function to customize merged values.
     * @param {Object} [stack] Tracks traversed source values and their merged
     *  counterparts.
     */
    function baseMerge(object, source, srcIndex, customizer, stack) {
      if (object === source) {
        return;
      }
      baseFor(source, function(srcValue, key) {
        stack || (stack = new Stack);
        if (isObject(srcValue)) {
          baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
        }
        else {
          var newValue = customizer
            ? customizer(safeGet(object, key), srcValue, (key + ''), object, source, stack)
            : undefined;

          if (newValue === undefined) {
            newValue = srcValue;
          }
          assignMergeValue(object, key, newValue);
        }
      }, keysIn);
    }

    /**
     * A specialized version of `baseMerge` for arrays and objects which performs
     * deep merges and tracks traversed objects enabling objects with circular
     * references to be merged.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @param {string} key The key of the value to merge.
     * @param {number} srcIndex The index of `source`.
     * @param {Function} mergeFunc The function to merge values.
     * @param {Function} [customizer] The function to customize assigned values.
     * @param {Object} [stack] Tracks traversed source values and their merged
     *  counterparts.
     */
    function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
      var objValue = safeGet(object, key),
          srcValue = safeGet(source, key),
          stacked = stack.get(srcValue);

      if (stacked) {
        assignMergeValue(object, key, stacked);
        return;
      }
      var newValue = customizer
        ? customizer(objValue, srcValue, (key + ''), object, source, stack)
        : undefined;

      var isCommon = newValue === undefined;

      if (isCommon) {
        var isArr = isArray(srcValue),
            isBuff = !isArr && isBuffer(srcValue),
            isTyped = !isArr && !isBuff && isTypedArray(srcValue);

        newValue = srcValue;
        if (isArr || isBuff || isTyped) {
          if (isArray(objValue)) {
            newValue = objValue;
          }
          else if (isArrayLikeObject(objValue)) {
            newValue = copyArray(objValue);
          }
          else if (isBuff) {
            isCommon = false;
            newValue = cloneBuffer(srcValue, true);
          }
          else if (isTyped) {
            isCommon = false;
            newValue = cloneTypedArray(srcValue, true);
          }
          else {
            newValue = [];
          }
        }
        else if (isPlainObject(srcValue) || isArguments(srcValue)) {
          newValue = objValue;
          if (isArguments(objValue)) {
            newValue = toPlainObject(objValue);
          }
          else if (!isObject(objValue) || isFunction(objValue)) {
            newValue = initCloneObject(srcValue);
          }
        }
        else {
          isCommon = false;
        }
      }
      if (isCommon) {
        // Recursively merge objects and arrays (susceptible to call stack limits).
        stack.set(srcValue, newValue);
        mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
        stack['delete'](srcValue);
      }
      assignMergeValue(object, key, newValue);
    }

    /**
     * The base implementation of `_.nth` which doesn't coerce arguments.
     *
     * @private
     * @param {Array} array The array to query.
     * @param {number} n The index of the element to return.
     * @returns {*} Returns the nth element of `array`.
     */
    function baseNth(array, n) {
      var length = array.length;
      if (!length) {
        return;
      }
      n += n < 0 ? length : 0;
      return isIndex(n, length) ? array[n] : undefined;
    }

    /**
     * The base implementation of `_.orderBy` without param guards.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.
     * @param {string[]} orders The sort orders of `iteratees`.
     * @returns {Array} Returns the new sorted array.
     */
    function baseOrderBy(collection, iteratees, orders) {
      if (iteratees.length) {
        iteratees = arrayMap(iteratees, function(iteratee) {
          if (isArray(iteratee)) {
            return function(value) {
              return baseGet(value, iteratee.length === 1 ? iteratee[0] : iteratee);
            }
          }
          return iteratee;
        });
      } else {
        iteratees = [identity];
      }

      var index = -1;
      iteratees = arrayMap(iteratees, baseUnary(getIteratee()));

      var result = baseMap(collection, function(value, key, collection) {
        var criteria = arrayMap(iteratees, function(iteratee) {
          return iteratee(value);
        });
        return { 'criteria': criteria, 'index': ++index, 'value': value };
      });

      return baseSortBy(result, function(object, other) {
        return compareMultiple(object, other, orders);
      });
    }

    /**
     * The base implementation of `_.pick` without support for individual
     * property identifiers.
     *
     * @private
     * @param {Object} object The source object.
     * @param {string[]} paths The property paths to pick.
     * @returns {Object} Returns the new object.
     */
    function basePick(object, paths) {
      return basePickBy(object, paths, function(value, path) {
        return hasIn(object, path);
      });
    }

    /**
     * The base implementation of  `_.pickBy` without support for iteratee shorthands.
     *
     * @private
     * @param {Object} object The source object.
     * @param {string[]} paths The property paths to pick.
     * @param {Function} predicate The function invoked per property.
     * @returns {Object} Returns the new object.
     */
    function basePickBy(object, paths, predicate) {
      var index = -1,
          length = paths.length,
          result = {};

      while (++index < length) {
        var path = paths[index],
            value = baseGet(object, path);

        if (predicate(value, path)) {
          baseSet(result, castPath(path, object), value);
        }
      }
      return result;
    }

    /**
     * A specialized version of `baseProperty` which supports deep paths.
     *
     * @private
     * @param {Array|string} path The path of the property to get.
     * @returns {Function} Returns the new accessor function.
     */
    function basePropertyDeep(path) {
      return function(object) {
        return baseGet(object, path);
      };
    }

    /**
     * The base implementation of `_.pullAllBy` without support for iteratee
     * shorthands.
     *
     * @private
     * @param {Array} array The array to modify.
     * @param {Array} values The values to remove.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns `array`.
     */
    function basePullAll(array, values, iteratee, comparator) {
      var indexOf = comparator ? baseIndexOfWith : baseIndexOf,
          index = -1,
          length = values.length,
          seen = array;

      if (array === values) {
        values = copyArray(values);
      }
      if (iteratee) {
        seen = arrayMap(array, baseUnary(iteratee));
      }
      while (++index < length) {
        var fromIndex = 0,
            value = values[index],
            computed = iteratee ? iteratee(value) : value;

        while ((fromIndex = indexOf(seen, computed, fromIndex, comparator)) > -1) {
          if (seen !== array) {
            splice.call(seen, fromIndex, 1);
          }
          splice.call(array, fromIndex, 1);
        }
      }
      return array;
    }

    /**
     * The base implementation of `_.pullAt` without support for individual
     * indexes or capturing the removed elements.
     *
     * @private
     * @param {Array} array The array to modify.
     * @param {number[]} indexes The indexes of elements to remove.
     * @returns {Array} Returns `array`.
     */
    function basePullAt(array, indexes) {
      var length = array ? indexes.length : 0,
          lastIndex = length - 1;

      while (length--) {
        var index = indexes[length];
        if (length == lastIndex || index !== previous) {
          var previous = index;
          if (isIndex(index)) {
            splice.call(array, index, 1);
          } else {
            baseUnset(array, index);
          }
        }
      }
      return array;
    }

    /**
     * The base implementation of `_.random` without support for returning
     * floating-point numbers.
     *
     * @private
     * @param {number} lower The lower bound.
     * @param {number} upper The upper bound.
     * @returns {number} Returns the random number.
     */
    function baseRandom(lower, upper) {
      return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
    }

    /**
     * The base implementation of `_.range` and `_.rangeRight` which doesn't
     * coerce arguments.
     *
     * @private
     * @param {number} start The start of the range.
     * @param {number} end The end of the range.
     * @param {number} step The value to increment or decrement by.
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Array} Returns the range of numbers.
     */
    function baseRange(start, end, step, fromRight) {
      var index = -1,
          length = nativeMax(nativeCeil((end - start) / (step || 1)), 0),
          result = Array(length);

      while (length--) {
        result[fromRight ? length : ++index] = start;
        start += step;
      }
      return result;
    }

    /**
     * The base implementation of `_.repeat` which doesn't coerce arguments.
     *
     * @private
     * @param {string} string The string to repeat.
     * @param {number} n The number of times to repeat the string.
     * @returns {string} Returns the repeated string.
     */
    function baseRepeat(string, n) {
      var result = '';
      if (!string || n < 1 || n > MAX_SAFE_INTEGER) {
        return result;
      }
      // Leverage the exponentiation by squaring algorithm for a faster repeat.
      // See https://en.wikipedia.org/wiki/Exponentiation_by_squaring for more details.
      do {
        if (n % 2) {
          result += string;
        }
        n = nativeFloor(n / 2);
        if (n) {
          string += string;
        }
      } while (n);

      return result;
    }

    /**
     * The base implementation of `_.rest` which doesn't validate or coerce arguments.
     *
     * @private
     * @param {Function} func The function to apply a rest parameter to.
     * @param {number} [start=func.length-1] The start position of the rest parameter.
     * @returns {Function} Returns the new function.
     */
    function baseRest(func, start) {
      return setToString(overRest(func, start, identity), func + '');
    }

    /**
     * The base implementation of `_.sample`.
     *
     * @private
     * @param {Array|Object} collection The collection to sample.
     * @returns {*} Returns the random element.
     */
    function baseSample(collection) {
      return arraySample(values(collection));
    }

    /**
     * The base implementation of `_.sampleSize` without param guards.
     *
     * @private
     * @param {Array|Object} collection The collection to sample.
     * @param {number} n The number of elements to sample.
     * @returns {Array} Returns the random elements.
     */
    function baseSampleSize(collection, n) {
      var array = values(collection);
      return shuffleSelf(array, baseClamp(n, 0, array.length));
    }

    /**
     * The base implementation of `_.set`.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to set.
     * @param {*} value The value to set.
     * @param {Function} [customizer] The function to customize path creation.
     * @returns {Object} Returns `object`.
     */
    function baseSet(object, path, value, customizer) {
      if (!isObject(object)) {
        return object;
      }
      path = castPath(path, object);

      var index = -1,
          length = path.length,
          lastIndex = length - 1,
          nested = object;

      while (nested != null && ++index < length) {
        var key = toKey(path[index]),
            newValue = value;

        if (key === '__proto__' || key === 'constructor' || key === 'prototype') {
          return object;
        }

        if (index != lastIndex) {
          var objValue = nested[key];
          newValue = customizer ? customizer(objValue, key, nested) : undefined;
          if (newValue === undefined) {
            newValue = isObject(objValue)
              ? objValue
              : (isIndex(path[index + 1]) ? [] : {});
          }
        }
        assignValue(nested, key, newValue);
        nested = nested[key];
      }
      return object;
    }

    /**
     * The base implementation of `setData` without support for hot loop shorting.
     *
     * @private
     * @param {Function} func The function to associate metadata with.
     * @param {*} data The metadata.
     * @returns {Function} Returns `func`.
     */
    var baseSetData = !metaMap ? identity : function(func, data) {
      metaMap.set(func, data);
      return func;
    };

    /**
     * The base implementation of `setToString` without support for hot loop shorting.
     *
     * @private
     * @param {Function} func The function to modify.
     * @param {Function} string The `toString` result.
     * @returns {Function} Returns `func`.
     */
    var baseSetToString = !defineProperty ? identity : function(func, string) {
      return defineProperty(func, 'toString', {
        'configurable': true,
        'enumerable': false,
        'value': constant(string),
        'writable': true
      });
    };

    /**
     * The base implementation of `_.shuffle`.
     *
     * @private
     * @param {Array|Object} collection The collection to shuffle.
     * @returns {Array} Returns the new shuffled array.
     */
    function baseShuffle(collection) {
      return shuffleSelf(values(collection));
    }

    /**
     * The base implementation of `_.slice` without an iteratee call guard.
     *
     * @private
     * @param {Array} array The array to slice.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns the slice of `array`.
     */
    function baseSlice(array, start, end) {
      var index = -1,
          length = array.length;

      if (start < 0) {
        start = -start > length ? 0 : (length + start);
      }
      end = end > length ? length : end;
      if (end < 0) {
        end += length;
      }
      length = start > end ? 0 : ((end - start) >>> 0);
      start >>>= 0;

      var result = Array(length);
      while (++index < length) {
        result[index] = array[index + start];
      }
      return result;
    }

    /**
     * The base implementation of `_.some` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {boolean} Returns `true` if any element passes the predicate check,
     *  else `false`.
     */
    function baseSome(collection, predicate) {
      var result;

      baseEach(collection, function(value, index, collection) {
        result = predicate(value, index, collection);
        return !result;
      });
      return !!result;
    }

    /**
     * The base implementation of `_.sortedIndex` and `_.sortedLastIndex` which
     * performs a binary search of `array` to determine the index at which `value`
     * should be inserted into `array` in order to maintain its sort order.
     *
     * @private
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {boolean} [retHighest] Specify returning the highest qualified index.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     */
    function baseSortedIndex(array, value, retHighest) {
      var low = 0,
          high = array == null ? low : array.length;

      if (typeof value == 'number' && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
        while (low < high) {
          var mid = (low + high) >>> 1,
              computed = array[mid];

          if (computed !== null && !isSymbol(computed) &&
              (retHighest ? (computed <= value) : (computed < value))) {
            low = mid + 1;
          } else {
            high = mid;
          }
        }
        return high;
      }
      return baseSortedIndexBy(array, value, identity, retHighest);
    }

    /**
     * The base implementation of `_.sortedIndexBy` and `_.sortedLastIndexBy`
     * which invokes `iteratee` for `value` and each element of `array` to compute
     * their sort ranking. The iteratee is invoked with one argument; (value).
     *
     * @private
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {Function} iteratee The iteratee invoked per element.
     * @param {boolean} [retHighest] Specify returning the highest qualified index.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     */
    function baseSortedIndexBy(array, value, iteratee, retHighest) {
      var low = 0,
          high = array == null ? 0 : array.length;
      if (high === 0) {
        return 0;
      }

      value = iteratee(value);
      var valIsNaN = value !== value,
          valIsNull = value === null,
          valIsSymbol = isSymbol(value),
          valIsUndefined = value === undefined;

      while (low < high) {
        var mid = nativeFloor((low + high) / 2),
            computed = iteratee(array[mid]),
            othIsDefined = computed !== undefined,
            othIsNull = computed === null,
            othIsReflexive = computed === computed,
            othIsSymbol = isSymbol(computed);

        if (valIsNaN) {
          var setLow = retHighest || othIsReflexive;
        } else if (valIsUndefined) {
          setLow = othIsReflexive && (retHighest || othIsDefined);
        } else if (valIsNull) {
          setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
        } else if (valIsSymbol) {
          setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
        } else if (othIsNull || othIsSymbol) {
          setLow = false;
        } else {
          setLow = retHighest ? (computed <= value) : (computed < value);
        }
        if (setLow) {
          low = mid + 1;
        } else {
          high = mid;
        }
      }
      return nativeMin(high, MAX_ARRAY_INDEX);
    }

    /**
     * The base implementation of `_.sortedUniq` and `_.sortedUniqBy` without
     * support for iteratee shorthands.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @returns {Array} Returns the new duplicate free array.
     */
    function baseSortedUniq(array, iteratee) {
      var index = -1,
          length = array.length,
          resIndex = 0,
          result = [];

      while (++index < length) {
        var value = array[index],
            computed = iteratee ? iteratee(value) : value;

        if (!index || !eq(computed, seen)) {
          var seen = computed;
          result[resIndex++] = value === 0 ? 0 : value;
        }
      }
      return result;
    }

    /**
     * The base implementation of `_.toNumber` which doesn't ensure correct
     * conversions of binary, hexadecimal, or octal string values.
     *
     * @private
     * @param {*} value The value to process.
     * @returns {number} Returns the number.
     */
    function baseToNumber(value) {
      if (typeof value == 'number') {
        return value;
      }
      if (isSymbol(value)) {
        return NAN;
      }
      return +value;
    }

    /**
     * The base implementation of `_.toString` which doesn't convert nullish
     * values to empty strings.
     *
     * @private
     * @param {*} value The value to process.
     * @returns {string} Returns the string.
     */
    function baseToString(value) {
      // Exit early for strings to avoid a performance hit in some environments.
      if (typeof value == 'string') {
        return value;
      }
      if (isArray(value)) {
        // Recursively convert values (susceptible to call stack limits).
        return arrayMap(value, baseToString) + '';
      }
      if (isSymbol(value)) {
        return symbolToString ? symbolToString.call(value) : '';
      }
      var result = (value + '');
      return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
    }

    /**
     * The base implementation of `_.uniqBy` without support for iteratee shorthands.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new duplicate free array.
     */
    function baseUniq(array, iteratee, comparator) {
      var index = -1,
          includes = arrayIncludes,
          length = array.length,
          isCommon = true,
          result = [],
          seen = result;

      if (comparator) {
        isCommon = false;
        includes = arrayIncludesWith;
      }
      else if (length >= LARGE_ARRAY_SIZE) {
        var set = iteratee ? null : createSet(array);
        if (set) {
          return setToArray(set);
        }
        isCommon = false;
        includes = cacheHas;
        seen = new SetCache;
      }
      else {
        seen = iteratee ? [] : result;
      }
      outer:
      while (++index < length) {
        var value = array[index],
            computed = iteratee ? iteratee(value) : value;

        value = (comparator || value !== 0) ? value : 0;
        if (isCommon && computed === computed) {
          var seenIndex = seen.length;
          while (seenIndex--) {
            if (seen[seenIndex] === computed) {
              continue outer;
            }
          }
          if (iteratee) {
            seen.push(computed);
          }
          result.push(value);
        }
        else if (!includes(seen, computed, comparator)) {
          if (seen !== result) {
            seen.push(computed);
          }
          result.push(value);
        }
      }
      return result;
    }

    /**
     * The base implementation of `_.unset`.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {Array|string} path The property path to unset.
     * @returns {boolean} Returns `true` if the property is deleted, else `false`.
     */
    function baseUnset(object, path) {
      path = castPath(path, object);
      object = parent(object, path);
      return object == null || delete object[toKey(last(path))];
    }

    /**
     * The base implementation of `_.update`.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to update.
     * @param {Function} updater The function to produce the updated value.
     * @param {Function} [customizer] The function to customize path creation.
     * @returns {Object} Returns `object`.
     */
    function baseUpdate(object, path, updater, customizer) {
      return baseSet(object, path, updater(baseGet(object, path)), customizer);
    }

    /**
     * The base implementation of methods like `_.dropWhile` and `_.takeWhile`
     * without support for iteratee shorthands.
     *
     * @private
     * @param {Array} array The array to query.
     * @param {Function} predicate The function invoked per iteration.
     * @param {boolean} [isDrop] Specify dropping elements instead of taking them.
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Array} Returns the slice of `array`.
     */
    function baseWhile(array, predicate, isDrop, fromRight) {
      var length = array.length,
          index = fromRight ? length : -1;

      while ((fromRight ? index-- : ++index < length) &&
        predicate(array[index], index, array)) {}

      return isDrop
        ? baseSlice(array, (fromRight ? 0 : index), (fromRight ? index + 1 : length))
        : baseSlice(array, (fromRight ? index + 1 : 0), (fromRight ? length : index));
    }

    /**
     * The base implementation of `wrapperValue` which returns the result of
     * performing a sequence of actions on the unwrapped `value`, where each
     * successive action is supplied the return value of the previous.
     *
     * @private
     * @param {*} value The unwrapped value.
     * @param {Array} actions Actions to perform to resolve the unwrapped value.
     * @returns {*} Returns the resolved value.
     */
    function baseWrapperValue(value, actions) {
      var result = value;
      if (result instanceof LazyWrapper) {
        result = result.value();
      }
      return arrayReduce(actions, function(result, action) {
        return action.func.apply(action.thisArg, arrayPush([result], action.args));
      }, result);
    }

    /**
     * The base implementation of methods like `_.xor`, without support for
     * iteratee shorthands, that accepts an array of arrays to inspect.
     *
     * @private
     * @param {Array} arrays The arrays to inspect.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of values.
     */
    function baseXor(arrays, iteratee, comparator) {
      var length = arrays.length;
      if (length < 2) {
        return length ? baseUniq(arrays[0]) : [];
      }
      var index = -1,
          result = Array(length);

      while (++index < length) {
        var array = arrays[index],
            othIndex = -1;

        while (++othIndex < length) {
          if (othIndex != index) {
            result[index] = baseDifference(result[index] || array, arrays[othIndex], iteratee, comparator);
          }
        }
      }
      return baseUniq(baseFlatten(result, 1), iteratee, comparator);
    }

    /**
     * This base implementation of `_.zipObject` which assigns values using `assignFunc`.
     *
     * @private
     * @param {Array} props The property identifiers.
     * @param {Array} values The property values.
     * @param {Function} assignFunc The function to assign values.
     * @returns {Object} Returns the new object.
     */
    function baseZipObject(props, values, assignFunc) {
      var index = -1,
          length = props.length,
          valsLength = values.length,
          result = {};

      while (++index < length) {
        var value = index < valsLength ? values[index] : undefined;
        assignFunc(result, props[index], value);
      }
      return result;
    }

    /**
     * Casts `value` to an empty array if it's not an array like object.
     *
     * @private
     * @param {*} value The value to inspect.
     * @returns {Array|Object} Returns the cast array-like object.
     */
    function castArrayLikeObject(value) {
      return isArrayLikeObject(value) ? value : [];
    }

    /**
     * Casts `value` to `identity` if it's not a function.
     *
     * @private
     * @param {*} value The value to inspect.
     * @returns {Function} Returns cast function.
     */
    function castFunction(value) {
      return typeof value == 'function' ? value : identity;
    }

    /**
     * Casts `value` to a path array if it's not one.
     *
     * @private
     * @param {*} value The value to inspect.
     * @param {Object} [object] The object to query keys on.
     * @returns {Array} Returns the cast property path array.
     */
    function castPath(value, object) {
      if (isArray(value)) {
        return value;
      }
      return isKey(value, object) ? [value] : stringToPath(toString(value));
    }

    /**
     * A `baseRest` alias which can be replaced with `identity` by module
     * replacement plugins.
     *
     * @private
     * @type {Function}
     * @param {Function} func The function to apply a rest parameter to.
     * @returns {Function} Returns the new function.
     */
    var castRest = baseRest;

    /**
     * Casts `array` to a slice if it's needed.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {number} start The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns the cast slice.
     */
    function castSlice(array, start, end) {
      var length = array.length;
      end = end === undefined ? length : end;
      return (!start && end >= length) ? array : baseSlice(array, start, end);
    }

    /**
     * A simple wrapper around the global [`clearTimeout`](https://mdn.io/clearTimeout).
     *
     * @private
     * @param {number|Object} id The timer id or timeout object of the timer to clear.
     */
    var clearTimeout = ctxClearTimeout || function(id) {
      return root.clearTimeout(id);
    };

    /**
     * Creates a clone of  `buffer`.
     *
     * @private
     * @param {Buffer} buffer The buffer to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Buffer} Returns the cloned buffer.
     */
    function cloneBuffer(buffer, isDeep) {
      if (isDeep) {
        return buffer.slice();
      }
      var length = buffer.length,
          result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);

      buffer.copy(result);
      return result;
    }

    /**
     * Creates a clone of `arrayBuffer`.
     *
     * @private
     * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
     * @returns {ArrayBuffer} Returns the cloned array buffer.
     */
    function cloneArrayBuffer(arrayBuffer) {
      var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
      new Uint8Array(result).set(new Uint8Array(arrayBuffer));
      return result;
    }

    /**
     * Creates a clone of `dataView`.
     *
     * @private
     * @param {Object} dataView The data view to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Object} Returns the cloned data view.
     */
    function cloneDataView(dataView, isDeep) {
      var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
      return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
    }

    /**
     * Creates a clone of `regexp`.
     *
     * @private
     * @param {Object} regexp The regexp to clone.
     * @returns {Object} Returns the cloned regexp.
     */
    function cloneRegExp(regexp) {
      var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
      result.lastIndex = regexp.lastIndex;
      return result;
    }

    /**
     * Creates a clone of the `symbol` object.
     *
     * @private
     * @param {Object} symbol The symbol object to clone.
     * @returns {Object} Returns the cloned symbol object.
     */
    function cloneSymbol(symbol) {
      return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
    }

    /**
     * Creates a clone of `typedArray`.
     *
     * @private
     * @param {Object} typedArray The typed array to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Object} Returns the cloned typed array.
     */
    function cloneTypedArray(typedArray, isDeep) {
      var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
      return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
    }

    /**
     * Compares values to sort them in ascending order.
     *
     * @private
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {number} Returns the sort order indicator for `value`.
     */
    function compareAscending(value, other) {
      if (value !== other) {
        var valIsDefined = value !== undefined,
            valIsNull = value === null,
            valIsReflexive = value === value,
            valIsSymbol = isSymbol(value);

        var othIsDefined = other !== undefined,
            othIsNull = other === null,
            othIsReflexive = other === other,
            othIsSymbol = isSymbol(other);

        if ((!othIsNull && !othIsSymbol && !valIsSymbol && value > other) ||
            (valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol) ||
            (valIsNull && othIsDefined && othIsReflexive) ||
            (!valIsDefined && othIsReflexive) ||
            !valIsReflexive) {
          return 1;
        }
        if ((!valIsNull && !valIsSymbol && !othIsSymbol && value < other) ||
            (othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol) ||
            (othIsNull && valIsDefined && valIsReflexive) ||
            (!othIsDefined && valIsReflexive) ||
            !othIsReflexive) {
          return -1;
        }
      }
      return 0;
    }

    /**
     * Used by `_.orderBy` to compare multiple properties of a value to another
     * and stable sort them.
     *
     * If `orders` is unspecified, all values are sorted in ascending order. Otherwise,
     * specify an order of "desc" for descending or "asc" for ascending sort order
     * of corresponding values.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {boolean[]|string[]} orders The order to sort by for each property.
     * @returns {number} Returns the sort order indicator for `object`.
     */
    function compareMultiple(object, other, orders) {
      var index = -1,
          objCriteria = object.criteria,
          othCriteria = other.criteria,
          length = objCriteria.length,
          ordersLength = orders.length;

      while (++index < length) {
        var result = compareAscending(objCriteria[index], othCriteria[index]);
        if (result) {
          if (index >= ordersLength) {
            return result;
          }
          var order = orders[index];
          return result * (order == 'desc' ? -1 : 1);
        }
      }
      // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications
      // that causes it, under certain circumstances, to provide the same value for
      // `object` and `other`. See https://github.com/jashkenas/underscore/pull/1247
      // for more details.
      //
      // This also ensures a stable sort in V8 and other engines.
      // See https://bugs.chromium.org/p/v8/issues/detail?id=90 for more details.
      return object.index - other.index;
    }

    /**
     * Creates an array that is the composition of partially applied arguments,
     * placeholders, and provided arguments into a single array of arguments.
     *
     * @private
     * @param {Array} args The provided arguments.
     * @param {Array} partials The arguments to prepend to those provided.
     * @param {Array} holders The `partials` placeholder indexes.
     * @params {boolean} [isCurried] Specify composing for a curried function.
     * @returns {Array} Returns the new array of composed arguments.
     */
    function composeArgs(args, partials, holders, isCurried) {
      var argsIndex = -1,
          argsLength = args.length,
          holdersLength = holders.length,
          leftIndex = -1,
          leftLength = partials.length,
          rangeLength = nativeMax(argsLength - holdersLength, 0),
          result = Array(leftLength + rangeLength),
          isUncurried = !isCurried;

      while (++leftIndex < leftLength) {
        result[leftIndex] = partials[leftIndex];
      }
      while (++argsIndex < holdersLength) {
        if (isUncurried || argsIndex < argsLength) {
          result[holders[argsIndex]] = args[argsIndex];
        }
      }
      while (rangeLength--) {
        result[leftIndex++] = args[argsIndex++];
      }
      return result;
    }

    /**
     * This function is like `composeArgs` except that the arguments composition
     * is tailored for `_.partialRight`.
     *
     * @private
     * @param {Array} args The provided arguments.
     * @param {Array} partials The arguments to append to those provided.
     * @param {Array} holders The `partials` placeholder indexes.
     * @params {boolean} [isCurried] Specify composing for a curried function.
     * @returns {Array} Returns the new array of composed arguments.
     */
    function composeArgsRight(args, partials, holders, isCurried) {
      var argsIndex = -1,
          argsLength = args.length,
          holdersIndex = -1,
          holdersLength = holders.length,
          rightIndex = -1,
          rightLength = partials.length,
          rangeLength = nativeMax(argsLength - holdersLength, 0),
          result = Array(rangeLength + rightLength),
          isUncurried = !isCurried;

      while (++argsIndex < rangeLength) {
        result[argsIndex] = args[argsIndex];
      }
      var offset = argsIndex;
      while (++rightIndex < rightLength) {
        result[offset + rightIndex] = partials[rightIndex];
      }
      while (++holdersIndex < holdersLength) {
        if (isUncurried || argsIndex < argsLength) {
          result[offset + holders[holdersIndex]] = args[argsIndex++];
        }
      }
      return result;
    }

    /**
     * Copies the values of `source` to `array`.
     *
     * @private
     * @param {Array} source The array to copy values from.
     * @param {Array} [array=[]] The array to copy values to.
     * @returns {Array} Returns `array`.
     */
    function copyArray(source, array) {
      var index = -1,
          length = source.length;

      array || (array = Array(length));
      while (++index < length) {
        array[index] = source[index];
      }
      return array;
    }

    /**
     * Copies properties of `source` to `object`.
     *
     * @private
     * @param {Object} source The object to copy properties from.
     * @param {Array} props The property identifiers to copy.
     * @param {Object} [object={}] The object to copy properties to.
     * @param {Function} [customizer] The function to customize copied values.
     * @returns {Object} Returns `object`.
     */
    function copyObject(source, props, object, customizer) {
      var isNew = !object;
      object || (object = {});

      var index = -1,
          length = props.length;

      while (++index < length) {
        var key = props[index];

        var newValue = customizer
          ? customizer(object[key], source[key], key, object, source)
          : undefined;

        if (newValue === undefined) {
          newValue = source[key];
        }
        if (isNew) {
          baseAssignValue(object, key, newValue);
        } else {
          assignValue(object, key, newValue);
        }
      }
      return object;
    }

    /**
     * Copies own symbols of `source` to `object`.
     *
     * @private
     * @param {Object} source The object to copy symbols from.
     * @param {Object} [object={}] The object to copy symbols to.
     * @returns {Object} Returns `object`.
     */
    function copySymbols(source, object) {
      return copyObject(source, getSymbols(source), object);
    }

    /**
     * Copies own and inherited symbols of `source` to `object`.
     *
     * @private
     * @param {Object} source The object to copy symbols from.
     * @param {Object} [object={}] The object to copy symbols to.
     * @returns {Object} Returns `object`.
     */
    function copySymbolsIn(source, object) {
      return copyObject(source, getSymbolsIn(source), object);
    }

    /**
     * Creates a function like `_.groupBy`.
     *
     * @private
     * @param {Function} setter The function to set accumulator values.
     * @param {Function} [initializer] The accumulator object initializer.
     * @returns {Function} Returns the new aggregator function.
     */
    function createAggregator(setter, initializer) {
      return function(collection, iteratee) {
        var func = isArray(collection) ? arrayAggregator : baseAggregator,
            accumulator = initializer ? initializer() : {};

        return func(collection, setter, getIteratee(iteratee, 2), accumulator);
      };
    }

    /**
     * Creates a function like `_.assign`.
     *
     * @private
     * @param {Function} assigner The function to assign values.
     * @returns {Function} Returns the new assigner function.
     */
    function createAssigner(assigner) {
      return baseRest(function(object, sources) {
        var index = -1,
            length = sources.length,
            customizer = length > 1 ? sources[length - 1] : undefined,
            guard = length > 2 ? sources[2] : undefined;

        customizer = (assigner.length > 3 && typeof customizer == 'function')
          ? (length--, customizer)
          : undefined;

        if (guard && isIterateeCall(sources[0], sources[1], guard)) {
          customizer = length < 3 ? undefined : customizer;
          length = 1;
        }
        object = Object(object);
        while (++index < length) {
          var source = sources[index];
          if (source) {
            assigner(object, source, index, customizer);
          }
        }
        return object;
      });
    }

    /**
     * Creates a `baseEach` or `baseEachRight` function.
     *
     * @private
     * @param {Function} eachFunc The function to iterate over a collection.
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new base function.
     */
    function createBaseEach(eachFunc, fromRight) {
      return function(collection, iteratee) {
        if (collection == null) {
          return collection;
        }
        if (!isArrayLike(collection)) {
          return eachFunc(collection, iteratee);
        }
        var length = collection.length,
            index = fromRight ? length : -1,
            iterable = Object(collection);

        while ((fromRight ? index-- : ++index < length)) {
          if (iteratee(iterable[index], index, iterable) === false) {
            break;
          }
        }
        return collection;
      };
    }

    /**
     * Creates a base function for methods like `_.forIn` and `_.forOwn`.
     *
     * @private
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new base function.
     */
    function createBaseFor(fromRight) {
      return function(object, iteratee, keysFunc) {
        var index = -1,
            iterable = Object(object),
            props = keysFunc(object),
            length = props.length;

        while (length--) {
          var key = props[fromRight ? length : ++index];
          if (iteratee(iterable[key], key, iterable) === false) {
            break;
          }
        }
        return object;
      };
    }

    /**
     * Creates a function that wraps `func` to invoke it with the optional `this`
     * binding of `thisArg`.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @returns {Function} Returns the new wrapped function.
     */
    function createBind(func, bitmask, thisArg) {
      var isBind = bitmask & WRAP_BIND_FLAG,
          Ctor = createCtor(func);

      function wrapper() {
        var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;
        return fn.apply(isBind ? thisArg : this, arguments);
      }
      return wrapper;
    }

    /**
     * Creates a function like `_.lowerFirst`.
     *
     * @private
     * @param {string} methodName The name of the `String` case method to use.
     * @returns {Function} Returns the new case function.
     */
    function createCaseFirst(methodName) {
      return function(string) {
        string = toString(string);

        var strSymbols = hasUnicode(string)
          ? stringToArray(string)
          : undefined;

        var chr = strSymbols
          ? strSymbols[0]
          : string.charAt(0);

        var trailing = strSymbols
          ? castSlice(strSymbols, 1).join('')
          : string.slice(1);

        return chr[methodName]() + trailing;
      };
    }

    /**
     * Creates a function like `_.camelCase`.
     *
     * @private
     * @param {Function} callback The function to combine each word.
     * @returns {Function} Returns the new compounder function.
     */
    function createCompounder(callback) {
      return function(string) {
        return arrayReduce(words(deburr(string).replace(reApos, '')), callback, '');
      };
    }

    /**
     * Creates a function that produces an instance of `Ctor` regardless of
     * whether it was invoked as part of a `new` expression or by `call` or `apply`.
     *
     * @private
     * @param {Function} Ctor The constructor to wrap.
     * @returns {Function} Returns the new wrapped function.
     */
    function createCtor(Ctor) {
      return function() {
        // Use a `switch` statement to work with class constructors. See
        // http://ecma-international.org/ecma-262/7.0/#sec-ecmascript-function-objects-call-thisargument-argumentslist
        // for more details.
        var args = arguments;
        switch (args.length) {
          case 0: return new Ctor;
          case 1: return new Ctor(args[0]);
          case 2: return new Ctor(args[0], args[1]);
          case 3: return new Ctor(args[0], args[1], args[2]);
          case 4: return new Ctor(args[0], args[1], args[2], args[3]);
          case 5: return new Ctor(args[0], args[1], args[2], args[3], args[4]);
          case 6: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
          case 7: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
        }
        var thisBinding = baseCreate(Ctor.prototype),
            result = Ctor.apply(thisBinding, args);

        // Mimic the constructor's `return` behavior.
        // See https://es5.github.io/#x13.2.2 for more details.
        return isObject(result) ? result : thisBinding;
      };
    }

    /**
     * Creates a function that wraps `func` to enable currying.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {number} arity The arity of `func`.
     * @returns {Function} Returns the new wrapped function.
     */
    function createCurry(func, bitmask, arity) {
      var Ctor = createCtor(func);

      function wrapper() {
        var length = arguments.length,
            args = Array(length),
            index = length,
            placeholder = getHolder(wrapper);

        while (index--) {
          args[index] = arguments[index];
        }
        var holders = (length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder)
          ? []
          : replaceHolders(args, placeholder);

        length -= holders.length;
        if (length < arity) {
          return createRecurry(
            func, bitmask, createHybrid, wrapper.placeholder, undefined,
            args, holders, undefined, undefined, arity - length);
        }
        var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;
        return apply(fn, this, args);
      }
      return wrapper;
    }

    /**
     * Creates a `_.find` or `_.findLast` function.
     *
     * @private
     * @param {Function} findIndexFunc The function to find the collection index.
     * @returns {Function} Returns the new find function.
     */
    function createFind(findIndexFunc) {
      return function(collection, predicate, fromIndex) {
        var iterable = Object(collection);
        if (!isArrayLike(collection)) {
          var iteratee = getIteratee(predicate, 3);
          collection = keys(collection);
          predicate = function(key) { return iteratee(iterable[key], key, iterable); };
        }
        var index = findIndexFunc(collection, predicate, fromIndex);
        return index > -1 ? iterable[iteratee ? collection[index] : index] : undefined;
      };
    }

    /**
     * Creates a `_.flow` or `_.flowRight` function.
     *
     * @private
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new flow function.
     */
    function createFlow(fromRight) {
      return flatRest(function(funcs) {
        var length = funcs.length,
            index = length,
            prereq = LodashWrapper.prototype.thru;

        if (fromRight) {
          funcs.reverse();
        }
        while (index--) {
          var func = funcs[index];
          if (typeof func != 'function') {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          if (prereq && !wrapper && getFuncName(func) == 'wrapper') {
            var wrapper = new LodashWrapper([], true);
          }
        }
        index = wrapper ? index : length;
        while (++index < length) {
          func = funcs[index];

          var funcName = getFuncName(func),
              data = funcName == 'wrapper' ? getData(func) : undefined;

          if (data && isLaziable(data[0]) &&
                data[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) &&
                !data[4].length && data[9] == 1
              ) {
            wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);
          } else {
            wrapper = (func.length == 1 && isLaziable(func))
              ? wrapper[funcName]()
              : wrapper.thru(func);
          }
        }
        return function() {
          var args = arguments,
              value = args[0];

          if (wrapper && args.length == 1 && isArray(value)) {
            return wrapper.plant(value).value();
          }
          var index = 0,
              result = length ? funcs[index].apply(this, args) : value;

          while (++index < length) {
            result = funcs[index].call(this, result);
          }
          return result;
        };
      });
    }

    /**
     * Creates a function that wraps `func` to invoke it with optional `this`
     * binding of `thisArg`, partial application, and currying.
     *
     * @private
     * @param {Function|string} func The function or method name to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {Array} [partials] The arguments to prepend to those provided to
     *  the new function.
     * @param {Array} [holders] The `partials` placeholder indexes.
     * @param {Array} [partialsRight] The arguments to append to those provided
     *  to the new function.
     * @param {Array} [holdersRight] The `partialsRight` placeholder indexes.
     * @param {Array} [argPos] The argument positions of the new function.
     * @param {number} [ary] The arity cap of `func`.
     * @param {number} [arity] The arity of `func`.
     * @returns {Function} Returns the new wrapped function.
     */
    function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity) {
      var isAry = bitmask & WRAP_ARY_FLAG,
          isBind = bitmask & WRAP_BIND_FLAG,
          isBindKey = bitmask & WRAP_BIND_KEY_FLAG,
          isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG),
          isFlip = bitmask & WRAP_FLIP_FLAG,
          Ctor = isBindKey ? undefined : createCtor(func);

      function wrapper() {
        var length = arguments.length,
            args = Array(length),
            index = length;

        while (index--) {
          args[index] = arguments[index];
        }
        if (isCurried) {
          var placeholder = getHolder(wrapper),
              holdersCount = countHolders(args, placeholder);
        }
        if (partials) {
          args = composeArgs(args, partials, holders, isCurried);
        }
        if (partialsRight) {
          args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
        }
        length -= holdersCount;
        if (isCurried && length < arity) {
          var newHolders = replaceHolders(args, placeholder);
          return createRecurry(
            func, bitmask, createHybrid, wrapper.placeholder, thisArg,
            args, newHolders, argPos, ary, arity - length
          );
        }
        var thisBinding = isBind ? thisArg : this,
            fn = isBindKey ? thisBinding[func] : func;

        length = args.length;
        if (argPos) {
          args = reorder(args, argPos);
        } else if (isFlip && length > 1) {
          args.reverse();
        }
        if (isAry && ary < length) {
          args.length = ary;
        }
        if (this && this !== root && this instanceof wrapper) {
          fn = Ctor || createCtor(fn);
        }
        return fn.apply(thisBinding, args);
      }
      return wrapper;
    }

    /**
     * Creates a function like `_.invertBy`.
     *
     * @private
     * @param {Function} setter The function to set accumulator values.
     * @param {Function} toIteratee The function to resolve iteratees.
     * @returns {Function} Returns the new inverter function.
     */
    function createInverter(setter, toIteratee) {
      return function(object, iteratee) {
        return baseInverter(object, setter, toIteratee(iteratee), {});
      };
    }

    /**
     * Creates a function that performs a mathematical operation on two values.
     *
     * @private
     * @param {Function} operator The function to perform the operation.
     * @param {number} [defaultValue] The value used for `undefined` arguments.
     * @returns {Function} Returns the new mathematical operation function.
     */
    function createMathOperation(operator, defaultValue) {
      return function(value, other) {
        var result;
        if (value === undefined && other === undefined) {
          return defaultValue;
        }
        if (value !== undefined) {
          result = value;
        }
        if (other !== undefined) {
          if (result === undefined) {
            return other;
          }
          if (typeof value == 'string' || typeof other == 'string') {
            value = baseToString(value);
            other = baseToString(other);
          } else {
            value = baseToNumber(value);
            other = baseToNumber(other);
          }
          result = operator(value, other);
        }
        return result;
      };
    }

    /**
     * Creates a function like `_.over`.
     *
     * @private
     * @param {Function} arrayFunc The function to iterate over iteratees.
     * @returns {Function} Returns the new over function.
     */
    function createOver(arrayFunc) {
      return flatRest(function(iteratees) {
        iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
        return baseRest(function(args) {
          var thisArg = this;
          return arrayFunc(iteratees, function(iteratee) {
            return apply(iteratee, thisArg, args);
          });
        });
      });
    }

    /**
     * Creates the padding for `string` based on `length`. The `chars` string
     * is truncated if the number of characters exceeds `length`.
     *
     * @private
     * @param {number} length The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padding for `string`.
     */
    function createPadding(length, chars) {
      chars = chars === undefined ? ' ' : baseToString(chars);

      var charsLength = chars.length;
      if (charsLength < 2) {
        return charsLength ? baseRepeat(chars, length) : chars;
      }
      var result = baseRepeat(chars, nativeCeil(length / stringSize(chars)));
      return hasUnicode(chars)
        ? castSlice(stringToArray(result), 0, length).join('')
        : result.slice(0, length);
    }

    /**
     * Creates a function that wraps `func` to invoke it with the `this` binding
     * of `thisArg` and `partials` prepended to the arguments it receives.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {*} thisArg The `this` binding of `func`.
     * @param {Array} partials The arguments to prepend to those provided to
     *  the new function.
     * @returns {Function} Returns the new wrapped function.
     */
    function createPartial(func, bitmask, thisArg, partials) {
      var isBind = bitmask & WRAP_BIND_FLAG,
          Ctor = createCtor(func);

      function wrapper() {
        var argsIndex = -1,
            argsLength = arguments.length,
            leftIndex = -1,
            leftLength = partials.length,
            args = Array(leftLength + argsLength),
            fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;

        while (++leftIndex < leftLength) {
          args[leftIndex] = partials[leftIndex];
        }
        while (argsLength--) {
          args[leftIndex++] = arguments[++argsIndex];
        }
        return apply(fn, isBind ? thisArg : this, args);
      }
      return wrapper;
    }

    /**
     * Creates a `_.range` or `_.rangeRight` function.
     *
     * @private
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new range function.
     */
    function createRange(fromRight) {
      return function(start, end, step) {
        if (step && typeof step != 'number' && isIterateeCall(start, end, step)) {
          end = step = undefined;
        }
        // Ensure the sign of `-0` is preserved.
        start = toFinite(start);
        if (end === undefined) {
          end = start;
          start = 0;
        } else {
          end = toFinite(end);
        }
        step = step === undefined ? (start < end ? 1 : -1) : toFinite(step);
        return baseRange(start, end, step, fromRight);
      };
    }

    /**
     * Creates a function that performs a relational operation on two values.
     *
     * @private
     * @param {Function} operator The function to perform the operation.
     * @returns {Function} Returns the new relational operation function.
     */
    function createRelationalOperation(operator) {
      return function(value, other) {
        if (!(typeof value == 'string' && typeof other == 'string')) {
          value = toNumber(value);
          other = toNumber(other);
        }
        return operator(value, other);
      };
    }

    /**
     * Creates a function that wraps `func` to continue currying.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {Function} wrapFunc The function to create the `func` wrapper.
     * @param {*} placeholder The placeholder value.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {Array} [partials] The arguments to prepend to those provided to
     *  the new function.
     * @param {Array} [holders] The `partials` placeholder indexes.
     * @param {Array} [argPos] The argument positions of the new function.
     * @param {number} [ary] The arity cap of `func`.
     * @param {number} [arity] The arity of `func`.
     * @returns {Function} Returns the new wrapped function.
     */
    function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary, arity) {
      var isCurry = bitmask & WRAP_CURRY_FLAG,
          newHolders = isCurry ? holders : undefined,
          newHoldersRight = isCurry ? undefined : holders,
          newPartials = isCurry ? partials : undefined,
          newPartialsRight = isCurry ? undefined : partials;

      bitmask |= (isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG);
      bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);

      if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {
        bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG);
      }
      var newData = [
        func, bitmask, thisArg, newPartials, newHolders, newPartialsRight,
        newHoldersRight, argPos, ary, arity
      ];

      var result = wrapFunc.apply(undefined, newData);
      if (isLaziable(func)) {
        setData(result, newData);
      }
      result.placeholder = placeholder;
      return setWrapToString(result, func, bitmask);
    }

    /**
     * Creates a function like `_.round`.
     *
     * @private
     * @param {string} methodName The name of the `Math` method to use when rounding.
     * @returns {Function} Returns the new round function.
     */
    function createRound(methodName) {
      var func = Math[methodName];
      return function(number, precision) {
        number = toNumber(number);
        precision = precision == null ? 0 : nativeMin(toInteger(precision), 292);
        if (precision && nativeIsFinite(number)) {
          // Shift with exponential notation to avoid floating-point issues.
          // See [MDN](https://mdn.io/round#Examples) for more details.
          var pair = (toString(number) + 'e').split('e'),
              value = func(pair[0] + 'e' + (+pair[1] + precision));

          pair = (toString(value) + 'e').split('e');
          return +(pair[0] + 'e' + (+pair[1] - precision));
        }
        return func(number);
      };
    }

    /**
     * Creates a set object of `values`.
     *
     * @private
     * @param {Array} values The values to add to the set.
     * @returns {Object} Returns the new set.
     */
    var createSet = !(Set && (1 / setToArray(new Set([,-0]))[1]) == INFINITY) ? noop : function(values) {
      return new Set(values);
    };

    /**
     * Creates a `_.toPairs` or `_.toPairsIn` function.
     *
     * @private
     * @param {Function} keysFunc The function to get the keys of a given object.
     * @returns {Function} Returns the new pairs function.
     */
    function createToPairs(keysFunc) {
      return function(object) {
        var tag = getTag(object);
        if (tag == mapTag) {
          return mapToArray(object);
        }
        if (tag == setTag) {
          return setToPairs(object);
        }
        return baseToPairs(object, keysFunc(object));
      };
    }

    /**
     * Creates a function that either curries or invokes `func` with optional
     * `this` binding and partially applied arguments.
     *
     * @private
     * @param {Function|string} func The function or method name to wrap.
     * @param {number} bitmask The bitmask flags.
     *    1 - `_.bind`
     *    2 - `_.bindKey`
     *    4 - `_.curry` or `_.curryRight` of a bound function
     *    8 - `_.curry`
     *   16 - `_.curryRight`
     *   32 - `_.partial`
     *   64 - `_.partialRight`
     *  128 - `_.rearg`
     *  256 - `_.ary`
     *  512 - `_.flip`
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {Array} [partials] The arguments to be partially applied.
     * @param {Array} [holders] The `partials` placeholder indexes.
     * @param {Array} [argPos] The argument positions of the new function.
     * @param {number} [ary] The arity cap of `func`.
     * @param {number} [arity] The arity of `func`.
     * @returns {Function} Returns the new wrapped function.
     */
    function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary, arity) {
      var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;
      if (!isBindKey && typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      var length = partials ? partials.length : 0;
      if (!length) {
        bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG);
        partials = holders = undefined;
      }
      ary = ary === undefined ? ary : nativeMax(toInteger(ary), 0);
      arity = arity === undefined ? arity : toInteger(arity);
      length -= holders ? holders.length : 0;

      if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {
        var partialsRight = partials,
            holdersRight = holders;

        partials = holders = undefined;
      }
      var data = isBindKey ? undefined : getData(func);

      var newData = [
        func, bitmask, thisArg, partials, holders, partialsRight, holdersRight,
        argPos, ary, arity
      ];

      if (data) {
        mergeData(newData, data);
      }
      func = newData[0];
      bitmask = newData[1];
      thisArg = newData[2];
      partials = newData[3];
      holders = newData[4];
      arity = newData[9] = newData[9] === undefined
        ? (isBindKey ? 0 : func.length)
        : nativeMax(newData[9] - length, 0);

      if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {
        bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG);
      }
      if (!bitmask || bitmask == WRAP_BIND_FLAG) {
        var result = createBind(func, bitmask, thisArg);
      } else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) {
        result = createCurry(func, bitmask, arity);
      } else if ((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length) {
        result = createPartial(func, bitmask, thisArg, partials);
      } else {
        result = createHybrid.apply(undefined, newData);
      }
      var setter = data ? baseSetData : setData;
      return setWrapToString(setter(result, newData), func, bitmask);
    }

    /**
     * Used by `_.defaults` to customize its `_.assignIn` use to assign properties
     * of source objects to the destination object for all destination properties
     * that resolve to `undefined`.
     *
     * @private
     * @param {*} objValue The destination value.
     * @param {*} srcValue The source value.
     * @param {string} key The key of the property to assign.
     * @param {Object} object The parent object of `objValue`.
     * @returns {*} Returns the value to assign.
     */
    function customDefaultsAssignIn(objValue, srcValue, key, object) {
      if (objValue === undefined ||
          (eq(objValue, objectProto[key]) && !hasOwnProperty.call(object, key))) {
        return srcValue;
      }
      return objValue;
    }

    /**
     * Used by `_.defaultsDeep` to customize its `_.merge` use to merge source
     * objects into destination objects that are passed thru.
     *
     * @private
     * @param {*} objValue The destination value.
     * @param {*} srcValue The source value.
     * @param {string} key The key of the property to merge.
     * @param {Object} object The parent object of `objValue`.
     * @param {Object} source The parent object of `srcValue`.
     * @param {Object} [stack] Tracks traversed source values and their merged
     *  counterparts.
     * @returns {*} Returns the value to assign.
     */
    function customDefaultsMerge(objValue, srcValue, key, object, source, stack) {
      if (isObject(objValue) && isObject(srcValue)) {
        // Recursively merge objects and arrays (susceptible to call stack limits).
        stack.set(srcValue, objValue);
        baseMerge(objValue, srcValue, undefined, customDefaultsMerge, stack);
        stack['delete'](srcValue);
      }
      return objValue;
    }

    /**
     * Used by `_.omit` to customize its `_.cloneDeep` use to only clone plain
     * objects.
     *
     * @private
     * @param {*} value The value to inspect.
     * @param {string} key The key of the property to inspect.
     * @returns {*} Returns the uncloned value or `undefined` to defer cloning to `_.cloneDeep`.
     */
    function customOmitClone(value) {
      return isPlainObject(value) ? undefined : value;
    }

    /**
     * A specialized version of `baseIsEqualDeep` for arrays with support for
     * partial deep comparisons.
     *
     * @private
     * @param {Array} array The array to compare.
     * @param {Array} other The other array to compare.
     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
     * @param {Function} customizer The function to customize comparisons.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Object} stack Tracks traversed `array` and `other` objects.
     * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
     */
    function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
          arrLength = array.length,
          othLength = other.length;

      if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
        return false;
      }
      // Check that cyclic values are equal.
      var arrStacked = stack.get(array);
      var othStacked = stack.get(other);
      if (arrStacked && othStacked) {
        return arrStacked == other && othStacked == array;
      }
      var index = -1,
          result = true,
          seen = (bitmask & COMPARE_UNORDERED_FLAG) ? new SetCache : undefined;

      stack.set(array, other);
      stack.set(other, array);

      // Ignore non-index properties.
      while (++index < arrLength) {
        var arrValue = array[index],
            othValue = other[index];

        if (customizer) {
          var compared = isPartial
            ? customizer(othValue, arrValue, index, other, array, stack)
            : customizer(arrValue, othValue, index, array, other, stack);
        }
        if (compared !== undefined) {
          if (compared) {
            continue;
          }
          result = false;
          break;
        }
        // Recursively compare arrays (susceptible to call stack limits).
        if (seen) {
          if (!arraySome(other, function(othValue, othIndex) {
                if (!cacheHas(seen, othIndex) &&
                    (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
                  return seen.push(othIndex);
                }
              })) {
            result = false;
            break;
          }
        } else if (!(
              arrValue === othValue ||
                equalFunc(arrValue, othValue, bitmask, customizer, stack)
            )) {
          result = false;
          break;
        }
      }
      stack['delete'](array);
      stack['delete'](other);
      return result;
    }

    /**
     * A specialized version of `baseIsEqualDeep` for comparing objects of
     * the same `toStringTag`.
     *
     * **Note:** This function only supports comparing values with tags of
     * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {string} tag The `toStringTag` of the objects to compare.
     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
     * @param {Function} customizer The function to customize comparisons.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Object} stack Tracks traversed `object` and `other` objects.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */
    function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
      switch (tag) {
        case dataViewTag:
          if ((object.byteLength != other.byteLength) ||
              (object.byteOffset != other.byteOffset)) {
            return false;
          }
          object = object.buffer;
          other = other.buffer;

        case arrayBufferTag:
          if ((object.byteLength != other.byteLength) ||
              !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
            return false;
          }
          return true;

        case boolTag:
        case dateTag:
        case numberTag:
          // Coerce booleans to `1` or `0` and dates to milliseconds.
          // Invalid dates are coerced to `NaN`.
          return eq(+object, +other);

        case errorTag:
          return object.name == other.name && object.message == other.message;

        case regexpTag:
        case stringTag:
          // Coerce regexes to strings and treat strings, primitives and objects,
          // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
          // for more details.
          return object == (other + '');

        case mapTag:
          var convert = mapToArray;

        case setTag:
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
          convert || (convert = setToArray);

          if (object.size != other.size && !isPartial) {
            return false;
          }
          // Assume cyclic values are equal.
          var stacked = stack.get(object);
          if (stacked) {
            return stacked == other;
          }
          bitmask |= COMPARE_UNORDERED_FLAG;

          // Recursively compare objects (susceptible to call stack limits).
          stack.set(object, other);
          var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
          stack['delete'](object);
          return result;

        case symbolTag:
          if (symbolValueOf) {
            return symbolValueOf.call(object) == symbolValueOf.call(other);
          }
      }
      return false;
    }

    /**
     * A specialized version of `baseIsEqualDeep` for objects with support for
     * partial deep comparisons.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
     * @param {Function} customizer The function to customize comparisons.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Object} stack Tracks traversed `object` and `other` objects.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */
    function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
          objProps = getAllKeys(object),
          objLength = objProps.length,
          othProps = getAllKeys(other),
          othLength = othProps.length;

      if (objLength != othLength && !isPartial) {
        return false;
      }
      var index = objLength;
      while (index--) {
        var key = objProps[index];
        if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
          return false;
        }
      }
      // Check that cyclic values are equal.
      var objStacked = stack.get(object);
      var othStacked = stack.get(other);
      if (objStacked && othStacked) {
        return objStacked == other && othStacked == object;
      }
      var result = true;
      stack.set(object, other);
      stack.set(other, object);

      var skipCtor = isPartial;
      while (++index < objLength) {
        key = objProps[index];
        var objValue = object[key],
            othValue = other[key];

        if (customizer) {
          var compared = isPartial
            ? customizer(othValue, objValue, key, other, object, stack)
            : customizer(objValue, othValue, key, object, other, stack);
        }
        // Recursively compare objects (susceptible to call stack limits).
        if (!(compared === undefined
              ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))
              : compared
            )) {
          result = false;
          break;
        }
        skipCtor || (skipCtor = key == 'constructor');
      }
      if (result && !skipCtor) {
        var objCtor = object.constructor,
            othCtor = other.constructor;

        // Non `Object` object instances with different constructors are not equal.
        if (objCtor != othCtor &&
            ('constructor' in object && 'constructor' in other) &&
            !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
              typeof othCtor == 'function' && othCtor instanceof othCtor)) {
          result = false;
        }
      }
      stack['delete'](object);
      stack['delete'](other);
      return result;
    }

    /**
     * A specialized version of `baseRest` which flattens the rest array.
     *
     * @private
     * @param {Function} func The function to apply a rest parameter to.
     * @returns {Function} Returns the new function.
     */
    function flatRest(func) {
      return setToString(overRest(func, undefined, flatten), func + '');
    }

    /**
     * Creates an array of own enumerable property names and symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names and symbols.
     */
    function getAllKeys(object) {
      return baseGetAllKeys(object, keys, getSymbols);
    }

    /**
     * Creates an array of own and inherited enumerable property names and
     * symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names and symbols.
     */
    function getAllKeysIn(object) {
      return baseGetAllKeys(object, keysIn, getSymbolsIn);
    }

    /**
     * Gets metadata for `func`.
     *
     * @private
     * @param {Function} func The function to query.
     * @returns {*} Returns the metadata for `func`.
     */
    var getData = !metaMap ? noop : function(func) {
      return metaMap.get(func);
    };

    /**
     * Gets the name of `func`.
     *
     * @private
     * @param {Function} func The function to query.
     * @returns {string} Returns the function name.
     */
    function getFuncName(func) {
      var result = (func.name + ''),
          array = realNames[result],
          length = hasOwnProperty.call(realNames, result) ? array.length : 0;

      while (length--) {
        var data = array[length],
            otherFunc = data.func;
        if (otherFunc == null || otherFunc == func) {
          return data.name;
        }
      }
      return result;
    }

    /**
     * Gets the argument placeholder value for `func`.
     *
     * @private
     * @param {Function} func The function to inspect.
     * @returns {*} Returns the placeholder value.
     */
    function getHolder(func) {
      var object = hasOwnProperty.call(lodash, 'placeholder') ? lodash : func;
      return object.placeholder;
    }

    /**
     * Gets the appropriate "iteratee" function. If `_.iteratee` is customized,
     * this function returns the custom method, otherwise it returns `baseIteratee`.
     * If arguments are provided, the chosen function is invoked with them and
     * its result is returned.
     *
     * @private
     * @param {*} [value] The value to convert to an iteratee.
     * @param {number} [arity] The arity of the created iteratee.
     * @returns {Function} Returns the chosen function or its result.
     */
    function getIteratee() {
      var result = lodash.iteratee || iteratee;
      result = result === iteratee ? baseIteratee : result;
      return arguments.length ? result(arguments[0], arguments[1]) : result;
    }

    /**
     * Gets the data for `map`.
     *
     * @private
     * @param {Object} map The map to query.
     * @param {string} key The reference key.
     * @returns {*} Returns the map data.
     */
    function getMapData(map, key) {
      var data = map.__data__;
      return isKeyable(key)
        ? data[typeof key == 'string' ? 'string' : 'hash']
        : data.map;
    }

    /**
     * Gets the property names, values, and compare flags of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the match data of `object`.
     */
    function getMatchData(object) {
      var result = keys(object),
          length = result.length;

      while (length--) {
        var key = result[length],
            value = object[key];

        result[length] = [key, value, isStrictComparable(value)];
      }
      return result;
    }

    /**
     * Gets the native function at `key` of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {string} key The key of the method to get.
     * @returns {*} Returns the function if it's native, else `undefined`.
     */
    function getNative(object, key) {
      var value = getValue(object, key);
      return baseIsNative(value) ? value : undefined;
    }

    /**
     * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
     *
     * @private
     * @param {*} value The value to query.
     * @returns {string} Returns the raw `toStringTag`.
     */
    function getRawTag(value) {
      var isOwn = hasOwnProperty.call(value, symToStringTag),
          tag = value[symToStringTag];

      try {
        value[symToStringTag] = undefined;
        var unmasked = true;
      } catch (e) {}

      var result = nativeObjectToString.call(value);
      if (unmasked) {
        if (isOwn) {
          value[symToStringTag] = tag;
        } else {
          delete value[symToStringTag];
        }
      }
      return result;
    }

    /**
     * Creates an array of the own enumerable symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of symbols.
     */
    var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
      if (object == null) {
        return [];
      }
      object = Object(object);
      return arrayFilter(nativeGetSymbols(object), function(symbol) {
        return propertyIsEnumerable.call(object, symbol);
      });
    };

    /**
     * Creates an array of the own and inherited enumerable symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of symbols.
     */
    var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
      var result = [];
      while (object) {
        arrayPush(result, getSymbols(object));
        object = getPrototype(object);
      }
      return result;
    };

    /**
     * Gets the `toStringTag` of `value`.
     *
     * @private
     * @param {*} value The value to query.
     * @returns {string} Returns the `toStringTag`.
     */
    var getTag = baseGetTag;

    // Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
    if ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||
        (Map && getTag(new Map) != mapTag) ||
        (Promise && getTag(Promise.resolve()) != promiseTag) ||
        (Set && getTag(new Set) != setTag) ||
        (WeakMap && getTag(new WeakMap) != weakMapTag)) {
      getTag = function(value) {
        var result = baseGetTag(value),
            Ctor = result == objectTag ? value.constructor : undefined,
            ctorString = Ctor ? toSource(Ctor) : '';

        if (ctorString) {
          switch (ctorString) {
            case dataViewCtorString: return dataViewTag;
            case mapCtorString: return mapTag;
            case promiseCtorString: return promiseTag;
            case setCtorString: return setTag;
            case weakMapCtorString: return weakMapTag;
          }
        }
        return result;
      };
    }

    /**
     * Gets the view, applying any `transforms` to the `start` and `end` positions.
     *
     * @private
     * @param {number} start The start of the view.
     * @param {number} end The end of the view.
     * @param {Array} transforms The transformations to apply to the view.
     * @returns {Object} Returns an object containing the `start` and `end`
     *  positions of the view.
     */
    function getView(start, end, transforms) {
      var index = -1,
          length = transforms.length;

      while (++index < length) {
        var data = transforms[index],
            size = data.size;

        switch (data.type) {
          case 'drop':      start += size; break;
          case 'dropRight': end -= size; break;
          case 'take':      end = nativeMin(end, start + size); break;
          case 'takeRight': start = nativeMax(start, end - size); break;
        }
      }
      return { 'start': start, 'end': end };
    }

    /**
     * Extracts wrapper details from the `source` body comment.
     *
     * @private
     * @param {string} source The source to inspect.
     * @returns {Array} Returns the wrapper details.
     */
    function getWrapDetails(source) {
      var match = source.match(reWrapDetails);
      return match ? match[1].split(reSplitDetails) : [];
    }

    /**
     * Checks if `path` exists on `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array|string} path The path to check.
     * @param {Function} hasFunc The function to check properties.
     * @returns {boolean} Returns `true` if `path` exists, else `false`.
     */
    function hasPath(object, path, hasFunc) {
      path = castPath(path, object);

      var index = -1,
          length = path.length,
          result = false;

      while (++index < length) {
        var key = toKey(path[index]);
        if (!(result = object != null && hasFunc(object, key))) {
          break;
        }
        object = object[key];
      }
      if (result || ++index != length) {
        return result;
      }
      length = object == null ? 0 : object.length;
      return !!length && isLength(length) && isIndex(key, length) &&
        (isArray(object) || isArguments(object));
    }

    /**
     * Initializes an array clone.
     *
     * @private
     * @param {Array} array The array to clone.
     * @returns {Array} Returns the initialized clone.
     */
    function initCloneArray(array) {
      var length = array.length,
          result = new array.constructor(length);

      // Add properties assigned by `RegExp#exec`.
      if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
        result.index = array.index;
        result.input = array.input;
      }
      return result;
    }

    /**
     * Initializes an object clone.
     *
     * @private
     * @param {Object} object The object to clone.
     * @returns {Object} Returns the initialized clone.
     */
    function initCloneObject(object) {
      return (typeof object.constructor == 'function' && !isPrototype(object))
        ? baseCreate(getPrototype(object))
        : {};
    }

    /**
     * Initializes an object clone based on its `toStringTag`.
     *
     * **Note:** This function only supports cloning values with tags of
     * `Boolean`, `Date`, `Error`, `Map`, `Number`, `RegExp`, `Set`, or `String`.
     *
     * @private
     * @param {Object} object The object to clone.
     * @param {string} tag The `toStringTag` of the object to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Object} Returns the initialized clone.
     */
    function initCloneByTag(object, tag, isDeep) {
      var Ctor = object.constructor;
      switch (tag) {
        case arrayBufferTag:
          return cloneArrayBuffer(object);

        case boolTag:
        case dateTag:
          return new Ctor(+object);

        case dataViewTag:
          return cloneDataView(object, isDeep);

        case float32Tag: case float64Tag:
        case int8Tag: case int16Tag: case int32Tag:
        case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:
          return cloneTypedArray(object, isDeep);

        case mapTag:
          return new Ctor;

        case numberTag:
        case stringTag:
          return new Ctor(object);

        case regexpTag:
          return cloneRegExp(object);

        case setTag:
          return new Ctor;

        case symbolTag:
          return cloneSymbol(object);
      }
    }

    /**
     * Inserts wrapper `details` in a comment at the top of the `source` body.
     *
     * @private
     * @param {string} source The source to modify.
     * @returns {Array} details The details to insert.
     * @returns {string} Returns the modified source.
     */
    function insertWrapDetails(source, details) {
      var length = details.length;
      if (!length) {
        return source;
      }
      var lastIndex = length - 1;
      details[lastIndex] = (length > 1 ? '& ' : '') + details[lastIndex];
      details = details.join(length > 2 ? ', ' : ' ');
      return source.replace(reWrapComment, '{\n/* [wrapped with ' + details + '] */\n');
    }

    /**
     * Checks if `value` is a flattenable `arguments` object or array.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
     */
    function isFlattenable(value) {
      return isArray(value) || isArguments(value) ||
        !!(spreadableSymbol && value && value[spreadableSymbol]);
    }

    /**
     * Checks if `value` is a valid array-like index.
     *
     * @private
     * @param {*} value The value to check.
     * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
     * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
     */
    function isIndex(value, length) {
      var type = typeof value;
      length = length == null ? MAX_SAFE_INTEGER : length;

      return !!length &&
        (type == 'number' ||
          (type != 'symbol' && reIsUint.test(value))) &&
            (value > -1 && value % 1 == 0 && value < length);
    }

    /**
     * Checks if the given arguments are from an iteratee call.
     *
     * @private
     * @param {*} value The potential iteratee value argument.
     * @param {*} index The potential iteratee index or key argument.
     * @param {*} object The potential iteratee object argument.
     * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
     *  else `false`.
     */
    function isIterateeCall(value, index, object) {
      if (!isObject(object)) {
        return false;
      }
      var type = typeof index;
      if (type == 'number'
            ? (isArrayLike(object) && isIndex(index, object.length))
            : (type == 'string' && index in object)
          ) {
        return eq(object[index], value);
      }
      return false;
    }

    /**
     * Checks if `value` is a property name and not a property path.
     *
     * @private
     * @param {*} value The value to check.
     * @param {Object} [object] The object to query keys on.
     * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
     */
    function isKey(value, object) {
      if (isArray(value)) {
        return false;
      }
      var type = typeof value;
      if (type == 'number' || type == 'symbol' || type == 'boolean' ||
          value == null || isSymbol(value)) {
        return true;
      }
      return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||
        (object != null && value in Object(object));
    }

    /**
     * Checks if `value` is suitable for use as unique object key.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
     */
    function isKeyable(value) {
      var type = typeof value;
      return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
        ? (value !== '__proto__')
        : (value === null);
    }

    /**
     * Checks if `func` has a lazy counterpart.
     *
     * @private
     * @param {Function} func The function to check.
     * @returns {boolean} Returns `true` if `func` has a lazy counterpart,
     *  else `false`.
     */
    function isLaziable(func) {
      var funcName = getFuncName(func),
          other = lodash[funcName];

      if (typeof other != 'function' || !(funcName in LazyWrapper.prototype)) {
        return false;
      }
      if (func === other) {
        return true;
      }
      var data = getData(other);
      return !!data && func === data[0];
    }

    /**
     * Checks if `func` has its source masked.
     *
     * @private
     * @param {Function} func The function to check.
     * @returns {boolean} Returns `true` if `func` is masked, else `false`.
     */
    function isMasked(func) {
      return !!maskSrcKey && (maskSrcKey in func);
    }

    /**
     * Checks if `func` is capable of being masked.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `func` is maskable, else `false`.
     */
    var isMaskable = coreJsData ? isFunction : stubFalse;

    /**
     * Checks if `value` is likely a prototype object.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
     */
    function isPrototype(value) {
      var Ctor = value && value.constructor,
          proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;

      return value === proto;
    }

    /**
     * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` if suitable for strict
     *  equality comparisons, else `false`.
     */
    function isStrictComparable(value) {
      return value === value && !isObject(value);
    }

    /**
     * A specialized version of `matchesProperty` for source values suitable
     * for strict equality comparisons, i.e. `===`.
     *
     * @private
     * @param {string} key The key of the property to get.
     * @param {*} srcValue The value to match.
     * @returns {Function} Returns the new spec function.
     */
    function matchesStrictComparable(key, srcValue) {
      return function(object) {
        if (object == null) {
          return false;
        }
        return object[key] === srcValue &&
          (srcValue !== undefined || (key in Object(object)));
      };
    }

    /**
     * A specialized version of `_.memoize` which clears the memoized function's
     * cache when it exceeds `MAX_MEMOIZE_SIZE`.
     *
     * @private
     * @param {Function} func The function to have its output memoized.
     * @returns {Function} Returns the new memoized function.
     */
    function memoizeCapped(func) {
      var result = memoize(func, function(key) {
        if (cache.size === MAX_MEMOIZE_SIZE) {
          cache.clear();
        }
        return key;
      });

      var cache = result.cache;
      return result;
    }

    /**
     * Merges the function metadata of `source` into `data`.
     *
     * Merging metadata reduces the number of wrappers used to invoke a function.
     * This is possible because methods like `_.bind`, `_.curry`, and `_.partial`
     * may be applied regardless of execution order. Methods like `_.ary` and
     * `_.rearg` modify function arguments, making the order in which they are
     * executed important, preventing the merging of metadata. However, we make
     * an exception for a safe combined case where curried functions have `_.ary`
     * and or `_.rearg` applied.
     *
     * @private
     * @param {Array} data The destination metadata.
     * @param {Array} source The source metadata.
     * @returns {Array} Returns `data`.
     */
    function mergeData(data, source) {
      var bitmask = data[1],
          srcBitmask = source[1],
          newBitmask = bitmask | srcBitmask,
          isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);

      var isCombo =
        ((srcBitmask == WRAP_ARY_FLAG) && (bitmask == WRAP_CURRY_FLAG)) ||
        ((srcBitmask == WRAP_ARY_FLAG) && (bitmask == WRAP_REARG_FLAG) && (data[7].length <= source[8])) ||
        ((srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG)) && (source[7].length <= source[8]) && (bitmask == WRAP_CURRY_FLAG));

      // Exit early if metadata can't be merged.
      if (!(isCommon || isCombo)) {
        return data;
      }
      // Use source `thisArg` if available.
      if (srcBitmask & WRAP_BIND_FLAG) {
        data[2] = source[2];
        // Set when currying a bound function.
        newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG;
      }
      // Compose partial arguments.
      var value = source[3];
      if (value) {
        var partials = data[3];
        data[3] = partials ? composeArgs(partials, value, source[4]) : value;
        data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4];
      }
      // Compose partial right arguments.
      value = source[5];
      if (value) {
        partials = data[5];
        data[5] = partials ? composeArgsRight(partials, value, source[6]) : value;
        data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6];
      }
      // Use source `argPos` if available.
      value = source[7];
      if (value) {
        data[7] = value;
      }
      // Use source `ary` if it's smaller.
      if (srcBitmask & WRAP_ARY_FLAG) {
        data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
      }
      // Use source `arity` if one is not provided.
      if (data[9] == null) {
        data[9] = source[9];
      }
      // Use source `func` and merge bitmasks.
      data[0] = source[0];
      data[1] = newBitmask;

      return data;
    }

    /**
     * This function is like
     * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
     * except that it includes inherited enumerable properties.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     */
    function nativeKeysIn(object) {
      var result = [];
      if (object != null) {
        for (var key in Object(object)) {
          result.push(key);
        }
      }
      return result;
    }

    /**
     * Converts `value` to a string using `Object.prototype.toString`.
     *
     * @private
     * @param {*} value The value to convert.
     * @returns {string} Returns the converted string.
     */
    function objectToString(value) {
      return nativeObjectToString.call(value);
    }

    /**
     * A specialized version of `baseRest` which transforms the rest array.
     *
     * @private
     * @param {Function} func The function to apply a rest parameter to.
     * @param {number} [start=func.length-1] The start position of the rest parameter.
     * @param {Function} transform The rest array transform.
     * @returns {Function} Returns the new function.
     */
    function overRest(func, start, transform) {
      start = nativeMax(start === undefined ? (func.length - 1) : start, 0);
      return function() {
        var args = arguments,
            index = -1,
            length = nativeMax(args.length - start, 0),
            array = Array(length);

        while (++index < length) {
          array[index] = args[start + index];
        }
        index = -1;
        var otherArgs = Array(start + 1);
        while (++index < start) {
          otherArgs[index] = args[index];
        }
        otherArgs[start] = transform(array);
        return apply(func, this, otherArgs);
      };
    }

    /**
     * Gets the parent value at `path` of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array} path The path to get the parent value of.
     * @returns {*} Returns the parent value.
     */
    function parent(object, path) {
      return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));
    }

    /**
     * Reorder `array` according to the specified indexes where the element at
     * the first index is assigned as the first element, the element at
     * the second index is assigned as the second element, and so on.
     *
     * @private
     * @param {Array} array The array to reorder.
     * @param {Array} indexes The arranged array indexes.
     * @returns {Array} Returns `array`.
     */
    function reorder(array, indexes) {
      var arrLength = array.length,
          length = nativeMin(indexes.length, arrLength),
          oldArray = copyArray(array);

      while (length--) {
        var index = indexes[length];
        array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined;
      }
      return array;
    }

    /**
     * Gets the value at `key`, unless `key` is "__proto__" or "constructor".
     *
     * @private
     * @param {Object} object The object to query.
     * @param {string} key The key of the property to get.
     * @returns {*} Returns the property value.
     */
    function safeGet(object, key) {
      if (key === 'constructor' && typeof object[key] === 'function') {
        return;
      }

      if (key == '__proto__') {
        return;
      }

      return object[key];
    }

    /**
     * Sets metadata for `func`.
     *
     * **Note:** If this function becomes hot, i.e. is invoked a lot in a short
     * period of time, it will trip its breaker and transition to an identity
     * function to avoid garbage collection pauses in V8. See
     * [V8 issue 2070](https://bugs.chromium.org/p/v8/issues/detail?id=2070)
     * for more details.
     *
     * @private
     * @param {Function} func The function to associate metadata with.
     * @param {*} data The metadata.
     * @returns {Function} Returns `func`.
     */
    var setData = shortOut(baseSetData);

    /**
     * A simple wrapper around the global [`setTimeout`](https://mdn.io/setTimeout).
     *
     * @private
     * @param {Function} func The function to delay.
     * @param {number} wait The number of milliseconds to delay invocation.
     * @returns {number|Object} Returns the timer id or timeout object.
     */
    var setTimeout = ctxSetTimeout || function(func, wait) {
      return root.setTimeout(func, wait);
    };

    /**
     * Sets the `toString` method of `func` to return `string`.
     *
     * @private
     * @param {Function} func The function to modify.
     * @param {Function} string The `toString` result.
     * @returns {Function} Returns `func`.
     */
    var setToString = shortOut(baseSetToString);

    /**
     * Sets the `toString` method of `wrapper` to mimic the source of `reference`
     * with wrapper details in a comment at the top of the source body.
     *
     * @private
     * @param {Function} wrapper The function to modify.
     * @param {Function} reference The reference function.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @returns {Function} Returns `wrapper`.
     */
    function setWrapToString(wrapper, reference, bitmask) {
      var source = (reference + '');
      return setToString(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));
    }

    /**
     * Creates a function that'll short out and invoke `identity` instead
     * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
     * milliseconds.
     *
     * @private
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new shortable function.
     */
    function shortOut(func) {
      var count = 0,
          lastCalled = 0;

      return function() {
        var stamp = nativeNow(),
            remaining = HOT_SPAN - (stamp - lastCalled);

        lastCalled = stamp;
        if (remaining > 0) {
          if (++count >= HOT_COUNT) {
            return arguments[0];
          }
        } else {
          count = 0;
        }
        return func.apply(undefined, arguments);
      };
    }

    /**
     * A specialized version of `_.shuffle` which mutates and sets the size of `array`.
     *
     * @private
     * @param {Array} array The array to shuffle.
     * @param {number} [size=array.length] The size of `array`.
     * @returns {Array} Returns `array`.
     */
    function shuffleSelf(array, size) {
      var index = -1,
          length = array.length,
          lastIndex = length - 1;

      size = size === undefined ? length : size;
      while (++index < size) {
        var rand = baseRandom(index, lastIndex),
            value = array[rand];

        array[rand] = array[index];
        array[index] = value;
      }
      array.length = size;
      return array;
    }

    /**
     * Converts `string` to a property path array.
     *
     * @private
     * @param {string} string The string to convert.
     * @returns {Array} Returns the property path array.
     */
    var stringToPath = memoizeCapped(function(string) {
      var result = [];
      if (string.charCodeAt(0) === 46 /* . */) {
        result.push('');
      }
      string.replace(rePropName, function(match, number, quote, subString) {
        result.push(quote ? subString.replace(reEscapeChar, '$1') : (number || match));
      });
      return result;
    });

    /**
     * Converts `value` to a string key if it's not a string or symbol.
     *
     * @private
     * @param {*} value The value to inspect.
     * @returns {string|symbol} Returns the key.
     */
    function toKey(value) {
      if (typeof value == 'string' || isSymbol(value)) {
        return value;
      }
      var result = (value + '');
      return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
    }

    /**
     * Converts `func` to its source code.
     *
     * @private
     * @param {Function} func The function to convert.
     * @returns {string} Returns the source code.
     */
    function toSource(func) {
      if (func != null) {
        try {
          return funcToString.call(func);
        } catch (e) {}
        try {
          return (func + '');
        } catch (e) {}
      }
      return '';
    }

    /**
     * Updates wrapper `details` based on `bitmask` flags.
     *
     * @private
     * @returns {Array} details The details to modify.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @returns {Array} Returns `details`.
     */
    function updateWrapDetails(details, bitmask) {
      arrayEach(wrapFlags, function(pair) {
        var value = '_.' + pair[0];
        if ((bitmask & pair[1]) && !arrayIncludes(details, value)) {
          details.push(value);
        }
      });
      return details.sort();
    }

    /**
     * Creates a clone of `wrapper`.
     *
     * @private
     * @param {Object} wrapper The wrapper to clone.
     * @returns {Object} Returns the cloned wrapper.
     */
    function wrapperClone(wrapper) {
      if (wrapper instanceof LazyWrapper) {
        return wrapper.clone();
      }
      var result = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
      result.__actions__ = copyArray(wrapper.__actions__);
      result.__index__  = wrapper.__index__;
      result.__values__ = wrapper.__values__;
      return result;
    }

    /*------------------------------------------------------------------------*/

    /**
     * Creates an array of elements split into groups the length of `size`.
     * If `array` can't be split evenly, the final chunk will be the remaining
     * elements.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to process.
     * @param {number} [size=1] The length of each chunk
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the new array of chunks.
     * @example
     *
     * _.chunk(['a', 'b', 'c', 'd'], 2);
     * // => [['a', 'b'], ['c', 'd']]
     *
     * _.chunk(['a', 'b', 'c', 'd'], 3);
     * // => [['a', 'b', 'c'], ['d']]
     */
    function chunk(array, size, guard) {
      if ((guard ? isIterateeCall(array, size, guard) : size === undefined)) {
        size = 1;
      } else {
        size = nativeMax(toInteger(size), 0);
      }
      var length = array == null ? 0 : array.length;
      if (!length || size < 1) {
        return [];
      }
      var index = 0,
          resIndex = 0,
          result = Array(nativeCeil(length / size));

      while (index < length) {
        result[resIndex++] = baseSlice(array, index, (index += size));
      }
      return result;
    }

    /**
     * Creates an array with all falsey values removed. The values `false`, `null`,
     * `0`, `""`, `undefined`, and `NaN` are falsey.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to compact.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * _.compact([0, 1, false, 2, '', 3]);
     * // => [1, 2, 3]
     */
    function compact(array) {
      var index = -1,
          length = array == null ? 0 : array.length,
          resIndex = 0,
          result = [];

      while (++index < length) {
        var value = array[index];
        if (value) {
          result[resIndex++] = value;
        }
      }
      return result;
    }

    /**
     * Creates a new array concatenating `array` with any additional arrays
     * and/or values.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to concatenate.
     * @param {...*} [values] The values to concatenate.
     * @returns {Array} Returns the new concatenated array.
     * @example
     *
     * var array = [1];
     * var other = _.concat(array, 2, [3], [[4]]);
     *
     * console.log(other);
     * // => [1, 2, 3, [4]]
     *
     * console.log(array);
     * // => [1]
     */
    function concat() {
      var length = arguments.length;
      if (!length) {
        return [];
      }
      var args = Array(length - 1),
          array = arguments[0],
          index = length;

      while (index--) {
        args[index - 1] = arguments[index];
      }
      return arrayPush(isArray(array) ? copyArray(array) : [array], baseFlatten(args, 1));
    }

    /**
     * Creates an array of `array` values not included in the other given arrays
     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons. The order and references of result values are
     * determined by the first array.
     *
     * **Note:** Unlike `_.pullAll`, this method returns a new array.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {...Array} [values] The values to exclude.
     * @returns {Array} Returns the new array of filtered values.
     * @see _.without, _.xor
     * @example
     *
     * _.difference([2, 1], [2, 3]);
     * // => [1]
     */
    var difference = baseRest(function(array, values) {
      return isArrayLikeObject(array)
        ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true))
        : [];
    });

    /**
     * This method is like `_.difference` except that it accepts `iteratee` which
     * is invoked for each element of `array` and `values` to generate the criterion
     * by which they're compared. The order and references of result values are
     * determined by the first array. The iteratee is invoked with one argument:
     * (value).
     *
     * **Note:** Unlike `_.pullAllBy`, this method returns a new array.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {...Array} [values] The values to exclude.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * _.differenceBy([2.1, 1.2], [2.3, 3.4], Math.floor);
     * // => [1.2]
     *
     * // The `_.property` iteratee shorthand.
     * _.differenceBy([{ 'x': 2 }, { 'x': 1 }], [{ 'x': 1 }], 'x');
     * // => [{ 'x': 2 }]
     */
    var differenceBy = baseRest(function(array, values) {
      var iteratee = last(values);
      if (isArrayLikeObject(iteratee)) {
        iteratee = undefined;
      }
      return isArrayLikeObject(array)
        ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true), getIteratee(iteratee, 2))
        : [];
    });

    /**
     * This method is like `_.difference` except that it accepts `comparator`
     * which is invoked to compare elements of `array` to `values`. The order and
     * references of result values are determined by the first array. The comparator
     * is invoked with two arguments: (arrVal, othVal).
     *
     * **Note:** Unlike `_.pullAllWith`, this method returns a new array.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {...Array} [values] The values to exclude.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
     *
     * _.differenceWith(objects, [{ 'x': 1, 'y': 2 }], _.isEqual);
     * // => [{ 'x': 2, 'y': 1 }]
     */
    var differenceWith = baseRest(function(array, values) {
      var comparator = last(values);
      if (isArrayLikeObject(comparator)) {
        comparator = undefined;
      }
      return isArrayLikeObject(array)
        ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true), undefined, comparator)
        : [];
    });

    /**
     * Creates a slice of `array` with `n` elements dropped from the beginning.
     *
     * @static
     * @memberOf _
     * @since 0.5.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to drop.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.drop([1, 2, 3]);
     * // => [2, 3]
     *
     * _.drop([1, 2, 3], 2);
     * // => [3]
     *
     * _.drop([1, 2, 3], 5);
     * // => []
     *
     * _.drop([1, 2, 3], 0);
     * // => [1, 2, 3]
     */
    function drop(array, n, guard) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return [];
      }
      n = (guard || n === undefined) ? 1 : toInteger(n);
      return baseSlice(array, n < 0 ? 0 : n, length);
    }

    /**
     * Creates a slice of `array` with `n` elements dropped from the end.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to drop.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.dropRight([1, 2, 3]);
     * // => [1, 2]
     *
     * _.dropRight([1, 2, 3], 2);
     * // => [1]
     *
     * _.dropRight([1, 2, 3], 5);
     * // => []
     *
     * _.dropRight([1, 2, 3], 0);
     * // => [1, 2, 3]
     */
    function dropRight(array, n, guard) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return [];
      }
      n = (guard || n === undefined) ? 1 : toInteger(n);
      n = length - n;
      return baseSlice(array, 0, n < 0 ? 0 : n);
    }

    /**
     * Creates a slice of `array` excluding elements dropped from the end.
     * Elements are dropped until `predicate` returns falsey. The predicate is
     * invoked with three arguments: (value, index, array).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': true },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': false }
     * ];
     *
     * _.dropRightWhile(users, function(o) { return !o.active; });
     * // => objects for ['barney']
     *
     * // The `_.matches` iteratee shorthand.
     * _.dropRightWhile(users, { 'user': 'pebbles', 'active': false });
     * // => objects for ['barney', 'fred']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.dropRightWhile(users, ['active', false]);
     * // => objects for ['barney']
     *
     * // The `_.property` iteratee shorthand.
     * _.dropRightWhile(users, 'active');
     * // => objects for ['barney', 'fred', 'pebbles']
     */
    function dropRightWhile(array, predicate) {
      return (array && array.length)
        ? baseWhile(array, getIteratee(predicate, 3), true, true)
        : [];
    }

    /**
     * Creates a slice of `array` excluding elements dropped from the beginning.
     * Elements are dropped until `predicate` returns falsey. The predicate is
     * invoked with three arguments: (value, index, array).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': false },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': true }
     * ];
     *
     * _.dropWhile(users, function(o) { return !o.active; });
     * // => objects for ['pebbles']
     *
     * // The `_.matches` iteratee shorthand.
     * _.dropWhile(users, { 'user': 'barney', 'active': false });
     * // => objects for ['fred', 'pebbles']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.dropWhile(users, ['active', false]);
     * // => objects for ['pebbles']
     *
     * // The `_.property` iteratee shorthand.
     * _.dropWhile(users, 'active');
     * // => objects for ['barney', 'fred', 'pebbles']
     */
    function dropWhile(array, predicate) {
      return (array && array.length)
        ? baseWhile(array, getIteratee(predicate, 3), true)
        : [];
    }

    /**
     * Fills elements of `array` with `value` from `start` up to, but not
     * including, `end`.
     *
     * **Note:** This method mutates `array`.
     *
     * @static
     * @memberOf _
     * @since 3.2.0
     * @category Array
     * @param {Array} array The array to fill.
     * @param {*} value The value to fill `array` with.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [1, 2, 3];
     *
     * _.fill(array, 'a');
     * console.log(array);
     * // => ['a', 'a', 'a']
     *
     * _.fill(Array(3), 2);
     * // => [2, 2, 2]
     *
     * _.fill([4, 6, 8, 10], '*', 1, 3);
     * // => [4, '*', '*', 10]
     */
    function fill(array, value, start, end) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return [];
      }
      if (start && typeof start != 'number' && isIterateeCall(array, value, start)) {
        start = 0;
        end = length;
      }
      return baseFill(array, value, start, end);
    }

    /**
     * This method is like `_.find` except that it returns the index of the first
     * element `predicate` returns truthy for instead of the element itself.
     *
     * @static
     * @memberOf _
     * @since 1.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param {number} [fromIndex=0] The index to search from.
     * @returns {number} Returns the index of the found element, else `-1`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': false },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': true }
     * ];
     *
     * _.findIndex(users, function(o) { return o.user == 'barney'; });
     * // => 0
     *
     * // The `_.matches` iteratee shorthand.
     * _.findIndex(users, { 'user': 'fred', 'active': false });
     * // => 1
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.findIndex(users, ['active', false]);
     * // => 0
     *
     * // The `_.property` iteratee shorthand.
     * _.findIndex(users, 'active');
     * // => 2
     */
    function findIndex(array, predicate, fromIndex) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return -1;
      }
      var index = fromIndex == null ? 0 : toInteger(fromIndex);
      if (index < 0) {
        index = nativeMax(length + index, 0);
      }
      return baseFindIndex(array, getIteratee(predicate, 3), index);
    }

    /**
     * This method is like `_.findIndex` except that it iterates over elements
     * of `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param {number} [fromIndex=array.length-1] The index to search from.
     * @returns {number} Returns the index of the found element, else `-1`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': true },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': false }
     * ];
     *
     * _.findLastIndex(users, function(o) { return o.user == 'pebbles'; });
     * // => 2
     *
     * // The `_.matches` iteratee shorthand.
     * _.findLastIndex(users, { 'user': 'barney', 'active': true });
     * // => 0
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.findLastIndex(users, ['active', false]);
     * // => 2
     *
     * // The `_.property` iteratee shorthand.
     * _.findLastIndex(users, 'active');
     * // => 0
     */
    function findLastIndex(array, predicate, fromIndex) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return -1;
      }
      var index = length - 1;
      if (fromIndex !== undefined) {
        index = toInteger(fromIndex);
        index = fromIndex < 0
          ? nativeMax(length + index, 0)
          : nativeMin(index, length - 1);
      }
      return baseFindIndex(array, getIteratee(predicate, 3), index, true);
    }

    /**
     * Flattens `array` a single level deep.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to flatten.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * _.flatten([1, [2, [3, [4]], 5]]);
     * // => [1, 2, [3, [4]], 5]
     */
    function flatten(array) {
      var length = array == null ? 0 : array.length;
      return length ? baseFlatten(array, 1) : [];
    }

    /**
     * Recursively flattens `array`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to flatten.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * _.flattenDeep([1, [2, [3, [4]], 5]]);
     * // => [1, 2, 3, 4, 5]
     */
    function flattenDeep(array) {
      var length = array == null ? 0 : array.length;
      return length ? baseFlatten(array, INFINITY) : [];
    }

    /**
     * Recursively flatten `array` up to `depth` times.
     *
     * @static
     * @memberOf _
     * @since 4.4.0
     * @category Array
     * @param {Array} array The array to flatten.
     * @param {number} [depth=1] The maximum recursion depth.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * var array = [1, [2, [3, [4]], 5]];
     *
     * _.flattenDepth(array, 1);
     * // => [1, 2, [3, [4]], 5]
     *
     * _.flattenDepth(array, 2);
     * // => [1, 2, 3, [4], 5]
     */
    function flattenDepth(array, depth) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return [];
      }
      depth = depth === undefined ? 1 : toInteger(depth);
      return baseFlatten(array, depth);
    }

    /**
     * The inverse of `_.toPairs`; this method returns an object composed
     * from key-value `pairs`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} pairs The key-value pairs.
     * @returns {Object} Returns the new object.
     * @example
     *
     * _.fromPairs([['a', 1], ['b', 2]]);
     * // => { 'a': 1, 'b': 2 }
     */
    function fromPairs(pairs) {
      var index = -1,
          length = pairs == null ? 0 : pairs.length,
          result = {};

      while (++index < length) {
        var pair = pairs[index];
        result[pair[0]] = pair[1];
      }
      return result;
    }

    /**
     * Gets the first element of `array`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @alias first
     * @category Array
     * @param {Array} array The array to query.
     * @returns {*} Returns the first element of `array`.
     * @example
     *
     * _.head([1, 2, 3]);
     * // => 1
     *
     * _.head([]);
     * // => undefined
     */
    function head(array) {
      return (array && array.length) ? array[0] : undefined;
    }

    /**
     * Gets the index at which the first occurrence of `value` is found in `array`
     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons. If `fromIndex` is negative, it's used as the
     * offset from the end of `array`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {*} value The value to search for.
     * @param {number} [fromIndex=0] The index to search from.
     * @returns {number} Returns the index of the matched value, else `-1`.
     * @example
     *
     * _.indexOf([1, 2, 1, 2], 2);
     * // => 1
     *
     * // Search from the `fromIndex`.
     * _.indexOf([1, 2, 1, 2], 2, 2);
     * // => 3
     */
    function indexOf(array, value, fromIndex) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return -1;
      }
      var index = fromIndex == null ? 0 : toInteger(fromIndex);
      if (index < 0) {
        index = nativeMax(length + index, 0);
      }
      return baseIndexOf(array, value, index);
    }

    /**
     * Gets all but the last element of `array`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to query.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.initial([1, 2, 3]);
     * // => [1, 2]
     */
    function initial(array) {
      var length = array == null ? 0 : array.length;
      return length ? baseSlice(array, 0, -1) : [];
    }

    /**
     * Creates an array of unique values that are included in all given arrays
     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons. The order and references of result values are
     * determined by the first array.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @returns {Array} Returns the new array of intersecting values.
     * @example
     *
     * _.intersection([2, 1], [2, 3]);
     * // => [2]
     */
    var intersection = baseRest(function(arrays) {
      var mapped = arrayMap(arrays, castArrayLikeObject);
      return (mapped.length && mapped[0] === arrays[0])
        ? baseIntersection(mapped)
        : [];
    });

    /**
     * This method is like `_.intersection` except that it accepts `iteratee`
     * which is invoked for each element of each `arrays` to generate the criterion
     * by which they're compared. The order and references of result values are
     * determined by the first array. The iteratee is invoked with one argument:
     * (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns the new array of intersecting values.
     * @example
     *
     * _.intersectionBy([2.1, 1.2], [2.3, 3.4], Math.floor);
     * // => [2.1]
     *
     * // The `_.property` iteratee shorthand.
     * _.intersectionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
     * // => [{ 'x': 1 }]
     */
    var intersectionBy = baseRest(function(arrays) {
      var iteratee = last(arrays),
          mapped = arrayMap(arrays, castArrayLikeObject);

      if (iteratee === last(mapped)) {
        iteratee = undefined;
      } else {
        mapped.pop();
      }
      return (mapped.length && mapped[0] === arrays[0])
        ? baseIntersection(mapped, getIteratee(iteratee, 2))
        : [];
    });

    /**
     * This method is like `_.intersection` except that it accepts `comparator`
     * which is invoked to compare elements of `arrays`. The order and references
     * of result values are determined by the first array. The comparator is
     * invoked with two arguments: (arrVal, othVal).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of intersecting values.
     * @example
     *
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
     *
     * _.intersectionWith(objects, others, _.isEqual);
     * // => [{ 'x': 1, 'y': 2 }]
     */
    var intersectionWith = baseRest(function(arrays) {
      var comparator = last(arrays),
          mapped = arrayMap(arrays, castArrayLikeObject);

      comparator = typeof comparator == 'function' ? comparator : undefined;
      if (comparator) {
        mapped.pop();
      }
      return (mapped.length && mapped[0] === arrays[0])
        ? baseIntersection(mapped, undefined, comparator)
        : [];
    });

    /**
     * Converts all elements in `array` into a string separated by `separator`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to convert.
     * @param {string} [separator=','] The element separator.
     * @returns {string} Returns the joined string.
     * @example
     *
     * _.join(['a', 'b', 'c'], '~');
     * // => 'a~b~c'
     */
    function join(array, separator) {
      return array == null ? '' : nativeJoin.call(array, separator);
    }

    /**
     * Gets the last element of `array`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to query.
     * @returns {*} Returns the last element of `array`.
     * @example
     *
     * _.last([1, 2, 3]);
     * // => 3
     */
    function last(array) {
      var length = array == null ? 0 : array.length;
      return length ? array[length - 1] : undefined;
    }

    /**
     * This method is like `_.indexOf` except that it iterates over elements of
     * `array` from right to left.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {*} value The value to search for.
     * @param {number} [fromIndex=array.length-1] The index to search from.
     * @returns {number} Returns the index of the matched value, else `-1`.
     * @example
     *
     * _.lastIndexOf([1, 2, 1, 2], 2);
     * // => 3
     *
     * // Search from the `fromIndex`.
     * _.lastIndexOf([1, 2, 1, 2], 2, 2);
     * // => 1
     */
    function lastIndexOf(array, value, fromIndex) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return -1;
      }
      var index = length;
      if (fromIndex !== undefined) {
        index = toInteger(fromIndex);
        index = index < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
      }
      return value === value
        ? strictLastIndexOf(array, value, index)
        : baseFindIndex(array, baseIsNaN, index, true);
    }

    /**
     * Gets the element at index `n` of `array`. If `n` is negative, the nth
     * element from the end is returned.
     *
     * @static
     * @memberOf _
     * @since 4.11.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=0] The index of the element to return.
     * @returns {*} Returns the nth element of `array`.
     * @example
     *
     * var array = ['a', 'b', 'c', 'd'];
     *
     * _.nth(array, 1);
     * // => 'b'
     *
     * _.nth(array, -2);
     * // => 'c';
     */
    function nth(array, n) {
      return (array && array.length) ? baseNth(array, toInteger(n)) : undefined;
    }

    /**
     * Removes all given values from `array` using
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * **Note:** Unlike `_.without`, this method mutates `array`. Use `_.remove`
     * to remove elements from an array by predicate.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {...*} [values] The values to remove.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = ['a', 'b', 'c', 'a', 'b', 'c'];
     *
     * _.pull(array, 'a', 'c');
     * console.log(array);
     * // => ['b', 'b']
     */
    var pull = baseRest(pullAll);

    /**
     * This method is like `_.pull` except that it accepts an array of values to remove.
     *
     * **Note:** Unlike `_.difference`, this method mutates `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {Array} values The values to remove.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = ['a', 'b', 'c', 'a', 'b', 'c'];
     *
     * _.pullAll(array, ['a', 'c']);
     * console.log(array);
     * // => ['b', 'b']
     */
    function pullAll(array, values) {
      return (array && array.length && values && values.length)
        ? basePullAll(array, values)
        : array;
    }

    /**
     * This method is like `_.pullAll` except that it accepts `iteratee` which is
     * invoked for each element of `array` and `values` to generate the criterion
     * by which they're compared. The iteratee is invoked with one argument: (value).
     *
     * **Note:** Unlike `_.differenceBy`, this method mutates `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {Array} values The values to remove.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [{ 'x': 1 }, { 'x': 2 }, { 'x': 3 }, { 'x': 1 }];
     *
     * _.pullAllBy(array, [{ 'x': 1 }, { 'x': 3 }], 'x');
     * console.log(array);
     * // => [{ 'x': 2 }]
     */
    function pullAllBy(array, values, iteratee) {
      return (array && array.length && values && values.length)
        ? basePullAll(array, values, getIteratee(iteratee, 2))
        : array;
    }

    /**
     * This method is like `_.pullAll` except that it accepts `comparator` which
     * is invoked to compare elements of `array` to `values`. The comparator is
     * invoked with two arguments: (arrVal, othVal).
     *
     * **Note:** Unlike `_.differenceWith`, this method mutates `array`.
     *
     * @static
     * @memberOf _
     * @since 4.6.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {Array} values The values to remove.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [{ 'x': 1, 'y': 2 }, { 'x': 3, 'y': 4 }, { 'x': 5, 'y': 6 }];
     *
     * _.pullAllWith(array, [{ 'x': 3, 'y': 4 }], _.isEqual);
     * console.log(array);
     * // => [{ 'x': 1, 'y': 2 }, { 'x': 5, 'y': 6 }]
     */
    function pullAllWith(array, values, comparator) {
      return (array && array.length && values && values.length)
        ? basePullAll(array, values, undefined, comparator)
        : array;
    }

    /**
     * Removes elements from `array` corresponding to `indexes` and returns an
     * array of removed elements.
     *
     * **Note:** Unlike `_.at`, this method mutates `array`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {...(number|number[])} [indexes] The indexes of elements to remove.
     * @returns {Array} Returns the new array of removed elements.
     * @example
     *
     * var array = ['a', 'b', 'c', 'd'];
     * var pulled = _.pullAt(array, [1, 3]);
     *
     * console.log(array);
     * // => ['a', 'c']
     *
     * console.log(pulled);
     * // => ['b', 'd']
     */
    var pullAt = flatRest(function(array, indexes) {
      var length = array == null ? 0 : array.length,
          result = baseAt(array, indexes);

      basePullAt(array, arrayMap(indexes, function(index) {
        return isIndex(index, length) ? +index : index;
      }).sort(compareAscending));

      return result;
    });

    /**
     * Removes all elements from `array` that `predicate` returns truthy for
     * and returns an array of the removed elements. The predicate is invoked
     * with three arguments: (value, index, array).
     *
     * **Note:** Unlike `_.filter`, this method mutates `array`. Use `_.pull`
     * to pull elements from an array by value.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new array of removed elements.
     * @example
     *
     * var array = [1, 2, 3, 4];
     * var evens = _.remove(array, function(n) {
     *   return n % 2 == 0;
     * });
     *
     * console.log(array);
     * // => [1, 3]
     *
     * console.log(evens);
     * // => [2, 4]
     */
    function remove(array, predicate) {
      var result = [];
      if (!(array && array.length)) {
        return result;
      }
      var index = -1,
          indexes = [],
          length = array.length;

      predicate = getIteratee(predicate, 3);
      while (++index < length) {
        var value = array[index];
        if (predicate(value, index, array)) {
          result.push(value);
          indexes.push(index);
        }
      }
      basePullAt(array, indexes);
      return result;
    }

    /**
     * Reverses `array` so that the first element becomes the last, the second
     * element becomes the second to last, and so on.
     *
     * **Note:** This method mutates `array` and is based on
     * [`Array#reverse`](https://mdn.io/Array/reverse).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [1, 2, 3];
     *
     * _.reverse(array);
     * // => [3, 2, 1]
     *
     * console.log(array);
     * // => [3, 2, 1]
     */
    function reverse(array) {
      return array == null ? array : nativeReverse.call(array);
    }

    /**
     * Creates a slice of `array` from `start` up to, but not including, `end`.
     *
     * **Note:** This method is used instead of
     * [`Array#slice`](https://mdn.io/Array/slice) to ensure dense arrays are
     * returned.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to slice.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns the slice of `array`.
     */
    function slice(array, start, end) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return [];
      }
      if (end && typeof end != 'number' && isIterateeCall(array, start, end)) {
        start = 0;
        end = length;
      }
      else {
        start = start == null ? 0 : toInteger(start);
        end = end === undefined ? length : toInteger(end);
      }
      return baseSlice(array, start, end);
    }

    /**
     * Uses a binary search to determine the lowest index at which `value`
     * should be inserted into `array` in order to maintain its sort order.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * _.sortedIndex([30, 50], 40);
     * // => 1
     */
    function sortedIndex(array, value) {
      return baseSortedIndex(array, value);
    }

    /**
     * This method is like `_.sortedIndex` except that it accepts `iteratee`
     * which is invoked for `value` and each element of `array` to compute their
     * sort ranking. The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * var objects = [{ 'x': 4 }, { 'x': 5 }];
     *
     * _.sortedIndexBy(objects, { 'x': 4 }, function(o) { return o.x; });
     * // => 0
     *
     * // The `_.property` iteratee shorthand.
     * _.sortedIndexBy(objects, { 'x': 4 }, 'x');
     * // => 0
     */
    function sortedIndexBy(array, value, iteratee) {
      return baseSortedIndexBy(array, value, getIteratee(iteratee, 2));
    }

    /**
     * This method is like `_.indexOf` except that it performs a binary
     * search on a sorted `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {*} value The value to search for.
     * @returns {number} Returns the index of the matched value, else `-1`.
     * @example
     *
     * _.sortedIndexOf([4, 5, 5, 5, 6], 5);
     * // => 1
     */
    function sortedIndexOf(array, value) {
      var length = array == null ? 0 : array.length;
      if (length) {
        var index = baseSortedIndex(array, value);
        if (index < length && eq(array[index], value)) {
          return index;
        }
      }
      return -1;
    }

    /**
     * This method is like `_.sortedIndex` except that it returns the highest
     * index at which `value` should be inserted into `array` in order to
     * maintain its sort order.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * _.sortedLastIndex([4, 5, 5, 5, 6], 5);
     * // => 4
     */
    function sortedLastIndex(array, value) {
      return baseSortedIndex(array, value, true);
    }

    /**
     * This method is like `_.sortedLastIndex` except that it accepts `iteratee`
     * which is invoked for `value` and each element of `array` to compute their
     * sort ranking. The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * var objects = [{ 'x': 4 }, { 'x': 5 }];
     *
     * _.sortedLastIndexBy(objects, { 'x': 4 }, function(o) { return o.x; });
     * // => 1
     *
     * // The `_.property` iteratee shorthand.
     * _.sortedLastIndexBy(objects, { 'x': 4 }, 'x');
     * // => 1
     */
    function sortedLastIndexBy(array, value, iteratee) {
      return baseSortedIndexBy(array, value, getIteratee(iteratee, 2), true);
    }

    /**
     * This method is like `_.lastIndexOf` except that it performs a binary
     * search on a sorted `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {*} value The value to search for.
     * @returns {number} Returns the index of the matched value, else `-1`.
     * @example
     *
     * _.sortedLastIndexOf([4, 5, 5, 5, 6], 5);
     * // => 3
     */
    function sortedLastIndexOf(array, value) {
      var length = array == null ? 0 : array.length;
      if (length) {
        var index = baseSortedIndex(array, value, true) - 1;
        if (eq(array[index], value)) {
          return index;
        }
      }
      return -1;
    }

    /**
     * This method is like `_.uniq` except that it's designed and optimized
     * for sorted arrays.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @returns {Array} Returns the new duplicate free array.
     * @example
     *
     * _.sortedUniq([1, 1, 2]);
     * // => [1, 2]
     */
    function sortedUniq(array) {
      return (array && array.length)
        ? baseSortedUniq(array)
        : [];
    }

    /**
     * This method is like `_.uniqBy` except that it's designed and optimized
     * for sorted arrays.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @returns {Array} Returns the new duplicate free array.
     * @example
     *
     * _.sortedUniqBy([1.1, 1.2, 2.3, 2.4], Math.floor);
     * // => [1.1, 2.3]
     */
    function sortedUniqBy(array, iteratee) {
      return (array && array.length)
        ? baseSortedUniq(array, getIteratee(iteratee, 2))
        : [];
    }

    /**
     * Gets all but the first element of `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.tail([1, 2, 3]);
     * // => [2, 3]
     */
    function tail(array) {
      var length = array == null ? 0 : array.length;
      return length ? baseSlice(array, 1, length) : [];
    }

    /**
     * Creates a slice of `array` with `n` elements taken from the beginning.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to take.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.take([1, 2, 3]);
     * // => [1]
     *
     * _.take([1, 2, 3], 2);
     * // => [1, 2]
     *
     * _.take([1, 2, 3], 5);
     * // => [1, 2, 3]
     *
     * _.take([1, 2, 3], 0);
     * // => []
     */
    function take(array, n, guard) {
      if (!(array && array.length)) {
        return [];
      }
      n = (guard || n === undefined) ? 1 : toInteger(n);
      return baseSlice(array, 0, n < 0 ? 0 : n);
    }

    /**
     * Creates a slice of `array` with `n` elements taken from the end.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to take.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.takeRight([1, 2, 3]);
     * // => [3]
     *
     * _.takeRight([1, 2, 3], 2);
     * // => [2, 3]
     *
     * _.takeRight([1, 2, 3], 5);
     * // => [1, 2, 3]
     *
     * _.takeRight([1, 2, 3], 0);
     * // => []
     */
    function takeRight(array, n, guard) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return [];
      }
      n = (guard || n === undefined) ? 1 : toInteger(n);
      n = length - n;
      return baseSlice(array, n < 0 ? 0 : n, length);
    }

    /**
     * Creates a slice of `array` with elements taken from the end. Elements are
     * taken until `predicate` returns falsey. The predicate is invoked with
     * three arguments: (value, index, array).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': true },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': false }
     * ];
     *
     * _.takeRightWhile(users, function(o) { return !o.active; });
     * // => objects for ['fred', 'pebbles']
     *
     * // The `_.matches` iteratee shorthand.
     * _.takeRightWhile(users, { 'user': 'pebbles', 'active': false });
     * // => objects for ['pebbles']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.takeRightWhile(users, ['active', false]);
     * // => objects for ['fred', 'pebbles']
     *
     * // The `_.property` iteratee shorthand.
     * _.takeRightWhile(users, 'active');
     * // => []
     */
    function takeRightWhile(array, predicate) {
      return (array && array.length)
        ? baseWhile(array, getIteratee(predicate, 3), false, true)
        : [];
    }

    /**
     * Creates a slice of `array` with elements taken from the beginning. Elements
     * are taken until `predicate` returns falsey. The predicate is invoked with
     * three arguments: (value, index, array).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': false },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': true }
     * ];
     *
     * _.takeWhile(users, function(o) { return !o.active; });
     * // => objects for ['barney', 'fred']
     *
     * // The `_.matches` iteratee shorthand.
     * _.takeWhile(users, { 'user': 'barney', 'active': false });
     * // => objects for ['barney']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.takeWhile(users, ['active', false]);
     * // => objects for ['barney', 'fred']
     *
     * // The `_.property` iteratee shorthand.
     * _.takeWhile(users, 'active');
     * // => []
     */
    function takeWhile(array, predicate) {
      return (array && array.length)
        ? baseWhile(array, getIteratee(predicate, 3))
        : [];
    }

    /**
     * Creates an array of unique values, in order, from all given arrays using
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @returns {Array} Returns the new array of combined values.
     * @example
     *
     * _.union([2], [1, 2]);
     * // => [2, 1]
     */
    var union = baseRest(function(arrays) {
      return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
    });

    /**
     * This method is like `_.union` except that it accepts `iteratee` which is
     * invoked for each element of each `arrays` to generate the criterion by
     * which uniqueness is computed. Result values are chosen from the first
     * array in which the value occurs. The iteratee is invoked with one argument:
     * (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns the new array of combined values.
     * @example
     *
     * _.unionBy([2.1], [1.2, 2.3], Math.floor);
     * // => [2.1, 1.2]
     *
     * // The `_.property` iteratee shorthand.
     * _.unionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
     * // => [{ 'x': 1 }, { 'x': 2 }]
     */
    var unionBy = baseRest(function(arrays) {
      var iteratee = last(arrays);
      if (isArrayLikeObject(iteratee)) {
        iteratee = undefined;
      }
      return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), getIteratee(iteratee, 2));
    });

    /**
     * This method is like `_.union` except that it accepts `comparator` which
     * is invoked to compare elements of `arrays`. Result values are chosen from
     * the first array in which the value occurs. The comparator is invoked
     * with two arguments: (arrVal, othVal).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of combined values.
     * @example
     *
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
     *
     * _.unionWith(objects, others, _.isEqual);
     * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]
     */
    var unionWith = baseRest(function(arrays) {
      var comparator = last(arrays);
      comparator = typeof comparator == 'function' ? comparator : undefined;
      return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined, comparator);
    });

    /**
     * Creates a duplicate-free version of an array, using
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons, in which only the first occurrence of each element
     * is kept. The order of result values is determined by the order they occur
     * in the array.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @returns {Array} Returns the new duplicate free array.
     * @example
     *
     * _.uniq([2, 1, 2]);
     * // => [2, 1]
     */
    function uniq(array) {
      return (array && array.length) ? baseUniq(array) : [];
    }

    /**
     * This method is like `_.uniq` except that it accepts `iteratee` which is
     * invoked for each element in `array` to generate the criterion by which
     * uniqueness is computed. The order of result values is determined by the
     * order they occur in the array. The iteratee is invoked with one argument:
     * (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns the new duplicate free array.
     * @example
     *
     * _.uniqBy([2.1, 1.2, 2.3], Math.floor);
     * // => [2.1, 1.2]
     *
     * // The `_.property` iteratee shorthand.
     * _.uniqBy([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');
     * // => [{ 'x': 1 }, { 'x': 2 }]
     */
    function uniqBy(array, iteratee) {
      return (array && array.length) ? baseUniq(array, getIteratee(iteratee, 2)) : [];
    }

    /**
     * This method is like `_.uniq` except that it accepts `comparator` which
     * is invoked to compare elements of `array`. The order of result values is
     * determined by the order they occur in the array.The comparator is invoked
     * with two arguments: (arrVal, othVal).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new duplicate free array.
     * @example
     *
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 2 }];
     *
     * _.uniqWith(objects, _.isEqual);
     * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }]
     */
    function uniqWith(array, comparator) {
      comparator = typeof comparator == 'function' ? comparator : undefined;
      return (array && array.length) ? baseUniq(array, undefined, comparator) : [];
    }

    /**
     * This method is like `_.zip` except that it accepts an array of grouped
     * elements and creates an array regrouping the elements to their pre-zip
     * configuration.
     *
     * @static
     * @memberOf _
     * @since 1.2.0
     * @category Array
     * @param {Array} array The array of grouped elements to process.
     * @returns {Array} Returns the new array of regrouped elements.
     * @example
     *
     * var zipped = _.zip(['a', 'b'], [1, 2], [true, false]);
     * // => [['a', 1, true], ['b', 2, false]]
     *
     * _.unzip(zipped);
     * // => [['a', 'b'], [1, 2], [true, false]]
     */
    function unzip(array) {
      if (!(array && array.length)) {
        return [];
      }
      var length = 0;
      array = arrayFilter(array, function(group) {
        if (isArrayLikeObject(group)) {
          length = nativeMax(group.length, length);
          return true;
        }
      });
      return baseTimes(length, function(index) {
        return arrayMap(array, baseProperty(index));
      });
    }

    /**
     * This method is like `_.unzip` except that it accepts `iteratee` to specify
     * how regrouped values should be combined. The iteratee is invoked with the
     * elements of each group: (...group).
     *
     * @static
     * @memberOf _
     * @since 3.8.0
     * @category Array
     * @param {Array} array The array of grouped elements to process.
     * @param {Function} [iteratee=_.identity] The function to combine
     *  regrouped values.
     * @returns {Array} Returns the new array of regrouped elements.
     * @example
     *
     * var zipped = _.zip([1, 2], [10, 20], [100, 200]);
     * // => [[1, 10, 100], [2, 20, 200]]
     *
     * _.unzipWith(zipped, _.add);
     * // => [3, 30, 300]
     */
    function unzipWith(array, iteratee) {
      if (!(array && array.length)) {
        return [];
      }
      var result = unzip(array);
      if (iteratee == null) {
        return result;
      }
      return arrayMap(result, function(group) {
        return apply(iteratee, undefined, group);
      });
    }

    /**
     * Creates an array excluding all given values using
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * **Note:** Unlike `_.pull`, this method returns a new array.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {...*} [values] The values to exclude.
     * @returns {Array} Returns the new array of filtered values.
     * @see _.difference, _.xor
     * @example
     *
     * _.without([2, 1, 2, 3], 1, 2);
     * // => [3]
     */
    var without = baseRest(function(array, values) {
      return isArrayLikeObject(array)
        ? baseDifference(array, values)
        : [];
    });

    /**
     * Creates an array of unique values that is the
     * [symmetric difference](https://en.wikipedia.org/wiki/Symmetric_difference)
     * of the given arrays. The order of result values is determined by the order
     * they occur in the arrays.
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @returns {Array} Returns the new array of filtered values.
     * @see _.difference, _.without
     * @example
     *
     * _.xor([2, 1], [2, 3]);
     * // => [1, 3]
     */
    var xor = baseRest(function(arrays) {
      return baseXor(arrayFilter(arrays, isArrayLikeObject));
    });

    /**
     * This method is like `_.xor` except that it accepts `iteratee` which is
     * invoked for each element of each `arrays` to generate the criterion by
     * which by which they're compared. The order of result values is determined
     * by the order they occur in the arrays. The iteratee is invoked with one
     * argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * _.xorBy([2.1, 1.2], [2.3, 3.4], Math.floor);
     * // => [1.2, 3.4]
     *
     * // The `_.property` iteratee shorthand.
     * _.xorBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
     * // => [{ 'x': 2 }]
     */
    var xorBy = baseRest(function(arrays) {
      var iteratee = last(arrays);
      if (isArrayLikeObject(iteratee)) {
        iteratee = undefined;
      }
      return baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee, 2));
    });

    /**
     * This method is like `_.xor` except that it accepts `comparator` which is
     * invoked to compare elements of `arrays`. The order of result values is
     * determined by the order they occur in the arrays. The comparator is invoked
     * with two arguments: (arrVal, othVal).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
     *
     * _.xorWith(objects, others, _.isEqual);
     * // => [{ 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]
     */
    var xorWith = baseRest(function(arrays) {
      var comparator = last(arrays);
      comparator = typeof comparator == 'function' ? comparator : undefined;
      return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined, comparator);
    });

    /**
     * Creates an array of grouped elements, the first of which contains the
     * first elements of the given arrays, the second of which contains the
     * second elements of the given arrays, and so on.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {...Array} [arrays] The arrays to process.
     * @returns {Array} Returns the new array of grouped elements.
     * @example
     *
     * _.zip(['a', 'b'], [1, 2], [true, false]);
     * // => [['a', 1, true], ['b', 2, false]]
     */
    var zip = baseRest(unzip);

    /**
     * This method is like `_.fromPairs` except that it accepts two arrays,
     * one of property identifiers and one of corresponding values.
     *
     * @static
     * @memberOf _
     * @since 0.4.0
     * @category Array
     * @param {Array} [props=[]] The property identifiers.
     * @param {Array} [values=[]] The property values.
     * @returns {Object} Returns the new object.
     * @example
     *
     * _.zipObject(['a', 'b'], [1, 2]);
     * // => { 'a': 1, 'b': 2 }
     */
    function zipObject(props, values) {
      return baseZipObject(props || [], values || [], assignValue);
    }

    /**
     * This method is like `_.zipObject` except that it supports property paths.
     *
     * @static
     * @memberOf _
     * @since 4.1.0
     * @category Array
     * @param {Array} [props=[]] The property identifiers.
     * @param {Array} [values=[]] The property values.
     * @returns {Object} Returns the new object.
     * @example
     *
     * _.zipObjectDeep(['a.b[0].c', 'a.b[1].d'], [1, 2]);
     * // => { 'a': { 'b': [{ 'c': 1 }, { 'd': 2 }] } }
     */
    function zipObjectDeep(props, values) {
      return baseZipObject(props || [], values || [], baseSet);
    }

    /**
     * This method is like `_.zip` except that it accepts `iteratee` to specify
     * how grouped values should be combined. The iteratee is invoked with the
     * elements of each group: (...group).
     *
     * @static
     * @memberOf _
     * @since 3.8.0
     * @category Array
     * @param {...Array} [arrays] The arrays to process.
     * @param {Function} [iteratee=_.identity] The function to combine
     *  grouped values.
     * @returns {Array} Returns the new array of grouped elements.
     * @example
     *
     * _.zipWith([1, 2], [10, 20], [100, 200], function(a, b, c) {
     *   return a + b + c;
     * });
     * // => [111, 222]
     */
    var zipWith = baseRest(function(arrays) {
      var length = arrays.length,
          iteratee = length > 1 ? arrays[length - 1] : undefined;

      iteratee = typeof iteratee == 'function' ? (arrays.pop(), iteratee) : undefined;
      return unzipWith(arrays, iteratee);
    });

    /*------------------------------------------------------------------------*/

    /**
     * Creates a `lodash` wrapper instance that wraps `value` with explicit method
     * chain sequences enabled. The result of such sequences must be unwrapped
     * with `_#value`.
     *
     * @static
     * @memberOf _
     * @since 1.3.0
     * @category Seq
     * @param {*} value The value to wrap.
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'age': 36 },
     *   { 'user': 'fred',    'age': 40 },
     *   { 'user': 'pebbles', 'age': 1 }
     * ];
     *
     * var youngest = _
     *   .chain(users)
     *   .sortBy('age')
     *   .map(function(o) {
     *     return o.user + ' is ' + o.age;
     *   })
     *   .head()
     *   .value();
     * // => 'pebbles is 1'
     */
    function chain(value) {
      var result = lodash(value);
      result.__chain__ = true;
      return result;
    }

    /**
     * This method invokes `interceptor` and returns `value`. The interceptor
     * is invoked with one argument; (value). The purpose of this method is to
     * "tap into" a method chain sequence in order to modify intermediate results.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Seq
     * @param {*} value The value to provide to `interceptor`.
     * @param {Function} interceptor The function to invoke.
     * @returns {*} Returns `value`.
     * @example
     *
     * _([1, 2, 3])
     *  .tap(function(array) {
     *    // Mutate input array.
     *    array.pop();
     *  })
     *  .reverse()
     *  .value();
     * // => [2, 1]
     */
    function tap(value, interceptor) {
      interceptor(value);
      return value;
    }

    /**
     * This method is like `_.tap` except that it returns the result of `interceptor`.
     * The purpose of this method is to "pass thru" values replacing intermediate
     * results in a method chain sequence.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Seq
     * @param {*} value The value to provide to `interceptor`.
     * @param {Function} interceptor The function to invoke.
     * @returns {*} Returns the result of `interceptor`.
     * @example
     *
     * _('  abc  ')
     *  .chain()
     *  .trim()
     *  .thru(function(value) {
     *    return [value];
     *  })
     *  .value();
     * // => ['abc']
     */
    function thru(value, interceptor) {
      return interceptor(value);
    }

    /**
     * This method is the wrapper version of `_.at`.
     *
     * @name at
     * @memberOf _
     * @since 1.0.0
     * @category Seq
     * @param {...(string|string[])} [paths] The property paths to pick.
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }, 4] };
     *
     * _(object).at(['a[0].b.c', 'a[1]']).value();
     * // => [3, 4]
     */
    var wrapperAt = flatRest(function(paths) {
      var length = paths.length,
          start = length ? paths[0] : 0,
          value = this.__wrapped__,
          interceptor = function(object) { return baseAt(object, paths); };

      if (length > 1 || this.__actions__.length ||
          !(value instanceof LazyWrapper) || !isIndex(start)) {
        return this.thru(interceptor);
      }
      value = value.slice(start, +start + (length ? 1 : 0));
      value.__actions__.push({
        'func': thru,
        'args': [interceptor],
        'thisArg': undefined
      });
      return new LodashWrapper(value, this.__chain__).thru(function(array) {
        if (length && !array.length) {
          array.push(undefined);
        }
        return array;
      });
    });

    /**
     * Creates a `lodash` wrapper instance with explicit method chain sequences enabled.
     *
     * @name chain
     * @memberOf _
     * @since 0.1.0
     * @category Seq
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36 },
     *   { 'user': 'fred',   'age': 40 }
     * ];
     *
     * // A sequence without explicit chaining.
     * _(users).head();
     * // => { 'user': 'barney', 'age': 36 }
     *
     * // A sequence with explicit chaining.
     * _(users)
     *   .chain()
     *   .head()
     *   .pick('user')
     *   .value();
     * // => { 'user': 'barney' }
     */
    function wrapperChain() {
      return chain(this);
    }

    /**
     * Executes the chain sequence and returns the wrapped result.
     *
     * @name commit
     * @memberOf _
     * @since 3.2.0
     * @category Seq
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var array = [1, 2];
     * var wrapped = _(array).push(3);
     *
     * console.log(array);
     * // => [1, 2]
     *
     * wrapped = wrapped.commit();
     * console.log(array);
     * // => [1, 2, 3]
     *
     * wrapped.last();
     * // => 3
     *
     * console.log(array);
     * // => [1, 2, 3]
     */
    function wrapperCommit() {
      return new LodashWrapper(this.value(), this.__chain__);
    }

    /**
     * Gets the next value on a wrapped object following the
     * [iterator protocol](https://mdn.io/iteration_protocols#iterator).
     *
     * @name next
     * @memberOf _
     * @since 4.0.0
     * @category Seq
     * @returns {Object} Returns the next iterator value.
     * @example
     *
     * var wrapped = _([1, 2]);
     *
     * wrapped.next();
     * // => { 'done': false, 'value': 1 }
     *
     * wrapped.next();
     * // => { 'done': false, 'value': 2 }
     *
     * wrapped.next();
     * // => { 'done': true, 'value': undefined }
     */
    function wrapperNext() {
      if (this.__values__ === undefined) {
        this.__values__ = toArray(this.value());
      }
      var done = this.__index__ >= this.__values__.length,
          value = done ? undefined : this.__values__[this.__index__++];

      return { 'done': done, 'value': value };
    }

    /**
     * Enables the wrapper to be iterable.
     *
     * @name Symbol.iterator
     * @memberOf _
     * @since 4.0.0
     * @category Seq
     * @returns {Object} Returns the wrapper object.
     * @example
     *
     * var wrapped = _([1, 2]);
     *
     * wrapped[Symbol.iterator]() === wrapped;
     * // => true
     *
     * Array.from(wrapped);
     * // => [1, 2]
     */
    function wrapperToIterator() {
      return this;
    }

    /**
     * Creates a clone of the chain sequence planting `value` as the wrapped value.
     *
     * @name plant
     * @memberOf _
     * @since 3.2.0
     * @category Seq
     * @param {*} value The value to plant.
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var wrapped = _([1, 2]).map(square);
     * var other = wrapped.plant([3, 4]);
     *
     * other.value();
     * // => [9, 16]
     *
     * wrapped.value();
     * // => [1, 4]
     */
    function wrapperPlant(value) {
      var result,
          parent = this;

      while (parent instanceof baseLodash) {
        var clone = wrapperClone(parent);
        clone.__index__ = 0;
        clone.__values__ = undefined;
        if (result) {
          previous.__wrapped__ = clone;
        } else {
          result = clone;
        }
        var previous = clone;
        parent = parent.__wrapped__;
      }
      previous.__wrapped__ = value;
      return result;
    }

    /**
     * This method is the wrapper version of `_.reverse`.
     *
     * **Note:** This method mutates the wrapped array.
     *
     * @name reverse
     * @memberOf _
     * @since 0.1.0
     * @category Seq
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var array = [1, 2, 3];
     *
     * _(array).reverse().value()
     * // => [3, 2, 1]
     *
     * console.log(array);
     * // => [3, 2, 1]
     */
    function wrapperReverse() {
      var value = this.__wrapped__;
      if (value instanceof LazyWrapper) {
        var wrapped = value;
        if (this.__actions__.length) {
          wrapped = new LazyWrapper(this);
        }
        wrapped = wrapped.reverse();
        wrapped.__actions__.push({
          'func': thru,
          'args': [reverse],
          'thisArg': undefined
        });
        return new LodashWrapper(wrapped, this.__chain__);
      }
      return this.thru(reverse);
    }

    /**
     * Executes the chain sequence to resolve the unwrapped value.
     *
     * @name value
     * @memberOf _
     * @since 0.1.0
     * @alias toJSON, valueOf
     * @category Seq
     * @returns {*} Returns the resolved unwrapped value.
     * @example
     *
     * _([1, 2, 3]).value();
     * // => [1, 2, 3]
     */
    function wrapperValue() {
      return baseWrapperValue(this.__wrapped__, this.__actions__);
    }

    /*------------------------------------------------------------------------*/

    /**
     * Creates an object composed of keys generated from the results of running
     * each element of `collection` thru `iteratee`. The corresponding value of
     * each key is the number of times the key was returned by `iteratee`. The
     * iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 0.5.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * _.countBy([6.1, 4.2, 6.3], Math.floor);
     * // => { '4': 1, '6': 2 }
     *
     * // The `_.property` iteratee shorthand.
     * _.countBy(['one', 'two', 'three'], 'length');
     * // => { '3': 2, '5': 1 }
     */
    var countBy = createAggregator(function(result, value, key) {
      if (hasOwnProperty.call(result, key)) {
        ++result[key];
      } else {
        baseAssignValue(result, key, 1);
      }
    });

    /**
     * Checks if `predicate` returns truthy for **all** elements of `collection`.
     * Iteration is stopped once `predicate` returns falsey. The predicate is
     * invoked with three arguments: (value, index|key, collection).
     *
     * **Note:** This method returns `true` for
     * [empty collections](https://en.wikipedia.org/wiki/Empty_set) because
     * [everything is true](https://en.wikipedia.org/wiki/Vacuous_truth) of
     * elements of empty collections.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {boolean} Returns `true` if all elements pass the predicate check,
     *  else `false`.
     * @example
     *
     * _.every([true, 1, null, 'yes'], Boolean);
     * // => false
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': false },
     *   { 'user': 'fred',   'age': 40, 'active': false }
     * ];
     *
     * // The `_.matches` iteratee shorthand.
     * _.every(users, { 'user': 'barney', 'active': false });
     * // => false
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.every(users, ['active', false]);
     * // => true
     *
     * // The `_.property` iteratee shorthand.
     * _.every(users, 'active');
     * // => false
     */
    function every(collection, predicate, guard) {
      var func = isArray(collection) ? arrayEvery : baseEvery;
      if (guard && isIterateeCall(collection, predicate, guard)) {
        predicate = undefined;
      }
      return func(collection, getIteratee(predicate, 3));
    }

    /**
     * Iterates over elements of `collection`, returning an array of all elements
     * `predicate` returns truthy for. The predicate is invoked with three
     * arguments: (value, index|key, collection).
     *
     * **Note:** Unlike `_.remove`, this method returns a new array.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new filtered array.
     * @see _.reject
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': true },
     *   { 'user': 'fred',   'age': 40, 'active': false }
     * ];
     *
     * _.filter(users, function(o) { return !o.active; });
     * // => objects for ['fred']
     *
     * // The `_.matches` iteratee shorthand.
     * _.filter(users, { 'age': 36, 'active': true });
     * // => objects for ['barney']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.filter(users, ['active', false]);
     * // => objects for ['fred']
     *
     * // The `_.property` iteratee shorthand.
     * _.filter(users, 'active');
     * // => objects for ['barney']
     *
     * // Combining several predicates using `_.overEvery` or `_.overSome`.
     * _.filter(users, _.overSome([{ 'age': 36 }, ['age', 40]]));
     * // => objects for ['fred', 'barney']
     */
    function filter(collection, predicate) {
      var func = isArray(collection) ? arrayFilter : baseFilter;
      return func(collection, getIteratee(predicate, 3));
    }

    /**
     * Iterates over elements of `collection`, returning the first element
     * `predicate` returns truthy for. The predicate is invoked with three
     * arguments: (value, index|key, collection).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param {number} [fromIndex=0] The index to search from.
     * @returns {*} Returns the matched element, else `undefined`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'age': 36, 'active': true },
     *   { 'user': 'fred',    'age': 40, 'active': false },
     *   { 'user': 'pebbles', 'age': 1,  'active': true }
     * ];
     *
     * _.find(users, function(o) { return o.age < 40; });
     * // => object for 'barney'
     *
     * // The `_.matches` iteratee shorthand.
     * _.find(users, { 'age': 1, 'active': true });
     * // => object for 'pebbles'
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.find(users, ['active', false]);
     * // => object for 'fred'
     *
     * // The `_.property` iteratee shorthand.
     * _.find(users, 'active');
     * // => object for 'barney'
     */
    var find = createFind(findIndex);

    /**
     * This method is like `_.find` except that it iterates over elements of
     * `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param {number} [fromIndex=collection.length-1] The index to search from.
     * @returns {*} Returns the matched element, else `undefined`.
     * @example
     *
     * _.findLast([1, 2, 3, 4], function(n) {
     *   return n % 2 == 1;
     * });
     * // => 3
     */
    var findLast = createFind(findLastIndex);

    /**
     * Creates a flattened array of values by running each element in `collection`
     * thru `iteratee` and flattening the mapped results. The iteratee is invoked
     * with three arguments: (value, index|key, collection).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * function duplicate(n) {
     *   return [n, n];
     * }
     *
     * _.flatMap([1, 2], duplicate);
     * // => [1, 1, 2, 2]
     */
    function flatMap(collection, iteratee) {
      return baseFlatten(map(collection, iteratee), 1);
    }

    /**
     * This method is like `_.flatMap` except that it recursively flattens the
     * mapped results.
     *
     * @static
     * @memberOf _
     * @since 4.7.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * function duplicate(n) {
     *   return [[[n, n]]];
     * }
     *
     * _.flatMapDeep([1, 2], duplicate);
     * // => [1, 1, 2, 2]
     */
    function flatMapDeep(collection, iteratee) {
      return baseFlatten(map(collection, iteratee), INFINITY);
    }

    /**
     * This method is like `_.flatMap` except that it recursively flattens the
     * mapped results up to `depth` times.
     *
     * @static
     * @memberOf _
     * @since 4.7.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {number} [depth=1] The maximum recursion depth.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * function duplicate(n) {
     *   return [[[n, n]]];
     * }
     *
     * _.flatMapDepth([1, 2], duplicate, 2);
     * // => [[1, 1], [2, 2]]
     */
    function flatMapDepth(collection, iteratee, depth) {
      depth = depth === undefined ? 1 : toInteger(depth);
      return baseFlatten(map(collection, iteratee), depth);
    }

    /**
     * Iterates over elements of `collection` and invokes `iteratee` for each element.
     * The iteratee is invoked with three arguments: (value, index|key, collection).
     * Iteratee functions may exit iteration early by explicitly returning `false`.
     *
     * **Note:** As with other "Collections" methods, objects with a "length"
     * property are iterated like arrays. To avoid this behavior use `_.forIn`
     * or `_.forOwn` for object iteration.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @alias each
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array|Object} Returns `collection`.
     * @see _.forEachRight
     * @example
     *
     * _.forEach([1, 2], function(value) {
     *   console.log(value);
     * });
     * // => Logs `1` then `2`.
     *
     * _.forEach({ 'a': 1, 'b': 2 }, function(value, key) {
     *   console.log(key);
     * });
     * // => Logs 'a' then 'b' (iteration order is not guaranteed).
     */
    function forEach(collection, iteratee) {
      var func = isArray(collection) ? arrayEach : baseEach;
      return func(collection, getIteratee(iteratee, 3));
    }

    /**
     * This method is like `_.forEach` except that it iterates over elements of
     * `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @alias eachRight
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array|Object} Returns `collection`.
     * @see _.forEach
     * @example
     *
     * _.forEachRight([1, 2], function(value) {
     *   console.log(value);
     * });
     * // => Logs `2` then `1`.
     */
    function forEachRight(collection, iteratee) {
      var func = isArray(collection) ? arrayEachRight : baseEachRight;
      return func(collection, getIteratee(iteratee, 3));
    }

    /**
     * Creates an object composed of keys generated from the results of running
     * each element of `collection` thru `iteratee`. The order of grouped values
     * is determined by the order they occur in `collection`. The corresponding
     * value of each key is an array of elements responsible for generating the
     * key. The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * _.groupBy([6.1, 4.2, 6.3], Math.floor);
     * // => { '4': [4.2], '6': [6.1, 6.3] }
     *
     * // The `_.property` iteratee shorthand.
     * _.groupBy(['one', 'two', 'three'], 'length');
     * // => { '3': ['one', 'two'], '5': ['three'] }
     */
    var groupBy = createAggregator(function(result, value, key) {
      if (hasOwnProperty.call(result, key)) {
        result[key].push(value);
      } else {
        baseAssignValue(result, key, [value]);
      }
    });

    /**
     * Checks if `value` is in `collection`. If `collection` is a string, it's
     * checked for a substring of `value`, otherwise
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * is used for equality comparisons. If `fromIndex` is negative, it's used as
     * the offset from the end of `collection`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object|string} collection The collection to inspect.
     * @param {*} value The value to search for.
     * @param {number} [fromIndex=0] The index to search from.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.
     * @returns {boolean} Returns `true` if `value` is found, else `false`.
     * @example
     *
     * _.includes([1, 2, 3], 1);
     * // => true
     *
     * _.includes([1, 2, 3], 1, 2);
     * // => false
     *
     * _.includes({ 'a': 1, 'b': 2 }, 1);
     * // => true
     *
     * _.includes('abcd', 'bc');
     * // => true
     */
    function includes(collection, value, fromIndex, guard) {
      collection = isArrayLike(collection) ? collection : values(collection);
      fromIndex = (fromIndex && !guard) ? toInteger(fromIndex) : 0;

      var length = collection.length;
      if (fromIndex < 0) {
        fromIndex = nativeMax(length + fromIndex, 0);
      }
      return isString(collection)
        ? (fromIndex <= length && collection.indexOf(value, fromIndex) > -1)
        : (!!length && baseIndexOf(collection, value, fromIndex) > -1);
    }

    /**
     * Invokes the method at `path` of each element in `collection`, returning
     * an array of the results of each invoked method. Any additional arguments
     * are provided to each invoked method. If `path` is a function, it's invoked
     * for, and `this` bound to, each element in `collection`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Array|Function|string} path The path of the method to invoke or
     *  the function invoked per iteration.
     * @param {...*} [args] The arguments to invoke each method with.
     * @returns {Array} Returns the array of results.
     * @example
     *
     * _.invokeMap([[5, 1, 7], [3, 2, 1]], 'sort');
     * // => [[1, 5, 7], [1, 2, 3]]
     *
     * _.invokeMap([123, 456], String.prototype.split, '');
     * // => [['1', '2', '3'], ['4', '5', '6']]
     */
    var invokeMap = baseRest(function(collection, path, args) {
      var index = -1,
          isFunc = typeof path == 'function',
          result = isArrayLike(collection) ? Array(collection.length) : [];

      baseEach(collection, function(value) {
        result[++index] = isFunc ? apply(path, value, args) : baseInvoke(value, path, args);
      });
      return result;
    });

    /**
     * Creates an object composed of keys generated from the results of running
     * each element of `collection` thru `iteratee`. The corresponding value of
     * each key is the last element responsible for generating the key. The
     * iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * var array = [
     *   { 'dir': 'left', 'code': 97 },
     *   { 'dir': 'right', 'code': 100 }
     * ];
     *
     * _.keyBy(array, function(o) {
     *   return String.fromCharCode(o.code);
     * });
     * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
     *
     * _.keyBy(array, 'dir');
     * // => { 'left': { 'dir': 'left', 'code': 97 }, 'right': { 'dir': 'right', 'code': 100 } }
     */
    var keyBy = createAggregator(function(result, value, key) {
      baseAssignValue(result, key, value);
    });

    /**
     * Creates an array of values by running each element in `collection` thru
     * `iteratee`. The iteratee is invoked with three arguments:
     * (value, index|key, collection).
     *
     * Many lodash methods are guarded to work as iteratees for methods like
     * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.
     *
     * The guarded methods are:
     * `ary`, `chunk`, `curry`, `curryRight`, `drop`, `dropRight`, `every`,
     * `fill`, `invert`, `parseInt`, `random`, `range`, `rangeRight`, `repeat`,
     * `sampleSize`, `slice`, `some`, `sortBy`, `split`, `take`, `takeRight`,
     * `template`, `trim`, `trimEnd`, `trimStart`, and `words`
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new mapped array.
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * _.map([4, 8], square);
     * // => [16, 64]
     *
     * _.map({ 'a': 4, 'b': 8 }, square);
     * // => [16, 64] (iteration order is not guaranteed)
     *
     * var users = [
     *   { 'user': 'barney' },
     *   { 'user': 'fred' }
     * ];
     *
     * // The `_.property` iteratee shorthand.
     * _.map(users, 'user');
     * // => ['barney', 'fred']
     */
    function map(collection, iteratee) {
      var func = isArray(collection) ? arrayMap : baseMap;
      return func(collection, getIteratee(iteratee, 3));
    }

    /**
     * This method is like `_.sortBy` except that it allows specifying the sort
     * orders of the iteratees to sort by. If `orders` is unspecified, all values
     * are sorted in ascending order. Otherwise, specify an order of "desc" for
     * descending or "asc" for ascending sort order of corresponding values.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Array[]|Function[]|Object[]|string[]} [iteratees=[_.identity]]
     *  The iteratees to sort by.
     * @param {string[]} [orders] The sort orders of `iteratees`.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.
     * @returns {Array} Returns the new sorted array.
     * @example
     *
     * var users = [
     *   { 'user': 'fred',   'age': 48 },
     *   { 'user': 'barney', 'age': 34 },
     *   { 'user': 'fred',   'age': 40 },
     *   { 'user': 'barney', 'age': 36 }
     * ];
     *
     * // Sort by `user` in ascending order and by `age` in descending order.
     * _.orderBy(users, ['user', 'age'], ['asc', 'desc']);
     * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 40]]
     */
    function orderBy(collection, iteratees, orders, guard) {
      if (collection == null) {
        return [];
      }
      if (!isArray(iteratees)) {
        iteratees = iteratees == null ? [] : [iteratees];
      }
      orders = guard ? undefined : orders;
      if (!isArray(orders)) {
        orders = orders == null ? [] : [orders];
      }
      return baseOrderBy(collection, iteratees, orders);
    }

    /**
     * Creates an array of elements split into two groups, the first of which
     * contains elements `predicate` returns truthy for, the second of which
     * contains elements `predicate` returns falsey for. The predicate is
     * invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the array of grouped elements.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'age': 36, 'active': false },
     *   { 'user': 'fred',    'age': 40, 'active': true },
     *   { 'user': 'pebbles', 'age': 1,  'active': false }
     * ];
     *
     * _.partition(users, function(o) { return o.active; });
     * // => objects for [['fred'], ['barney', 'pebbles']]
     *
     * // The `_.matches` iteratee shorthand.
     * _.partition(users, { 'age': 1, 'active': false });
     * // => objects for [['pebbles'], ['barney', 'fred']]
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.partition(users, ['active', false]);
     * // => objects for [['barney', 'pebbles'], ['fred']]
     *
     * // The `_.property` iteratee shorthand.
     * _.partition(users, 'active');
     * // => objects for [['fred'], ['barney', 'pebbles']]
     */
    var partition = createAggregator(function(result, value, key) {
      result[key ? 0 : 1].push(value);
    }, function() { return [[], []]; });

    /**
     * Reduces `collection` to a value which is the accumulated result of running
     * each element in `collection` thru `iteratee`, where each successive
     * invocation is supplied the return value of the previous. If `accumulator`
     * is not given, the first element of `collection` is used as the initial
     * value. The iteratee is invoked with four arguments:
     * (accumulator, value, index|key, collection).
     *
     * Many lodash methods are guarded to work as iteratees for methods like
     * `_.reduce`, `_.reduceRight`, and `_.transform`.
     *
     * The guarded methods are:
     * `assign`, `defaults`, `defaultsDeep`, `includes`, `merge`, `orderBy`,
     * and `sortBy`
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [accumulator] The initial value.
     * @returns {*} Returns the accumulated value.
     * @see _.reduceRight
     * @example
     *
     * _.reduce([1, 2], function(sum, n) {
     *   return sum + n;
     * }, 0);
     * // => 3
     *
     * _.reduce({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {
     *   (result[value] || (result[value] = [])).push(key);
     *   return result;
     * }, {});
     * // => { '1': ['a', 'c'], '2': ['b'] } (iteration order is not guaranteed)
     */
    function reduce(collection, iteratee, accumulator) {
      var func = isArray(collection) ? arrayReduce : baseReduce,
          initAccum = arguments.length < 3;

      return func(collection, getIteratee(iteratee, 4), accumulator, initAccum, baseEach);
    }

    /**
     * This method is like `_.reduce` except that it iterates over elements of
     * `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [accumulator] The initial value.
     * @returns {*} Returns the accumulated value.
     * @see _.reduce
     * @example
     *
     * var array = [[0, 1], [2, 3], [4, 5]];
     *
     * _.reduceRight(array, function(flattened, other) {
     *   return flattened.concat(other);
     * }, []);
     * // => [4, 5, 2, 3, 0, 1]
     */
    function reduceRight(collection, iteratee, accumulator) {
      var func = isArray(collection) ? arrayReduceRight : baseReduce,
          initAccum = arguments.length < 3;

      return func(collection, getIteratee(iteratee, 4), accumulator, initAccum, baseEachRight);
    }

    /**
     * The opposite of `_.filter`; this method returns the elements of `collection`
     * that `predicate` does **not** return truthy for.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new filtered array.
     * @see _.filter
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': false },
     *   { 'user': 'fred',   'age': 40, 'active': true }
     * ];
     *
     * _.reject(users, function(o) { return !o.active; });
     * // => objects for ['fred']
     *
     * // The `_.matches` iteratee shorthand.
     * _.reject(users, { 'age': 40, 'active': true });
     * // => objects for ['barney']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.reject(users, ['active', false]);
     * // => objects for ['fred']
     *
     * // The `_.property` iteratee shorthand.
     * _.reject(users, 'active');
     * // => objects for ['barney']
     */
    function reject(collection, predicate) {
      var func = isArray(collection) ? arrayFilter : baseFilter;
      return func(collection, negate(getIteratee(predicate, 3)));
    }

    /**
     * Gets a random element from `collection`.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to sample.
     * @returns {*} Returns the random element.
     * @example
     *
     * _.sample([1, 2, 3, 4]);
     * // => 2
     */
    function sample(collection) {
      var func = isArray(collection) ? arraySample : baseSample;
      return func(collection);
    }

    /**
     * Gets `n` random elements at unique keys from `collection` up to the
     * size of `collection`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to sample.
     * @param {number} [n=1] The number of elements to sample.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the random elements.
     * @example
     *
     * _.sampleSize([1, 2, 3], 2);
     * // => [3, 1]
     *
     * _.sampleSize([1, 2, 3], 4);
     * // => [2, 3, 1]
     */
    function sampleSize(collection, n, guard) {
      if ((guard ? isIterateeCall(collection, n, guard) : n === undefined)) {
        n = 1;
      } else {
        n = toInteger(n);
      }
      var func = isArray(collection) ? arraySampleSize : baseSampleSize;
      return func(collection, n);
    }

    /**
     * Creates an array of shuffled values, using a version of the
     * [Fisher-Yates shuffle](https://en.wikipedia.org/wiki/Fisher-Yates_shuffle).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to shuffle.
     * @returns {Array} Returns the new shuffled array.
     * @example
     *
     * _.shuffle([1, 2, 3, 4]);
     * // => [4, 1, 3, 2]
     */
    function shuffle(collection) {
      var func = isArray(collection) ? arrayShuffle : baseShuffle;
      return func(collection);
    }

    /**
     * Gets the size of `collection` by returning its length for array-like
     * values or the number of own enumerable string keyed properties for objects.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object|string} collection The collection to inspect.
     * @returns {number} Returns the collection size.
     * @example
     *
     * _.size([1, 2, 3]);
     * // => 3
     *
     * _.size({ 'a': 1, 'b': 2 });
     * // => 2
     *
     * _.size('pebbles');
     * // => 7
     */
    function size(collection) {
      if (collection == null) {
        return 0;
      }
      if (isArrayLike(collection)) {
        return isString(collection) ? stringSize(collection) : collection.length;
      }
      var tag = getTag(collection);
      if (tag == mapTag || tag == setTag) {
        return collection.size;
      }
      return baseKeys(collection).length;
    }

    /**
     * Checks if `predicate` returns truthy for **any** element of `collection`.
     * Iteration is stopped once `predicate` returns truthy. The predicate is
     * invoked with three arguments: (value, index|key, collection).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {boolean} Returns `true` if any element passes the predicate check,
     *  else `false`.
     * @example
     *
     * _.some([null, 0, 'yes', false], Boolean);
     * // => true
     *
     * var users = [
     *   { 'user': 'barney', 'active': true },
     *   { 'user': 'fred',   'active': false }
     * ];
     *
     * // The `_.matches` iteratee shorthand.
     * _.some(users, { 'user': 'barney', 'active': false });
     * // => false
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.some(users, ['active', false]);
     * // => true
     *
     * // The `_.property` iteratee shorthand.
     * _.some(users, 'active');
     * // => true
     */
    function some(collection, predicate, guard) {
      var func = isArray(collection) ? arraySome : baseSome;
      if (guard && isIterateeCall(collection, predicate, guard)) {
        predicate = undefined;
      }
      return func(collection, getIteratee(predicate, 3));
    }

    /**
     * Creates an array of elements, sorted in ascending order by the results of
     * running each element in a collection thru each iteratee. This method
     * performs a stable sort, that is, it preserves the original sort order of
     * equal elements. The iteratees are invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {...(Function|Function[])} [iteratees=[_.identity]]
     *  The iteratees to sort by.
     * @returns {Array} Returns the new sorted array.
     * @example
     *
     * var users = [
     *   { 'user': 'fred',   'age': 48 },
     *   { 'user': 'barney', 'age': 36 },
     *   { 'user': 'fred',   'age': 30 },
     *   { 'user': 'barney', 'age': 34 }
     * ];
     *
     * _.sortBy(users, [function(o) { return o.user; }]);
     * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 30]]
     *
     * _.sortBy(users, ['user', 'age']);
     * // => objects for [['barney', 34], ['barney', 36], ['fred', 30], ['fred', 48]]
     */
    var sortBy = baseRest(function(collection, iteratees) {
      if (collection == null) {
        return [];
      }
      var length = iteratees.length;
      if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
        iteratees = [];
      } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
        iteratees = [iteratees[0]];
      }
      return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
    });

    /*------------------------------------------------------------------------*/

    /**
     * Gets the timestamp of the number of milliseconds that have elapsed since
     * the Unix epoch (1 January 1970 00:00:00 UTC).
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Date
     * @returns {number} Returns the timestamp.
     * @example
     *
     * _.defer(function(stamp) {
     *   console.log(_.now() - stamp);
     * }, _.now());
     * // => Logs the number of milliseconds it took for the deferred invocation.
     */
    var now = ctxNow || function() {
      return root.Date.now();
    };

    /*------------------------------------------------------------------------*/

    /**
     * The opposite of `_.before`; this method creates a function that invokes
     * `func` once it's called `n` or more times.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {number} n The number of calls before `func` is invoked.
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * var saves = ['profile', 'settings'];
     *
     * var done = _.after(saves.length, function() {
     *   console.log('done saving!');
     * });
     *
     * _.forEach(saves, function(type) {
     *   asyncSave({ 'type': type, 'complete': done });
     * });
     * // => Logs 'done saving!' after the two async saves have completed.
     */
    function after(n, func) {
      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      n = toInteger(n);
      return function() {
        if (--n < 1) {
          return func.apply(this, arguments);
        }
      };
    }

    /**
     * Creates a function that invokes `func`, with up to `n` arguments,
     * ignoring any additional arguments.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Function
     * @param {Function} func The function to cap arguments for.
     * @param {number} [n=func.length] The arity cap.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Function} Returns the new capped function.
     * @example
     *
     * _.map(['6', '8', '10'], _.ary(parseInt, 1));
     * // => [6, 8, 10]
     */
    function ary(func, n, guard) {
      n = guard ? undefined : n;
      n = (func && n == null) ? func.length : n;
      return createWrap(func, WRAP_ARY_FLAG, undefined, undefined, undefined, undefined, n);
    }

    /**
     * Creates a function that invokes `func`, with the `this` binding and arguments
     * of the created function, while it's called less than `n` times. Subsequent
     * calls to the created function return the result of the last `func` invocation.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Function
     * @param {number} n The number of calls at which `func` is no longer invoked.
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * jQuery(element).on('click', _.before(5, addContactToList));
     * // => Allows adding up to 4 contacts to the list.
     */
    function before(n, func) {
      var result;
      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      n = toInteger(n);
      return function() {
        if (--n > 0) {
          result = func.apply(this, arguments);
        }
        if (n <= 1) {
          func = undefined;
        }
        return result;
      };
    }

    /**
     * Creates a function that invokes `func` with the `this` binding of `thisArg`
     * and `partials` prepended to the arguments it receives.
     *
     * The `_.bind.placeholder` value, which defaults to `_` in monolithic builds,
     * may be used as a placeholder for partially applied arguments.
     *
     * **Note:** Unlike native `Function#bind`, this method doesn't set the "length"
     * property of bound functions.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to bind.
     * @param {*} thisArg The `this` binding of `func`.
     * @param {...*} [partials] The arguments to be partially applied.
     * @returns {Function} Returns the new bound function.
     * @example
     *
     * function greet(greeting, punctuation) {
     *   return greeting + ' ' + this.user + punctuation;
     * }
     *
     * var object = { 'user': 'fred' };
     *
     * var bound = _.bind(greet, object, 'hi');
     * bound('!');
     * // => 'hi fred!'
     *
     * // Bound with placeholders.
     * var bound = _.bind(greet, object, _, '!');
     * bound('hi');
     * // => 'hi fred!'
     */
    var bind = baseRest(function(func, thisArg, partials) {
      var bitmask = WRAP_BIND_FLAG;
      if (partials.length) {
        var holders = replaceHolders(partials, getHolder(bind));
        bitmask |= WRAP_PARTIAL_FLAG;
      }
      return createWrap(func, bitmask, thisArg, partials, holders);
    });

    /**
     * Creates a function that invokes the method at `object[key]` with `partials`
     * prepended to the arguments it receives.
     *
     * This method differs from `_.bind` by allowing bound functions to reference
     * methods that may be redefined or don't yet exist. See
     * [Peter Michaux's article](http://peter.michaux.ca/articles/lazy-function-definition-pattern)
     * for more details.
     *
     * The `_.bindKey.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for partially applied arguments.
     *
     * @static
     * @memberOf _
     * @since 0.10.0
     * @category Function
     * @param {Object} object The object to invoke the method on.
     * @param {string} key The key of the method.
     * @param {...*} [partials] The arguments to be partially applied.
     * @returns {Function} Returns the new bound function.
     * @example
     *
     * var object = {
     *   'user': 'fred',
     *   'greet': function(greeting, punctuation) {
     *     return greeting + ' ' + this.user + punctuation;
     *   }
     * };
     *
     * var bound = _.bindKey(object, 'greet', 'hi');
     * bound('!');
     * // => 'hi fred!'
     *
     * object.greet = function(greeting, punctuation) {
     *   return greeting + 'ya ' + this.user + punctuation;
     * };
     *
     * bound('!');
     * // => 'hiya fred!'
     *
     * // Bound with placeholders.
     * var bound = _.bindKey(object, 'greet', _, '!');
     * bound('hi');
     * // => 'hiya fred!'
     */
    var bindKey = baseRest(function(object, key, partials) {
      var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;
      if (partials.length) {
        var holders = replaceHolders(partials, getHolder(bindKey));
        bitmask |= WRAP_PARTIAL_FLAG;
      }
      return createWrap(key, bitmask, object, partials, holders);
    });

    /**
     * Creates a function that accepts arguments of `func` and either invokes
     * `func` returning its result, if at least `arity` number of arguments have
     * been provided, or returns a function that accepts the remaining `func`
     * arguments, and so on. The arity of `func` may be specified if `func.length`
     * is not sufficient.
     *
     * The `_.curry.placeholder` value, which defaults to `_` in monolithic builds,
     * may be used as a placeholder for provided arguments.
     *
     * **Note:** This method doesn't set the "length" property of curried functions.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Function
     * @param {Function} func The function to curry.
     * @param {number} [arity=func.length] The arity of `func`.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Function} Returns the new curried function.
     * @example
     *
     * var abc = function(a, b, c) {
     *   return [a, b, c];
     * };
     *
     * var curried = _.curry(abc);
     *
     * curried(1)(2)(3);
     * // => [1, 2, 3]
     *
     * curried(1, 2)(3);
     * // => [1, 2, 3]
     *
     * curried(1, 2, 3);
     * // => [1, 2, 3]
     *
     * // Curried with placeholders.
     * curried(1)(_, 3)(2);
     * // => [1, 2, 3]
     */
    function curry(func, arity, guard) {
      arity = guard ? undefined : arity;
      var result = createWrap(func, WRAP_CURRY_FLAG, undefined, undefined, undefined, undefined, undefined, arity);
      result.placeholder = curry.placeholder;
      return result;
    }

    /**
     * This method is like `_.curry` except that arguments are applied to `func`
     * in the manner of `_.partialRight` instead of `_.partial`.
     *
     * The `_.curryRight.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for provided arguments.
     *
     * **Note:** This method doesn't set the "length" property of curried functions.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Function
     * @param {Function} func The function to curry.
     * @param {number} [arity=func.length] The arity of `func`.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Function} Returns the new curried function.
     * @example
     *
     * var abc = function(a, b, c) {
     *   return [a, b, c];
     * };
     *
     * var curried = _.curryRight(abc);
     *
     * curried(3)(2)(1);
     * // => [1, 2, 3]
     *
     * curried(2, 3)(1);
     * // => [1, 2, 3]
     *
     * curried(1, 2, 3);
     * // => [1, 2, 3]
     *
     * // Curried with placeholders.
     * curried(3)(1, _)(2);
     * // => [1, 2, 3]
     */
    function curryRight(func, arity, guard) {
      arity = guard ? undefined : arity;
      var result = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined, undefined, undefined, undefined, undefined, arity);
      result.placeholder = curryRight.placeholder;
      return result;
    }

    /**
     * Creates a debounced function that delays invoking `func` until after `wait`
     * milliseconds have elapsed since the last time the debounced function was
     * invoked. The debounced function comes with a `cancel` method to cancel
     * delayed `func` invocations and a `flush` method to immediately invoke them.
     * Provide `options` to indicate whether `func` should be invoked on the
     * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
     * with the last arguments provided to the debounced function. Subsequent
     * calls to the debounced function return the result of the last `func`
     * invocation.
     *
     * **Note:** If `leading` and `trailing` options are `true`, `func` is
     * invoked on the trailing edge of the timeout only if the debounced function
     * is invoked more than once during the `wait` timeout.
     *
     * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
     * until to the next tick, similar to `setTimeout` with a timeout of `0`.
     *
     * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
     * for details over the differences between `_.debounce` and `_.throttle`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to debounce.
     * @param {number} [wait=0] The number of milliseconds to delay.
     * @param {Object} [options={}] The options object.
     * @param {boolean} [options.leading=false]
     *  Specify invoking on the leading edge of the timeout.
     * @param {number} [options.maxWait]
     *  The maximum time `func` is allowed to be delayed before it's invoked.
     * @param {boolean} [options.trailing=true]
     *  Specify invoking on the trailing edge of the timeout.
     * @returns {Function} Returns the new debounced function.
     * @example
     *
     * // Avoid costly calculations while the window size is in flux.
     * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
     *
     * // Invoke `sendMail` when clicked, debouncing subsequent calls.
     * jQuery(element).on('click', _.debounce(sendMail, 300, {
     *   'leading': true,
     *   'trailing': false
     * }));
     *
     * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
     * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
     * var source = new EventSource('/stream');
     * jQuery(source).on('message', debounced);
     *
     * // Cancel the trailing debounced invocation.
     * jQuery(window).on('popstate', debounced.cancel);
     */
    function debounce(func, wait, options) {
      var lastArgs,
          lastThis,
          maxWait,
          result,
          timerId,
          lastCallTime,
          lastInvokeTime = 0,
          leading = false,
          maxing = false,
          trailing = true;

      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      wait = toNumber(wait) || 0;
      if (isObject(options)) {
        leading = !!options.leading;
        maxing = 'maxWait' in options;
        maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
        trailing = 'trailing' in options ? !!options.trailing : trailing;
      }

      function invokeFunc(time) {
        var args = lastArgs,
            thisArg = lastThis;

        lastArgs = lastThis = undefined;
        lastInvokeTime = time;
        result = func.apply(thisArg, args);
        return result;
      }

      function leadingEdge(time) {
        // Reset any `maxWait` timer.
        lastInvokeTime = time;
        // Start the timer for the trailing edge.
        timerId = setTimeout(timerExpired, wait);
        // Invoke the leading edge.
        return leading ? invokeFunc(time) : result;
      }

      function remainingWait(time) {
        var timeSinceLastCall = time - lastCallTime,
            timeSinceLastInvoke = time - lastInvokeTime,
            timeWaiting = wait - timeSinceLastCall;

        return maxing
          ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke)
          : timeWaiting;
      }

      function shouldInvoke(time) {
        var timeSinceLastCall = time - lastCallTime,
            timeSinceLastInvoke = time - lastInvokeTime;

        // Either this is the first call, activity has stopped and we're at the
        // trailing edge, the system time has gone backwards and we're treating
        // it as the trailing edge, or we've hit the `maxWait` limit.
        return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||
          (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));
      }

      function timerExpired() {
        var time = now();
        if (shouldInvoke(time)) {
          return trailingEdge(time);
        }
        // Restart the timer.
        timerId = setTimeout(timerExpired, remainingWait(time));
      }

      function trailingEdge(time) {
        timerId = undefined;

        // Only invoke if we have `lastArgs` which means `func` has been
        // debounced at least once.
        if (trailing && lastArgs) {
          return invokeFunc(time);
        }
        lastArgs = lastThis = undefined;
        return result;
      }

      function cancel() {
        if (timerId !== undefined) {
          clearTimeout(timerId);
        }
        lastInvokeTime = 0;
        lastArgs = lastCallTime = lastThis = timerId = undefined;
      }

      function flush() {
        return timerId === undefined ? result : trailingEdge(now());
      }

      function debounced() {
        var time = now(),
            isInvoking = shouldInvoke(time);

        lastArgs = arguments;
        lastThis = this;
        lastCallTime = time;

        if (isInvoking) {
          if (timerId === undefined) {
            return leadingEdge(lastCallTime);
          }
          if (maxing) {
            // Handle invocations in a tight loop.
            clearTimeout(timerId);
            timerId = setTimeout(timerExpired, wait);
            return invokeFunc(lastCallTime);
          }
        }
        if (timerId === undefined) {
          timerId = setTimeout(timerExpired, wait);
        }
        return result;
      }
      debounced.cancel = cancel;
      debounced.flush = flush;
      return debounced;
    }

    /**
     * Defers invoking the `func` until the current call stack has cleared. Any
     * additional arguments are provided to `func` when it's invoked.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to defer.
     * @param {...*} [args] The arguments to invoke `func` with.
     * @returns {number} Returns the timer id.
     * @example
     *
     * _.defer(function(text) {
     *   console.log(text);
     * }, 'deferred');
     * // => Logs 'deferred' after one millisecond.
     */
    var defer = baseRest(function(func, args) {
      return baseDelay(func, 1, args);
    });

    /**
     * Invokes `func` after `wait` milliseconds. Any additional arguments are
     * provided to `func` when it's invoked.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to delay.
     * @param {number} wait The number of milliseconds to delay invocation.
     * @param {...*} [args] The arguments to invoke `func` with.
     * @returns {number} Returns the timer id.
     * @example
     *
     * _.delay(function(text) {
     *   console.log(text);
     * }, 1000, 'later');
     * // => Logs 'later' after one second.
     */
    var delay = baseRest(function(func, wait, args) {
      return baseDelay(func, toNumber(wait) || 0, args);
    });

    /**
     * Creates a function that invokes `func` with arguments reversed.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Function
     * @param {Function} func The function to flip arguments for.
     * @returns {Function} Returns the new flipped function.
     * @example
     *
     * var flipped = _.flip(function() {
     *   return _.toArray(arguments);
     * });
     *
     * flipped('a', 'b', 'c', 'd');
     * // => ['d', 'c', 'b', 'a']
     */
    function flip(func) {
      return createWrap(func, WRAP_FLIP_FLAG);
    }

    /**
     * Creates a function that memoizes the result of `func`. If `resolver` is
     * provided, it determines the cache key for storing the result based on the
     * arguments provided to the memoized function. By default, the first argument
     * provided to the memoized function is used as the map cache key. The `func`
     * is invoked with the `this` binding of the memoized function.
     *
     * **Note:** The cache is exposed as the `cache` property on the memoized
     * function. Its creation may be customized by replacing the `_.memoize.Cache`
     * constructor with one whose instances implement the
     * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
     * method interface of `clear`, `delete`, `get`, `has`, and `set`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to have its output memoized.
     * @param {Function} [resolver] The function to resolve the cache key.
     * @returns {Function} Returns the new memoized function.
     * @example
     *
     * var object = { 'a': 1, 'b': 2 };
     * var other = { 'c': 3, 'd': 4 };
     *
     * var values = _.memoize(_.values);
     * values(object);
     * // => [1, 2]
     *
     * values(other);
     * // => [3, 4]
     *
     * object.a = 2;
     * values(object);
     * // => [1, 2]
     *
     * // Modify the result cache.
     * values.cache.set(object, ['a', 'b']);
     * values(object);
     * // => ['a', 'b']
     *
     * // Replace `_.memoize.Cache`.
     * _.memoize.Cache = WeakMap;
     */
    function memoize(func, resolver) {
      if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      var memoized = function() {
        var args = arguments,
            key = resolver ? resolver.apply(this, args) : args[0],
            cache = memoized.cache;

        if (cache.has(key)) {
          return cache.get(key);
        }
        var result = func.apply(this, args);
        memoized.cache = cache.set(key, result) || cache;
        return result;
      };
      memoized.cache = new (memoize.Cache || MapCache);
      return memoized;
    }

    // Expose `MapCache`.
    memoize.Cache = MapCache;

    /**
     * Creates a function that negates the result of the predicate `func`. The
     * `func` predicate is invoked with the `this` binding and arguments of the
     * created function.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Function
     * @param {Function} predicate The predicate to negate.
     * @returns {Function} Returns the new negated function.
     * @example
     *
     * function isEven(n) {
     *   return n % 2 == 0;
     * }
     *
     * _.filter([1, 2, 3, 4, 5, 6], _.negate(isEven));
     * // => [1, 3, 5]
     */
    function negate(predicate) {
      if (typeof predicate != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      return function() {
        var args = arguments;
        switch (args.length) {
          case 0: return !predicate.call(this);
          case 1: return !predicate.call(this, args[0]);
          case 2: return !predicate.call(this, args[0], args[1]);
          case 3: return !predicate.call(this, args[0], args[1], args[2]);
        }
        return !predicate.apply(this, args);
      };
    }

    /**
     * Creates a function that is restricted to invoking `func` once. Repeat calls
     * to the function return the value of the first invocation. The `func` is
     * invoked with the `this` binding and arguments of the created function.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * var initialize = _.once(createApplication);
     * initialize();
     * initialize();
     * // => `createApplication` is invoked once
     */
    function once(func) {
      return before(2, func);
    }

    /**
     * Creates a function that invokes `func` with its arguments transformed.
     *
     * @static
     * @since 4.0.0
     * @memberOf _
     * @category Function
     * @param {Function} func The function to wrap.
     * @param {...(Function|Function[])} [transforms=[_.identity]]
     *  The argument transforms.
     * @returns {Function} Returns the new function.
     * @example
     *
     * function doubled(n) {
     *   return n * 2;
     * }
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var func = _.overArgs(function(x, y) {
     *   return [x, y];
     * }, [square, doubled]);
     *
     * func(9, 3);
     * // => [81, 6]
     *
     * func(10, 5);
     * // => [100, 10]
     */
    var overArgs = castRest(function(func, transforms) {
      transforms = (transforms.length == 1 && isArray(transforms[0]))
        ? arrayMap(transforms[0], baseUnary(getIteratee()))
        : arrayMap(baseFlatten(transforms, 1), baseUnary(getIteratee()));

      var funcsLength = transforms.length;
      return baseRest(function(args) {
        var index = -1,
            length = nativeMin(args.length, funcsLength);

        while (++index < length) {
          args[index] = transforms[index].call(this, args[index]);
        }
        return apply(func, this, args);
      });
    });

    /**
     * Creates a function that invokes `func` with `partials` prepended to the
     * arguments it receives. This method is like `_.bind` except it does **not**
     * alter the `this` binding.
     *
     * The `_.partial.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for partially applied arguments.
     *
     * **Note:** This method doesn't set the "length" property of partially
     * applied functions.
     *
     * @static
     * @memberOf _
     * @since 0.2.0
     * @category Function
     * @param {Function} func The function to partially apply arguments to.
     * @param {...*} [partials] The arguments to be partially applied.
     * @returns {Function} Returns the new partially applied function.
     * @example
     *
     * function greet(greeting, name) {
     *   return greeting + ' ' + name;
     * }
     *
     * var sayHelloTo = _.partial(greet, 'hello');
     * sayHelloTo('fred');
     * // => 'hello fred'
     *
     * // Partially applied with placeholders.
     * var greetFred = _.partial(greet, _, 'fred');
     * greetFred('hi');
     * // => 'hi fred'
     */
    var partial = baseRest(function(func, partials) {
      var holders = replaceHolders(partials, getHolder(partial));
      return createWrap(func, WRAP_PARTIAL_FLAG, undefined, partials, holders);
    });

    /**
     * This method is like `_.partial` except that partially applied arguments
     * are appended to the arguments it receives.
     *
     * The `_.partialRight.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for partially applied arguments.
     *
     * **Note:** This method doesn't set the "length" property of partially
     * applied functions.
     *
     * @static
     * @memberOf _
     * @since 1.0.0
     * @category Function
     * @param {Function} func The function to partially apply arguments to.
     * @param {...*} [partials] The arguments to be partially applied.
     * @returns {Function} Returns the new partially applied function.
     * @example
     *
     * function greet(greeting, name) {
     *   return greeting + ' ' + name;
     * }
     *
     * var greetFred = _.partialRight(greet, 'fred');
     * greetFred('hi');
     * // => 'hi fred'
     *
     * // Partially applied with placeholders.
     * var sayHelloTo = _.partialRight(greet, 'hello', _);
     * sayHelloTo('fred');
     * // => 'hello fred'
     */
    var partialRight = baseRest(function(func, partials) {
      var holders = replaceHolders(partials, getHolder(partialRight));
      return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined, partials, holders);
    });

    /**
     * Creates a function that invokes `func` with arguments arranged according
     * to the specified `indexes` where the argument value at the first index is
     * provided as the first argument, the argument value at the second index is
     * provided as the second argument, and so on.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Function
     * @param {Function} func The function to rearrange arguments for.
     * @param {...(number|number[])} indexes The arranged argument indexes.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var rearged = _.rearg(function(a, b, c) {
     *   return [a, b, c];
     * }, [2, 0, 1]);
     *
     * rearged('b', 'c', 'a')
     * // => ['a', 'b', 'c']
     */
    var rearg = flatRest(function(func, indexes) {
      return createWrap(func, WRAP_REARG_FLAG, undefined, undefined, undefined, indexes);
    });

    /**
     * Creates a function that invokes `func` with the `this` binding of the
     * created function and arguments from `start` and beyond provided as
     * an array.
     *
     * **Note:** This method is based on the
     * [rest parameter](https://mdn.io/rest_parameters).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Function
     * @param {Function} func The function to apply a rest parameter to.
     * @param {number} [start=func.length-1] The start position of the rest parameter.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var say = _.rest(function(what, names) {
     *   return what + ' ' + _.initial(names).join(', ') +
     *     (_.size(names) > 1 ? ', & ' : '') + _.last(names);
     * });
     *
     * say('hello', 'fred', 'barney', 'pebbles');
     * // => 'hello fred, barney, & pebbles'
     */
    function rest(func, start) {
      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      start = start === undefined ? start : toInteger(start);
      return baseRest(func, start);
    }

    /**
     * Creates a function that invokes `func` with the `this` binding of the
     * create function and an array of arguments much like
     * [`Function#apply`](http://www.ecma-international.org/ecma-262/7.0/#sec-function.prototype.apply).
     *
     * **Note:** This method is based on the
     * [spread operator](https://mdn.io/spread_operator).
     *
     * @static
     * @memberOf _
     * @since 3.2.0
     * @category Function
     * @param {Function} func The function to spread arguments over.
     * @param {number} [start=0] The start position of the spread.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var say = _.spread(function(who, what) {
     *   return who + ' says ' + what;
     * });
     *
     * say(['fred', 'hello']);
     * // => 'fred says hello'
     *
     * var numbers = Promise.all([
     *   Promise.resolve(40),
     *   Promise.resolve(36)
     * ]);
     *
     * numbers.then(_.spread(function(x, y) {
     *   return x + y;
     * }));
     * // => a Promise of 76
     */
    function spread(func, start) {
      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      start = start == null ? 0 : nativeMax(toInteger(start), 0);
      return baseRest(function(args) {
        var array = args[start],
            otherArgs = castSlice(args, 0, start);

        if (array) {
          arrayPush(otherArgs, array);
        }
        return apply(func, this, otherArgs);
      });
    }

    /**
     * Creates a throttled function that only invokes `func` at most once per
     * every `wait` milliseconds. The throttled function comes with a `cancel`
     * method to cancel delayed `func` invocations and a `flush` method to
     * immediately invoke them. Provide `options` to indicate whether `func`
     * should be invoked on the leading and/or trailing edge of the `wait`
     * timeout. The `func` is invoked with the last arguments provided to the
     * throttled function. Subsequent calls to the throttled function return the
     * result of the last `func` invocation.
     *
     * **Note:** If `leading` and `trailing` options are `true`, `func` is
     * invoked on the trailing edge of the timeout only if the throttled function
     * is invoked more than once during the `wait` timeout.
     *
     * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
     * until to the next tick, similar to `setTimeout` with a timeout of `0`.
     *
     * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
     * for details over the differences between `_.throttle` and `_.debounce`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to throttle.
     * @param {number} [wait=0] The number of milliseconds to throttle invocations to.
     * @param {Object} [options={}] The options object.
     * @param {boolean} [options.leading=true]
     *  Specify invoking on the leading edge of the timeout.
     * @param {boolean} [options.trailing=true]
     *  Specify invoking on the trailing edge of the timeout.
     * @returns {Function} Returns the new throttled function.
     * @example
     *
     * // Avoid excessively updating the position while scrolling.
     * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
     *
     * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.
     * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });
     * jQuery(element).on('click', throttled);
     *
     * // Cancel the trailing throttled invocation.
     * jQuery(window).on('popstate', throttled.cancel);
     */
    function throttle(func, wait, options) {
      var leading = true,
          trailing = true;

      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      if (isObject(options)) {
        leading = 'leading' in options ? !!options.leading : leading;
        trailing = 'trailing' in options ? !!options.trailing : trailing;
      }
      return debounce(func, wait, {
        'leading': leading,
        'maxWait': wait,
        'trailing': trailing
      });
    }

    /**
     * Creates a function that accepts up to one argument, ignoring any
     * additional arguments.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Function
     * @param {Function} func The function to cap arguments for.
     * @returns {Function} Returns the new capped function.
     * @example
     *
     * _.map(['6', '8', '10'], _.unary(parseInt));
     * // => [6, 8, 10]
     */
    function unary(func) {
      return ary(func, 1);
    }

    /**
     * Creates a function that provides `value` to `wrapper` as its first
     * argument. Any additional arguments provided to the function are appended
     * to those provided to the `wrapper`. The wrapper is invoked with the `this`
     * binding of the created function.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {*} value The value to wrap.
     * @param {Function} [wrapper=identity] The wrapper function.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var p = _.wrap(_.escape, function(func, text) {
     *   return '<p>' + func(text) + '</p>';
     * });
     *
     * p('fred, barney, & pebbles');
     * // => '<p>fred, barney, &amp; pebbles</p>'
     */
    function wrap(value, wrapper) {
      return partial(castFunction(wrapper), value);
    }

    /*------------------------------------------------------------------------*/

    /**
     * Casts `value` as an array if it's not one.
     *
     * @static
     * @memberOf _
     * @since 4.4.0
     * @category Lang
     * @param {*} value The value to inspect.
     * @returns {Array} Returns the cast array.
     * @example
     *
     * _.castArray(1);
     * // => [1]
     *
     * _.castArray({ 'a': 1 });
     * // => [{ 'a': 1 }]
     *
     * _.castArray('abc');
     * // => ['abc']
     *
     * _.castArray(null);
     * // => [null]
     *
     * _.castArray(undefined);
     * // => [undefined]
     *
     * _.castArray();
     * // => []
     *
     * var array = [1, 2, 3];
     * console.log(_.castArray(array) === array);
     * // => true
     */
    function castArray() {
      if (!arguments.length) {
        return [];
      }
      var value = arguments[0];
      return isArray(value) ? value : [value];
    }

    /**
     * Creates a shallow clone of `value`.
     *
     * **Note:** This method is loosely based on the
     * [structured clone algorithm](https://mdn.io/Structured_clone_algorithm)
     * and supports cloning arrays, array buffers, booleans, date objects, maps,
     * numbers, `Object` objects, regexes, sets, strings, symbols, and typed
     * arrays. The own enumerable properties of `arguments` objects are cloned
     * as plain objects. An empty object is returned for uncloneable values such
     * as error objects, functions, DOM nodes, and WeakMaps.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to clone.
     * @returns {*} Returns the cloned value.
     * @see _.cloneDeep
     * @example
     *
     * var objects = [{ 'a': 1 }, { 'b': 2 }];
     *
     * var shallow = _.clone(objects);
     * console.log(shallow[0] === objects[0]);
     * // => true
     */
    function clone(value) {
      return baseClone(value, CLONE_SYMBOLS_FLAG);
    }

    /**
     * This method is like `_.clone` except that it accepts `customizer` which
     * is invoked to produce the cloned value. If `customizer` returns `undefined`,
     * cloning is handled by the method instead. The `customizer` is invoked with
     * up to four arguments; (value [, index|key, object, stack]).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to clone.
     * @param {Function} [customizer] The function to customize cloning.
     * @returns {*} Returns the cloned value.
     * @see _.cloneDeepWith
     * @example
     *
     * function customizer(value) {
     *   if (_.isElement(value)) {
     *     return value.cloneNode(false);
     *   }
     * }
     *
     * var el = _.cloneWith(document.body, customizer);
     *
     * console.log(el === document.body);
     * // => false
     * console.log(el.nodeName);
     * // => 'BODY'
     * console.log(el.childNodes.length);
     * // => 0
     */
    function cloneWith(value, customizer) {
      customizer = typeof customizer == 'function' ? customizer : undefined;
      return baseClone(value, CLONE_SYMBOLS_FLAG, customizer);
    }

    /**
     * This method is like `_.clone` except that it recursively clones `value`.
     *
     * @static
     * @memberOf _
     * @since 1.0.0
     * @category Lang
     * @param {*} value The value to recursively clone.
     * @returns {*} Returns the deep cloned value.
     * @see _.clone
     * @example
     *
     * var objects = [{ 'a': 1 }, { 'b': 2 }];
     *
     * var deep = _.cloneDeep(objects);
     * console.log(deep[0] === objects[0]);
     * // => false
     */
    function cloneDeep(value) {
      return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
    }

    /**
     * This method is like `_.cloneWith` except that it recursively clones `value`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to recursively clone.
     * @param {Function} [customizer] The function to customize cloning.
     * @returns {*} Returns the deep cloned value.
     * @see _.cloneWith
     * @example
     *
     * function customizer(value) {
     *   if (_.isElement(value)) {
     *     return value.cloneNode(true);
     *   }
     * }
     *
     * var el = _.cloneDeepWith(document.body, customizer);
     *
     * console.log(el === document.body);
     * // => false
     * console.log(el.nodeName);
     * // => 'BODY'
     * console.log(el.childNodes.length);
     * // => 20
     */
    function cloneDeepWith(value, customizer) {
      customizer = typeof customizer == 'function' ? customizer : undefined;
      return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer);
    }

    /**
     * Checks if `object` conforms to `source` by invoking the predicate
     * properties of `source` with the corresponding property values of `object`.
     *
     * **Note:** This method is equivalent to `_.conforms` when `source` is
     * partially applied.
     *
     * @static
     * @memberOf _
     * @since 4.14.0
     * @category Lang
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property predicates to conform to.
     * @returns {boolean} Returns `true` if `object` conforms, else `false`.
     * @example
     *
     * var object = { 'a': 1, 'b': 2 };
     *
     * _.conformsTo(object, { 'b': function(n) { return n > 1; } });
     * // => true
     *
     * _.conformsTo(object, { 'b': function(n) { return n > 2; } });
     * // => false
     */
    function conformsTo(object, source) {
      return source == null || baseConformsTo(object, source, keys(source));
    }

    /**
     * Performs a
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * comparison between two values to determine if they are equivalent.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     * @example
     *
     * var object = { 'a': 1 };
     * var other = { 'a': 1 };
     *
     * _.eq(object, object);
     * // => true
     *
     * _.eq(object, other);
     * // => false
     *
     * _.eq('a', 'a');
     * // => true
     *
     * _.eq('a', Object('a'));
     * // => false
     *
     * _.eq(NaN, NaN);
     * // => true
     */
    function eq(value, other) {
      return value === other || (value !== value && other !== other);
    }

    /**
     * Checks if `value` is greater than `other`.
     *
     * @static
     * @memberOf _
     * @since 3.9.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is greater than `other`,
     *  else `false`.
     * @see _.lt
     * @example
     *
     * _.gt(3, 1);
     * // => true
     *
     * _.gt(3, 3);
     * // => false
     *
     * _.gt(1, 3);
     * // => false
     */
    var gt = createRelationalOperation(baseGt);

    /**
     * Checks if `value` is greater than or equal to `other`.
     *
     * @static
     * @memberOf _
     * @since 3.9.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is greater than or equal to
     *  `other`, else `false`.
     * @see _.lte
     * @example
     *
     * _.gte(3, 1);
     * // => true
     *
     * _.gte(3, 3);
     * // => true
     *
     * _.gte(1, 3);
     * // => false
     */
    var gte = createRelationalOperation(function(value, other) {
      return value >= other;
    });

    /**
     * Checks if `value` is likely an `arguments` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an `arguments` object,
     *  else `false`.
     * @example
     *
     * _.isArguments(function() { return arguments; }());
     * // => true
     *
     * _.isArguments([1, 2, 3]);
     * // => false
     */
    var isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {
      return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&
        !propertyIsEnumerable.call(value, 'callee');
    };

    /**
     * Checks if `value` is classified as an `Array` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array, else `false`.
     * @example
     *
     * _.isArray([1, 2, 3]);
     * // => true
     *
     * _.isArray(document.body.children);
     * // => false
     *
     * _.isArray('abc');
     * // => false
     *
     * _.isArray(_.noop);
     * // => false
     */
    var isArray = Array.isArray;

    /**
     * Checks if `value` is classified as an `ArrayBuffer` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array buffer, else `false`.
     * @example
     *
     * _.isArrayBuffer(new ArrayBuffer(2));
     * // => true
     *
     * _.isArrayBuffer(new Array(2));
     * // => false
     */
    var isArrayBuffer = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer;

    /**
     * Checks if `value` is array-like. A value is considered array-like if it's
     * not a function and has a `value.length` that's an integer greater than or
     * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
     * @example
     *
     * _.isArrayLike([1, 2, 3]);
     * // => true
     *
     * _.isArrayLike(document.body.children);
     * // => true
     *
     * _.isArrayLike('abc');
     * // => true
     *
     * _.isArrayLike(_.noop);
     * // => false
     */
    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction(value);
    }

    /**
     * This method is like `_.isArrayLike` except that it also checks if `value`
     * is an object.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array-like object,
     *  else `false`.
     * @example
     *
     * _.isArrayLikeObject([1, 2, 3]);
     * // => true
     *
     * _.isArrayLikeObject(document.body.children);
     * // => true
     *
     * _.isArrayLikeObject('abc');
     * // => false
     *
     * _.isArrayLikeObject(_.noop);
     * // => false
     */
    function isArrayLikeObject(value) {
      return isObjectLike(value) && isArrayLike(value);
    }

    /**
     * Checks if `value` is classified as a boolean primitive or object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a boolean, else `false`.
     * @example
     *
     * _.isBoolean(false);
     * // => true
     *
     * _.isBoolean(null);
     * // => false
     */
    function isBoolean(value) {
      return value === true || value === false ||
        (isObjectLike(value) && baseGetTag(value) == boolTag);
    }

    /**
     * Checks if `value` is a buffer.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
     * @example
     *
     * _.isBuffer(new Buffer(2));
     * // => true
     *
     * _.isBuffer(new Uint8Array(2));
     * // => false
     */
    var isBuffer = nativeIsBuffer || stubFalse;

    /**
     * Checks if `value` is classified as a `Date` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a date object, else `false`.
     * @example
     *
     * _.isDate(new Date);
     * // => true
     *
     * _.isDate('Mon April 23 2012');
     * // => false
     */
    var isDate = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;

    /**
     * Checks if `value` is likely a DOM element.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a DOM element, else `false`.
     * @example
     *
     * _.isElement(document.body);
     * // => true
     *
     * _.isElement('<body>');
     * // => false
     */
    function isElement(value) {
      return isObjectLike(value) && value.nodeType === 1 && !isPlainObject(value);
    }

    /**
     * Checks if `value` is an empty object, collection, map, or set.
     *
     * Objects are considered empty if they have no own enumerable string keyed
     * properties.
     *
     * Array-like values such as `arguments` objects, arrays, buffers, strings, or
     * jQuery-like collections are considered empty if they have a `length` of `0`.
     * Similarly, maps and sets are considered empty if they have a `size` of `0`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is empty, else `false`.
     * @example
     *
     * _.isEmpty(null);
     * // => true
     *
     * _.isEmpty(true);
     * // => true
     *
     * _.isEmpty(1);
     * // => true
     *
     * _.isEmpty([1, 2, 3]);
     * // => false
     *
     * _.isEmpty({ 'a': 1 });
     * // => false
     */
    function isEmpty(value) {
      if (value == null) {
        return true;
      }
      if (isArrayLike(value) &&
          (isArray(value) || typeof value == 'string' || typeof value.splice == 'function' ||
            isBuffer(value) || isTypedArray(value) || isArguments(value))) {
        return !value.length;
      }
      var tag = getTag(value);
      if (tag == mapTag || tag == setTag) {
        return !value.size;
      }
      if (isPrototype(value)) {
        return !baseKeys(value).length;
      }
      for (var key in value) {
        if (hasOwnProperty.call(value, key)) {
          return false;
        }
      }
      return true;
    }

    /**
     * Performs a deep comparison between two values to determine if they are
     * equivalent.
     *
     * **Note:** This method supports comparing arrays, array buffers, booleans,
     * date objects, error objects, maps, numbers, `Object` objects, regexes,
     * sets, strings, symbols, and typed arrays. `Object` objects are compared
     * by their own, not inherited, enumerable properties. Functions and DOM
     * nodes are compared by strict equality, i.e. `===`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     * @example
     *
     * var object = { 'a': 1 };
     * var other = { 'a': 1 };
     *
     * _.isEqual(object, other);
     * // => true
     *
     * object === other;
     * // => false
     */
    function isEqual(value, other) {
      return baseIsEqual(value, other);
    }

    /**
     * This method is like `_.isEqual` except that it accepts `customizer` which
     * is invoked to compare values. If `customizer` returns `undefined`, comparisons
     * are handled by the method instead. The `customizer` is invoked with up to
     * six arguments: (objValue, othValue [, index|key, object, other, stack]).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @param {Function} [customizer] The function to customize comparisons.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     * @example
     *
     * function isGreeting(value) {
     *   return /^h(?:i|ello)$/.test(value);
     * }
     *
     * function customizer(objValue, othValue) {
     *   if (isGreeting(objValue) && isGreeting(othValue)) {
     *     return true;
     *   }
     * }
     *
     * var array = ['hello', 'goodbye'];
     * var other = ['hi', 'goodbye'];
     *
     * _.isEqualWith(array, other, customizer);
     * // => true
     */
    function isEqualWith(value, other, customizer) {
      customizer = typeof customizer == 'function' ? customizer : undefined;
      var result = customizer ? customizer(value, other) : undefined;
      return result === undefined ? baseIsEqual(value, other, undefined, customizer) : !!result;
    }

    /**
     * Checks if `value` is an `Error`, `EvalError`, `RangeError`, `ReferenceError`,
     * `SyntaxError`, `TypeError`, or `URIError` object.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an error object, else `false`.
     * @example
     *
     * _.isError(new Error);
     * // => true
     *
     * _.isError(Error);
     * // => false
     */
    function isError(value) {
      if (!isObjectLike(value)) {
        return false;
      }
      var tag = baseGetTag(value);
      return tag == errorTag || tag == domExcTag ||
        (typeof value.message == 'string' && typeof value.name == 'string' && !isPlainObject(value));
    }

    /**
     * Checks if `value` is a finite primitive number.
     *
     * **Note:** This method is based on
     * [`Number.isFinite`](https://mdn.io/Number/isFinite).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a finite number, else `false`.
     * @example
     *
     * _.isFinite(3);
     * // => true
     *
     * _.isFinite(Number.MIN_VALUE);
     * // => true
     *
     * _.isFinite(Infinity);
     * // => false
     *
     * _.isFinite('3');
     * // => false
     */
    function isFinite(value) {
      return typeof value == 'number' && nativeIsFinite(value);
    }

    /**
     * Checks if `value` is classified as a `Function` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a function, else `false`.
     * @example
     *
     * _.isFunction(_);
     * // => true
     *
     * _.isFunction(/abc/);
     * // => false
     */
    function isFunction(value) {
      if (!isObject(value)) {
        return false;
      }
      // The use of `Object#toString` avoids issues with the `typeof` operator
      // in Safari 9 which returns 'object' for typed arrays and other constructors.
      var tag = baseGetTag(value);
      return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
    }

    /**
     * Checks if `value` is an integer.
     *
     * **Note:** This method is based on
     * [`Number.isInteger`](https://mdn.io/Number/isInteger).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an integer, else `false`.
     * @example
     *
     * _.isInteger(3);
     * // => true
     *
     * _.isInteger(Number.MIN_VALUE);
     * // => false
     *
     * _.isInteger(Infinity);
     * // => false
     *
     * _.isInteger('3');
     * // => false
     */
    function isInteger(value) {
      return typeof value == 'number' && value == toInteger(value);
    }

    /**
     * Checks if `value` is a valid array-like length.
     *
     * **Note:** This method is loosely based on
     * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
     * @example
     *
     * _.isLength(3);
     * // => true
     *
     * _.isLength(Number.MIN_VALUE);
     * // => false
     *
     * _.isLength(Infinity);
     * // => false
     *
     * _.isLength('3');
     * // => false
     */
    function isLength(value) {
      return typeof value == 'number' &&
        value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }

    /**
     * Checks if `value` is the
     * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
     * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an object, else `false`.
     * @example
     *
     * _.isObject({});
     * // => true
     *
     * _.isObject([1, 2, 3]);
     * // => true
     *
     * _.isObject(_.noop);
     * // => true
     *
     * _.isObject(null);
     * // => false
     */
    function isObject(value) {
      var type = typeof value;
      return value != null && (type == 'object' || type == 'function');
    }

    /**
     * Checks if `value` is object-like. A value is object-like if it's not `null`
     * and has a `typeof` result of "object".
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
     * @example
     *
     * _.isObjectLike({});
     * // => true
     *
     * _.isObjectLike([1, 2, 3]);
     * // => true
     *
     * _.isObjectLike(_.noop);
     * // => false
     *
     * _.isObjectLike(null);
     * // => false
     */
    function isObjectLike(value) {
      return value != null && typeof value == 'object';
    }

    /**
     * Checks if `value` is classified as a `Map` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a map, else `false`.
     * @example
     *
     * _.isMap(new Map);
     * // => true
     *
     * _.isMap(new WeakMap);
     * // => false
     */
    var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;

    /**
     * Performs a partial deep comparison between `object` and `source` to
     * determine if `object` contains equivalent property values.
     *
     * **Note:** This method is equivalent to `_.matches` when `source` is
     * partially applied.
     *
     * Partial comparisons will match empty array and empty object `source`
     * values against any array or object value, respectively. See `_.isEqual`
     * for a list of supported value comparisons.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property values to match.
     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
     * @example
     *
     * var object = { 'a': 1, 'b': 2 };
     *
     * _.isMatch(object, { 'b': 2 });
     * // => true
     *
     * _.isMatch(object, { 'b': 1 });
     * // => false
     */
    function isMatch(object, source) {
      return object === source || baseIsMatch(object, source, getMatchData(source));
    }

    /**
     * This method is like `_.isMatch` except that it accepts `customizer` which
     * is invoked to compare values. If `customizer` returns `undefined`, comparisons
     * are handled by the method instead. The `customizer` is invoked with five
     * arguments: (objValue, srcValue, index|key, object, source).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property values to match.
     * @param {Function} [customizer] The function to customize comparisons.
     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
     * @example
     *
     * function isGreeting(value) {
     *   return /^h(?:i|ello)$/.test(value);
     * }
     *
     * function customizer(objValue, srcValue) {
     *   if (isGreeting(objValue) && isGreeting(srcValue)) {
     *     return true;
     *   }
     * }
     *
     * var object = { 'greeting': 'hello' };
     * var source = { 'greeting': 'hi' };
     *
     * _.isMatchWith(object, source, customizer);
     * // => true
     */
    function isMatchWith(object, source, customizer) {
      customizer = typeof customizer == 'function' ? customizer : undefined;
      return baseIsMatch(object, source, getMatchData(source), customizer);
    }

    /**
     * Checks if `value` is `NaN`.
     *
     * **Note:** This method is based on
     * [`Number.isNaN`](https://mdn.io/Number/isNaN) and is not the same as
     * global [`isNaN`](https://mdn.io/isNaN) which returns `true` for
     * `undefined` and other non-number values.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
     * @example
     *
     * _.isNaN(NaN);
     * // => true
     *
     * _.isNaN(new Number(NaN));
     * // => true
     *
     * isNaN(undefined);
     * // => true
     *
     * _.isNaN(undefined);
     * // => false
     */
    function isNaN(value) {
      // An `NaN` primitive is the only value that is not equal to itself.
      // Perform the `toStringTag` check first to avoid errors with some
      // ActiveX objects in IE.
      return isNumber(value) && value != +value;
    }

    /**
     * Checks if `value` is a pristine native function.
     *
     * **Note:** This method can't reliably detect native functions in the presence
     * of the core-js package because core-js circumvents this kind of detection.
     * Despite multiple requests, the core-js maintainer has made it clear: any
     * attempt to fix the detection will be obstructed. As a result, we're left
     * with little choice but to throw an error. Unfortunately, this also affects
     * packages, like [babel-polyfill](https://www.npmjs.com/package/babel-polyfill),
     * which rely on core-js.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a native function,
     *  else `false`.
     * @example
     *
     * _.isNative(Array.prototype.push);
     * // => true
     *
     * _.isNative(_);
     * // => false
     */
    function isNative(value) {
      if (isMaskable(value)) {
        throw new Error(CORE_ERROR_TEXT);
      }
      return baseIsNative(value);
    }

    /**
     * Checks if `value` is `null`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is `null`, else `false`.
     * @example
     *
     * _.isNull(null);
     * // => true
     *
     * _.isNull(void 0);
     * // => false
     */
    function isNull(value) {
      return value === null;
    }

    /**
     * Checks if `value` is `null` or `undefined`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is nullish, else `false`.
     * @example
     *
     * _.isNil(null);
     * // => true
     *
     * _.isNil(void 0);
     * // => true
     *
     * _.isNil(NaN);
     * // => false
     */
    function isNil(value) {
      return value == null;
    }

    /**
     * Checks if `value` is classified as a `Number` primitive or object.
     *
     * **Note:** To exclude `Infinity`, `-Infinity`, and `NaN`, which are
     * classified as numbers, use the `_.isFinite` method.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a number, else `false`.
     * @example
     *
     * _.isNumber(3);
     * // => true
     *
     * _.isNumber(Number.MIN_VALUE);
     * // => true
     *
     * _.isNumber(Infinity);
     * // => true
     *
     * _.isNumber('3');
     * // => false
     */
    function isNumber(value) {
      return typeof value == 'number' ||
        (isObjectLike(value) && baseGetTag(value) == numberTag);
    }

    /**
     * Checks if `value` is a plain object, that is, an object created by the
     * `Object` constructor or one with a `[[Prototype]]` of `null`.
     *
     * @static
     * @memberOf _
     * @since 0.8.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     * }
     *
     * _.isPlainObject(new Foo);
     * // => false
     *
     * _.isPlainObject([1, 2, 3]);
     * // => false
     *
     * _.isPlainObject({ 'x': 0, 'y': 0 });
     * // => true
     *
     * _.isPlainObject(Object.create(null));
     * // => true
     */
    function isPlainObject(value) {
      if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
        return false;
      }
      var proto = getPrototype(value);
      if (proto === null) {
        return true;
      }
      var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
      return typeof Ctor == 'function' && Ctor instanceof Ctor &&
        funcToString.call(Ctor) == objectCtorString;
    }

    /**
     * Checks if `value` is classified as a `RegExp` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.
     * @example
     *
     * _.isRegExp(/abc/);
     * // => true
     *
     * _.isRegExp('/abc/');
     * // => false
     */
    var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;

    /**
     * Checks if `value` is a safe integer. An integer is safe if it's an IEEE-754
     * double precision number which isn't the result of a rounded unsafe integer.
     *
     * **Note:** This method is based on
     * [`Number.isSafeInteger`](https://mdn.io/Number/isSafeInteger).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a safe integer, else `false`.
     * @example
     *
     * _.isSafeInteger(3);
     * // => true
     *
     * _.isSafeInteger(Number.MIN_VALUE);
     * // => false
     *
     * _.isSafeInteger(Infinity);
     * // => false
     *
     * _.isSafeInteger('3');
     * // => false
     */
    function isSafeInteger(value) {
      return isInteger(value) && value >= -MAX_SAFE_INTEGER && value <= MAX_SAFE_INTEGER;
    }

    /**
     * Checks if `value` is classified as a `Set` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a set, else `false`.
     * @example
     *
     * _.isSet(new Set);
     * // => true
     *
     * _.isSet(new WeakSet);
     * // => false
     */
    var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;

    /**
     * Checks if `value` is classified as a `String` primitive or object.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a string, else `false`.
     * @example
     *
     * _.isString('abc');
     * // => true
     *
     * _.isString(1);
     * // => false
     */
    function isString(value) {
      return typeof value == 'string' ||
        (!isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag);
    }

    /**
     * Checks if `value` is classified as a `Symbol` primitive or object.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
     * @example
     *
     * _.isSymbol(Symbol.iterator);
     * // => true
     *
     * _.isSymbol('abc');
     * // => false
     */
    function isSymbol(value) {
      return typeof value == 'symbol' ||
        (isObjectLike(value) && baseGetTag(value) == symbolTag);
    }

    /**
     * Checks if `value` is classified as a typed array.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
     * @example
     *
     * _.isTypedArray(new Uint8Array);
     * // => true
     *
     * _.isTypedArray([]);
     * // => false
     */
    var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

    /**
     * Checks if `value` is `undefined`.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.
     * @example
     *
     * _.isUndefined(void 0);
     * // => true
     *
     * _.isUndefined(null);
     * // => false
     */
    function isUndefined(value) {
      return value === undefined;
    }

    /**
     * Checks if `value` is classified as a `WeakMap` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a weak map, else `false`.
     * @example
     *
     * _.isWeakMap(new WeakMap);
     * // => true
     *
     * _.isWeakMap(new Map);
     * // => false
     */
    function isWeakMap(value) {
      return isObjectLike(value) && getTag(value) == weakMapTag;
    }

    /**
     * Checks if `value` is classified as a `WeakSet` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a weak set, else `false`.
     * @example
     *
     * _.isWeakSet(new WeakSet);
     * // => true
     *
     * _.isWeakSet(new Set);
     * // => false
     */
    function isWeakSet(value) {
      return isObjectLike(value) && baseGetTag(value) == weakSetTag;
    }

    /**
     * Checks if `value` is less than `other`.
     *
     * @static
     * @memberOf _
     * @since 3.9.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is less than `other`,
     *  else `false`.
     * @see _.gt
     * @example
     *
     * _.lt(1, 3);
     * // => true
     *
     * _.lt(3, 3);
     * // => false
     *
     * _.lt(3, 1);
     * // => false
     */
    var lt = createRelationalOperation(baseLt);

    /**
     * Checks if `value` is less than or equal to `other`.
     *
     * @static
     * @memberOf _
     * @since 3.9.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is less than or equal to
     *  `other`, else `false`.
     * @see _.gte
     * @example
     *
     * _.lte(1, 3);
     * // => true
     *
     * _.lte(3, 3);
     * // => true
     *
     * _.lte(3, 1);
     * // => false
     */
    var lte = createRelationalOperation(function(value, other) {
      return value <= other;
    });

    /**
     * Converts `value` to an array.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {Array} Returns the converted array.
     * @example
     *
     * _.toArray({ 'a': 1, 'b': 2 });
     * // => [1, 2]
     *
     * _.toArray('abc');
     * // => ['a', 'b', 'c']
     *
     * _.toArray(1);
     * // => []
     *
     * _.toArray(null);
     * // => []
     */
    function toArray(value) {
      if (!value) {
        return [];
      }
      if (isArrayLike(value)) {
        return isString(value) ? stringToArray(value) : copyArray(value);
      }
      if (symIterator && value[symIterator]) {
        return iteratorToArray(value[symIterator]());
      }
      var tag = getTag(value),
          func = tag == mapTag ? mapToArray : (tag == setTag ? setToArray : values);

      return func(value);
    }

    /**
     * Converts `value` to a finite number.
     *
     * @static
     * @memberOf _
     * @since 4.12.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {number} Returns the converted number.
     * @example
     *
     * _.toFinite(3.2);
     * // => 3.2
     *
     * _.toFinite(Number.MIN_VALUE);
     * // => 5e-324
     *
     * _.toFinite(Infinity);
     * // => 1.7976931348623157e+308
     *
     * _.toFinite('3.2');
     * // => 3.2
     */
    function toFinite(value) {
      if (!value) {
        return value === 0 ? value : 0;
      }
      value = toNumber(value);
      if (value === INFINITY || value === -INFINITY) {
        var sign = (value < 0 ? -1 : 1);
        return sign * MAX_INTEGER;
      }
      return value === value ? value : 0;
    }

    /**
     * Converts `value` to an integer.
     *
     * **Note:** This method is loosely based on
     * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {number} Returns the converted integer.
     * @example
     *
     * _.toInteger(3.2);
     * // => 3
     *
     * _.toInteger(Number.MIN_VALUE);
     * // => 0
     *
     * _.toInteger(Infinity);
     * // => 1.7976931348623157e+308
     *
     * _.toInteger('3.2');
     * // => 3
     */
    function toInteger(value) {
      var result = toFinite(value),
          remainder = result % 1;

      return result === result ? (remainder ? result - remainder : result) : 0;
    }

    /**
     * Converts `value` to an integer suitable for use as the length of an
     * array-like object.
     *
     * **Note:** This method is based on
     * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {number} Returns the converted integer.
     * @example
     *
     * _.toLength(3.2);
     * // => 3
     *
     * _.toLength(Number.MIN_VALUE);
     * // => 0
     *
     * _.toLength(Infinity);
     * // => 4294967295
     *
     * _.toLength('3.2');
     * // => 3
     */
    function toLength(value) {
      return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH) : 0;
    }

    /**
     * Converts `value` to a number.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to process.
     * @returns {number} Returns the number.
     * @example
     *
     * _.toNumber(3.2);
     * // => 3.2
     *
     * _.toNumber(Number.MIN_VALUE);
     * // => 5e-324
     *
     * _.toNumber(Infinity);
     * // => Infinity
     *
     * _.toNumber('3.2');
     * // => 3.2
     */
    function toNumber(value) {
      if (typeof value == 'number') {
        return value;
      }
      if (isSymbol(value)) {
        return NAN;
      }
      if (isObject(value)) {
        var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
        value = isObject(other) ? (other + '') : other;
      }
      if (typeof value != 'string') {
        return value === 0 ? value : +value;
      }
      value = baseTrim(value);
      var isBinary = reIsBinary.test(value);
      return (isBinary || reIsOctal.test(value))
        ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
        : (reIsBadHex.test(value) ? NAN : +value);
    }

    /**
     * Converts `value` to a plain object flattening inherited enumerable string
     * keyed properties of `value` to own properties of the plain object.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {Object} Returns the converted plain object.
     * @example
     *
     * function Foo() {
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.assign({ 'a': 1 }, new Foo);
     * // => { 'a': 1, 'b': 2 }
     *
     * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
     * // => { 'a': 1, 'b': 2, 'c': 3 }
     */
    function toPlainObject(value) {
      return copyObject(value, keysIn(value));
    }

    /**
     * Converts `value` to a safe integer. A safe integer can be compared and
     * represented correctly.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {number} Returns the converted integer.
     * @example
     *
     * _.toSafeInteger(3.2);
     * // => 3
     *
     * _.toSafeInteger(Number.MIN_VALUE);
     * // => 0
     *
     * _.toSafeInteger(Infinity);
     * // => 9007199254740991
     *
     * _.toSafeInteger('3.2');
     * // => 3
     */
    function toSafeInteger(value) {
      return value
        ? baseClamp(toInteger(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER)
        : (value === 0 ? value : 0);
    }

    /**
     * Converts `value` to a string. An empty string is returned for `null`
     * and `undefined` values. The sign of `-0` is preserved.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {string} Returns the converted string.
     * @example
     *
     * _.toString(null);
     * // => ''
     *
     * _.toString(-0);
     * // => '-0'
     *
     * _.toString([1, 2, 3]);
     * // => '1,2,3'
     */
    function toString(value) {
      return value == null ? '' : baseToString(value);
    }

    /*------------------------------------------------------------------------*/

    /**
     * Assigns own enumerable string keyed properties of source objects to the
     * destination object. Source objects are applied from left to right.
     * Subsequent sources overwrite property assignments of previous sources.
     *
     * **Note:** This method mutates `object` and is loosely based on
     * [`Object.assign`](https://mdn.io/Object/assign).
     *
     * @static
     * @memberOf _
     * @since 0.10.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @see _.assignIn
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     * }
     *
     * function Bar() {
     *   this.c = 3;
     * }
     *
     * Foo.prototype.b = 2;
     * Bar.prototype.d = 4;
     *
     * _.assign({ 'a': 0 }, new Foo, new Bar);
     * // => { 'a': 1, 'c': 3 }
     */
    var assign = createAssigner(function(object, source) {
      if (isPrototype(source) || isArrayLike(source)) {
        copyObject(source, keys(source), object);
        return;
      }
      for (var key in source) {
        if (hasOwnProperty.call(source, key)) {
          assignValue(object, key, source[key]);
        }
      }
    });

    /**
     * This method is like `_.assign` except that it iterates over own and
     * inherited source properties.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @alias extend
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @see _.assign
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     * }
     *
     * function Bar() {
     *   this.c = 3;
     * }
     *
     * Foo.prototype.b = 2;
     * Bar.prototype.d = 4;
     *
     * _.assignIn({ 'a': 0 }, new Foo, new Bar);
     * // => { 'a': 1, 'b': 2, 'c': 3, 'd': 4 }
     */
    var assignIn = createAssigner(function(object, source) {
      copyObject(source, keysIn(source), object);
    });

    /**
     * This method is like `_.assignIn` except that it accepts `customizer`
     * which is invoked to produce the assigned values. If `customizer` returns
     * `undefined`, assignment is handled by the method instead. The `customizer`
     * is invoked with five arguments: (objValue, srcValue, key, object, source).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @alias extendWith
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} sources The source objects.
     * @param {Function} [customizer] The function to customize assigned values.
     * @returns {Object} Returns `object`.
     * @see _.assignWith
     * @example
     *
     * function customizer(objValue, srcValue) {
     *   return _.isUndefined(objValue) ? srcValue : objValue;
     * }
     *
     * var defaults = _.partialRight(_.assignInWith, customizer);
     *
     * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
     * // => { 'a': 1, 'b': 2 }
     */
    var assignInWith = createAssigner(function(object, source, srcIndex, customizer) {
      copyObject(source, keysIn(source), object, customizer);
    });

    /**
     * This method is like `_.assign` except that it accepts `customizer`
     * which is invoked to produce the assigned values. If `customizer` returns
     * `undefined`, assignment is handled by the method instead. The `customizer`
     * is invoked with five arguments: (objValue, srcValue, key, object, source).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} sources The source objects.
     * @param {Function} [customizer] The function to customize assigned values.
     * @returns {Object} Returns `object`.
     * @see _.assignInWith
     * @example
     *
     * function customizer(objValue, srcValue) {
     *   return _.isUndefined(objValue) ? srcValue : objValue;
     * }
     *
     * var defaults = _.partialRight(_.assignWith, customizer);
     *
     * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
     * // => { 'a': 1, 'b': 2 }
     */
    var assignWith = createAssigner(function(object, source, srcIndex, customizer) {
      copyObject(source, keys(source), object, customizer);
    });

    /**
     * Creates an array of values corresponding to `paths` of `object`.
     *
     * @static
     * @memberOf _
     * @since 1.0.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {...(string|string[])} [paths] The property paths to pick.
     * @returns {Array} Returns the picked values.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }, 4] };
     *
     * _.at(object, ['a[0].b.c', 'a[1]']);
     * // => [3, 4]
     */
    var at = flatRest(baseAt);

    /**
     * Creates an object that inherits from the `prototype` object. If a
     * `properties` object is given, its own enumerable string keyed properties
     * are assigned to the created object.
     *
     * @static
     * @memberOf _
     * @since 2.3.0
     * @category Object
     * @param {Object} prototype The object to inherit from.
     * @param {Object} [properties] The properties to assign to the object.
     * @returns {Object} Returns the new object.
     * @example
     *
     * function Shape() {
     *   this.x = 0;
     *   this.y = 0;
     * }
     *
     * function Circle() {
     *   Shape.call(this);
     * }
     *
     * Circle.prototype = _.create(Shape.prototype, {
     *   'constructor': Circle
     * });
     *
     * var circle = new Circle;
     * circle instanceof Circle;
     * // => true
     *
     * circle instanceof Shape;
     * // => true
     */
    function create(prototype, properties) {
      var result = baseCreate(prototype);
      return properties == null ? result : baseAssign(result, properties);
    }

    /**
     * Assigns own and inherited enumerable string keyed properties of source
     * objects to the destination object for all destination properties that
     * resolve to `undefined`. Source objects are applied from left to right.
     * Once a property is set, additional values of the same property are ignored.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @see _.defaultsDeep
     * @example
     *
     * _.defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
     * // => { 'a': 1, 'b': 2 }
     */
    var defaults = baseRest(function(object, sources) {
      object = Object(object);

      var index = -1;
      var length = sources.length;
      var guard = length > 2 ? sources[2] : undefined;

      if (guard && isIterateeCall(sources[0], sources[1], guard)) {
        length = 1;
      }

      while (++index < length) {
        var source = sources[index];
        var props = keysIn(source);
        var propsIndex = -1;
        var propsLength = props.length;

        while (++propsIndex < propsLength) {
          var key = props[propsIndex];
          var value = object[key];

          if (value === undefined ||
              (eq(value, objectProto[key]) && !hasOwnProperty.call(object, key))) {
            object[key] = source[key];
          }
        }
      }

      return object;
    });

    /**
     * This method is like `_.defaults` except that it recursively assigns
     * default properties.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 3.10.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @see _.defaults
     * @example
     *
     * _.defaultsDeep({ 'a': { 'b': 2 } }, { 'a': { 'b': 1, 'c': 3 } });
     * // => { 'a': { 'b': 2, 'c': 3 } }
     */
    var defaultsDeep = baseRest(function(args) {
      args.push(undefined, customDefaultsMerge);
      return apply(mergeWith, undefined, args);
    });

    /**
     * This method is like `_.find` except that it returns the key of the first
     * element `predicate` returns truthy for instead of the element itself.
     *
     * @static
     * @memberOf _
     * @since 1.1.0
     * @category Object
     * @param {Object} object The object to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {string|undefined} Returns the key of the matched element,
     *  else `undefined`.
     * @example
     *
     * var users = {
     *   'barney':  { 'age': 36, 'active': true },
     *   'fred':    { 'age': 40, 'active': false },
     *   'pebbles': { 'age': 1,  'active': true }
     * };
     *
     * _.findKey(users, function(o) { return o.age < 40; });
     * // => 'barney' (iteration order is not guaranteed)
     *
     * // The `_.matches` iteratee shorthand.
     * _.findKey(users, { 'age': 1, 'active': true });
     * // => 'pebbles'
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.findKey(users, ['active', false]);
     * // => 'fred'
     *
     * // The `_.property` iteratee shorthand.
     * _.findKey(users, 'active');
     * // => 'barney'
     */
    function findKey(object, predicate) {
      return baseFindKey(object, getIteratee(predicate, 3), baseForOwn);
    }

    /**
     * This method is like `_.findKey` except that it iterates over elements of
     * a collection in the opposite order.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Object
     * @param {Object} object The object to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {string|undefined} Returns the key of the matched element,
     *  else `undefined`.
     * @example
     *
     * var users = {
     *   'barney':  { 'age': 36, 'active': true },
     *   'fred':    { 'age': 40, 'active': false },
     *   'pebbles': { 'age': 1,  'active': true }
     * };
     *
     * _.findLastKey(users, function(o) { return o.age < 40; });
     * // => returns 'pebbles' assuming `_.findKey` returns 'barney'
     *
     * // The `_.matches` iteratee shorthand.
     * _.findLastKey(users, { 'age': 36, 'active': true });
     * // => 'barney'
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.findLastKey(users, ['active', false]);
     * // => 'fred'
     *
     * // The `_.property` iteratee shorthand.
     * _.findLastKey(users, 'active');
     * // => 'pebbles'
     */
    function findLastKey(object, predicate) {
      return baseFindKey(object, getIteratee(predicate, 3), baseForOwnRight);
    }

    /**
     * Iterates over own and inherited enumerable string keyed properties of an
     * object and invokes `iteratee` for each property. The iteratee is invoked
     * with three arguments: (value, key, object). Iteratee functions may exit
     * iteration early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @since 0.3.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns `object`.
     * @see _.forInRight
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forIn(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => Logs 'a', 'b', then 'c' (iteration order is not guaranteed).
     */
    function forIn(object, iteratee) {
      return object == null
        ? object
        : baseFor(object, getIteratee(iteratee, 3), keysIn);
    }

    /**
     * This method is like `_.forIn` except that it iterates over properties of
     * `object` in the opposite order.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns `object`.
     * @see _.forIn
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forInRight(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => Logs 'c', 'b', then 'a' assuming `_.forIn` logs 'a', 'b', then 'c'.
     */
    function forInRight(object, iteratee) {
      return object == null
        ? object
        : baseForRight(object, getIteratee(iteratee, 3), keysIn);
    }

    /**
     * Iterates over own enumerable string keyed properties of an object and
     * invokes `iteratee` for each property. The iteratee is invoked with three
     * arguments: (value, key, object). Iteratee functions may exit iteration
     * early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @since 0.3.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns `object`.
     * @see _.forOwnRight
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forOwn(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => Logs 'a' then 'b' (iteration order is not guaranteed).
     */
    function forOwn(object, iteratee) {
      return object && baseForOwn(object, getIteratee(iteratee, 3));
    }

    /**
     * This method is like `_.forOwn` except that it iterates over properties of
     * `object` in the opposite order.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns `object`.
     * @see _.forOwn
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forOwnRight(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => Logs 'b' then 'a' assuming `_.forOwn` logs 'a' then 'b'.
     */
    function forOwnRight(object, iteratee) {
      return object && baseForOwnRight(object, getIteratee(iteratee, 3));
    }

    /**
     * Creates an array of function property names from own enumerable properties
     * of `object`.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns the function names.
     * @see _.functionsIn
     * @example
     *
     * function Foo() {
     *   this.a = _.constant('a');
     *   this.b = _.constant('b');
     * }
     *
     * Foo.prototype.c = _.constant('c');
     *
     * _.functions(new Foo);
     * // => ['a', 'b']
     */
    function functions(object) {
      return object == null ? [] : baseFunctions(object, keys(object));
    }

    /**
     * Creates an array of function property names from own and inherited
     * enumerable properties of `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns the function names.
     * @see _.functions
     * @example
     *
     * function Foo() {
     *   this.a = _.constant('a');
     *   this.b = _.constant('b');
     * }
     *
     * Foo.prototype.c = _.constant('c');
     *
     * _.functionsIn(new Foo);
     * // => ['a', 'b', 'c']
     */
    function functionsIn(object) {
      return object == null ? [] : baseFunctions(object, keysIn(object));
    }

    /**
     * Gets the value at `path` of `object`. If the resolved value is
     * `undefined`, the `defaultValue` is returned in its place.
     *
     * @static
     * @memberOf _
     * @since 3.7.0
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the property to get.
     * @param {*} [defaultValue] The value returned for `undefined` resolved values.
     * @returns {*} Returns the resolved value.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
     *
     * _.get(object, 'a[0].b.c');
     * // => 3
     *
     * _.get(object, ['a', '0', 'b', 'c']);
     * // => 3
     *
     * _.get(object, 'a.b.c', 'default');
     * // => 'default'
     */
    function get(object, path, defaultValue) {
      var result = object == null ? undefined : baseGet(object, path);
      return result === undefined ? defaultValue : result;
    }

    /**
     * Checks if `path` is a direct property of `object`.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path to check.
     * @returns {boolean} Returns `true` if `path` exists, else `false`.
     * @example
     *
     * var object = { 'a': { 'b': 2 } };
     * var other = _.create({ 'a': _.create({ 'b': 2 }) });
     *
     * _.has(object, 'a');
     * // => true
     *
     * _.has(object, 'a.b');
     * // => true
     *
     * _.has(object, ['a', 'b']);
     * // => true
     *
     * _.has(other, 'a');
     * // => false
     */
    function has(object, path) {
      return object != null && hasPath(object, path, baseHas);
    }

    /**
     * Checks if `path` is a direct or inherited property of `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path to check.
     * @returns {boolean} Returns `true` if `path` exists, else `false`.
     * @example
     *
     * var object = _.create({ 'a': _.create({ 'b': 2 }) });
     *
     * _.hasIn(object, 'a');
     * // => true
     *
     * _.hasIn(object, 'a.b');
     * // => true
     *
     * _.hasIn(object, ['a', 'b']);
     * // => true
     *
     * _.hasIn(object, 'b');
     * // => false
     */
    function hasIn(object, path) {
      return object != null && hasPath(object, path, baseHasIn);
    }

    /**
     * Creates an object composed of the inverted keys and values of `object`.
     * If `object` contains duplicate values, subsequent values overwrite
     * property assignments of previous values.
     *
     * @static
     * @memberOf _
     * @since 0.7.0
     * @category Object
     * @param {Object} object The object to invert.
     * @returns {Object} Returns the new inverted object.
     * @example
     *
     * var object = { 'a': 1, 'b': 2, 'c': 1 };
     *
     * _.invert(object);
     * // => { '1': 'c', '2': 'b' }
     */
    var invert = createInverter(function(result, value, key) {
      if (value != null &&
          typeof value.toString != 'function') {
        value = nativeObjectToString.call(value);
      }

      result[value] = key;
    }, constant(identity));

    /**
     * This method is like `_.invert` except that the inverted object is generated
     * from the results of running each element of `object` thru `iteratee`. The
     * corresponding inverted value of each inverted key is an array of keys
     * responsible for generating the inverted value. The iteratee is invoked
     * with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.1.0
     * @category Object
     * @param {Object} object The object to invert.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Object} Returns the new inverted object.
     * @example
     *
     * var object = { 'a': 1, 'b': 2, 'c': 1 };
     *
     * _.invertBy(object);
     * // => { '1': ['a', 'c'], '2': ['b'] }
     *
     * _.invertBy(object, function(value) {
     *   return 'group' + value;
     * });
     * // => { 'group1': ['a', 'c'], 'group2': ['b'] }
     */
    var invertBy = createInverter(function(result, value, key) {
      if (value != null &&
          typeof value.toString != 'function') {
        value = nativeObjectToString.call(value);
      }

      if (hasOwnProperty.call(result, value)) {
        result[value].push(key);
      } else {
        result[value] = [key];
      }
    }, getIteratee);

    /**
     * Invokes the method at `path` of `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the method to invoke.
     * @param {...*} [args] The arguments to invoke the method with.
     * @returns {*} Returns the result of the invoked method.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': [1, 2, 3, 4] } }] };
     *
     * _.invoke(object, 'a[0].b.c.slice', 1, 3);
     * // => [2, 3]
     */
    var invoke = baseRest(baseInvoke);

    /**
     * Creates an array of the own enumerable property names of `object`.
     *
     * **Note:** Non-object values are coerced to objects. See the
     * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
     * for more details.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.keys(new Foo);
     * // => ['a', 'b'] (iteration order is not guaranteed)
     *
     * _.keys('hi');
     * // => ['0', '1']
     */
    function keys(object) {
      return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
    }

    /**
     * Creates an array of the own and inherited enumerable property names of `object`.
     *
     * **Note:** Non-object values are coerced to objects.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.keysIn(new Foo);
     * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
     */
    function keysIn(object) {
      return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
    }

    /**
     * The opposite of `_.mapValues`; this method creates an object with the
     * same values as `object` and keys generated by running each own enumerable
     * string keyed property of `object` thru `iteratee`. The iteratee is invoked
     * with three arguments: (value, key, object).
     *
     * @static
     * @memberOf _
     * @since 3.8.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns the new mapped object.
     * @see _.mapValues
     * @example
     *
     * _.mapKeys({ 'a': 1, 'b': 2 }, function(value, key) {
     *   return key + value;
     * });
     * // => { 'a1': 1, 'b2': 2 }
     */
    function mapKeys(object, iteratee) {
      var result = {};
      iteratee = getIteratee(iteratee, 3);

      baseForOwn(object, function(value, key, object) {
        baseAssignValue(result, iteratee(value, key, object), value);
      });
      return result;
    }

    /**
     * Creates an object with the same keys as `object` and values generated
     * by running each own enumerable string keyed property of `object` thru
     * `iteratee`. The iteratee is invoked with three arguments:
     * (value, key, object).
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns the new mapped object.
     * @see _.mapKeys
     * @example
     *
     * var users = {
     *   'fred':    { 'user': 'fred',    'age': 40 },
     *   'pebbles': { 'user': 'pebbles', 'age': 1 }
     * };
     *
     * _.mapValues(users, function(o) { return o.age; });
     * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
     *
     * // The `_.property` iteratee shorthand.
     * _.mapValues(users, 'age');
     * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
     */
    function mapValues(object, iteratee) {
      var result = {};
      iteratee = getIteratee(iteratee, 3);

      baseForOwn(object, function(value, key, object) {
        baseAssignValue(result, key, iteratee(value, key, object));
      });
      return result;
    }

    /**
     * This method is like `_.assign` except that it recursively merges own and
     * inherited enumerable string keyed properties of source objects into the
     * destination object. Source properties that resolve to `undefined` are
     * skipped if a destination value exists. Array and plain object properties
     * are merged recursively. Other objects and value types are overridden by
     * assignment. Source objects are applied from left to right. Subsequent
     * sources overwrite property assignments of previous sources.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 0.5.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = {
     *   'a': [{ 'b': 2 }, { 'd': 4 }]
     * };
     *
     * var other = {
     *   'a': [{ 'c': 3 }, { 'e': 5 }]
     * };
     *
     * _.merge(object, other);
     * // => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }
     */
    var merge = createAssigner(function(object, source, srcIndex) {
      baseMerge(object, source, srcIndex);
    });

    /**
     * This method is like `_.merge` except that it accepts `customizer` which
     * is invoked to produce the merged values of the destination and source
     * properties. If `customizer` returns `undefined`, merging is handled by the
     * method instead. The `customizer` is invoked with six arguments:
     * (objValue, srcValue, key, object, source, stack).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} sources The source objects.
     * @param {Function} customizer The function to customize assigned values.
     * @returns {Object} Returns `object`.
     * @example
     *
     * function customizer(objValue, srcValue) {
     *   if (_.isArray(objValue)) {
     *     return objValue.concat(srcValue);
     *   }
     * }
     *
     * var object = { 'a': [1], 'b': [2] };
     * var other = { 'a': [3], 'b': [4] };
     *
     * _.mergeWith(object, other, customizer);
     * // => { 'a': [1, 3], 'b': [2, 4] }
     */
    var mergeWith = createAssigner(function(object, source, srcIndex, customizer) {
      baseMerge(object, source, srcIndex, customizer);
    });

    /**
     * The opposite of `_.pick`; this method creates an object composed of the
     * own and inherited enumerable property paths of `object` that are not omitted.
     *
     * **Note:** This method is considerably slower than `_.pick`.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The source object.
     * @param {...(string|string[])} [paths] The property paths to omit.
     * @returns {Object} Returns the new object.
     * @example
     *
     * var object = { 'a': 1, 'b': '2', 'c': 3 };
     *
     * _.omit(object, ['a', 'c']);
     * // => { 'b': '2' }
     */
    var omit = flatRest(function(object, paths) {
      var result = {};
      if (object == null) {
        return result;
      }
      var isDeep = false;
      paths = arrayMap(paths, function(path) {
        path = castPath(path, object);
        isDeep || (isDeep = path.length > 1);
        return path;
      });
      copyObject(object, getAllKeysIn(object), result);
      if (isDeep) {
        result = baseClone(result, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
      }
      var length = paths.length;
      while (length--) {
        baseUnset(result, paths[length]);
      }
      return result;
    });

    /**
     * The opposite of `_.pickBy`; this method creates an object composed of
     * the own and inherited enumerable string keyed properties of `object` that
     * `predicate` doesn't return truthy for. The predicate is invoked with two
     * arguments: (value, key).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The source object.
     * @param {Function} [predicate=_.identity] The function invoked per property.
     * @returns {Object} Returns the new object.
     * @example
     *
     * var object = { 'a': 1, 'b': '2', 'c': 3 };
     *
     * _.omitBy(object, _.isNumber);
     * // => { 'b': '2' }
     */
    function omitBy(object, predicate) {
      return pickBy(object, negate(getIteratee(predicate)));
    }

    /**
     * Creates an object composed of the picked `object` properties.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The source object.
     * @param {...(string|string[])} [paths] The property paths to pick.
     * @returns {Object} Returns the new object.
     * @example
     *
     * var object = { 'a': 1, 'b': '2', 'c': 3 };
     *
     * _.pick(object, ['a', 'c']);
     * // => { 'a': 1, 'c': 3 }
     */
    var pick = flatRest(function(object, paths) {
      return object == null ? {} : basePick(object, paths);
    });

    /**
     * Creates an object composed of the `object` properties `predicate` returns
     * truthy for. The predicate is invoked with two arguments: (value, key).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The source object.
     * @param {Function} [predicate=_.identity] The function invoked per property.
     * @returns {Object} Returns the new object.
     * @example
     *
     * var object = { 'a': 1, 'b': '2', 'c': 3 };
     *
     * _.pickBy(object, _.isNumber);
     * // => { 'a': 1, 'c': 3 }
     */
    function pickBy(object, predicate) {
      if (object == null) {
        return {};
      }
      var props = arrayMap(getAllKeysIn(object), function(prop) {
        return [prop];
      });
      predicate = getIteratee(predicate);
      return basePickBy(object, props, function(value, path) {
        return predicate(value, path[0]);
      });
    }

    /**
     * This method is like `_.get` except that if the resolved value is a
     * function it's invoked with the `this` binding of its parent object and
     * its result is returned.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the property to resolve.
     * @param {*} [defaultValue] The value returned for `undefined` resolved values.
     * @returns {*} Returns the resolved value.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c1': 3, 'c2': _.constant(4) } }] };
     *
     * _.result(object, 'a[0].b.c1');
     * // => 3
     *
     * _.result(object, 'a[0].b.c2');
     * // => 4
     *
     * _.result(object, 'a[0].b.c3', 'default');
     * // => 'default'
     *
     * _.result(object, 'a[0].b.c3', _.constant('default'));
     * // => 'default'
     */
    function result(object, path, defaultValue) {
      path = castPath(path, object);

      var index = -1,
          length = path.length;

      // Ensure the loop is entered when path is empty.
      if (!length) {
        length = 1;
        object = undefined;
      }
      while (++index < length) {
        var value = object == null ? undefined : object[toKey(path[index])];
        if (value === undefined) {
          index = length;
          value = defaultValue;
        }
        object = isFunction(value) ? value.call(object) : value;
      }
      return object;
    }

    /**
     * Sets the value at `path` of `object`. If a portion of `path` doesn't exist,
     * it's created. Arrays are created for missing index properties while objects
     * are created for all other missing properties. Use `_.setWith` to customize
     * `path` creation.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 3.7.0
     * @category Object
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
     *
     * _.set(object, 'a[0].b.c', 4);
     * console.log(object.a[0].b.c);
     * // => 4
     *
     * _.set(object, ['x', '0', 'y', 'z'], 5);
     * console.log(object.x[0].y.z);
     * // => 5
     */
    function set(object, path, value) {
      return object == null ? object : baseSet(object, path, value);
    }

    /**
     * This method is like `_.set` except that it accepts `customizer` which is
     * invoked to produce the objects of `path`.  If `customizer` returns `undefined`
     * path creation is handled by the method instead. The `customizer` is invoked
     * with three arguments: (nsValue, key, nsObject).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to set.
     * @param {*} value The value to set.
     * @param {Function} [customizer] The function to customize assigned values.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = {};
     *
     * _.setWith(object, '[0][1]', 'a', Object);
     * // => { '0': { '1': 'a' } }
     */
    function setWith(object, path, value, customizer) {
      customizer = typeof customizer == 'function' ? customizer : undefined;
      return object == null ? object : baseSet(object, path, value, customizer);
    }

    /**
     * Creates an array of own enumerable string keyed-value pairs for `object`
     * which can be consumed by `_.fromPairs`. If `object` is a map or set, its
     * entries are returned.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @alias entries
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the key-value pairs.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.toPairs(new Foo);
     * // => [['a', 1], ['b', 2]] (iteration order is not guaranteed)
     */
    var toPairs = createToPairs(keys);

    /**
     * Creates an array of own and inherited enumerable string keyed-value pairs
     * for `object` which can be consumed by `_.fromPairs`. If `object` is a map
     * or set, its entries are returned.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @alias entriesIn
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the key-value pairs.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.toPairsIn(new Foo);
     * // => [['a', 1], ['b', 2], ['c', 3]] (iteration order is not guaranteed)
     */
    var toPairsIn = createToPairs(keysIn);

    /**
     * An alternative to `_.reduce`; this method transforms `object` to a new
     * `accumulator` object which is the result of running each of its own
     * enumerable string keyed properties thru `iteratee`, with each invocation
     * potentially mutating the `accumulator` object. If `accumulator` is not
     * provided, a new object with the same `[[Prototype]]` will be used. The
     * iteratee is invoked with four arguments: (accumulator, value, key, object).
     * Iteratee functions may exit iteration early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @since 1.3.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [accumulator] The custom accumulator value.
     * @returns {*} Returns the accumulated value.
     * @example
     *
     * _.transform([2, 3, 4], function(result, n) {
     *   result.push(n *= n);
     *   return n % 2 == 0;
     * }, []);
     * // => [4, 9]
     *
     * _.transform({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {
     *   (result[value] || (result[value] = [])).push(key);
     * }, {});
     * // => { '1': ['a', 'c'], '2': ['b'] }
     */
    function transform(object, iteratee, accumulator) {
      var isArr = isArray(object),
          isArrLike = isArr || isBuffer(object) || isTypedArray(object);

      iteratee = getIteratee(iteratee, 4);
      if (accumulator == null) {
        var Ctor = object && object.constructor;
        if (isArrLike) {
          accumulator = isArr ? new Ctor : [];
        }
        else if (isObject(object)) {
          accumulator = isFunction(Ctor) ? baseCreate(getPrototype(object)) : {};
        }
        else {
          accumulator = {};
        }
      }
      (isArrLike ? arrayEach : baseForOwn)(object, function(value, index, object) {
        return iteratee(accumulator, value, index, object);
      });
      return accumulator;
    }

    /**
     * Removes the property at `path` of `object`.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to unset.
     * @returns {boolean} Returns `true` if the property is deleted, else `false`.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 7 } }] };
     * _.unset(object, 'a[0].b.c');
     * // => true
     *
     * console.log(object);
     * // => { 'a': [{ 'b': {} }] };
     *
     * _.unset(object, ['a', '0', 'b', 'c']);
     * // => true
     *
     * console.log(object);
     * // => { 'a': [{ 'b': {} }] };
     */
    function unset(object, path) {
      return object == null ? true : baseUnset(object, path);
    }

    /**
     * This method is like `_.set` except that accepts `updater` to produce the
     * value to set. Use `_.updateWith` to customize `path` creation. The `updater`
     * is invoked with one argument: (value).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.6.0
     * @category Object
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to set.
     * @param {Function} updater The function to produce the updated value.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
     *
     * _.update(object, 'a[0].b.c', function(n) { return n * n; });
     * console.log(object.a[0].b.c);
     * // => 9
     *
     * _.update(object, 'x[0].y.z', function(n) { return n ? n + 1 : 0; });
     * console.log(object.x[0].y.z);
     * // => 0
     */
    function update(object, path, updater) {
      return object == null ? object : baseUpdate(object, path, castFunction(updater));
    }

    /**
     * This method is like `_.update` except that it accepts `customizer` which is
     * invoked to produce the objects of `path`.  If `customizer` returns `undefined`
     * path creation is handled by the method instead. The `customizer` is invoked
     * with three arguments: (nsValue, key, nsObject).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.6.0
     * @category Object
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to set.
     * @param {Function} updater The function to produce the updated value.
     * @param {Function} [customizer] The function to customize assigned values.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = {};
     *
     * _.updateWith(object, '[0][1]', _.constant('a'), Object);
     * // => { '0': { '1': 'a' } }
     */
    function updateWith(object, path, updater, customizer) {
      customizer = typeof customizer == 'function' ? customizer : undefined;
      return object == null ? object : baseUpdate(object, path, castFunction(updater), customizer);
    }

    /**
     * Creates an array of the own enumerable string keyed property values of `object`.
     *
     * **Note:** Non-object values are coerced to objects.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property values.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.values(new Foo);
     * // => [1, 2] (iteration order is not guaranteed)
     *
     * _.values('hi');
     * // => ['h', 'i']
     */
    function values(object) {
      return object == null ? [] : baseValues(object, keys(object));
    }

    /**
     * Creates an array of the own and inherited enumerable string keyed property
     * values of `object`.
     *
     * **Note:** Non-object values are coerced to objects.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property values.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.valuesIn(new Foo);
     * // => [1, 2, 3] (iteration order is not guaranteed)
     */
    function valuesIn(object) {
      return object == null ? [] : baseValues(object, keysIn(object));
    }

    /*------------------------------------------------------------------------*/

    /**
     * Clamps `number` within the inclusive `lower` and `upper` bounds.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Number
     * @param {number} number The number to clamp.
     * @param {number} [lower] The lower bound.
     * @param {number} upper The upper bound.
     * @returns {number} Returns the clamped number.
     * @example
     *
     * _.clamp(-10, -5, 5);
     * // => -5
     *
     * _.clamp(10, -5, 5);
     * // => 5
     */
    function clamp(number, lower, upper) {
      if (upper === undefined) {
        upper = lower;
        lower = undefined;
      }
      if (upper !== undefined) {
        upper = toNumber(upper);
        upper = upper === upper ? upper : 0;
      }
      if (lower !== undefined) {
        lower = toNumber(lower);
        lower = lower === lower ? lower : 0;
      }
      return baseClamp(toNumber(number), lower, upper);
    }

    /**
     * Checks if `n` is between `start` and up to, but not including, `end`. If
     * `end` is not specified, it's set to `start` with `start` then set to `0`.
     * If `start` is greater than `end` the params are swapped to support
     * negative ranges.
     *
     * @static
     * @memberOf _
     * @since 3.3.0
     * @category Number
     * @param {number} number The number to check.
     * @param {number} [start=0] The start of the range.
     * @param {number} end The end of the range.
     * @returns {boolean} Returns `true` if `number` is in the range, else `false`.
     * @see _.range, _.rangeRight
     * @example
     *
     * _.inRange(3, 2, 4);
     * // => true
     *
     * _.inRange(4, 8);
     * // => true
     *
     * _.inRange(4, 2);
     * // => false
     *
     * _.inRange(2, 2);
     * // => false
     *
     * _.inRange(1.2, 2);
     * // => true
     *
     * _.inRange(5.2, 4);
     * // => false
     *
     * _.inRange(-3, -2, -6);
     * // => true
     */
    function inRange(number, start, end) {
      start = toFinite(start);
      if (end === undefined) {
        end = start;
        start = 0;
      } else {
        end = toFinite(end);
      }
      number = toNumber(number);
      return baseInRange(number, start, end);
    }

    /**
     * Produces a random number between the inclusive `lower` and `upper` bounds.
     * If only one argument is provided a number between `0` and the given number
     * is returned. If `floating` is `true`, or either `lower` or `upper` are
     * floats, a floating-point number is returned instead of an integer.
     *
     * **Note:** JavaScript follows the IEEE-754 standard for resolving
     * floating-point values which can produce unexpected results.
     *
     * @static
     * @memberOf _
     * @since 0.7.0
     * @category Number
     * @param {number} [lower=0] The lower bound.
     * @param {number} [upper=1] The upper bound.
     * @param {boolean} [floating] Specify returning a floating-point number.
     * @returns {number} Returns the random number.
     * @example
     *
     * _.random(0, 5);
     * // => an integer between 0 and 5
     *
     * _.random(5);
     * // => also an integer between 0 and 5
     *
     * _.random(5, true);
     * // => a floating-point number between 0 and 5
     *
     * _.random(1.2, 5.2);
     * // => a floating-point number between 1.2 and 5.2
     */
    function random(lower, upper, floating) {
      if (floating && typeof floating != 'boolean' && isIterateeCall(lower, upper, floating)) {
        upper = floating = undefined;
      }
      if (floating === undefined) {
        if (typeof upper == 'boolean') {
          floating = upper;
          upper = undefined;
        }
        else if (typeof lower == 'boolean') {
          floating = lower;
          lower = undefined;
        }
      }
      if (lower === undefined && upper === undefined) {
        lower = 0;
        upper = 1;
      }
      else {
        lower = toFinite(lower);
        if (upper === undefined) {
          upper = lower;
          lower = 0;
        } else {
          upper = toFinite(upper);
        }
      }
      if (lower > upper) {
        var temp = lower;
        lower = upper;
        upper = temp;
      }
      if (floating || lower % 1 || upper % 1) {
        var rand = nativeRandom();
        return nativeMin(lower + (rand * (upper - lower + freeParseFloat('1e-' + ((rand + '').length - 1)))), upper);
      }
      return baseRandom(lower, upper);
    }

    /*------------------------------------------------------------------------*/

    /**
     * Converts `string` to [camel case](https://en.wikipedia.org/wiki/CamelCase).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the camel cased string.
     * @example
     *
     * _.camelCase('Foo Bar');
     * // => 'fooBar'
     *
     * _.camelCase('--foo-bar--');
     * // => 'fooBar'
     *
     * _.camelCase('__FOO_BAR__');
     * // => 'fooBar'
     */
    var camelCase = createCompounder(function(result, word, index) {
      word = word.toLowerCase();
      return result + (index ? capitalize(word) : word);
    });

    /**
     * Converts the first character of `string` to upper case and the remaining
     * to lower case.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to capitalize.
     * @returns {string} Returns the capitalized string.
     * @example
     *
     * _.capitalize('FRED');
     * // => 'Fred'
     */
    function capitalize(string) {
      return upperFirst(toString(string).toLowerCase());
    }

    /**
     * Deburrs `string` by converting
     * [Latin-1 Supplement](https://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block)#Character_table)
     * and [Latin Extended-A](https://en.wikipedia.org/wiki/Latin_Extended-A)
     * letters to basic Latin letters and removing
     * [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to deburr.
     * @returns {string} Returns the deburred string.
     * @example
     *
     * _.deburr('d√©j√† vu');
     * // => 'deja vu'
     */
    function deburr(string) {
      string = toString(string);
      return string && string.replace(reLatin, deburrLetter).replace(reComboMark, '');
    }

    /**
     * Checks if `string` ends with the given target string.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to inspect.
     * @param {string} [target] The string to search for.
     * @param {number} [position=string.length] The position to search up to.
     * @returns {boolean} Returns `true` if `string` ends with `target`,
     *  else `false`.
     * @example
     *
     * _.endsWith('abc', 'c');
     * // => true
     *
     * _.endsWith('abc', 'b');
     * // => false
     *
     * _.endsWith('abc', 'b', 2);
     * // => true
     */
    function endsWith(string, target, position) {
      string = toString(string);
      target = baseToString(target);

      var length = string.length;
      position = position === undefined
        ? length
        : baseClamp(toInteger(position), 0, length);

      var end = position;
      position -= target.length;
      return position >= 0 && string.slice(position, end) == target;
    }

    /**
     * Converts the characters "&", "<", ">", '"', and "'" in `string` to their
     * corresponding HTML entities.
     *
     * **Note:** No other characters are escaped. To escape additional
     * characters use a third-party library like [_he_](https://mths.be/he).
     *
     * Though the ">" character is escaped for symmetry, characters like
     * ">" and "/" don't need escaping in HTML and have no special meaning
     * unless they're part of a tag or unquoted attribute value. See
     * [Mathias Bynens's article](https://mathiasbynens.be/notes/ambiguous-ampersands)
     * (under "semi-related fun fact") for more details.
     *
     * When working with HTML you should always
     * [quote attribute values](http://wonko.com/post/html-escaping) to reduce
     * XSS vectors.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to escape.
     * @returns {string} Returns the escaped string.
     * @example
     *
     * _.escape('fred, barney, & pebbles');
     * // => 'fred, barney, &amp; pebbles'
     */
    function escape(string) {
      string = toString(string);
      return (string && reHasUnescapedHtml.test(string))
        ? string.replace(reUnescapedHtml, escapeHtmlChar)
        : string;
    }

    /**
     * Escapes the `RegExp` special characters "^", "$", "\", ".", "*", "+",
     * "?", "(", ")", "[", "]", "{", "}", and "|" in `string`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to escape.
     * @returns {string} Returns the escaped string.
     * @example
     *
     * _.escapeRegExp('[lodash](https://lodash.com/)');
     * // => '\[lodash\]\(https://lodash\.com/\)'
     */
    function escapeRegExp(string) {
      string = toString(string);
      return (string && reHasRegExpChar.test(string))
        ? string.replace(reRegExpChar, '\\$&')
        : string;
    }

    /**
     * Converts `string` to
     * [kebab case](https://en.wikipedia.org/wiki/Letter_case#Special_case_styles).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the kebab cased string.
     * @example
     *
     * _.kebabCase('Foo Bar');
     * // => 'foo-bar'
     *
     * _.kebabCase('fooBar');
     * // => 'foo-bar'
     *
     * _.kebabCase('__FOO_BAR__');
     * // => 'foo-bar'
     */
    var kebabCase = createCompounder(function(result, word, index) {
      return result + (index ? '-' : '') + word.toLowerCase();
    });

    /**
     * Converts `string`, as space separated words, to lower case.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the lower cased string.
     * @example
     *
     * _.lowerCase('--Foo-Bar--');
     * // => 'foo bar'
     *
     * _.lowerCase('fooBar');
     * // => 'foo bar'
     *
     * _.lowerCase('__FOO_BAR__');
     * // => 'foo bar'
     */
    var lowerCase = createCompounder(function(result, word, index) {
      return result + (index ? ' ' : '') + word.toLowerCase();
    });

    /**
     * Converts the first character of `string` to lower case.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the converted string.
     * @example
     *
     * _.lowerFirst('Fred');
     * // => 'fred'
     *
     * _.lowerFirst('FRED');
     * // => 'fRED'
     */
    var lowerFirst = createCaseFirst('toLowerCase');

    /**
     * Pads `string` on the left and right sides if it's shorter than `length`.
     * Padding characters are truncated if they can't be evenly divided by `length`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to pad.
     * @param {number} [length=0] The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padded string.
     * @example
     *
     * _.pad('abc', 8);
     * // => '  abc   '
     *
     * _.pad('abc', 8, '_-');
     * // => '_-abc_-_'
     *
     * _.pad('abc', 3);
     * // => 'abc'
     */
    function pad(string, length, chars) {
      string = toString(string);
      length = toInteger(length);

      var strLength = length ? stringSize(string) : 0;
      if (!length || strLength >= length) {
        return string;
      }
      var mid = (length - strLength) / 2;
      return (
        createPadding(nativeFloor(mid), chars) +
        string +
        createPadding(nativeCeil(mid), chars)
      );
    }

    /**
     * Pads `string` on the right side if it's shorter than `length`. Padding
     * characters are truncated if they exceed `length`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to pad.
     * @param {number} [length=0] The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padded string.
     * @example
     *
     * _.padEnd('abc', 6);
     * // => 'abc   '
     *
     * _.padEnd('abc', 6, '_-');
     * // => 'abc_-_'
     *
     * _.padEnd('abc', 3);
     * // => 'abc'
     */
    function padEnd(string, length, chars) {
      string = toString(string);
      length = toInteger(length);

      var strLength = length ? stringSize(string) : 0;
      return (length && strLength < length)
        ? (string + createPadding(length - strLength, chars))
        : string;
    }

    /**
     * Pads `string` on the left side if it's shorter than `length`. Padding
     * characters are truncated if they exceed `length`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to pad.
     * @param {number} [length=0] The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padded string.
     * @example
     *
     * _.padStart('abc', 6);
     * // => '   abc'
     *
     * _.padStart('abc', 6, '_-');
     * // => '_-_abc'
     *
     * _.padStart('abc', 3);
     * // => 'abc'
     */
    function padStart(string, length, chars) {
      string = toString(string);
      length = toInteger(length);

      var strLength = length ? stringSize(string) : 0;
      return (length && strLength < length)
        ? (createPadding(length - strLength, chars) + string)
        : string;
    }

    /**
     * Converts `string` to an integer of the specified radix. If `radix` is
     * `undefined` or `0`, a `radix` of `10` is used unless `value` is a
     * hexadecimal, in which case a `radix` of `16` is used.
     *
     * **Note:** This method aligns with the
     * [ES5 implementation](https://es5.github.io/#x15.1.2.2) of `parseInt`.
     *
     * @static
     * @memberOf _
     * @since 1.1.0
     * @category String
     * @param {string} string The string to convert.
     * @param {number} [radix=10] The radix to interpret `value` by.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {number} Returns the converted integer.
     * @example
     *
     * _.parseInt('08');
     * // => 8
     *
     * _.map(['6', '08', '10'], _.parseInt);
     * // => [6, 8, 10]
     */
    function parseInt(string, radix, guard) {
      if (guard || radix == null) {
        radix = 0;
      } else if (radix) {
        radix = +radix;
      }
      return nativeParseInt(toString(string).replace(reTrimStart, ''), radix || 0);
    }

    /**
     * Repeats the given string `n` times.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to repeat.
     * @param {number} [n=1] The number of times to repeat the string.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {string} Returns the repeated string.
     * @example
     *
     * _.repeat('*', 3);
     * // => '***'
     *
     * _.repeat('abc', 2);
     * // => 'abcabc'
     *
     * _.repeat('abc', 0);
     * // => ''
     */
    function repeat(string, n, guard) {
      if ((guard ? isIterateeCall(string, n, guard) : n === undefined)) {
        n = 1;
      } else {
        n = toInteger(n);
      }
      return baseRepeat(toString(string), n);
    }

    /**
     * Replaces matches for `pattern` in `string` with `replacement`.
     *
     * **Note:** This method is based on
     * [`String#replace`](https://mdn.io/String/replace).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to modify.
     * @param {RegExp|string} pattern The pattern to replace.
     * @param {Function|string} replacement The match replacement.
     * @returns {string} Returns the modified string.
     * @example
     *
     * _.replace('Hi Fred', 'Fred', 'Barney');
     * // => 'Hi Barney'
     */
    function replace() {
      var args = arguments,
          string = toString(args[0]);

      return args.length < 3 ? string : string.replace(args[1], args[2]);
    }

    /**
     * Converts `string` to
     * [snake case](https://en.wikipedia.org/wiki/Snake_case).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the snake cased string.
     * @example
     *
     * _.snakeCase('Foo Bar');
     * // => 'foo_bar'
     *
     * _.snakeCase('fooBar');
     * // => 'foo_bar'
     *
     * _.snakeCase('--FOO-BAR--');
     * // => 'foo_bar'
     */
    var snakeCase = createCompounder(function(result, word, index) {
      return result + (index ? '_' : '') + word.toLowerCase();
    });

    /**
     * Splits `string` by `separator`.
     *
     * **Note:** This method is based on
     * [`String#split`](https://mdn.io/String/split).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to split.
     * @param {RegExp|string} separator The separator pattern to split by.
     * @param {number} [limit] The length to truncate results to.
     * @returns {Array} Returns the string segments.
     * @example
     *
     * _.split('a-b-c', '-', 2);
     * // => ['a', 'b']
     */
    function split(string, separator, limit) {
      if (limit && typeof limit != 'number' && isIterateeCall(string, separator, limit)) {
        separator = limit = undefined;
      }
      limit = limit === undefined ? MAX_ARRAY_LENGTH : limit >>> 0;
      if (!limit) {
        return [];
      }
      string = toString(string);
      if (string && (
            typeof separator == 'string' ||
            (separator != null && !isRegExp(separator))
          )) {
        separator = baseToString(separator);
        if (!separator && hasUnicode(string)) {
          return castSlice(stringToArray(string), 0, limit);
        }
      }
      return string.split(separator, limit);
    }

    /**
     * Converts `string` to
     * [start case](https://en.wikipedia.org/wiki/Letter_case#Stylistic_or_specialised_usage).
     *
     * @static
     * @memberOf _
     * @since 3.1.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the start cased string.
     * @example
     *
     * _.startCase('--foo-bar--');
     * // => 'Foo Bar'
     *
     * _.startCase('fooBar');
     * // => 'Foo Bar'
     *
     * _.startCase('__FOO_BAR__');
     * // => 'FOO BAR'
     */
    var startCase = createCompounder(function(result, word, index) {
      return result + (index ? ' ' : '') + upperFirst(word);
    });

    /**
     * Checks if `string` starts with the given target string.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to inspect.
     * @param {string} [target] The string to search for.
     * @param {number} [position=0] The position to search from.
     * @returns {boolean} Returns `true` if `string` starts with `target`,
     *  else `false`.
     * @example
     *
     * _.startsWith('abc', 'a');
     * // => true
     *
     * _.startsWith('abc', 'b');
     * // => false
     *
     * _.startsWith('abc', 'b', 1);
     * // => true
     */
    function startsWith(string, target, position) {
      string = toString(string);
      position = position == null
        ? 0
        : baseClamp(toInteger(position), 0, string.length);

      target = baseToString(target);
      return string.slice(position, position + target.length) == target;
    }

    /**
     * Creates a compiled template function that can interpolate data properties
     * in "interpolate" delimiters, HTML-escape interpolated data properties in
     * "escape" delimiters, and execute JavaScript in "evaluate" delimiters. Data
     * properties may be accessed as free variables in the template. If a setting
     * object is given, it takes precedence over `_.templateSettings` values.
     *
     * **Note:** In the development build `_.template` utilizes
     * [sourceURLs](http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl)
     * for easier debugging.
     *
     * For more information on precompiling templates see
     * [lodash's custom builds documentation](https://lodash.com/custom-builds).
     *
     * For more information on Chrome extension sandboxes see
     * [Chrome's extensions documentation](https://developer.chrome.com/extensions/sandboxingEval).
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category String
     * @param {string} [string=''] The template string.
     * @param {Object} [options={}] The options object.
     * @param {RegExp} [options.escape=_.templateSettings.escape]
     *  The HTML "escape" delimiter.
     * @param {RegExp} [options.evaluate=_.templateSettings.evaluate]
     *  The "evaluate" delimiter.
     * @param {Object} [options.imports=_.templateSettings.imports]
     *  An object to import into the template as free variables.
     * @param {RegExp} [options.interpolate=_.templateSettings.interpolate]
     *  The "interpolate" delimiter.
     * @param {string} [options.sourceURL='lodash.templateSources[n]']
     *  The sourceURL of the compiled template.
     * @param {string} [options.variable='obj']
     *  The data object variable name.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Function} Returns the compiled template function.
     * @example
     *
     * // Use the "interpolate" delimiter to create a compiled template.
     * var compiled = _.template('hello <%= user %>!');
     * compiled({ 'user': 'fred' });
     * // => 'hello fred!'
     *
     * // Use the HTML "escape" delimiter to escape data property values.
     * var compiled = _.template('<b><%- value %></b>');
     * compiled({ 'value': '<script>' });
     * // => '<b>&lt;script&gt;</b>'
     *
     * // Use the "evaluate" delimiter to execute JavaScript and generate HTML.
     * var compiled = _.template('<% _.forEach(users, function(user) { %><li><%- user %></li><% }); %>');
     * compiled({ 'users': ['fred', 'barney'] });
     * // => '<li>fred</li><li>barney</li>'
     *
     * // Use the internal `print` function in "evaluate" delimiters.
     * var compiled = _.template('<% print("hello " + user); %>!');
     * compiled({ 'user': 'barney' });
     * // => 'hello barney!'
     *
     * // Use the ES template literal delimiter as an "interpolate" delimiter.
     * // Disable support by replacing the "interpolate" delimiter.
     * var compiled = _.template('hello ${ user }!');
     * compiled({ 'user': 'pebbles' });
     * // => 'hello pebbles!'
     *
     * // Use backslashes to treat delimiters as plain text.
     * var compiled = _.template('<%= "\\<%- value %\\>" %>');
     * compiled({ 'value': 'ignored' });
     * // => '<%- value %>'
     *
     * // Use the `imports` option to import `jQuery` as `jq`.
     * var text = '<% jq.each(users, function(user) { %><li><%- user %></li><% }); %>';
     * var compiled = _.template(text, { 'imports': { 'jq': jQuery } });
     * compiled({ 'users': ['fred', 'barney'] });
     * // => '<li>fred</li><li>barney</li>'
     *
     * // Use the `sourceURL` option to specify a custom sourceURL for the template.
     * var compiled = _.template('hello <%= user %>!', { 'sourceURL': '/basic/greeting.jst' });
     * compiled(data);
     * // => Find the source of "greeting.jst" under the Sources tab or Resources panel of the web inspector.
     *
     * // Use the `variable` option to ensure a with-statement isn't used in the compiled template.
     * var compiled = _.template('hi <%= data.user %>!', { 'variable': 'data' });
     * compiled.source;
     * // => function(data) {
     * //   var __t, __p = '';
     * //   __p += 'hi ' + ((__t = ( data.user )) == null ? '' : __t) + '!';
     * //   return __p;
     * // }
     *
     * // Use custom template delimiters.
     * _.templateSettings.interpolate = /{{([\s\S]+?)}}/g;
     * var compiled = _.template('hello {{ user }}!');
     * compiled({ 'user': 'mustache' });
     * // => 'hello mustache!'
     *
     * // Use the `source` property to inline compiled templates for meaningful
     * // line numbers in error messages and stack traces.
     * fs.writeFileSync(path.join(process.cwd(), 'jst.js'), '\
     *   var JST = {\
     *     "main": ' + _.template(mainText).source + '\
     *   };\
     * ');
     */
    function template(string, options, guard) {
      // Based on John Resig's `tmpl` implementation
      // (http://ejohn.org/blog/javascript-micro-templating/)
      // and Laura Doktorova's doT.js (https://github.com/olado/doT).
      var settings = lodash.templateSettings;

      if (guard && isIterateeCall(string, options, guard)) {
        options = undefined;
      }
      string = toString(string);
      options = assignInWith({}, options, settings, customDefaultsAssignIn);

      var imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn),
          importsKeys = keys(imports),
          importsValues = baseValues(imports, importsKeys);

      var isEscaping,
          isEvaluating,
          index = 0,
          interpolate = options.interpolate || reNoMatch,
          source = "__p += '";

      // Compile the regexp to match each delimiter.
      var reDelimiters = RegExp(
        (options.escape || reNoMatch).source + '|' +
        interpolate.source + '|' +
        (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + '|' +
        (options.evaluate || reNoMatch).source + '|$'
      , 'g');

      // Use a sourceURL for easier debugging.
      // The sourceURL gets injected into the source that's eval-ed, so be careful
      // to normalize all kinds of whitespace, so e.g. newlines (and unicode versions of it) can't sneak in
      // and escape the comment, thus injecting code that gets evaled.
      var sourceURL = '//# sourceURL=' +
        (hasOwnProperty.call(options, 'sourceURL')
          ? (options.sourceURL + '').replace(/\s/g, ' ')
          : ('lodash.templateSources[' + (++templateCounter) + ']')
        ) + '\n';

      string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
        interpolateValue || (interpolateValue = esTemplateValue);

        // Escape characters that can't be included in string literals.
        source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);

        // Replace delimiters with snippets.
        if (escapeValue) {
          isEscaping = true;
          source += "' +\n__e(" + escapeValue + ") +\n'";
        }
        if (evaluateValue) {
          isEvaluating = true;
          source += "';\n" + evaluateValue + ";\n__p += '";
        }
        if (interpolateValue) {
          source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
        }
        index = offset + match.length;

        // The JS engine embedded in Adobe products needs `match` returned in
        // order to produce the correct `offset` value.
        return match;
      });

      source += "';\n";

      // If `variable` is not specified wrap a with-statement around the generated
      // code to add the data object to the top of the scope chain.
      var variable = hasOwnProperty.call(options, 'variable') && options.variable;
      if (!variable) {
        source = 'with (obj) {\n' + source + '\n}\n';
      }
      // Throw an error if a forbidden character was found in `variable`, to prevent
      // potential command injection attacks.
      else if (reForbiddenIdentifierChars.test(variable)) {
        throw new Error(INVALID_TEMPL_VAR_ERROR_TEXT);
      }

      // Cleanup code by stripping empty strings.
      source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source)
        .replace(reEmptyStringMiddle, '$1')
        .replace(reEmptyStringTrailing, '$1;');

      // Frame code as the function body.
      source = 'function(' + (variable || 'obj') + ') {\n' +
        (variable
          ? ''
          : 'obj || (obj = {});\n'
        ) +
        "var __t, __p = ''" +
        (isEscaping
           ? ', __e = _.escape'
           : ''
        ) +
        (isEvaluating
          ? ', __j = Array.prototype.join;\n' +
            "function print() { __p += __j.call(arguments, '') }\n"
          : ';\n'
        ) +
        source +
        'return __p\n}';

      var result = attempt(function() {
        return Function(importsKeys, sourceURL + 'return ' + source)
          .apply(undefined, importsValues);
      });

      // Provide the compiled function's source by its `toString` method or
      // the `source` property as a convenience for inlining compiled templates.
      result.source = source;
      if (isError(result)) {
        throw result;
      }
      return result;
    }

    /**
     * Converts `string`, as a whole, to lower case just like
     * [String#toLowerCase](https://mdn.io/toLowerCase).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the lower cased string.
     * @example
     *
     * _.toLower('--Foo-Bar--');
     * // => '--foo-bar--'
     *
     * _.toLower('fooBar');
     * // => 'foobar'
     *
     * _.toLower('__FOO_BAR__');
     * // => '__foo_bar__'
     */
    function toLower(value) {
      return toString(value).toLowerCase();
    }

    /**
     * Converts `string`, as a whole, to upper case just like
     * [String#toUpperCase](https://mdn.io/toUpperCase).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the upper cased string.
     * @example
     *
     * _.toUpper('--foo-bar--');
     * // => '--FOO-BAR--'
     *
     * _.toUpper('fooBar');
     * // => 'FOOBAR'
     *
     * _.toUpper('__foo_bar__');
     * // => '__FOO_BAR__'
     */
    function toUpper(value) {
      return toString(value).toUpperCase();
    }

    /**
     * Removes leading and trailing whitespace or specified characters from `string`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to trim.
     * @param {string} [chars=whitespace] The characters to trim.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {string} Returns the trimmed string.
     * @example
     *
     * _.trim('  abc  ');
     * // => 'abc'
     *
     * _.trim('-_-abc-_-', '_-');
     * // => 'abc'
     *
     * _.map(['  foo  ', '  bar  '], _.trim);
     * // => ['foo', 'bar']
     */
    function trim(string, chars, guard) {
      string = toString(string);
      if (string && (guard || chars === undefined)) {
        return baseTrim(string);
      }
      if (!string || !(chars = baseToString(chars))) {
        return string;
      }
      var strSymbols = stringToArray(string),
          chrSymbols = stringToArray(chars),
          start = charsStartIndex(strSymbols, chrSymbols),
          end = charsEndIndex(strSymbols, chrSymbols) + 1;

      return castSlice(strSymbols, start, end).join('');
    }

    /**
     * Removes trailing whitespace or specified characters from `string`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to trim.
     * @param {string} [chars=whitespace] The characters to trim.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {string} Returns the trimmed string.
     * @example
     *
     * _.trimEnd('  abc  ');
     * // => '  abc'
     *
     * _.trimEnd('-_-abc-_-', '_-');
     * // => '-_-abc'
     */
    function trimEnd(string, chars, guard) {
      string = toString(string);
      if (string && (guard || chars === undefined)) {
        return string.slice(0, trimmedEndIndex(string) + 1);
      }
      if (!string || !(chars = baseToString(chars))) {
        return string;
      }
      var strSymbols = stringToArray(string),
          end = charsEndIndex(strSymbols, stringToArray(chars)) + 1;

      return castSlice(strSymbols, 0, end).join('');
    }

    /**
     * Removes leading whitespace or specified characters from `string`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to trim.
     * @param {string} [chars=whitespace] The characters to trim.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {string} Returns the trimmed string.
     * @example
     *
     * _.trimStart('  abc  ');
     * // => 'abc  '
     *
     * _.trimStart('-_-abc-_-', '_-');
     * // => 'abc-_-'
     */
    function trimStart(string, chars, guard) {
      string = toString(string);
      if (string && (guard || chars === undefined)) {
        return string.replace(reTrimStart, '');
      }
      if (!string || !(chars = baseToString(chars))) {
        return string;
      }
      var strSymbols = stringToArray(string),
          start = charsStartIndex(strSymbols, stringToArray(chars));

      return castSlice(strSymbols, start).join('');
    }

    /**
     * Truncates `string` if it's longer than the given maximum string length.
     * The last characters of the truncated string are replaced with the omission
     * string which defaults to "...".
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to truncate.
     * @param {Object} [options={}] The options object.
     * @param {number} [options.length=30] The maximum string length.
     * @param {string} [options.omission='...'] The string to indicate text is omitted.
     * @param {RegExp|string} [options.separator] The separator pattern to truncate to.
     * @returns {string} Returns the truncated string.
     * @example
     *
     * _.truncate('hi-diddly-ho there, neighborino');
     * // => 'hi-diddly-ho there, neighbo...'
     *
     * _.truncate('hi-diddly-ho there, neighborino', {
     *   'length': 24,
     *   'separator': ' '
     * });
     * // => 'hi-diddly-ho there,...'
     *
     * _.truncate('hi-diddly-ho there, neighborino', {
     *   'length': 24,
     *   'separator': /,? +/
     * });
     * // => 'hi-diddly-ho there...'
     *
     * _.truncate('hi-diddly-ho there, neighborino', {
     *   'omission': ' [...]'
     * });
     * // => 'hi-diddly-ho there, neig [...]'
     */
    function truncate(string, options) {
      var length = DEFAULT_TRUNC_LENGTH,
          omission = DEFAULT_TRUNC_OMISSION;

      if (isObject(options)) {
        var separator = 'separator' in options ? options.separator : separator;
        length = 'length' in options ? toInteger(options.length) : length;
        omission = 'omission' in options ? baseToString(options.omission) : omission;
      }
      string = toString(string);

      var strLength = string.length;
      if (hasUnicode(string)) {
        var strSymbols = stringToArray(string);
        strLength = strSymbols.length;
      }
      if (length >= strLength) {
        return string;
      }
      var end = length - stringSize(omission);
      if (end < 1) {
        return omission;
      }
      var result = strSymbols
        ? castSlice(strSymbols, 0, end).join('')
        : string.slice(0, end);

      if (separator === undefined) {
        return result + omission;
      }
      if (strSymbols) {
        end += (result.length - end);
      }
      if (isRegExp(separator)) {
        if (string.slice(end).search(separator)) {
          var match,
              substring = result;

          if (!separator.global) {
            separator = RegExp(separator.source, toString(reFlags.exec(separator)) + 'g');
          }
          separator.lastIndex = 0;
          while ((match = separator.exec(substring))) {
            var newEnd = match.index;
          }
          result = result.slice(0, newEnd === undefined ? end : newEnd);
        }
      } else if (string.indexOf(baseToString(separator), end) != end) {
        var index = result.lastIndexOf(separator);
        if (index > -1) {
          result = result.slice(0, index);
        }
      }
      return result + omission;
    }

    /**
     * The inverse of `_.escape`; this method converts the HTML entities
     * `&amp;`, `&lt;`, `&gt;`, `&quot;`, and `&#39;` in `string` to
     * their corresponding characters.
     *
     * **Note:** No other HTML entities are unescaped. To unescape additional
     * HTML entities use a third-party library like [_he_](https://mths.be/he).
     *
     * @static
     * @memberOf _
     * @since 0.6.0
     * @category String
     * @param {string} [string=''] The string to unescape.
     * @returns {string} Returns the unescaped string.
     * @example
     *
     * _.unescape('fred, barney, &amp; pebbles');
     * // => 'fred, barney, & pebbles'
     */
    function unescape(string) {
      string = toString(string);
      return (string && reHasEscapedHtml.test(string))
        ? string.replace(reEscapedHtml, unescapeHtmlChar)
        : string;
    }

    /**
     * Converts `string`, as space separated words, to upper case.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the upper cased string.
     * @example
     *
     * _.upperCase('--foo-bar');
     * // => 'FOO BAR'
     *
     * _.upperCase('fooBar');
     * // => 'FOO BAR'
     *
     * _.upperCase('__foo_bar__');
     * // => 'FOO BAR'
     */
    var upperCase = createCompounder(function(result, word, index) {
      return result + (index ? ' ' : '') + word.toUpperCase();
    });

    /**
     * Converts the first character of `string` to upper case.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the converted string.
     * @example
     *
     * _.upperFirst('fred');
     * // => 'Fred'
     *
     * _.upperFirst('FRED');
     * // => 'FRED'
     */
    var upperFirst = createCaseFirst('toUpperCase');

    /**
     * Splits `string` into an array of its words.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to inspect.
     * @param {RegExp|string} [pattern] The pattern to match words.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the words of `string`.
     * @example
     *
     * _.words('fred, barney, & pebbles');
     * // => ['fred', 'barney', 'pebbles']
     *
     * _.words('fred, barney, & pebbles', /[^, ]+/g);
     * // => ['fred', 'barney', '&', 'pebbles']
     */
    function words(string, pattern, guard) {
      string = toString(string);
      pattern = guard ? undefined : pattern;

      if (pattern === undefined) {
        return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
      }
      return string.match(pattern) || [];
    }

    /*------------------------------------------------------------------------*/

    /**
     * Attempts to invoke `func`, returning either the result or the caught error
     * object. Any additional arguments are provided to `func` when it's invoked.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Util
     * @param {Function} func The function to attempt.
     * @param {...*} [args] The arguments to invoke `func` with.
     * @returns {*} Returns the `func` result or error object.
     * @example
     *
     * // Avoid throwing errors for invalid selectors.
     * var elements = _.attempt(function(selector) {
     *   return document.querySelectorAll(selector);
     * }, '>_>');
     *
     * if (_.isError(elements)) {
     *   elements = [];
     * }
     */
    var attempt = baseRest(function(func, args) {
      try {
        return apply(func, undefined, args);
      } catch (e) {
        return isError(e) ? e : new Error(e);
      }
    });

    /**
     * Binds methods of an object to the object itself, overwriting the existing
     * method.
     *
     * **Note:** This method doesn't set the "length" property of bound functions.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {Object} object The object to bind and assign the bound methods to.
     * @param {...(string|string[])} methodNames The object method names to bind.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var view = {
     *   'label': 'docs',
     *   'click': function() {
     *     console.log('clicked ' + this.label);
     *   }
     * };
     *
     * _.bindAll(view, ['click']);
     * jQuery(element).on('click', view.click);
     * // => Logs 'clicked docs' when clicked.
     */
    var bindAll = flatRest(function(object, methodNames) {
      arrayEach(methodNames, function(key) {
        key = toKey(key);
        baseAssignValue(object, key, bind(object[key], object));
      });
      return object;
    });

    /**
     * Creates a function that iterates over `pairs` and invokes the corresponding
     * function of the first predicate to return truthy. The predicate-function
     * pairs are invoked with the `this` binding and arguments of the created
     * function.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {Array} pairs The predicate-function pairs.
     * @returns {Function} Returns the new composite function.
     * @example
     *
     * var func = _.cond([
     *   [_.matches({ 'a': 1 }),           _.constant('matches A')],
     *   [_.conforms({ 'b': _.isNumber }), _.constant('matches B')],
     *   [_.stubTrue,                      _.constant('no match')]
     * ]);
     *
     * func({ 'a': 1, 'b': 2 });
     * // => 'matches A'
     *
     * func({ 'a': 0, 'b': 1 });
     * // => 'matches B'
     *
     * func({ 'a': '1', 'b': '2' });
     * // => 'no match'
     */
    function cond(pairs) {
      var length = pairs == null ? 0 : pairs.length,
          toIteratee = getIteratee();

      pairs = !length ? [] : arrayMap(pairs, function(pair) {
        if (typeof pair[1] != 'function') {
          throw new TypeError(FUNC_ERROR_TEXT);
        }
        return [toIteratee(pair[0]), pair[1]];
      });

      return baseRest(function(args) {
        var index = -1;
        while (++index < length) {
          var pair = pairs[index];
          if (apply(pair[0], this, args)) {
            return apply(pair[1], this, args);
          }
        }
      });
    }

    /**
     * Creates a function that invokes the predicate properties of `source` with
     * the corresponding property values of a given object, returning `true` if
     * all predicates return truthy, else `false`.
     *
     * **Note:** The created function is equivalent to `_.conformsTo` with
     * `source` partially applied.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {Object} source The object of property predicates to conform to.
     * @returns {Function} Returns the new spec function.
     * @example
     *
     * var objects = [
     *   { 'a': 2, 'b': 1 },
     *   { 'a': 1, 'b': 2 }
     * ];
     *
     * _.filter(objects, _.conforms({ 'b': function(n) { return n > 1; } }));
     * // => [{ 'a': 1, 'b': 2 }]
     */
    function conforms(source) {
      return baseConforms(baseClone(source, CLONE_DEEP_FLAG));
    }

    /**
     * Creates a function that returns `value`.
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Util
     * @param {*} value The value to return from the new function.
     * @returns {Function} Returns the new constant function.
     * @example
     *
     * var objects = _.times(2, _.constant({ 'a': 1 }));
     *
     * console.log(objects);
     * // => [{ 'a': 1 }, { 'a': 1 }]
     *
     * console.log(objects[0] === objects[1]);
     * // => true
     */
    function constant(value) {
      return function() {
        return value;
      };
    }

    /**
     * Checks `value` to determine whether a default value should be returned in
     * its place. The `defaultValue` is returned if `value` is `NaN`, `null`,
     * or `undefined`.
     *
     * @static
     * @memberOf _
     * @since 4.14.0
     * @category Util
     * @param {*} value The value to check.
     * @param {*} defaultValue The default value.
     * @returns {*} Returns the resolved value.
     * @example
     *
     * _.defaultTo(1, 10);
     * // => 1
     *
     * _.defaultTo(undefined, 10);
     * // => 10
     */
    function defaultTo(value, defaultValue) {
      return (value == null || value !== value) ? defaultValue : value;
    }

    /**
     * Creates a function that returns the result of invoking the given functions
     * with the `this` binding of the created function, where each successive
     * invocation is supplied the return value of the previous.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Util
     * @param {...(Function|Function[])} [funcs] The functions to invoke.
     * @returns {Function} Returns the new composite function.
     * @see _.flowRight
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var addSquare = _.flow([_.add, square]);
     * addSquare(1, 2);
     * // => 9
     */
    var flow = createFlow();

    /**
     * This method is like `_.flow` except that it creates a function that
     * invokes the given functions from right to left.
     *
     * @static
     * @since 3.0.0
     * @memberOf _
     * @category Util
     * @param {...(Function|Function[])} [funcs] The functions to invoke.
     * @returns {Function} Returns the new composite function.
     * @see _.flow
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var addSquare = _.flowRight([square, _.add]);
     * addSquare(1, 2);
     * // => 9
     */
    var flowRight = createFlow(true);

    /**
     * This method returns the first argument it receives.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {*} value Any value.
     * @returns {*} Returns `value`.
     * @example
     *
     * var object = { 'a': 1 };
     *
     * console.log(_.identity(object) === object);
     * // => true
     */
    function identity(value) {
      return value;
    }

    /**
     * Creates a function that invokes `func` with the arguments of the created
     * function. If `func` is a property name, the created function returns the
     * property value for a given element. If `func` is an array or object, the
     * created function returns `true` for elements that contain the equivalent
     * source properties, otherwise it returns `false`.
     *
     * @static
     * @since 4.0.0
     * @memberOf _
     * @category Util
     * @param {*} [func=_.identity] The value to convert to a callback.
     * @returns {Function} Returns the callback.
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': true },
     *   { 'user': 'fred',   'age': 40, 'active': false }
     * ];
     *
     * // The `_.matches` iteratee shorthand.
     * _.filter(users, _.iteratee({ 'user': 'barney', 'active': true }));
     * // => [{ 'user': 'barney', 'age': 36, 'active': true }]
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.filter(users, _.iteratee(['user', 'fred']));
     * // => [{ 'user': 'fred', 'age': 40 }]
     *
     * // The `_.property` iteratee shorthand.
     * _.map(users, _.iteratee('user'));
     * // => ['barney', 'fred']
     *
     * // Create custom iteratee shorthands.
     * _.iteratee = _.wrap(_.iteratee, function(iteratee, func) {
     *   return !_.isRegExp(func) ? iteratee(func) : function(string) {
     *     return func.test(string);
     *   };
     * });
     *
     * _.filter(['abc', 'def'], /ef/);
     * // => ['def']
     */
    function iteratee(func) {
      return baseIteratee(typeof func == 'function' ? func : baseClone(func, CLONE_DEEP_FLAG));
    }

    /**
     * Creates a function that performs a partial deep comparison between a given
     * object and `source`, returning `true` if the given object has equivalent
     * property values, else `false`.
     *
     * **Note:** The created function is equivalent to `_.isMatch` with `source`
     * partially applied.
     *
     * Partial comparisons will match empty array and empty object `source`
     * values against any array or object value, respectively. See `_.isEqual`
     * for a list of supported value comparisons.
     *
     * **Note:** Multiple values can be checked by combining several matchers
     * using `_.overSome`
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Util
     * @param {Object} source The object of property values to match.
     * @returns {Function} Returns the new spec function.
     * @example
     *
     * var objects = [
     *   { 'a': 1, 'b': 2, 'c': 3 },
     *   { 'a': 4, 'b': 5, 'c': 6 }
     * ];
     *
     * _.filter(objects, _.matches({ 'a': 4, 'c': 6 }));
     * // => [{ 'a': 4, 'b': 5, 'c': 6 }]
     *
     * // Checking for several possible values
     * _.filter(objects, _.overSome([_.matches({ 'a': 1 }), _.matches({ 'a': 4 })]));
     * // => [{ 'a': 1, 'b': 2, 'c': 3 }, { 'a': 4, 'b': 5, 'c': 6 }]
     */
    function matches(source) {
      return baseMatches(baseClone(source, CLONE_DEEP_FLAG));
    }

    /**
     * Creates a function that performs a partial deep comparison between the
     * value at `path` of a given object to `srcValue`, returning `true` if the
     * object value is equivalent, else `false`.
     *
     * **Note:** Partial comparisons will match empty array and empty object
     * `srcValue` values against any array or object value, respectively. See
     * `_.isEqual` for a list of supported value comparisons.
     *
     * **Note:** Multiple values can be checked by combining several matchers
     * using `_.overSome`
     *
     * @static
     * @memberOf _
     * @since 3.2.0
     * @category Util
     * @param {Array|string} path The path of the property to get.
     * @param {*} srcValue The value to match.
     * @returns {Function} Returns the new spec function.
     * @example
     *
     * var objects = [
     *   { 'a': 1, 'b': 2, 'c': 3 },
     *   { 'a': 4, 'b': 5, 'c': 6 }
     * ];
     *
     * _.find(objects, _.matchesProperty('a', 4));
     * // => { 'a': 4, 'b': 5, 'c': 6 }
     *
     * // Checking for several possible values
     * _.filter(objects, _.overSome([_.matchesProperty('a', 1), _.matchesProperty('a', 4)]));
     * // => [{ 'a': 1, 'b': 2, 'c': 3 }, { 'a': 4, 'b': 5, 'c': 6 }]
     */
    function matchesProperty(path, srcValue) {
      return baseMatchesProperty(path, baseClone(srcValue, CLONE_DEEP_FLAG));
    }

    /**
     * Creates a function that invokes the method at `path` of a given object.
     * Any additional arguments are provided to the invoked method.
     *
     * @static
     * @memberOf _
     * @since 3.7.0
     * @category Util
     * @param {Array|string} path The path of the method to invoke.
     * @param {...*} [args] The arguments to invoke the method with.
     * @returns {Function} Returns the new invoker function.
     * @example
     *
     * var objects = [
     *   { 'a': { 'b': _.constant(2) } },
     *   { 'a': { 'b': _.constant(1) } }
     * ];
     *
     * _.map(objects, _.method('a.b'));
     * // => [2, 1]
     *
     * _.map(objects, _.method(['a', 'b']));
     * // => [2, 1]
     */
    var method = baseRest(function(path, args) {
      return function(object) {
        return baseInvoke(object, path, args);
      };
    });

    /**
     * The opposite of `_.method`; this method creates a function that invokes
     * the method at a given path of `object`. Any additional arguments are
     * provided to the invoked method.
     *
     * @static
     * @memberOf _
     * @since 3.7.0
     * @category Util
     * @param {Object} object The object to query.
     * @param {...*} [args] The arguments to invoke the method with.
     * @returns {Function} Returns the new invoker function.
     * @example
     *
     * var array = _.times(3, _.constant),
     *     object = { 'a': array, 'b': array, 'c': array };
     *
     * _.map(['a[2]', 'c[0]'], _.methodOf(object));
     * // => [2, 0]
     *
     * _.map([['a', '2'], ['c', '0']], _.methodOf(object));
     * // => [2, 0]
     */
    var methodOf = baseRest(function(object, args) {
      return function(path) {
        return baseInvoke(object, path, args);
      };
    });

    /**
     * Adds all own enumerable string keyed function properties of a source
     * object to the destination object. If `object` is a function, then methods
     * are added to its prototype as well.
     *
     * **Note:** Use `_.runInContext` to create a pristine `lodash` function to
     * avoid conflicts caused by modifying the original.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {Function|Object} [object=lodash] The destination object.
     * @param {Object} source The object of functions to add.
     * @param {Object} [options={}] The options object.
     * @param {boolean} [options.chain=true] Specify whether mixins are chainable.
     * @returns {Function|Object} Returns `object`.
     * @example
     *
     * function vowels(string) {
     *   return _.filter(string, function(v) {
     *     return /[aeiou]/i.test(v);
     *   });
     * }
     *
     * _.mixin({ 'vowels': vowels });
     * _.vowels('fred');
     * // => ['e']
     *
     * _('fred').vowels().value();
     * // => ['e']
     *
     * _.mixin({ 'vowels': vowels }, { 'chain': false });
     * _('fred').vowels();
     * // => ['e']
     */
    function mixin(object, source, options) {
      var props = keys(source),
          methodNames = baseFunctions(source, props);

      if (options == null &&
          !(isObject(source) && (methodNames.length || !props.length))) {
        options = source;
        source = object;
        object = this;
        methodNames = baseFunctions(source, keys(source));
      }
      var chain = !(isObject(options) && 'chain' in options) || !!options.chain,
          isFunc = isFunction(object);

      arrayEach(methodNames, function(methodName) {
        var func = source[methodName];
        object[methodName] = func;
        if (isFunc) {
          object.prototype[methodName] = function() {
            var chainAll = this.__chain__;
            if (chain || chainAll) {
              var result = object(this.__wrapped__),
                  actions = result.__actions__ = copyArray(this.__actions__);

              actions.push({ 'func': func, 'args': arguments, 'thisArg': object });
              result.__chain__ = chainAll;
              return result;
            }
            return func.apply(object, arrayPush([this.value()], arguments));
          };
        }
      });

      return object;
    }

    /**
     * Reverts the `_` variable to its previous value and returns a reference to
     * the `lodash` function.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @returns {Function} Returns the `lodash` function.
     * @example
     *
     * var lodash = _.noConflict();
     */
    function noConflict() {
      if (root._ === this) {
        root._ = oldDash;
      }
      return this;
    }

    /**
     * This method returns `undefined`.
     *
     * @static
     * @memberOf _
     * @since 2.3.0
     * @category Util
     * @example
     *
     * _.times(2, _.noop);
     * // => [undefined, undefined]
     */
    function noop() {
      // No operation performed.
    }

    /**
     * Creates a function that gets the argument at index `n`. If `n` is negative,
     * the nth argument from the end is returned.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {number} [n=0] The index of the argument to return.
     * @returns {Function} Returns the new pass-thru function.
     * @example
     *
     * var func = _.nthArg(1);
     * func('a', 'b', 'c', 'd');
     * // => 'b'
     *
     * var func = _.nthArg(-2);
     * func('a', 'b', 'c', 'd');
     * // => 'c'
     */
    function nthArg(n) {
      n = toInteger(n);
      return baseRest(function(args) {
        return baseNth(args, n);
      });
    }

    /**
     * Creates a function that invokes `iteratees` with the arguments it receives
     * and returns their results.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {...(Function|Function[])} [iteratees=[_.identity]]
     *  The iteratees to invoke.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var func = _.over([Math.max, Math.min]);
     *
     * func(1, 2, 3, 4);
     * // => [4, 1]
     */
    var over = createOver(arrayMap);

    /**
     * Creates a function that checks if **all** of the `predicates` return
     * truthy when invoked with the arguments it receives.
     *
     * Following shorthands are possible for providing predicates.
     * Pass an `Object` and it will be used as an parameter for `_.matches` to create the predicate.
     * Pass an `Array` of parameters for `_.matchesProperty` and the predicate will be created using them.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {...(Function|Function[])} [predicates=[_.identity]]
     *  The predicates to check.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var func = _.overEvery([Boolean, isFinite]);
     *
     * func('1');
     * // => true
     *
     * func(null);
     * // => false
     *
     * func(NaN);
     * // => false
     */
    var overEvery = createOver(arrayEvery);

    /**
     * Creates a function that checks if **any** of the `predicates` return
     * truthy when invoked with the arguments it receives.
     *
     * Following shorthands are possible for providing predicates.
     * Pass an `Object` and it will be used as an parameter for `_.matches` to create the predicate.
     * Pass an `Array` of parameters for `_.matchesProperty` and the predicate will be created using them.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {...(Function|Function[])} [predicates=[_.identity]]
     *  The predicates to check.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var func = _.overSome([Boolean, isFinite]);
     *
     * func('1');
     * // => true
     *
     * func(null);
     * // => true
     *
     * func(NaN);
     * // => false
     *
     * var matchesFunc = _.overSome([{ 'a': 1 }, { 'a': 2 }])
     * var matchesPropertyFunc = _.overSome([['a', 1], ['a', 2]])
     */
    var overSome = createOver(arraySome);

    /**
     * Creates a function that returns the value at `path` of a given object.
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Util
     * @param {Array|string} path The path of the property to get.
     * @returns {Function} Returns the new accessor function.
     * @example
     *
     * var objects = [
     *   { 'a': { 'b': 2 } },
     *   { 'a': { 'b': 1 } }
     * ];
     *
     * _.map(objects, _.property('a.b'));
     * // => [2, 1]
     *
     * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
     * // => [1, 2]
     */
    function property(path) {
      return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
    }

    /**
     * The opposite of `_.property`; this method creates a function that returns
     * the value at a given path of `object`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Util
     * @param {Object} object The object to query.
     * @returns {Function} Returns the new accessor function.
     * @example
     *
     * var array = [0, 1, 2],
     *     object = { 'a': array, 'b': array, 'c': array };
     *
     * _.map(['a[2]', 'c[0]'], _.propertyOf(object));
     * // => [2, 0]
     *
     * _.map([['a', '2'], ['c', '0']], _.propertyOf(object));
     * // => [2, 0]
     */
    function propertyOf(object) {
      return function(path) {
        return object == null ? undefined : baseGet(object, path);
      };
    }

    /**
     * Creates an array of numbers (positive and/or negative) progressing from
     * `start` up to, but not including, `end`. A step of `-1` is used if a negative
     * `start` is specified without an `end` or `step`. If `end` is not specified,
     * it's set to `start` with `start` then set to `0`.
     *
     * **Note:** JavaScript follows the IEEE-754 standard for resolving
     * floating-point values which can produce unexpected results.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {number} [start=0] The start of the range.
     * @param {number} end The end of the range.
     * @param {number} [step=1] The value to increment or decrement by.
     * @returns {Array} Returns the range of numbers.
     * @see _.inRange, _.rangeRight
     * @example
     *
     * _.range(4);
     * // => [0, 1, 2, 3]
     *
     * _.range(-4);
     * // => [0, -1, -2, -3]
     *
     * _.range(1, 5);
     * // => [1, 2, 3, 4]
     *
     * _.range(0, 20, 5);
     * // => [0, 5, 10, 15]
     *
     * _.range(0, -4, -1);
     * // => [0, -1, -2, -3]
     *
     * _.range(1, 4, 0);
     * // => [1, 1, 1]
     *
     * _.range(0);
     * // => []
     */
    var range = createRange();

    /**
     * This method is like `_.range` except that it populates values in
     * descending order.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {number} [start=0] The start of the range.
     * @param {number} end The end of the range.
     * @param {number} [step=1] The value to increment or decrement by.
     * @returns {Array} Returns the range of numbers.
     * @see _.inRange, _.range
     * @example
     *
     * _.rangeRight(4);
     * // => [3, 2, 1, 0]
     *
     * _.rangeRight(-4);
     * // => [-3, -2, -1, 0]
     *
     * _.rangeRight(1, 5);
     * // => [4, 3, 2, 1]
     *
     * _.rangeRight(0, 20, 5);
     * // => [15, 10, 5, 0]
     *
     * _.rangeRight(0, -4, -1);
     * // => [-3, -2, -1, 0]
     *
     * _.rangeRight(1, 4, 0);
     * // => [1, 1, 1]
     *
     * _.rangeRight(0);
     * // => []
     */
    var rangeRight = createRange(true);

    /**
     * This method returns a new empty array.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {Array} Returns the new empty array.
     * @example
     *
     * var arrays = _.times(2, _.stubArray);
     *
     * console.log(arrays);
     * // => [[], []]
     *
     * console.log(arrays[0] === arrays[1]);
     * // => false
     */
    function stubArray() {
      return [];
    }

    /**
     * This method returns `false`.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {boolean} Returns `false`.
     * @example
     *
     * _.times(2, _.stubFalse);
     * // => [false, false]
     */
    function stubFalse() {
      return false;
    }

    /**
     * This method returns a new empty object.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {Object} Returns the new empty object.
     * @example
     *
     * var objects = _.times(2, _.stubObject);
     *
     * console.log(objects);
     * // => [{}, {}]
     *
     * console.log(objects[0] === objects[1]);
     * // => false
     */
    function stubObject() {
      return {};
    }

    /**
     * This method returns an empty string.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {string} Returns the empty string.
     * @example
     *
     * _.times(2, _.stubString);
     * // => ['', '']
     */
    function stubString() {
      return '';
    }

    /**
     * This method returns `true`.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {boolean} Returns `true`.
     * @example
     *
     * _.times(2, _.stubTrue);
     * // => [true, true]
     */
    function stubTrue() {
      return true;
    }

    /**
     * Invokes the iteratee `n` times, returning an array of the results of
     * each invocation. The iteratee is invoked with one argument; (index).
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {number} n The number of times to invoke `iteratee`.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the array of results.
     * @example
     *
     * _.times(3, String);
     * // => ['0', '1', '2']
     *
     *  _.times(4, _.constant(0));
     * // => [0, 0, 0, 0]
     */
    function times(n, iteratee) {
      n = toInteger(n);
      if (n < 1 || n > MAX_SAFE_INTEGER) {
        return [];
      }
      var index = MAX_ARRAY_LENGTH,
          length = nativeMin(n, MAX_ARRAY_LENGTH);

      iteratee = getIteratee(iteratee);
      n -= MAX_ARRAY_LENGTH;

      var result = baseTimes(length, iteratee);
      while (++index < n) {
        iteratee(index);
      }
      return result;
    }

    /**
     * Converts `value` to a property path array.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {*} value The value to convert.
     * @returns {Array} Returns the new property path array.
     * @example
     *
     * _.toPath('a.b.c');
     * // => ['a', 'b', 'c']
     *
     * _.toPath('a[0].b.c');
     * // => ['a', '0', 'b', 'c']
     */
    function toPath(value) {
      if (isArray(value)) {
        return arrayMap(value, toKey);
      }
      return isSymbol(value) ? [value] : copyArray(stringToPath(toString(value)));
    }

    /**
     * Generates a unique ID. If `prefix` is given, the ID is appended to it.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {string} [prefix=''] The value to prefix the ID with.
     * @returns {string} Returns the unique ID.
     * @example
     *
     * _.uniqueId('contact_');
     * // => 'contact_104'
     *
     * _.uniqueId();
     * // => '105'
     */
    function uniqueId(prefix) {
      var id = ++idCounter;
      return toString(prefix) + id;
    }

    /*------------------------------------------------------------------------*/

    /**
     * Adds two numbers.
     *
     * @static
     * @memberOf _
     * @since 3.4.0
     * @category Math
     * @param {number} augend The first number in an addition.
     * @param {number} addend The second number in an addition.
     * @returns {number} Returns the total.
     * @example
     *
     * _.add(6, 4);
     * // => 10
     */
    var add = createMathOperation(function(augend, addend) {
      return augend + addend;
    }, 0);

    /**
     * Computes `number` rounded up to `precision`.
     *
     * @static
     * @memberOf _
     * @since 3.10.0
     * @category Math
     * @param {number} number The number to round up.
     * @param {number} [precision=0] The precision to round up to.
     * @returns {number} Returns the rounded up number.
     * @example
     *
     * _.ceil(4.006);
     * // => 5
     *
     * _.ceil(6.004, 2);
     * // => 6.01
     *
     * _.ceil(6040, -2);
     * // => 6100
     */
    var ceil = createRound('ceil');

    /**
     * Divide two numbers.
     *
     * @static
     * @memberOf _
     * @since 4.7.0
     * @category Math
     * @param {number} dividend The first number in a division.
     * @param {number} divisor The second number in a division.
     * @returns {number} Returns the quotient.
     * @example
     *
     * _.divide(6, 4);
     * // => 1.5
     */
    var divide = createMathOperation(function(dividend, divisor) {
      return dividend / divisor;
    }, 1);

    /**
     * Computes `number` rounded down to `precision`.
     *
     * @static
     * @memberOf _
     * @since 3.10.0
     * @category Math
     * @param {number} number The number to round down.
     * @param {number} [precision=0] The precision to round down to.
     * @returns {number} Returns the rounded down number.
     * @example
     *
     * _.floor(4.006);
     * // => 4
     *
     * _.floor(0.046, 2);
     * // => 0.04
     *
     * _.floor(4060, -2);
     * // => 4000
     */
    var floor = createRound('floor');

    /**
     * Computes the maximum value of `array`. If `array` is empty or falsey,
     * `undefined` is returned.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Math
     * @param {Array} array The array to iterate over.
     * @returns {*} Returns the maximum value.
     * @example
     *
     * _.max([4, 2, 8, 6]);
     * // => 8
     *
     * _.max([]);
     * // => undefined
     */
    function max(array) {
      return (array && array.length)
        ? baseExtremum(array, identity, baseGt)
        : undefined;
    }

    /**
     * This method is like `_.max` except that it accepts `iteratee` which is
     * invoked for each element in `array` to generate the criterion by which
     * the value is ranked. The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {*} Returns the maximum value.
     * @example
     *
     * var objects = [{ 'n': 1 }, { 'n': 2 }];
     *
     * _.maxBy(objects, function(o) { return o.n; });
     * // => { 'n': 2 }
     *
     * // The `_.property` iteratee shorthand.
     * _.maxBy(objects, 'n');
     * // => { 'n': 2 }
     */
    function maxBy(array, iteratee) {
      return (array && array.length)
        ? baseExtremum(array, getIteratee(iteratee, 2), baseGt)
        : undefined;
    }

    /**
     * Computes the mean of the values in `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @returns {number} Returns the mean.
     * @example
     *
     * _.mean([4, 2, 8, 6]);
     * // => 5
     */
    function mean(array) {
      return baseMean(array, identity);
    }

    /**
     * This method is like `_.mean` except that it accepts `iteratee` which is
     * invoked for each element in `array` to generate the value to be averaged.
     * The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.7.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {number} Returns the mean.
     * @example
     *
     * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }];
     *
     * _.meanBy(objects, function(o) { return o.n; });
     * // => 5
     *
     * // The `_.property` iteratee shorthand.
     * _.meanBy(objects, 'n');
     * // => 5
     */
    function meanBy(array, iteratee) {
      return baseMean(array, getIteratee(iteratee, 2));
    }

    /**
     * Computes the minimum value of `array`. If `array` is empty or falsey,
     * `undefined` is returned.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Math
     * @param {Array} array The array to iterate over.
     * @returns {*} Returns the minimum value.
     * @example
     *
     * _.min([4, 2, 8, 6]);
     * // => 2
     *
     * _.min([]);
     * // => undefined
     */
    function min(array) {
      return (array && array.length)
        ? baseExtremum(array, identity, baseLt)
        : undefined;
    }

    /**
     * This method is like `_.min` except that it accepts `iteratee` which is
     * invoked for each element in `array` to generate the criterion by which
     * the value is ranked. The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {*} Returns the minimum value.
     * @example
     *
     * var objects = [{ 'n': 1 }, { 'n': 2 }];
     *
     * _.minBy(objects, function(o) { return o.n; });
     * // => { 'n': 1 }
     *
     * // The `_.property` iteratee shorthand.
     * _.minBy(objects, 'n');
     * // => { 'n': 1 }
     */
    function minBy(array, iteratee) {
      return (array && array.length)
        ? baseExtremum(array, getIteratee(iteratee, 2), baseLt)
        : undefined;
    }

    /**
     * Multiply two numbers.
     *
     * @static
     * @memberOf _
     * @since 4.7.0
     * @category Math
     * @param {number} multiplier The first number in a multiplication.
     * @param {number} multiplicand The second number in a multiplication.
     * @returns {number} Returns the product.
     * @example
     *
     * _.multiply(6, 4);
     * // => 24
     */
    var multiply = createMathOperation(function(multiplier, multiplicand) {
      return multiplier * multiplicand;
    }, 1);

    /**
     * Computes `number` rounded to `precision`.
     *
     * @static
     * @memberOf _
     * @since 3.10.0
     * @category Math
     * @param {number} number The number to round.
     * @param {number} [precision=0] The precision to round to.
     * @returns {number} Returns the rounded number.
     * @example
     *
     * _.round(4.006);
     * // => 4
     *
     * _.round(4.006, 2);
     * // => 4.01
     *
     * _.round(4060, -2);
     * // => 4100
     */
    var round = createRound('round');

    /**
     * Subtract two numbers.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Math
     * @param {number} minuend The first number in a subtraction.
     * @param {number} subtrahend The second number in a subtraction.
     * @returns {number} Returns the difference.
     * @example
     *
     * _.subtract(6, 4);
     * // => 2
     */
    var subtract = createMathOperation(function(minuend, subtrahend) {
      return minuend - subtrahend;
    }, 0);

    /**
     * Computes the sum of the values in `array`.
     *
     * @static
     * @memberOf _
     * @since 3.4.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @returns {number} Returns the sum.
     * @example
     *
     * _.sum([4, 2, 8, 6]);
     * // => 20
     */
    function sum(array) {
      return (array && array.length)
        ? baseSum(array, identity)
        : 0;
    }

    /**
     * This method is like `_.sum` except that it accepts `iteratee` which is
     * invoked for each element in `array` to generate the value to be summed.
     * The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {number} Returns the sum.
     * @example
     *
     * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }];
     *
     * _.sumBy(objects, function(o) { return o.n; });
     * // => 20
     *
     * // The `_.property` iteratee shorthand.
     * _.sumBy(objects, 'n');
     * // => 20
     */
    function sumBy(array, iteratee) {
      return (array && array.length)
        ? baseSum(array, getIteratee(iteratee, 2))
        : 0;
    }

    /*------------------------------------------------------------------------*/

    // Add methods that return wrapped values in chain sequences.
    lodash.after = after;
    lodash.ary = ary;
    lodash.assign = assign;
    lodash.assignIn = assignIn;
    lodash.assignInWith = assignInWith;
    lodash.assignWith = assignWith;
    lodash.at = at;
    lodash.before = before;
    lodash.bind = bind;
    lodash.bindAll = bindAll;
    lodash.bindKey = bindKey;
    lodash.castArray = castArray;
    lodash.chain = chain;
    lodash.chunk = chunk;
    lodash.compact = compact;
    lodash.concat = concat;
    lodash.cond = cond;
    lodash.conforms = conforms;
    lodash.constant = constant;
    lodash.countBy = countBy;
    lodash.create = create;
    lodash.curry = curry;
    lodash.curryRight = curryRight;
    lodash.debounce = debounce;
    lodash.defaults = defaults;
    lodash.defaultsDeep = defaultsDeep;
    lodash.defer = defer;
    lodash.delay = delay;
    lodash.difference = difference;
    lodash.differenceBy = differenceBy;
    lodash.differenceWith = differenceWith;
    lodash.drop = drop;
    lodash.dropRight = dropRight;
    lodash.dropRightWhile = dropRightWhile;
    lodash.dropWhile = dropWhile;
    lodash.fill = fill;
    lodash.filter = filter;
    lodash.flatMap = flatMap;
    lodash.flatMapDeep = flatMapDeep;
    lodash.flatMapDepth = flatMapDepth;
    lodash.flatten = flatten;
    lodash.flattenDeep = flattenDeep;
    lodash.flattenDepth = flattenDepth;
    lodash.flip = flip;
    lodash.flow = flow;
    lodash.flowRight = flowRight;
    lodash.fromPairs = fromPairs;
    lodash.functions = functions;
    lodash.functionsIn = functionsIn;
    lodash.groupBy = groupBy;
    lodash.initial = initial;
    lodash.intersection = intersection;
    lodash.intersectionBy = intersectionBy;
    lodash.intersectionWith = intersectionWith;
    lodash.invert = invert;
    lodash.invertBy = invertBy;
    lodash.invokeMap = invokeMap;
    lodash.iteratee = iteratee;
    lodash.keyBy = keyBy;
    lodash.keys = keys;
    lodash.keysIn = keysIn;
    lodash.map = map;
    lodash.mapKeys = mapKeys;
    lodash.mapValues = mapValues;
    lodash.matches = matches;
    lodash.matchesProperty = matchesProperty;
    lodash.memoize = memoize;
    lodash.merge = merge;
    lodash.mergeWith = mergeWith;
    lodash.method = method;
    lodash.methodOf = methodOf;
    lodash.mixin = mixin;
    lodash.negate = negate;
    lodash.nthArg = nthArg;
    lodash.omit = omit;
    lodash.omitBy = omitBy;
    lodash.once = once;
    lodash.orderBy = orderBy;
    lodash.over = over;
    lodash.overArgs = overArgs;
    lodash.overEvery = overEvery;
    lodash.overSome = overSome;
    lodash.partial = partial;
    lodash.partialRight = partialRight;
    lodash.partition = partition;
    lodash.pick = pick;
    lodash.pickBy = pickBy;
    lodash.property = property;
    lodash.propertyOf = propertyOf;
    lodash.pull = pull;
    lodash.pullAll = pullAll;
    lodash.pullAllBy = pullAllBy;
    lodash.pullAllWith = pullAllWith;
    lodash.pullAt = pullAt;
    lodash.range = range;
    lodash.rangeRight = rangeRight;
    lodash.rearg = rearg;
    lodash.reject = reject;
    lodash.remove = remove;
    lodash.rest = rest;
    lodash.reverse = reverse;
    lodash.sampleSize = sampleSize;
    lodash.set = set;
    lodash.setWith = setWith;
    lodash.shuffle = shuffle;
    lodash.slice = slice;
    lodash.sortBy = sortBy;
    lodash.sortedUniq = sortedUniq;
    lodash.sortedUniqBy = sortedUniqBy;
    lodash.split = split;
    lodash.spread = spread;
    lodash.tail = tail;
    lodash.take = take;
    lodash.takeRight = takeRight;
    lodash.takeRightWhile = takeRightWhile;
    lodash.takeWhile = takeWhile;
    lodash.tap = tap;
    lodash.throttle = throttle;
    lodash.thru = thru;
    lodash.toArray = toArray;
    lodash.toPairs = toPairs;
    lodash.toPairsIn = toPairsIn;
    lodash.toPath = toPath;
    lodash.toPlainObject = toPlainObject;
    lodash.transform = transform;
    lodash.unary = unary;
    lodash.union = union;
    lodash.unionBy = unionBy;
    lodash.unionWith = unionWith;
    lodash.uniq = uniq;
    lodash.uniqBy = uniqBy;
    lodash.uniqWith = uniqWith;
    lodash.unset = unset;
    lodash.unzip = unzip;
    lodash.unzipWith = unzipWith;
    lodash.update = update;
    lodash.updateWith = updateWith;
    lodash.values = values;
    lodash.valuesIn = valuesIn;
    lodash.without = without;
    lodash.words = words;
    lodash.wrap = wrap;
    lodash.xor = xor;
    lodash.xorBy = xorBy;
    lodash.xorWith = xorWith;
    lodash.zip = zip;
    lodash.zipObject = zipObject;
    lodash.zipObjectDeep = zipObjectDeep;
    lodash.zipWith = zipWith;

    // Add aliases.
    lodash.entries = toPairs;
    lodash.entriesIn = toPairsIn;
    lodash.extend = assignIn;
    lodash.extendWith = assignInWith;

    // Add methods to `lodash.prototype`.
    mixin(lodash, lodash);

    /*------------------------------------------------------------------------*/

    // Add methods that return unwrapped values in chain sequences.
    lodash.add = add;
    lodash.attempt = attempt;
    lodash.camelCase = camelCase;
    lodash.capitalize = capitalize;
    lodash.ceil = ceil;
    lodash.clamp = clamp;
    lodash.clone = clone;
    lodash.cloneDeep = cloneDeep;
    lodash.cloneDeepWith = cloneDeepWith;
    lodash.cloneWith = cloneWith;
    lodash.conformsTo = conformsTo;
    lodash.deburr = deburr;
    lodash.defaultTo = defaultTo;
    lodash.divide = divide;
    lodash.endsWith = endsWith;
    lodash.eq = eq;
    lodash.escape = escape;
    lodash.escapeRegExp = escapeRegExp;
    lodash.every = every;
    lodash.find = find;
    lodash.findIndex = findIndex;
    lodash.findKey = findKey;
    lodash.findLast = findLast;
    lodash.findLastIndex = findLastIndex;
    lodash.findLastKey = findLastKey;
    lodash.floor = floor;
    lodash.forEach = forEach;
    lodash.forEachRight = forEachRight;
    lodash.forIn = forIn;
    lodash.forInRight = forInRight;
    lodash.forOwn = forOwn;
    lodash.forOwnRight = forOwnRight;
    lodash.get = get;
    lodash.gt = gt;
    lodash.gte = gte;
    lodash.has = has;
    lodash.hasIn = hasIn;
    lodash.head = head;
    lodash.identity = identity;
    lodash.includes = includes;
    lodash.indexOf = indexOf;
    lodash.inRange = inRange;
    lodash.invoke = invoke;
    lodash.isArguments = isArguments;
    lodash.isArray = isArray;
    lodash.isArrayBuffer = isArrayBuffer;
    lodash.isArrayLike = isArrayLike;
    lodash.isArrayLikeObject = isArrayLikeObject;
    lodash.isBoolean = isBoolean;
    lodash.isBuffer = isBuffer;
    lodash.isDate = isDate;
    lodash.isElement = isElement;
    lodash.isEmpty = isEmpty;
    lodash.isEqual = isEqual;
    lodash.isEqualWith = isEqualWith;
    lodash.isError = isError;
    lodash.isFinite = isFinite;
    lodash.isFunction = isFunction;
    lodash.isInteger = isInteger;
    lodash.isLength = isLength;
    lodash.isMap = isMap;
    lodash.isMatch = isMatch;
    lodash.isMatchWith = isMatchWith;
    lodash.isNaN = isNaN;
    lodash.isNative = isNative;
    lodash.isNil = isNil;
    lodash.isNull = isNull;
    lodash.isNumber = isNumber;
    lodash.isObject = isObject;
    lodash.isObjectLike = isObjectLike;
    lodash.isPlainObject = isPlainObject;
    lodash.isRegExp = isRegExp;
    lodash.isSafeInteger = isSafeInteger;
    lodash.isSet = isSet;
    lodash.isString = isString;
    lodash.isSymbol = isSymbol;
    lodash.isTypedArray = isTypedArray;
    lodash.isUndefined = isUndefined;
    lodash.isWeakMap = isWeakMap;
    lodash.isWeakSet = isWeakSet;
    lodash.join = join;
    lodash.kebabCase = kebabCase;
    lodash.last = last;
    lodash.lastIndexOf = lastIndexOf;
    lodash.lowerCase = lowerCase;
    lodash.lowerFirst = lowerFirst;
    lodash.lt = lt;
    lodash.lte = lte;
    lodash.max = max;
    lodash.maxBy = maxBy;
    lodash.mean = mean;
    lodash.meanBy = meanBy;
    lodash.min = min;
    lodash.minBy = minBy;
    lodash.stubArray = stubArray;
    lodash.stubFalse = stubFalse;
    lodash.stubObject = stubObject;
    lodash.stubString = stubString;
    lodash.stubTrue = stubTrue;
    lodash.multiply = multiply;
    lodash.nth = nth;
    lodash.noConflict = noConflict;
    lodash.noop = noop;
    lodash.now = now;
    lodash.pad = pad;
    lodash.padEnd = padEnd;
    lodash.padStart = padStart;
    lodash.parseInt = parseInt;
    lodash.random = random;
    lodash.reduce = reduce;
    lodash.reduceRight = reduceRight;
    lodash.repeat = repeat;
    lodash.replace = replace;
    lodash.result = result;
    lodash.round = round;
    lodash.runInContext = runInContext;
    lodash.sample = sample;
    lodash.size = size;
    lodash.snakeCase = snakeCase;
    lodash.some = some;
    lodash.sortedIndex = sortedIndex;
    lodash.sortedIndexBy = sortedIndexBy;
    lodash.sortedIndexOf = sortedIndexOf;
    lodash.sortedLastIndex = sortedLastIndex;
    lodash.sortedLastIndexBy = sortedLastIndexBy;
    lodash.sortedLastIndexOf = sortedLastIndexOf;
    lodash.startCase = startCase;
    lodash.startsWith = startsWith;
    lodash.subtract = subtract;
    lodash.sum = sum;
    lodash.sumBy = sumBy;
    lodash.template = template;
    lodash.times = times;
    lodash.toFinite = toFinite;
    lodash.toInteger = toInteger;
    lodash.toLength = toLength;
    lodash.toLower = toLower;
    lodash.toNumber = toNumber;
    lodash.toSafeInteger = toSafeInteger;
    lodash.toString = toString;
    lodash.toUpper = toUpper;
    lodash.trim = trim;
    lodash.trimEnd = trimEnd;
    lodash.trimStart = trimStart;
    lodash.truncate = truncate;
    lodash.unescape = unescape;
    lodash.uniqueId = uniqueId;
    lodash.upperCase = upperCase;
    lodash.upperFirst = upperFirst;

    // Add aliases.
    lodash.each = forEach;
    lodash.eachRight = forEachRight;
    lodash.first = head;

    mixin(lodash, (function() {
      var source = {};
      baseForOwn(lodash, function(func, methodName) {
        if (!hasOwnProperty.call(lodash.prototype, methodName)) {
          source[methodName] = func;
        }
      });
      return source;
    }()), { 'chain': false });

    /*------------------------------------------------------------------------*/

    /**
     * The semantic version number.
     *
     * @static
     * @memberOf _
     * @type {string}
     */
    lodash.VERSION = VERSION;

    // Assign default placeholders.
    arrayEach(['bind', 'bindKey', 'curry', 'curryRight', 'partial', 'partialRight'], function(methodName) {
      lodash[methodName].placeholder = lodash;
    });

    // Add `LazyWrapper` methods for `_.drop` and `_.take` variants.
    arrayEach(['drop', 'take'], function(methodName, index) {
      LazyWrapper.prototype[methodName] = function(n) {
        n = n === undefined ? 1 : nativeMax(toInteger(n), 0);

        var result = (this.__filtered__ && !index)
          ? new LazyWrapper(this)
          : this.clone();

        if (result.__filtered__) {
          result.__takeCount__ = nativeMin(n, result.__takeCount__);
        } else {
          result.__views__.push({
            'size': nativeMin(n, MAX_ARRAY_LENGTH),
            'type': methodName + (result.__dir__ < 0 ? 'Right' : '')
          });
        }
        return result;
      };

      LazyWrapper.prototype[methodName + 'Right'] = function(n) {
        return this.reverse()[methodName](n).reverse();
      };
    });

    // Add `LazyWrapper` methods that accept an `iteratee` value.
    arrayEach(['filter', 'map', 'takeWhile'], function(methodName, index) {
      var type = index + 1,
          isFilter = type == LAZY_FILTER_FLAG || type == LAZY_WHILE_FLAG;

      LazyWrapper.prototype[methodName] = function(iteratee) {
        var result = this.clone();
        result.__iteratees__.push({
          'iteratee': getIteratee(iteratee, 3),
          'type': type
        });
        result.__filtered__ = result.__filtered__ || isFilter;
        return result;
      };
    });

    // Add `LazyWrapper` methods for `_.head` and `_.last`.
    arrayEach(['head', 'last'], function(methodName, index) {
      var takeName = 'take' + (index ? 'Right' : '');

      LazyWrapper.prototype[methodName] = function() {
        return this[takeName](1).value()[0];
      };
    });

    // Add `LazyWrapper` methods for `_.initial` and `_.tail`.
    arrayEach(['initial', 'tail'], function(methodName, index) {
      var dropName = 'drop' + (index ? '' : 'Right');

      LazyWrapper.prototype[methodName] = function() {
        return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
      };
    });

    LazyWrapper.prototype.compact = function() {
      return this.filter(identity);
    };

    LazyWrapper.prototype.find = function(predicate) {
      return this.filter(predicate).head();
    };

    LazyWrapper.prototype.findLast = function(predicate) {
      return this.reverse().find(predicate);
    };

    LazyWrapper.prototype.invokeMap = baseRest(function(path, args) {
      if (typeof path == 'function') {
        return new LazyWrapper(this);
      }
      return this.map(function(value) {
        return baseInvoke(value, path, args);
      });
    });

    LazyWrapper.prototype.reject = function(predicate) {
      return this.filter(negate(getIteratee(predicate)));
    };

    LazyWrapper.prototype.slice = function(start, end) {
      start = toInteger(start);

      var result = this;
      if (result.__filtered__ && (start > 0 || end < 0)) {
        return new LazyWrapper(result);
      }
      if (start < 0) {
        result = result.takeRight(-start);
      } else if (start) {
        result = result.drop(start);
      }
      if (end !== undefined) {
        end = toInteger(end);
        result = end < 0 ? result.dropRight(-end) : result.take(end - start);
      }
      return result;
    };

    LazyWrapper.prototype.takeRightWhile = function(predicate) {
      return this.reverse().takeWhile(predicate).reverse();
    };

    LazyWrapper.prototype.toArray = function() {
      return this.take(MAX_ARRAY_LENGTH);
    };

    // Add `LazyWrapper` methods to `lodash.prototype`.
    baseForOwn(LazyWrapper.prototype, function(func, methodName) {
      var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName),
          isTaker = /^(?:head|last)$/.test(methodName),
          lodashFunc = lodash[isTaker ? ('take' + (methodName == 'last' ? 'Right' : '')) : methodName],
          retUnwrapped = isTaker || /^find/.test(methodName);

      if (!lodashFunc) {
        return;
      }
      lodash.prototype[methodName] = function() {
        var value = this.__wrapped__,
            args = isTaker ? [1] : arguments,
            isLazy = value instanceof LazyWrapper,
            iteratee = args[0],
            useLazy = isLazy || isArray(value);

        var interceptor = function(value) {
          var result = lodashFunc.apply(lodash, arrayPush([value], args));
          return (isTaker && chainAll) ? result[0] : result;
        };

        if (useLazy && checkIteratee && typeof iteratee == 'function' && iteratee.length != 1) {
          // Avoid lazy use if the iteratee has a "length" value other than `1`.
          isLazy = useLazy = false;
        }
        var chainAll = this.__chain__,
            isHybrid = !!this.__actions__.length,
            isUnwrapped = retUnwrapped && !chainAll,
            onlyLazy = isLazy && !isHybrid;

        if (!retUnwrapped && useLazy) {
          value = onlyLazy ? value : new LazyWrapper(this);
          var result = func.apply(value, args);
          result.__actions__.push({ 'func': thru, 'args': [interceptor], 'thisArg': undefined });
          return new LodashWrapper(result, chainAll);
        }
        if (isUnwrapped && onlyLazy) {
          return func.apply(this, args);
        }
        result = this.thru(interceptor);
        return isUnwrapped ? (isTaker ? result.value()[0] : result.value()) : result;
      };
    });

    // Add `Array` methods to `lodash.prototype`.
    arrayEach(['pop', 'push', 'shift', 'sort', 'splice', 'unshift'], function(methodName) {
      var func = arrayProto[methodName],
          chainName = /^(?:push|sort|unshift)$/.test(methodName) ? 'tap' : 'thru',
          retUnwrapped = /^(?:pop|shift)$/.test(methodName);

      lodash.prototype[methodName] = function() {
        var args = arguments;
        if (retUnwrapped && !this.__chain__) {
          var value = this.value();
          return func.apply(isArray(value) ? value : [], args);
        }
        return this[chainName](function(value) {
          return func.apply(isArray(value) ? value : [], args);
        });
      };
    });

    // Map minified method names to their real names.
    baseForOwn(LazyWrapper.prototype, function(func, methodName) {
      var lodashFunc = lodash[methodName];
      if (lodashFunc) {
        var key = lodashFunc.name + '';
        if (!hasOwnProperty.call(realNames, key)) {
          realNames[key] = [];
        }
        realNames[key].push({ 'name': methodName, 'func': lodashFunc });
      }
    });

    realNames[createHybrid(undefined, WRAP_BIND_KEY_FLAG).name] = [{
      'name': 'wrapper',
      'func': undefined
    }];

    // Add methods to `LazyWrapper`.
    LazyWrapper.prototype.clone = lazyClone;
    LazyWrapper.prototype.reverse = lazyReverse;
    LazyWrapper.prototype.value = lazyValue;

    // Add chain sequence methods to the `lodash` wrapper.
    lodash.prototype.at = wrapperAt;
    lodash.prototype.chain = wrapperChain;
    lodash.prototype.commit = wrapperCommit;
    lodash.prototype.next = wrapperNext;
    lodash.prototype.plant = wrapperPlant;
    lodash.prototype.reverse = wrapperReverse;
    lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;

    // Add lazy aliases.
    lodash.prototype.first = lodash.prototype.head;

    if (symIterator) {
      lodash.prototype[symIterator] = wrapperToIterator;
    }
    return lodash;
  });

  /*--------------------------------------------------------------------------*/

  // Export lodash.
  var _ = runInContext();

  // Some AMD build optimizers, like r.js, check for condition patterns like:
  if (true) {
    // Expose Lodash on the global object to prevent errors when Lodash is
    // loaded by a script tag in the presence of an AMD loader.
    // See http://requirejs.org/docs/errors.html#mismatch for more details.
    // Use `_.noConflict` to remove Lodash from the global object.
    root._ = _;

    // Define as an anonymous module so, through path mapping, it can be
    // referenced as the "underscore" module.
    !(__WEBPACK_AMD_DEFINE_RESULT__ = (function() {
      return _;
    }).call(exports, __webpack_require__, exports, module),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  }
  // Check for `exports` after `define` in case a build optimizer adds it.
  else {}
}.call(this));


/***/ }),

/***/ 3349:
/***/ ((module) => {

module.exports = assert;

function assert(val, msg) {
  if (!val)
    throw new Error(msg || 'Assertion failed');
}

assert.equal = function assertEqual(l, r, msg) {
  if (l != r)
    throw new Error(msg || ('Assertion failed: ' + l + ' != ' + r));
};


/***/ }),

/***/ 4367:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


var utils = exports;

function toArray(msg, enc) {
  if (Array.isArray(msg))
    return msg.slice();
  if (!msg)
    return [];
  var res = [];
  if (typeof msg !== 'string') {
    for (var i = 0; i < msg.length; i++)
      res[i] = msg[i] | 0;
    return res;
  }
  if (enc === 'hex') {
    msg = msg.replace(/[^a-z0-9]+/ig, '');
    if (msg.length % 2 !== 0)
      msg = '0' + msg;
    for (var i = 0; i < msg.length; i += 2)
      res.push(parseInt(msg[i] + msg[i + 1], 16));
  } else {
    for (var i = 0; i < msg.length; i++) {
      var c = msg.charCodeAt(i);
      var hi = c >> 8;
      var lo = c & 0xff;
      if (hi)
        res.push(hi, lo);
      else
        res.push(lo);
    }
  }
  return res;
}
utils.toArray = toArray;

function zero2(word) {
  if (word.length === 1)
    return '0' + word;
  else
    return word;
}
utils.zero2 = zero2;

function toHex(msg) {
  var res = '';
  for (var i = 0; i < msg.length; i++)
    res += zero2(msg[i].toString(16));
  return res;
}
utils.toHex = toHex;

utils.encode = function encode(arr, enc) {
  if (enc === 'hex')
    return toHex(arr);
  else
    return arr;
};


/***/ }),

/***/ 4741:
/***/ (() => {

/*! *****************************************************************************
Copyright (C) Microsoft. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
var Reflect;
(function (Reflect) {
    // Metadata Proposal
    // https://rbuckton.github.io/reflect-metadata/
    (function (factory) {
        var root = typeof global === "object" ? global :
            typeof self === "object" ? self :
                typeof this === "object" ? this :
                    Function("return this;")();
        var exporter = makeExporter(Reflect);
        if (typeof root.Reflect === "undefined") {
            root.Reflect = Reflect;
        }
        else {
            exporter = makeExporter(root.Reflect, exporter);
        }
        factory(exporter);
        function makeExporter(target, previous) {
            return function (key, value) {
                if (typeof target[key] !== "function") {
                    Object.defineProperty(target, key, { configurable: true, writable: true, value: value });
                }
                if (previous)
                    previous(key, value);
            };
        }
    })(function (exporter) {
        var hasOwn = Object.prototype.hasOwnProperty;
        // feature test for Symbol support
        var supportsSymbol = typeof Symbol === "function";
        var toPrimitiveSymbol = supportsSymbol && typeof Symbol.toPrimitive !== "undefined" ? Symbol.toPrimitive : "@@toPrimitive";
        var iteratorSymbol = supportsSymbol && typeof Symbol.iterator !== "undefined" ? Symbol.iterator : "@@iterator";
        var supportsCreate = typeof Object.create === "function"; // feature test for Object.create support
        var supportsProto = { __proto__: [] } instanceof Array; // feature test for __proto__ support
        var downLevel = !supportsCreate && !supportsProto;
        var HashMap = {
            // create an object in dictionary mode (a.k.a. "slow" mode in v8)
            create: supportsCreate
                ? function () { return MakeDictionary(Object.create(null)); }
                : supportsProto
                    ? function () { return MakeDictionary({ __proto__: null }); }
                    : function () { return MakeDictionary({}); },
            has: downLevel
                ? function (map, key) { return hasOwn.call(map, key); }
                : function (map, key) { return key in map; },
            get: downLevel
                ? function (map, key) { return hasOwn.call(map, key) ? map[key] : undefined; }
                : function (map, key) { return map[key]; },
        };
        // Load global or shim versions of Map, Set, and WeakMap
        var functionPrototype = Object.getPrototypeOf(Function);
        var usePolyfill = typeof process === "object" && process["env" + ""] && process["env" + ""]["REFLECT_METADATA_USE_MAP_POLYFILL"] === "true";
        var _Map = !usePolyfill && typeof Map === "function" && typeof Map.prototype.entries === "function" ? Map : CreateMapPolyfill();
        var _Set = !usePolyfill && typeof Set === "function" && typeof Set.prototype.entries === "function" ? Set : CreateSetPolyfill();
        var _WeakMap = !usePolyfill && typeof WeakMap === "function" ? WeakMap : CreateWeakMapPolyfill();
        // [[Metadata]] internal slot
        // https://rbuckton.github.io/reflect-metadata/#ordinary-object-internal-methods-and-internal-slots
        var Metadata = new _WeakMap();
        /**
         * Applies a set of decorators to a property of a target object.
         * @param decorators An array of decorators.
         * @param target The target object.
         * @param propertyKey (Optional) The property key to decorate.
         * @param attributes (Optional) The property descriptor for the target key.
         * @remarks Decorators are applied in reverse order.
         * @example
         *
         *     class Example {
         *         // property declarations are not part of ES6, though they are valid in TypeScript:
         *         // static staticProperty;
         *         // property;
         *
         *         constructor(p) { }
         *         static staticMethod(p) { }
         *         method(p) { }
         *     }
         *
         *     // constructor
         *     Example = Reflect.decorate(decoratorsArray, Example);
         *
         *     // property (on constructor)
         *     Reflect.decorate(decoratorsArray, Example, "staticProperty");
         *
         *     // property (on prototype)
         *     Reflect.decorate(decoratorsArray, Example.prototype, "property");
         *
         *     // method (on constructor)
         *     Object.defineProperty(Example, "staticMethod",
         *         Reflect.decorate(decoratorsArray, Example, "staticMethod",
         *             Object.getOwnPropertyDescriptor(Example, "staticMethod")));
         *
         *     // method (on prototype)
         *     Object.defineProperty(Example.prototype, "method",
         *         Reflect.decorate(decoratorsArray, Example.prototype, "method",
         *             Object.getOwnPropertyDescriptor(Example.prototype, "method")));
         *
         */
        function decorate(decorators, target, propertyKey, attributes) {
            if (!IsUndefined(propertyKey)) {
                if (!IsArray(decorators))
                    throw new TypeError();
                if (!IsObject(target))
                    throw new TypeError();
                if (!IsObject(attributes) && !IsUndefined(attributes) && !IsNull(attributes))
                    throw new TypeError();
                if (IsNull(attributes))
                    attributes = undefined;
                propertyKey = ToPropertyKey(propertyKey);
                return DecorateProperty(decorators, target, propertyKey, attributes);
            }
            else {
                if (!IsArray(decorators))
                    throw new TypeError();
                if (!IsConstructor(target))
                    throw new TypeError();
                return DecorateConstructor(decorators, target);
            }
        }
        exporter("decorate", decorate);
        // 4.1.2 Reflect.metadata(metadataKey, metadataValue)
        // https://rbuckton.github.io/reflect-metadata/#reflect.metadata
        /**
         * A default metadata decorator factory that can be used on a class, class member, or parameter.
         * @param metadataKey The key for the metadata entry.
         * @param metadataValue The value for the metadata entry.
         * @returns A decorator function.
         * @remarks
         * If `metadataKey` is already defined for the target and target key, the
         * metadataValue for that key will be overwritten.
         * @example
         *
         *     // constructor
         *     @Reflect.metadata(key, value)
         *     class Example {
         *     }
         *
         *     // property (on constructor, TypeScript only)
         *     class Example {
         *         @Reflect.metadata(key, value)
         *         static staticProperty;
         *     }
         *
         *     // property (on prototype, TypeScript only)
         *     class Example {
         *         @Reflect.metadata(key, value)
         *         property;
         *     }
         *
         *     // method (on constructor)
         *     class Example {
         *         @Reflect.metadata(key, value)
         *         static staticMethod() { }
         *     }
         *
         *     // method (on prototype)
         *     class Example {
         *         @Reflect.metadata(key, value)
         *         method() { }
         *     }
         *
         */
        function metadata(metadataKey, metadataValue) {
            function decorator(target, propertyKey) {
                if (!IsObject(target))
                    throw new TypeError();
                if (!IsUndefined(propertyKey) && !IsPropertyKey(propertyKey))
                    throw new TypeError();
                OrdinaryDefineOwnMetadata(metadataKey, metadataValue, target, propertyKey);
            }
            return decorator;
        }
        exporter("metadata", metadata);
        /**
         * Define a unique metadata entry on the target.
         * @param metadataKey A key used to store and retrieve metadata.
         * @param metadataValue A value that contains attached metadata.
         * @param target The target object on which to define metadata.
         * @param propertyKey (Optional) The property key for the target.
         * @example
         *
         *     class Example {
         *         // property declarations are not part of ES6, though they are valid in TypeScript:
         *         // static staticProperty;
         *         // property;
         *
         *         constructor(p) { }
         *         static staticMethod(p) { }
         *         method(p) { }
         *     }
         *
         *     // constructor
         *     Reflect.defineMetadata("custom:annotation", options, Example);
         *
         *     // property (on constructor)
         *     Reflect.defineMetadata("custom:annotation", options, Example, "staticProperty");
         *
         *     // property (on prototype)
         *     Reflect.defineMetadata("custom:annotation", options, Example.prototype, "property");
         *
         *     // method (on constructor)
         *     Reflect.defineMetadata("custom:annotation", options, Example, "staticMethod");
         *
         *     // method (on prototype)
         *     Reflect.defineMetadata("custom:annotation", options, Example.prototype, "method");
         *
         *     // decorator factory as metadata-producing annotation.
         *     function MyAnnotation(options): Decorator {
         *         return (target, key?) => Reflect.defineMetadata("custom:annotation", options, target, key);
         *     }
         *
         */
        function defineMetadata(metadataKey, metadataValue, target, propertyKey) {
            if (!IsObject(target))
                throw new TypeError();
            if (!IsUndefined(propertyKey))
                propertyKey = ToPropertyKey(propertyKey);
            return OrdinaryDefineOwnMetadata(metadataKey, metadataValue, target, propertyKey);
        }
        exporter("defineMetadata", defineMetadata);
        /**
         * Gets a value indicating whether the target object or its prototype chain has the provided metadata key defined.
         * @param metadataKey A key used to store and retrieve metadata.
         * @param target The target object on which the metadata is defined.
         * @param propertyKey (Optional) The property key for the target.
         * @returns `true` if the metadata key was defined on the target object or its prototype chain; otherwise, `false`.
         * @example
         *
         *     class Example {
         *         // property declarations are not part of ES6, though they are valid in TypeScript:
         *         // static staticProperty;
         *         // property;
         *
         *         constructor(p) { }
         *         static staticMethod(p) { }
         *         method(p) { }
         *     }
         *
         *     // constructor
         *     result = Reflect.hasMetadata("custom:annotation", Example);
         *
         *     // property (on constructor)
         *     result = Reflect.hasMetadata("custom:annotation", Example, "staticProperty");
         *
         *     // property (on prototype)
         *     result = Reflect.hasMetadata("custom:annotation", Example.prototype, "property");
         *
         *     // method (on constructor)
         *     result = Reflect.hasMetadata("custom:annotation", Example, "staticMethod");
         *
         *     // method (on prototype)
         *     result = Reflect.hasMetadata("custom:annotation", Example.prototype, "method");
         *
         */
        function hasMetadata(metadataKey, target, propertyKey) {
            if (!IsObject(target))
                throw new TypeError();
            if (!IsUndefined(propertyKey))
                propertyKey = ToPropertyKey(propertyKey);
            return OrdinaryHasMetadata(metadataKey, target, propertyKey);
        }
        exporter("hasMetadata", hasMetadata);
        /**
         * Gets a value indicating whether the target object has the provided metadata key defined.
         * @param metadataKey A key used to store and retrieve metadata.
         * @param target The target object on which the metadata is defined.
         * @param propertyKey (Optional) The property key for the target.
         * @returns `true` if the metadata key was defined on the target object; otherwise, `false`.
         * @example
         *
         *     class Example {
         *         // property declarations are not part of ES6, though they are valid in TypeScript:
         *         // static staticProperty;
         *         // property;
         *
         *         constructor(p) { }
         *         static staticMethod(p) { }
         *         method(p) { }
         *     }
         *
         *     // constructor
         *     result = Reflect.hasOwnMetadata("custom:annotation", Example);
         *
         *     // property (on constructor)
         *     result = Reflect.hasOwnMetadata("custom:annotation", Example, "staticProperty");
         *
         *     // property (on prototype)
         *     result = Reflect.hasOwnMetadata("custom:annotation", Example.prototype, "property");
         *
         *     // method (on constructor)
         *     result = Reflect.hasOwnMetadata("custom:annotation", Example, "staticMethod");
         *
         *     // method (on prototype)
         *     result = Reflect.hasOwnMetadata("custom:annotation", Example.prototype, "method");
         *
         */
        function hasOwnMetadata(metadataKey, target, propertyKey) {
            if (!IsObject(target))
                throw new TypeError();
            if (!IsUndefined(propertyKey))
                propertyKey = ToPropertyKey(propertyKey);
            return OrdinaryHasOwnMetadata(metadataKey, target, propertyKey);
        }
        exporter("hasOwnMetadata", hasOwnMetadata);
        /**
         * Gets the metadata value for the provided metadata key on the target object or its prototype chain.
         * @param metadataKey A key used to store and retrieve metadata.
         * @param target The target object on which the metadata is defined.
         * @param propertyKey (Optional) The property key for the target.
         * @returns The metadata value for the metadata key if found; otherwise, `undefined`.
         * @example
         *
         *     class Example {
         *         // property declarations are not part of ES6, though they are valid in TypeScript:
         *         // static staticProperty;
         *         // property;
         *
         *         constructor(p) { }
         *         static staticMethod(p) { }
         *         method(p) { }
         *     }
         *
         *     // constructor
         *     result = Reflect.getMetadata("custom:annotation", Example);
         *
         *     // property (on constructor)
         *     result = Reflect.getMetadata("custom:annotation", Example, "staticProperty");
         *
         *     // property (on prototype)
         *     result = Reflect.getMetadata("custom:annotation", Example.prototype, "property");
         *
         *     // method (on constructor)
         *     result = Reflect.getMetadata("custom:annotation", Example, "staticMethod");
         *
         *     // method (on prototype)
         *     result = Reflect.getMetadata("custom:annotation", Example.prototype, "method");
         *
         */
        function getMetadata(metadataKey, target, propertyKey) {
            if (!IsObject(target))
                throw new TypeError();
            if (!IsUndefined(propertyKey))
                propertyKey = ToPropertyKey(propertyKey);
            return OrdinaryGetMetadata(metadataKey, target, propertyKey);
        }
        exporter("getMetadata", getMetadata);
        /**
         * Gets the metadata value for the provided metadata key on the target object.
         * @param metadataKey A key used to store and retrieve metadata.
         * @param target The target object on which the metadata is defined.
         * @param propertyKey (Optional) The property key for the target.
         * @returns The metadata value for the metadata key if found; otherwise, `undefined`.
         * @example
         *
         *     class Example {
         *         // property declarations are not part of ES6, though they are valid in TypeScript:
         *         // static staticProperty;
         *         // property;
         *
         *         constructor(p) { }
         *         static staticMethod(p) { }
         *         method(p) { }
         *     }
         *
         *     // constructor
         *     result = Reflect.getOwnMetadata("custom:annotation", Example);
         *
         *     // property (on constructor)
         *     result = Reflect.getOwnMetadata("custom:annotation", Example, "staticProperty");
         *
         *     // property (on prototype)
         *     result = Reflect.getOwnMetadata("custom:annotation", Example.prototype, "property");
         *
         *     // method (on constructor)
         *     result = Reflect.getOwnMetadata("custom:annotation", Example, "staticMethod");
         *
         *     // method (on prototype)
         *     result = Reflect.getOwnMetadata("custom:annotation", Example.prototype, "method");
         *
         */
        function getOwnMetadata(metadataKey, target, propertyKey) {
            if (!IsObject(target))
                throw new TypeError();
            if (!IsUndefined(propertyKey))
                propertyKey = ToPropertyKey(propertyKey);
            return OrdinaryGetOwnMetadata(metadataKey, target, propertyKey);
        }
        exporter("getOwnMetadata", getOwnMetadata);
        /**
         * Gets the metadata keys defined on the target object or its prototype chain.
         * @param target The target object on which the metadata is defined.
         * @param propertyKey (Optional) The property key for the target.
         * @returns An array of unique metadata keys.
         * @example
         *
         *     class Example {
         *         // property declarations are not part of ES6, though they are valid in TypeScript:
         *         // static staticProperty;
         *         // property;
         *
         *         constructor(p) { }
         *         static staticMethod(p) { }
         *         method(p) { }
         *     }
         *
         *     // constructor
         *     result = Reflect.getMetadataKeys(Example);
         *
         *     // property (on constructor)
         *     result = Reflect.getMetadataKeys(Example, "staticProperty");
         *
         *     // property (on prototype)
         *     result = Reflect.getMetadataKeys(Example.prototype, "property");
         *
         *     // method (on constructor)
         *     result = Reflect.getMetadataKeys(Example, "staticMethod");
         *
         *     // method (on prototype)
         *     result = Reflect.getMetadataKeys(Example.prototype, "method");
         *
         */
        function getMetadataKeys(target, propertyKey) {
            if (!IsObject(target))
                throw new TypeError();
            if (!IsUndefined(propertyKey))
                propertyKey = ToPropertyKey(propertyKey);
            return OrdinaryMetadataKeys(target, propertyKey);
        }
        exporter("getMetadataKeys", getMetadataKeys);
        /**
         * Gets the unique metadata keys defined on the target object.
         * @param target The target object on which the metadata is defined.
         * @param propertyKey (Optional) The property key for the target.
         * @returns An array of unique metadata keys.
         * @example
         *
         *     class Example {
         *         // property declarations are not part of ES6, though they are valid in TypeScript:
         *         // static staticProperty;
         *         // property;
         *
         *         constructor(p) { }
         *         static staticMethod(p) { }
         *         method(p) { }
         *     }
         *
         *     // constructor
         *     result = Reflect.getOwnMetadataKeys(Example);
         *
         *     // property (on constructor)
         *     result = Reflect.getOwnMetadataKeys(Example, "staticProperty");
         *
         *     // property (on prototype)
         *     result = Reflect.getOwnMetadataKeys(Example.prototype, "property");
         *
         *     // method (on constructor)
         *     result = Reflect.getOwnMetadataKeys(Example, "staticMethod");
         *
         *     // method (on prototype)
         *     result = Reflect.getOwnMetadataKeys(Example.prototype, "method");
         *
         */
        function getOwnMetadataKeys(target, propertyKey) {
            if (!IsObject(target))
                throw new TypeError();
            if (!IsUndefined(propertyKey))
                propertyKey = ToPropertyKey(propertyKey);
            return OrdinaryOwnMetadataKeys(target, propertyKey);
        }
        exporter("getOwnMetadataKeys", getOwnMetadataKeys);
        /**
         * Deletes the metadata entry from the target object with the provided key.
         * @param metadataKey A key used to store and retrieve metadata.
         * @param target The target object on which the metadata is defined.
         * @param propertyKey (Optional) The property key for the target.
         * @returns `true` if the metadata entry was found and deleted; otherwise, false.
         * @example
         *
         *     class Example {
         *         // property declarations are not part of ES6, though they are valid in TypeScript:
         *         // static staticProperty;
         *         // property;
         *
         *         constructor(p) { }
         *         static staticMethod(p) { }
         *         method(p) { }
         *     }
         *
         *     // constructor
         *     result = Reflect.deleteMetadata("custom:annotation", Example);
         *
         *     // property (on constructor)
         *     result = Reflect.deleteMetadata("custom:annotation", Example, "staticProperty");
         *
         *     // property (on prototype)
         *     result = Reflect.deleteMetadata("custom:annotation", Example.prototype, "property");
         *
         *     // method (on constructor)
         *     result = Reflect.deleteMetadata("custom:annotation", Example, "staticMethod");
         *
         *     // method (on prototype)
         *     result = Reflect.deleteMetadata("custom:annotation", Example.prototype, "method");
         *
         */
        function deleteMetadata(metadataKey, target, propertyKey) {
            if (!IsObject(target))
                throw new TypeError();
            if (!IsUndefined(propertyKey))
                propertyKey = ToPropertyKey(propertyKey);
            var metadataMap = GetOrCreateMetadataMap(target, propertyKey, /*Create*/ false);
            if (IsUndefined(metadataMap))
                return false;
            if (!metadataMap.delete(metadataKey))
                return false;
            if (metadataMap.size > 0)
                return true;
            var targetMetadata = Metadata.get(target);
            targetMetadata.delete(propertyKey);
            if (targetMetadata.size > 0)
                return true;
            Metadata.delete(target);
            return true;
        }
        exporter("deleteMetadata", deleteMetadata);
        function DecorateConstructor(decorators, target) {
            for (var i = decorators.length - 1; i >= 0; --i) {
                var decorator = decorators[i];
                var decorated = decorator(target);
                if (!IsUndefined(decorated) && !IsNull(decorated)) {
                    if (!IsConstructor(decorated))
                        throw new TypeError();
                    target = decorated;
                }
            }
            return target;
        }
        function DecorateProperty(decorators, target, propertyKey, descriptor) {
            for (var i = decorators.length - 1; i >= 0; --i) {
                var decorator = decorators[i];
                var decorated = decorator(target, propertyKey, descriptor);
                if (!IsUndefined(decorated) && !IsNull(decorated)) {
                    if (!IsObject(decorated))
                        throw new TypeError();
                    descriptor = decorated;
                }
            }
            return descriptor;
        }
        function GetOrCreateMetadataMap(O, P, Create) {
            var targetMetadata = Metadata.get(O);
            if (IsUndefined(targetMetadata)) {
                if (!Create)
                    return undefined;
                targetMetadata = new _Map();
                Metadata.set(O, targetMetadata);
            }
            var metadataMap = targetMetadata.get(P);
            if (IsUndefined(metadataMap)) {
                if (!Create)
                    return undefined;
                metadataMap = new _Map();
                targetMetadata.set(P, metadataMap);
            }
            return metadataMap;
        }
        // 3.1.1.1 OrdinaryHasMetadata(MetadataKey, O, P)
        // https://rbuckton.github.io/reflect-metadata/#ordinaryhasmetadata
        function OrdinaryHasMetadata(MetadataKey, O, P) {
            var hasOwn = OrdinaryHasOwnMetadata(MetadataKey, O, P);
            if (hasOwn)
                return true;
            var parent = OrdinaryGetPrototypeOf(O);
            if (!IsNull(parent))
                return OrdinaryHasMetadata(MetadataKey, parent, P);
            return false;
        }
        // 3.1.2.1 OrdinaryHasOwnMetadata(MetadataKey, O, P)
        // https://rbuckton.github.io/reflect-metadata/#ordinaryhasownmetadata
        function OrdinaryHasOwnMetadata(MetadataKey, O, P) {
            var metadataMap = GetOrCreateMetadataMap(O, P, /*Create*/ false);
            if (IsUndefined(metadataMap))
                return false;
            return ToBoolean(metadataMap.has(MetadataKey));
        }
        // 3.1.3.1 OrdinaryGetMetadata(MetadataKey, O, P)
        // https://rbuckton.github.io/reflect-metadata/#ordinarygetmetadata
        function OrdinaryGetMetadata(MetadataKey, O, P) {
            var hasOwn = OrdinaryHasOwnMetadata(MetadataKey, O, P);
            if (hasOwn)
                return OrdinaryGetOwnMetadata(MetadataKey, O, P);
            var parent = OrdinaryGetPrototypeOf(O);
            if (!IsNull(parent))
                return OrdinaryGetMetadata(MetadataKey, parent, P);
            return undefined;
        }
        // 3.1.4.1 OrdinaryGetOwnMetadata(MetadataKey, O, P)
        // https://rbuckton.github.io/reflect-metadata/#ordinarygetownmetadata
        function OrdinaryGetOwnMetadata(MetadataKey, O, P) {
            var metadataMap = GetOrCreateMetadataMap(O, P, /*Create*/ false);
            if (IsUndefined(metadataMap))
                return undefined;
            return metadataMap.get(MetadataKey);
        }
        // 3.1.5.1 OrdinaryDefineOwnMetadata(MetadataKey, MetadataValue, O, P)
        // https://rbuckton.github.io/reflect-metadata/#ordinarydefineownmetadata
        function OrdinaryDefineOwnMetadata(MetadataKey, MetadataValue, O, P) {
            var metadataMap = GetOrCreateMetadataMap(O, P, /*Create*/ true);
            metadataMap.set(MetadataKey, MetadataValue);
        }
        // 3.1.6.1 OrdinaryMetadataKeys(O, P)
        // https://rbuckton.github.io/reflect-metadata/#ordinarymetadatakeys
        function OrdinaryMetadataKeys(O, P) {
            var ownKeys = OrdinaryOwnMetadataKeys(O, P);
            var parent = OrdinaryGetPrototypeOf(O);
            if (parent === null)
                return ownKeys;
            var parentKeys = OrdinaryMetadataKeys(parent, P);
            if (parentKeys.length <= 0)
                return ownKeys;
            if (ownKeys.length <= 0)
                return parentKeys;
            var set = new _Set();
            var keys = [];
            for (var _i = 0, ownKeys_1 = ownKeys; _i < ownKeys_1.length; _i++) {
                var key = ownKeys_1[_i];
                var hasKey = set.has(key);
                if (!hasKey) {
                    set.add(key);
                    keys.push(key);
                }
            }
            for (var _a = 0, parentKeys_1 = parentKeys; _a < parentKeys_1.length; _a++) {
                var key = parentKeys_1[_a];
                var hasKey = set.has(key);
                if (!hasKey) {
                    set.add(key);
                    keys.push(key);
                }
            }
            return keys;
        }
        // 3.1.7.1 OrdinaryOwnMetadataKeys(O, P)
        // https://rbuckton.github.io/reflect-metadata/#ordinaryownmetadatakeys
        function OrdinaryOwnMetadataKeys(O, P) {
            var keys = [];
            var metadataMap = GetOrCreateMetadataMap(O, P, /*Create*/ false);
            if (IsUndefined(metadataMap))
                return keys;
            var keysObj = metadataMap.keys();
            var iterator = GetIterator(keysObj);
            var k = 0;
            while (true) {
                var next = IteratorStep(iterator);
                if (!next) {
                    keys.length = k;
                    return keys;
                }
                var nextValue = IteratorValue(next);
                try {
                    keys[k] = nextValue;
                }
                catch (e) {
                    try {
                        IteratorClose(iterator);
                    }
                    finally {
                        throw e;
                    }
                }
                k++;
            }
        }
        // 6 ECMAScript Data Typ0es and Values
        // https://tc39.github.io/ecma262/#sec-ecmascript-data-types-and-values
        function Type(x) {
            if (x === null)
                return 1 /* Null */;
            switch (typeof x) {
                case "undefined": return 0 /* Undefined */;
                case "boolean": return 2 /* Boolean */;
                case "string": return 3 /* String */;
                case "symbol": return 4 /* Symbol */;
                case "number": return 5 /* Number */;
                case "object": return x === null ? 1 /* Null */ : 6 /* Object */;
                default: return 6 /* Object */;
            }
        }
        // 6.1.1 The Undefined Type
        // https://tc39.github.io/ecma262/#sec-ecmascript-language-types-undefined-type
        function IsUndefined(x) {
            return x === undefined;
        }
        // 6.1.2 The Null Type
        // https://tc39.github.io/ecma262/#sec-ecmascript-language-types-null-type
        function IsNull(x) {
            return x === null;
        }
        // 6.1.5 The Symbol Type
        // https://tc39.github.io/ecma262/#sec-ecmascript-language-types-symbol-type
        function IsSymbol(x) {
            return typeof x === "symbol";
        }
        // 6.1.7 The Object Type
        // https://tc39.github.io/ecma262/#sec-object-type
        function IsObject(x) {
            return typeof x === "object" ? x !== null : typeof x === "function";
        }
        // 7.1 Type Conversion
        // https://tc39.github.io/ecma262/#sec-type-conversion
        // 7.1.1 ToPrimitive(input [, PreferredType])
        // https://tc39.github.io/ecma262/#sec-toprimitive
        function ToPrimitive(input, PreferredType) {
            switch (Type(input)) {
                case 0 /* Undefined */: return input;
                case 1 /* Null */: return input;
                case 2 /* Boolean */: return input;
                case 3 /* String */: return input;
                case 4 /* Symbol */: return input;
                case 5 /* Number */: return input;
            }
            var hint = PreferredType === 3 /* String */ ? "string" : PreferredType === 5 /* Number */ ? "number" : "default";
            var exoticToPrim = GetMethod(input, toPrimitiveSymbol);
            if (exoticToPrim !== undefined) {
                var result = exoticToPrim.call(input, hint);
                if (IsObject(result))
                    throw new TypeError();
                return result;
            }
            return OrdinaryToPrimitive(input, hint === "default" ? "number" : hint);
        }
        // 7.1.1.1 OrdinaryToPrimitive(O, hint)
        // https://tc39.github.io/ecma262/#sec-ordinarytoprimitive
        function OrdinaryToPrimitive(O, hint) {
            if (hint === "string") {
                var toString_1 = O.toString;
                if (IsCallable(toString_1)) {
                    var result = toString_1.call(O);
                    if (!IsObject(result))
                        return result;
                }
                var valueOf = O.valueOf;
                if (IsCallable(valueOf)) {
                    var result = valueOf.call(O);
                    if (!IsObject(result))
                        return result;
                }
            }
            else {
                var valueOf = O.valueOf;
                if (IsCallable(valueOf)) {
                    var result = valueOf.call(O);
                    if (!IsObject(result))
                        return result;
                }
                var toString_2 = O.toString;
                if (IsCallable(toString_2)) {
                    var result = toString_2.call(O);
                    if (!IsObject(result))
                        return result;
                }
            }
            throw new TypeError();
        }
        // 7.1.2 ToBoolean(argument)
        // https://tc39.github.io/ecma262/2016/#sec-toboolean
        function ToBoolean(argument) {
            return !!argument;
        }
        // 7.1.12 ToString(argument)
        // https://tc39.github.io/ecma262/#sec-tostring
        function ToString(argument) {
            return "" + argument;
        }
        // 7.1.14 ToPropertyKey(argument)
        // https://tc39.github.io/ecma262/#sec-topropertykey
        function ToPropertyKey(argument) {
            var key = ToPrimitive(argument, 3 /* String */);
            if (IsSymbol(key))
                return key;
            return ToString(key);
        }
        // 7.2 Testing and Comparison Operations
        // https://tc39.github.io/ecma262/#sec-testing-and-comparison-operations
        // 7.2.2 IsArray(argument)
        // https://tc39.github.io/ecma262/#sec-isarray
        function IsArray(argument) {
            return Array.isArray
                ? Array.isArray(argument)
                : argument instanceof Object
                    ? argument instanceof Array
                    : Object.prototype.toString.call(argument) === "[object Array]";
        }
        // 7.2.3 IsCallable(argument)
        // https://tc39.github.io/ecma262/#sec-iscallable
        function IsCallable(argument) {
            // NOTE: This is an approximation as we cannot check for [[Call]] internal method.
            return typeof argument === "function";
        }
        // 7.2.4 IsConstructor(argument)
        // https://tc39.github.io/ecma262/#sec-isconstructor
        function IsConstructor(argument) {
            // NOTE: This is an approximation as we cannot check for [[Construct]] internal method.
            return typeof argument === "function";
        }
        // 7.2.7 IsPropertyKey(argument)
        // https://tc39.github.io/ecma262/#sec-ispropertykey
        function IsPropertyKey(argument) {
            switch (Type(argument)) {
                case 3 /* String */: return true;
                case 4 /* Symbol */: return true;
                default: return false;
            }
        }
        // 7.3 Operations on Objects
        // https://tc39.github.io/ecma262/#sec-operations-on-objects
        // 7.3.9 GetMethod(V, P)
        // https://tc39.github.io/ecma262/#sec-getmethod
        function GetMethod(V, P) {
            var func = V[P];
            if (func === undefined || func === null)
                return undefined;
            if (!IsCallable(func))
                throw new TypeError();
            return func;
        }
        // 7.4 Operations on Iterator Objects
        // https://tc39.github.io/ecma262/#sec-operations-on-iterator-objects
        function GetIterator(obj) {
            var method = GetMethod(obj, iteratorSymbol);
            if (!IsCallable(method))
                throw new TypeError(); // from Call
            var iterator = method.call(obj);
            if (!IsObject(iterator))
                throw new TypeError();
            return iterator;
        }
        // 7.4.4 IteratorValue(iterResult)
        // https://tc39.github.io/ecma262/2016/#sec-iteratorvalue
        function IteratorValue(iterResult) {
            return iterResult.value;
        }
        // 7.4.5 IteratorStep(iterator)
        // https://tc39.github.io/ecma262/#sec-iteratorstep
        function IteratorStep(iterator) {
            var result = iterator.next();
            return result.done ? false : result;
        }
        // 7.4.6 IteratorClose(iterator, completion)
        // https://tc39.github.io/ecma262/#sec-iteratorclose
        function IteratorClose(iterator) {
            var f = iterator["return"];
            if (f)
                f.call(iterator);
        }
        // 9.1 Ordinary Object Internal Methods and Internal Slots
        // https://tc39.github.io/ecma262/#sec-ordinary-object-internal-methods-and-internal-slots
        // 9.1.1.1 OrdinaryGetPrototypeOf(O)
        // https://tc39.github.io/ecma262/#sec-ordinarygetprototypeof
        function OrdinaryGetPrototypeOf(O) {
            var proto = Object.getPrototypeOf(O);
            if (typeof O !== "function" || O === functionPrototype)
                return proto;
            // TypeScript doesn't set __proto__ in ES5, as it's non-standard.
            // Try to determine the superclass constructor. Compatible implementations
            // must either set __proto__ on a subclass constructor to the superclass constructor,
            // or ensure each class has a valid `constructor` property on its prototype that
            // points back to the constructor.
            // If this is not the same as Function.[[Prototype]], then this is definately inherited.
            // This is the case when in ES6 or when using __proto__ in a compatible browser.
            if (proto !== functionPrototype)
                return proto;
            // If the super prototype is Object.prototype, null, or undefined, then we cannot determine the heritage.
            var prototype = O.prototype;
            var prototypeProto = prototype && Object.getPrototypeOf(prototype);
            if (prototypeProto == null || prototypeProto === Object.prototype)
                return proto;
            // If the constructor was not a function, then we cannot determine the heritage.
            var constructor = prototypeProto.constructor;
            if (typeof constructor !== "function")
                return proto;
            // If we have some kind of self-reference, then we cannot determine the heritage.
            if (constructor === O)
                return proto;
            // we have a pretty good guess at the heritage.
            return constructor;
        }
        // naive Map shim
        function CreateMapPolyfill() {
            var cacheSentinel = {};
            var arraySentinel = [];
            var MapIterator = /** @class */ (function () {
                function MapIterator(keys, values, selector) {
                    this._index = 0;
                    this._keys = keys;
                    this._values = values;
                    this._selector = selector;
                }
                MapIterator.prototype["@@iterator"] = function () { return this; };
                MapIterator.prototype[iteratorSymbol] = function () { return this; };
                MapIterator.prototype.next = function () {
                    var index = this._index;
                    if (index >= 0 && index < this._keys.length) {
                        var result = this._selector(this._keys[index], this._values[index]);
                        if (index + 1 >= this._keys.length) {
                            this._index = -1;
                            this._keys = arraySentinel;
                            this._values = arraySentinel;
                        }
                        else {
                            this._index++;
                        }
                        return { value: result, done: false };
                    }
                    return { value: undefined, done: true };
                };
                MapIterator.prototype.throw = function (error) {
                    if (this._index >= 0) {
                        this._index = -1;
                        this._keys = arraySentinel;
                        this._values = arraySentinel;
                    }
                    throw error;
                };
                MapIterator.prototype.return = function (value) {
                    if (this._index >= 0) {
                        this._index = -1;
                        this._keys = arraySentinel;
                        this._values = arraySentinel;
                    }
                    return { value: value, done: true };
                };
                return MapIterator;
            }());
            return /** @class */ (function () {
                function Map() {
                    this._keys = [];
                    this._values = [];
                    this._cacheKey = cacheSentinel;
                    this._cacheIndex = -2;
                }
                Object.defineProperty(Map.prototype, "size", {
                    get: function () { return this._keys.length; },
                    enumerable: true,
                    configurable: true
                });
                Map.prototype.has = function (key) { return this._find(key, /*insert*/ false) >= 0; };
                Map.prototype.get = function (key) {
                    var index = this._find(key, /*insert*/ false);
                    return index >= 0 ? this._values[index] : undefined;
                };
                Map.prototype.set = function (key, value) {
                    var index = this._find(key, /*insert*/ true);
                    this._values[index] = value;
                    return this;
                };
                Map.prototype.delete = function (key) {
                    var index = this._find(key, /*insert*/ false);
                    if (index >= 0) {
                        var size = this._keys.length;
                        for (var i = index + 1; i < size; i++) {
                            this._keys[i - 1] = this._keys[i];
                            this._values[i - 1] = this._values[i];
                        }
                        this._keys.length--;
                        this._values.length--;
                        if (key === this._cacheKey) {
                            this._cacheKey = cacheSentinel;
                            this._cacheIndex = -2;
                        }
                        return true;
                    }
                    return false;
                };
                Map.prototype.clear = function () {
                    this._keys.length = 0;
                    this._values.length = 0;
                    this._cacheKey = cacheSentinel;
                    this._cacheIndex = -2;
                };
                Map.prototype.keys = function () { return new MapIterator(this._keys, this._values, getKey); };
                Map.prototype.values = function () { return new MapIterator(this._keys, this._values, getValue); };
                Map.prototype.entries = function () { return new MapIterator(this._keys, this._values, getEntry); };
                Map.prototype["@@iterator"] = function () { return this.entries(); };
                Map.prototype[iteratorSymbol] = function () { return this.entries(); };
                Map.prototype._find = function (key, insert) {
                    if (this._cacheKey !== key) {
                        this._cacheIndex = this._keys.indexOf(this._cacheKey = key);
                    }
                    if (this._cacheIndex < 0 && insert) {
                        this._cacheIndex = this._keys.length;
                        this._keys.push(key);
                        this._values.push(undefined);
                    }
                    return this._cacheIndex;
                };
                return Map;
            }());
            function getKey(key, _) {
                return key;
            }
            function getValue(_, value) {
                return value;
            }
            function getEntry(key, value) {
                return [key, value];
            }
        }
        // naive Set shim
        function CreateSetPolyfill() {
            return /** @class */ (function () {
                function Set() {
                    this._map = new _Map();
                }
                Object.defineProperty(Set.prototype, "size", {
                    get: function () { return this._map.size; },
                    enumerable: true,
                    configurable: true
                });
                Set.prototype.has = function (value) { return this._map.has(value); };
                Set.prototype.add = function (value) { return this._map.set(value, value), this; };
                Set.prototype.delete = function (value) { return this._map.delete(value); };
                Set.prototype.clear = function () { this._map.clear(); };
                Set.prototype.keys = function () { return this._map.keys(); };
                Set.prototype.values = function () { return this._map.values(); };
                Set.prototype.entries = function () { return this._map.entries(); };
                Set.prototype["@@iterator"] = function () { return this.keys(); };
                Set.prototype[iteratorSymbol] = function () { return this.keys(); };
                return Set;
            }());
        }
        // naive WeakMap shim
        function CreateWeakMapPolyfill() {
            var UUID_SIZE = 16;
            var keys = HashMap.create();
            var rootKey = CreateUniqueKey();
            return /** @class */ (function () {
                function WeakMap() {
                    this._key = CreateUniqueKey();
                }
                WeakMap.prototype.has = function (target) {
                    var table = GetOrCreateWeakMapTable(target, /*create*/ false);
                    return table !== undefined ? HashMap.has(table, this._key) : false;
                };
                WeakMap.prototype.get = function (target) {
                    var table = GetOrCreateWeakMapTable(target, /*create*/ false);
                    return table !== undefined ? HashMap.get(table, this._key) : undefined;
                };
                WeakMap.prototype.set = function (target, value) {
                    var table = GetOrCreateWeakMapTable(target, /*create*/ true);
                    table[this._key] = value;
                    return this;
                };
                WeakMap.prototype.delete = function (target) {
                    var table = GetOrCreateWeakMapTable(target, /*create*/ false);
                    return table !== undefined ? delete table[this._key] : false;
                };
                WeakMap.prototype.clear = function () {
                    // NOTE: not a real clear, just makes the previous data unreachable
                    this._key = CreateUniqueKey();
                };
                return WeakMap;
            }());
            function CreateUniqueKey() {
                var key;
                do
                    key = "@@WeakMap@@" + CreateUUID();
                while (HashMap.has(keys, key));
                keys[key] = true;
                return key;
            }
            function GetOrCreateWeakMapTable(target, create) {
                if (!hasOwn.call(target, rootKey)) {
                    if (!create)
                        return undefined;
                    Object.defineProperty(target, rootKey, { value: HashMap.create() });
                }
                return target[rootKey];
            }
            function FillRandomBytes(buffer, size) {
                for (var i = 0; i < size; ++i)
                    buffer[i] = Math.random() * 0xff | 0;
                return buffer;
            }
            function GenRandomBytes(size) {
                if (typeof Uint8Array === "function") {
                    if (typeof crypto !== "undefined")
                        return crypto.getRandomValues(new Uint8Array(size));
                    if (typeof msCrypto !== "undefined")
                        return msCrypto.getRandomValues(new Uint8Array(size));
                    return FillRandomBytes(new Uint8Array(size), size);
                }
                return FillRandomBytes(new Array(size), size);
            }
            function CreateUUID() {
                var data = GenRandomBytes(UUID_SIZE);
                // mark as random - RFC 4122 ¬ß 4.4
                data[6] = data[6] & 0x4f | 0x40;
                data[8] = data[8] & 0xbf | 0x80;
                var result = "";
                for (var offset = 0; offset < UUID_SIZE; ++offset) {
                    var byte = data[offset];
                    if (offset === 4 || offset === 6 || offset === 8)
                        result += "-";
                    if (byte < 16)
                        result += "0";
                    result += byte.toString(16).toLowerCase();
                }
                return result;
            }
        }
        // uses a heuristic used by v8 and chakra to force an object into dictionary mode.
        function MakeDictionary(obj) {
            obj.__ = undefined;
            delete obj.__;
            return obj;
        }
    });
})(Reflect || (Reflect = {}));


/***/ }),

/***/ 7391:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// A library of seedable RNGs implemented in Javascript.
//
// Usage:
//
// var seedrandom = require('seedrandom');
// var random = seedrandom(1); // or any seed.
// var x = random();       // 0 <= x < 1.  Every bit is random.
// var x = random.quick(); // 0 <= x < 1.  32 bits of randomness.

// alea, a 53-bit multiply-with-carry generator by Johannes Baag√∏e.
// Period: ~2^116
// Reported to pass all BigCrush tests.
var alea = __webpack_require__(7180);

// xor128, a pure xor-shift generator by George Marsaglia.
// Period: 2^128-1.
// Reported to fail: MatrixRank and LinearComp.
var xor128 = __webpack_require__(3181);

// xorwow, George Marsaglia's 160-bit xor-shift combined plus weyl.
// Period: 2^192-2^32
// Reported to fail: CollisionOver, SimpPoker, and LinearComp.
var xorwow = __webpack_require__(3031);

// xorshift7, by Fran√ßois Panneton and Pierre L'ecuyer, takes
// a different approach: it adds robustness by allowing more shifts
// than Marsaglia's original three.  It is a 7-shift generator
// with 256 bits, that passes BigCrush with no systmatic failures.
// Period 2^256-1.
// No systematic BigCrush failures reported.
var xorshift7 = __webpack_require__(9067);

// xor4096, by Richard Brent, is a 4096-bit xor-shift with a
// very long period that also adds a Weyl generator. It also passes
// BigCrush with no systematic failures.  Its long period may
// be useful if you have many generators and need to avoid
// collisions.
// Period: 2^4128-2^32.
// No systematic BigCrush failures reported.
var xor4096 = __webpack_require__(6833);

// Tyche-i, by Samuel Neves and Filipe Araujo, is a bit-shifting random
// number generator derived from ChaCha, a modern stream cipher.
// https://eden.dei.uc.pt/~sneves/pubs/2011-snfa2.pdf
// Period: ~2^127
// No systematic BigCrush failures reported.
var tychei = __webpack_require__(3717);

// The original ARC4-based prng included in this library.
// Period: ~2^1600
var sr = __webpack_require__(4801);

sr.alea = alea;
sr.xor128 = xor128;
sr.xorwow = xorwow;
sr.xorshift7 = xorshift7;
sr.xor4096 = xor4096;
sr.tychei = tychei;

module.exports = sr;


/***/ }),

/***/ 7180:
/***/ (function(module, exports, __webpack_require__) {

/* module decorator */ module = __webpack_require__.nmd(module);
var __WEBPACK_AMD_DEFINE_RESULT__;// A port of an algorithm by Johannes Baag√∏e <baagoe@baagoe.com>, 2010
// http://baagoe.com/en/RandomMusings/javascript/
// https://github.com/nquinlan/better-random-numbers-for-javascript-mirror
// Original work is under MIT license -

// Copyright (C) 2010 by Johannes Baag√∏e <baagoe@baagoe.org>
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.



(function(global, module, define) {

function Alea(seed) {
  var me = this, mash = Mash();

  me.next = function() {
    var t = 2091639 * me.s0 + me.c * 2.3283064365386963e-10; // 2^-32
    me.s0 = me.s1;
    me.s1 = me.s2;
    return me.s2 = t - (me.c = t | 0);
  };

  // Apply the seeding algorithm from Baagoe.
  me.c = 1;
  me.s0 = mash(' ');
  me.s1 = mash(' ');
  me.s2 = mash(' ');
  me.s0 -= mash(seed);
  if (me.s0 < 0) { me.s0 += 1; }
  me.s1 -= mash(seed);
  if (me.s1 < 0) { me.s1 += 1; }
  me.s2 -= mash(seed);
  if (me.s2 < 0) { me.s2 += 1; }
  mash = null;
}

function copy(f, t) {
  t.c = f.c;
  t.s0 = f.s0;
  t.s1 = f.s1;
  t.s2 = f.s2;
  return t;
}

function impl(seed, opts) {
  var xg = new Alea(seed),
      state = opts && opts.state,
      prng = xg.next;
  prng.int32 = function() { return (xg.next() * 0x100000000) | 0; }
  prng.double = function() {
    return prng() + (prng() * 0x200000 | 0) * 1.1102230246251565e-16; // 2^-53
  };
  prng.quick = prng;
  if (state) {
    if (typeof(state) == 'object') copy(state, xg);
    prng.state = function() { return copy(xg, {}); }
  }
  return prng;
}

function Mash() {
  var n = 0xefc8249d;

  var mash = function(data) {
    data = String(data);
    for (var i = 0; i < data.length; i++) {
      n += data.charCodeAt(i);
      var h = 0.02519603282416938 * n;
      n = h >>> 0;
      h -= n;
      h *= n;
      n = h >>> 0;
      h -= n;
      n += h * 0x100000000; // 2^32
    }
    return (n >>> 0) * 2.3283064365386963e-10; // 2^-32
  };

  return mash;
}


if (module && module.exports) {
  module.exports = impl;
} else if (__webpack_require__.amdD && __webpack_require__.amdO) {
  !(__WEBPACK_AMD_DEFINE_RESULT__ = (function() { return impl; }).call(exports, __webpack_require__, exports, module),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
} else {
  this.alea = impl;
}

})(
  this,
   true && module,    // present in node.js
  __webpack_require__.amdD   // present with an AMD loader
);




/***/ }),

/***/ 3717:
/***/ (function(module, exports, __webpack_require__) {

/* module decorator */ module = __webpack_require__.nmd(module);
var __WEBPACK_AMD_DEFINE_RESULT__;// A Javascript implementaion of the "Tyche-i" prng algorithm by
// Samuel Neves and Filipe Araujo.
// See https://eden.dei.uc.pt/~sneves/pubs/2011-snfa2.pdf

(function(global, module, define) {

function XorGen(seed) {
  var me = this, strseed = '';

  // Set up generator function.
  me.next = function() {
    var b = me.b, c = me.c, d = me.d, a = me.a;
    b = (b << 25) ^ (b >>> 7) ^ c;
    c = (c - d) | 0;
    d = (d << 24) ^ (d >>> 8) ^ a;
    a = (a - b) | 0;
    me.b = b = (b << 20) ^ (b >>> 12) ^ c;
    me.c = c = (c - d) | 0;
    me.d = (d << 16) ^ (c >>> 16) ^ a;
    return me.a = (a - b) | 0;
  };

  /* The following is non-inverted tyche, which has better internal
   * bit diffusion, but which is about 25% slower than tyche-i in JS.
  me.next = function() {
    var a = me.a, b = me.b, c = me.c, d = me.d;
    a = (me.a + me.b | 0) >>> 0;
    d = me.d ^ a; d = d << 16 ^ d >>> 16;
    c = me.c + d | 0;
    b = me.b ^ c; b = b << 12 ^ d >>> 20;
    me.a = a = a + b | 0;
    d = d ^ a; me.d = d = d << 8 ^ d >>> 24;
    me.c = c = c + d | 0;
    b = b ^ c;
    return me.b = (b << 7 ^ b >>> 25);
  }
  */

  me.a = 0;
  me.b = 0;
  me.c = 2654435769 | 0;
  me.d = 1367130551;

  if (seed === Math.floor(seed)) {
    // Integer seed.
    me.a = (seed / 0x100000000) | 0;
    me.b = seed | 0;
  } else {
    // String seed.
    strseed += seed;
  }

  // Mix in string seed, then discard an initial batch of 64 values.
  for (var k = 0; k < strseed.length + 20; k++) {
    me.b ^= strseed.charCodeAt(k) | 0;
    me.next();
  }
}

function copy(f, t) {
  t.a = f.a;
  t.b = f.b;
  t.c = f.c;
  t.d = f.d;
  return t;
};

function impl(seed, opts) {
  var xg = new XorGen(seed),
      state = opts && opts.state,
      prng = function() { return (xg.next() >>> 0) / 0x100000000; };
  prng.double = function() {
    do {
      var top = xg.next() >>> 11,
          bot = (xg.next() >>> 0) / 0x100000000,
          result = (top + bot) / (1 << 21);
    } while (result === 0);
    return result;
  };
  prng.int32 = xg.next;
  prng.quick = prng;
  if (state) {
    if (typeof(state) == 'object') copy(state, xg);
    prng.state = function() { return copy(xg, {}); }
  }
  return prng;
}

if (module && module.exports) {
  module.exports = impl;
} else if (__webpack_require__.amdD && __webpack_require__.amdO) {
  !(__WEBPACK_AMD_DEFINE_RESULT__ = (function() { return impl; }).call(exports, __webpack_require__, exports, module),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
} else {
  this.tychei = impl;
}

})(
  this,
   true && module,    // present in node.js
  __webpack_require__.amdD   // present with an AMD loader
);




/***/ }),

/***/ 3181:
/***/ (function(module, exports, __webpack_require__) {

/* module decorator */ module = __webpack_require__.nmd(module);
var __WEBPACK_AMD_DEFINE_RESULT__;// A Javascript implementaion of the "xor128" prng algorithm by
// George Marsaglia.  See http://www.jstatsoft.org/v08/i14/paper

(function(global, module, define) {

function XorGen(seed) {
  var me = this, strseed = '';

  me.x = 0;
  me.y = 0;
  me.z = 0;
  me.w = 0;

  // Set up generator function.
  me.next = function() {
    var t = me.x ^ (me.x << 11);
    me.x = me.y;
    me.y = me.z;
    me.z = me.w;
    return me.w ^= (me.w >>> 19) ^ t ^ (t >>> 8);
  };

  if (seed === (seed | 0)) {
    // Integer seed.
    me.x = seed;
  } else {
    // String seed.
    strseed += seed;
  }

  // Mix in string seed, then discard an initial batch of 64 values.
  for (var k = 0; k < strseed.length + 64; k++) {
    me.x ^= strseed.charCodeAt(k) | 0;
    me.next();
  }
}

function copy(f, t) {
  t.x = f.x;
  t.y = f.y;
  t.z = f.z;
  t.w = f.w;
  return t;
}

function impl(seed, opts) {
  var xg = new XorGen(seed),
      state = opts && opts.state,
      prng = function() { return (xg.next() >>> 0) / 0x100000000; };
  prng.double = function() {
    do {
      var top = xg.next() >>> 11,
          bot = (xg.next() >>> 0) / 0x100000000,
          result = (top + bot) / (1 << 21);
    } while (result === 0);
    return result;
  };
  prng.int32 = xg.next;
  prng.quick = prng;
  if (state) {
    if (typeof(state) == 'object') copy(state, xg);
    prng.state = function() { return copy(xg, {}); }
  }
  return prng;
}

if (module && module.exports) {
  module.exports = impl;
} else if (__webpack_require__.amdD && __webpack_require__.amdO) {
  !(__WEBPACK_AMD_DEFINE_RESULT__ = (function() { return impl; }).call(exports, __webpack_require__, exports, module),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
} else {
  this.xor128 = impl;
}

})(
  this,
   true && module,    // present in node.js
  __webpack_require__.amdD   // present with an AMD loader
);




/***/ }),

/***/ 6833:
/***/ (function(module, exports, __webpack_require__) {

/* module decorator */ module = __webpack_require__.nmd(module);
var __WEBPACK_AMD_DEFINE_RESULT__;// A Javascript implementaion of Richard Brent's Xorgens xor4096 algorithm.
//
// This fast non-cryptographic random number generator is designed for
// use in Monte-Carlo algorithms. It combines a long-period xorshift
// generator with a Weyl generator, and it passes all common batteries
// of stasticial tests for randomness while consuming only a few nanoseconds
// for each prng generated.  For background on the generator, see Brent's
// paper: "Some long-period random number generators using shifts and xors."
// http://arxiv.org/pdf/1004.3115v1.pdf
//
// Usage:
//
// var xor4096 = require('xor4096');
// random = xor4096(1);                        // Seed with int32 or string.
// assert.equal(random(), 0.1520436450538547); // (0, 1) range, 53 bits.
// assert.equal(random.int32(), 1806534897);   // signed int32, 32 bits.
//
// For nonzero numeric keys, this impelementation provides a sequence
// identical to that by Brent's xorgens 3 implementaion in C.  This
// implementation also provides for initalizing the generator with
// string seeds, or for saving and restoring the state of the generator.
//
// On Chrome, this prng benchmarks about 2.1 times slower than
// Javascript's built-in Math.random().

(function(global, module, define) {

function XorGen(seed) {
  var me = this;

  // Set up generator function.
  me.next = function() {
    var w = me.w,
        X = me.X, i = me.i, t, v;
    // Update Weyl generator.
    me.w = w = (w + 0x61c88647) | 0;
    // Update xor generator.
    v = X[(i + 34) & 127];
    t = X[i = ((i + 1) & 127)];
    v ^= v << 13;
    t ^= t << 17;
    v ^= v >>> 15;
    t ^= t >>> 12;
    // Update Xor generator array state.
    v = X[i] = v ^ t;
    me.i = i;
    // Result is the combination.
    return (v + (w ^ (w >>> 16))) | 0;
  };

  function init(me, seed) {
    var t, v, i, j, w, X = [], limit = 128;
    if (seed === (seed | 0)) {
      // Numeric seeds initialize v, which is used to generates X.
      v = seed;
      seed = null;
    } else {
      // String seeds are mixed into v and X one character at a time.
      seed = seed + '\0';
      v = 0;
      limit = Math.max(limit, seed.length);
    }
    // Initialize circular array and weyl value.
    for (i = 0, j = -32; j < limit; ++j) {
      // Put the unicode characters into the array, and shuffle them.
      if (seed) v ^= seed.charCodeAt((j + 32) % seed.length);
      // After 32 shuffles, take v as the starting w value.
      if (j === 0) w = v;
      v ^= v << 10;
      v ^= v >>> 15;
      v ^= v << 4;
      v ^= v >>> 13;
      if (j >= 0) {
        w = (w + 0x61c88647) | 0;     // Weyl.
        t = (X[j & 127] ^= (v + w));  // Combine xor and weyl to init array.
        i = (0 == t) ? i + 1 : 0;     // Count zeroes.
      }
    }
    // We have detected all zeroes; make the key nonzero.
    if (i >= 128) {
      X[(seed && seed.length || 0) & 127] = -1;
    }
    // Run the generator 512 times to further mix the state before using it.
    // Factoring this as a function slows the main generator, so it is just
    // unrolled here.  The weyl generator is not advanced while warming up.
    i = 127;
    for (j = 4 * 128; j > 0; --j) {
      v = X[(i + 34) & 127];
      t = X[i = ((i + 1) & 127)];
      v ^= v << 13;
      t ^= t << 17;
      v ^= v >>> 15;
      t ^= t >>> 12;
      X[i] = v ^ t;
    }
    // Storing state as object members is faster than using closure variables.
    me.w = w;
    me.X = X;
    me.i = i;
  }

  init(me, seed);
}

function copy(f, t) {
  t.i = f.i;
  t.w = f.w;
  t.X = f.X.slice();
  return t;
};

function impl(seed, opts) {
  if (seed == null) seed = +(new Date);
  var xg = new XorGen(seed),
      state = opts && opts.state,
      prng = function() { return (xg.next() >>> 0) / 0x100000000; };
  prng.double = function() {
    do {
      var top = xg.next() >>> 11,
          bot = (xg.next() >>> 0) / 0x100000000,
          result = (top + bot) / (1 << 21);
    } while (result === 0);
    return result;
  };
  prng.int32 = xg.next;
  prng.quick = prng;
  if (state) {
    if (state.X) copy(state, xg);
    prng.state = function() { return copy(xg, {}); }
  }
  return prng;
}

if (module && module.exports) {
  module.exports = impl;
} else if (__webpack_require__.amdD && __webpack_require__.amdO) {
  !(__WEBPACK_AMD_DEFINE_RESULT__ = (function() { return impl; }).call(exports, __webpack_require__, exports, module),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
} else {
  this.xor4096 = impl;
}

})(
  this,                                     // window object or global
   true && module,    // present in node.js
  __webpack_require__.amdD   // present with an AMD loader
);


/***/ }),

/***/ 9067:
/***/ (function(module, exports, __webpack_require__) {

/* module decorator */ module = __webpack_require__.nmd(module);
var __WEBPACK_AMD_DEFINE_RESULT__;// A Javascript implementaion of the "xorshift7" algorithm by
// Fran√ßois Panneton and Pierre L'ecuyer:
// "On the Xorgshift Random Number Generators"
// http://saluc.engr.uconn.edu/refs/crypto/rng/panneton05onthexorshift.pdf

(function(global, module, define) {

function XorGen(seed) {
  var me = this;

  // Set up generator function.
  me.next = function() {
    // Update xor generator.
    var X = me.x, i = me.i, t, v, w;
    t = X[i]; t ^= (t >>> 7); v = t ^ (t << 24);
    t = X[(i + 1) & 7]; v ^= t ^ (t >>> 10);
    t = X[(i + 3) & 7]; v ^= t ^ (t >>> 3);
    t = X[(i + 4) & 7]; v ^= t ^ (t << 7);
    t = X[(i + 7) & 7]; t = t ^ (t << 13); v ^= t ^ (t << 9);
    X[i] = v;
    me.i = (i + 1) & 7;
    return v;
  };

  function init(me, seed) {
    var j, w, X = [];

    if (seed === (seed | 0)) {
      // Seed state array using a 32-bit integer.
      w = X[0] = seed;
    } else {
      // Seed state using a string.
      seed = '' + seed;
      for (j = 0; j < seed.length; ++j) {
        X[j & 7] = (X[j & 7] << 15) ^
            (seed.charCodeAt(j) + X[(j + 1) & 7] << 13);
      }
    }
    // Enforce an array length of 8, not all zeroes.
    while (X.length < 8) X.push(0);
    for (j = 0; j < 8 && X[j] === 0; ++j);
    if (j == 8) w = X[7] = -1; else w = X[j];

    me.x = X;
    me.i = 0;

    // Discard an initial 256 values.
    for (j = 256; j > 0; --j) {
      me.next();
    }
  }

  init(me, seed);
}

function copy(f, t) {
  t.x = f.x.slice();
  t.i = f.i;
  return t;
}

function impl(seed, opts) {
  if (seed == null) seed = +(new Date);
  var xg = new XorGen(seed),
      state = opts && opts.state,
      prng = function() { return (xg.next() >>> 0) / 0x100000000; };
  prng.double = function() {
    do {
      var top = xg.next() >>> 11,
          bot = (xg.next() >>> 0) / 0x100000000,
          result = (top + bot) / (1 << 21);
    } while (result === 0);
    return result;
  };
  prng.int32 = xg.next;
  prng.quick = prng;
  if (state) {
    if (state.x) copy(state, xg);
    prng.state = function() { return copy(xg, {}); }
  }
  return prng;
}

if (module && module.exports) {
  module.exports = impl;
} else if (__webpack_require__.amdD && __webpack_require__.amdO) {
  !(__WEBPACK_AMD_DEFINE_RESULT__ = (function() { return impl; }).call(exports, __webpack_require__, exports, module),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
} else {
  this.xorshift7 = impl;
}

})(
  this,
   true && module,    // present in node.js
  __webpack_require__.amdD   // present with an AMD loader
);



/***/ }),

/***/ 3031:
/***/ (function(module, exports, __webpack_require__) {

/* module decorator */ module = __webpack_require__.nmd(module);
var __WEBPACK_AMD_DEFINE_RESULT__;// A Javascript implementaion of the "xorwow" prng algorithm by
// George Marsaglia.  See http://www.jstatsoft.org/v08/i14/paper

(function(global, module, define) {

function XorGen(seed) {
  var me = this, strseed = '';

  // Set up generator function.
  me.next = function() {
    var t = (me.x ^ (me.x >>> 2));
    me.x = me.y; me.y = me.z; me.z = me.w; me.w = me.v;
    return (me.d = (me.d + 362437 | 0)) +
       (me.v = (me.v ^ (me.v << 4)) ^ (t ^ (t << 1))) | 0;
  };

  me.x = 0;
  me.y = 0;
  me.z = 0;
  me.w = 0;
  me.v = 0;

  if (seed === (seed | 0)) {
    // Integer seed.
    me.x = seed;
  } else {
    // String seed.
    strseed += seed;
  }

  // Mix in string seed, then discard an initial batch of 64 values.
  for (var k = 0; k < strseed.length + 64; k++) {
    me.x ^= strseed.charCodeAt(k) | 0;
    if (k == strseed.length) {
      me.d = me.x << 10 ^ me.x >>> 4;
    }
    me.next();
  }
}

function copy(f, t) {
  t.x = f.x;
  t.y = f.y;
  t.z = f.z;
  t.w = f.w;
  t.v = f.v;
  t.d = f.d;
  return t;
}

function impl(seed, opts) {
  var xg = new XorGen(seed),
      state = opts && opts.state,
      prng = function() { return (xg.next() >>> 0) / 0x100000000; };
  prng.double = function() {
    do {
      var top = xg.next() >>> 11,
          bot = (xg.next() >>> 0) / 0x100000000,
          result = (top + bot) / (1 << 21);
    } while (result === 0);
    return result;
  };
  prng.int32 = xg.next;
  prng.quick = prng;
  if (state) {
    if (typeof(state) == 'object') copy(state, xg);
    prng.state = function() { return copy(xg, {}); }
  }
  return prng;
}

if (module && module.exports) {
  module.exports = impl;
} else if (__webpack_require__.amdD && __webpack_require__.amdO) {
  !(__WEBPACK_AMD_DEFINE_RESULT__ = (function() { return impl; }).call(exports, __webpack_require__, exports, module),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
} else {
  this.xorwow = impl;
}

})(
  this,
   true && module,    // present in node.js
  __webpack_require__.amdD   // present with an AMD loader
);




/***/ }),

/***/ 4801:
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_RESULT__;/*
Copyright 2019 David Bau.

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

*/

(function (global, pool, math) {
//
// The following constants are related to IEEE 754 limits.
//

var width = 256,        // each RC4 output is 0 <= x < 256
    chunks = 6,         // at least six RC4 outputs for each double
    digits = 52,        // there are 52 significant digits in a double
    rngname = 'random', // rngname: name for Math.random and Math.seedrandom
    startdenom = math.pow(width, chunks),
    significance = math.pow(2, digits),
    overflow = significance * 2,
    mask = width - 1,
    nodecrypto;         // node.js crypto module, initialized at the bottom.

//
// seedrandom()
// This is the seedrandom function described above.
//
function seedrandom(seed, options, callback) {
  var key = [];
  options = (options == true) ? { entropy: true } : (options || {});

  // Flatten the seed string or build one from local entropy if needed.
  var shortseed = mixkey(flatten(
    options.entropy ? [seed, tostring(pool)] :
    (seed == null) ? autoseed() : seed, 3), key);

  // Use the seed to initialize an ARC4 generator.
  var arc4 = new ARC4(key);

  // This function returns a random double in [0, 1) that contains
  // randomness in every bit of the mantissa of the IEEE 754 value.
  var prng = function() {
    var n = arc4.g(chunks),             // Start with a numerator n < 2 ^ 48
        d = startdenom,                 //   and denominator d = 2 ^ 48.
        x = 0;                          //   and no 'extra last byte'.
    while (n < significance) {          // Fill up all significant digits by
      n = (n + x) * width;              //   shifting numerator and
      d *= width;                       //   denominator and generating a
      x = arc4.g(1);                    //   new least-significant-byte.
    }
    while (n >= overflow) {             // To avoid rounding up, before adding
      n /= 2;                           //   last byte, shift everything
      d /= 2;                           //   right using integer math until
      x >>>= 1;                         //   we have exactly the desired bits.
    }
    return (n + x) / d;                 // Form the number within [0, 1).
  };

  prng.int32 = function() { return arc4.g(4) | 0; }
  prng.quick = function() { return arc4.g(4) / 0x100000000; }
  prng.double = prng;

  // Mix the randomness into accumulated entropy.
  mixkey(tostring(arc4.S), pool);

  // Calling convention: what to return as a function of prng, seed, is_math.
  return (options.pass || callback ||
      function(prng, seed, is_math_call, state) {
        if (state) {
          // Load the arc4 state from the given state if it has an S array.
          if (state.S) { copy(state, arc4); }
          // Only provide the .state method if requested via options.state.
          prng.state = function() { return copy(arc4, {}); }
        }

        // If called as a method of Math (Math.seedrandom()), mutate
        // Math.random because that is how seedrandom.js has worked since v1.0.
        if (is_math_call) { math[rngname] = prng; return seed; }

        // Otherwise, it is a newer calling convention, so return the
        // prng directly.
        else return prng;
      })(
  prng,
  shortseed,
  'global' in options ? options.global : (this == math),
  options.state);
}

//
// ARC4
//
// An ARC4 implementation.  The constructor takes a key in the form of
// an array of at most (width) integers that should be 0 <= x < (width).
//
// The g(count) method returns a pseudorandom integer that concatenates
// the next (count) outputs from ARC4.  Its return value is a number x
// that is in the range 0 <= x < (width ^ count).
//
function ARC4(key) {
  var t, keylen = key.length,
      me = this, i = 0, j = me.i = me.j = 0, s = me.S = [];

  // The empty key [] is treated as [0].
  if (!keylen) { key = [keylen++]; }

  // Set up S using the standard key scheduling algorithm.
  while (i < width) {
    s[i] = i++;
  }
  for (i = 0; i < width; i++) {
    s[i] = s[j = mask & (j + key[i % keylen] + (t = s[i]))];
    s[j] = t;
  }

  // The "g" method returns the next (count) outputs as one number.
  (me.g = function(count) {
    // Using instance members instead of closure state nearly doubles speed.
    var t, r = 0,
        i = me.i, j = me.j, s = me.S;
    while (count--) {
      t = s[i = mask & (i + 1)];
      r = r * width + s[mask & ((s[i] = s[j = mask & (j + t)]) + (s[j] = t))];
    }
    me.i = i; me.j = j;
    return r;
    // For robust unpredictability, the function call below automatically
    // discards an initial batch of values.  This is called RC4-drop[256].
    // See http://google.com/search?q=rsa+fluhrer+response&btnI
  })(width);
}

//
// copy()
// Copies internal state of ARC4 to or from a plain object.
//
function copy(f, t) {
  t.i = f.i;
  t.j = f.j;
  t.S = f.S.slice();
  return t;
};

//
// flatten()
// Converts an object tree to nested arrays of strings.
//
function flatten(obj, depth) {
  var result = [], typ = (typeof obj), prop;
  if (depth && typ == 'object') {
    for (prop in obj) {
      try { result.push(flatten(obj[prop], depth - 1)); } catch (e) {}
    }
  }
  return (result.length ? result : typ == 'string' ? obj : obj + '\0');
}

//
// mixkey()
// Mixes a string seed into a key that is an array of integers, and
// returns a shortened string seed that is equivalent to the result key.
//
function mixkey(seed, key) {
  var stringseed = seed + '', smear, j = 0;
  while (j < stringseed.length) {
    key[mask & j] =
      mask & ((smear ^= key[mask & j] * 19) + stringseed.charCodeAt(j++));
  }
  return tostring(key);
}

//
// autoseed()
// Returns an object for autoseeding, using window.crypto and Node crypto
// module if available.
//
function autoseed() {
  try {
    var out;
    if (nodecrypto && (out = nodecrypto.randomBytes)) {
      // The use of 'out' to remember randomBytes makes tight minified code.
      out = out(width);
    } else {
      out = new Uint8Array(width);
      (global.crypto || global.msCrypto).getRandomValues(out);
    }
    return tostring(out);
  } catch (e) {
    var browser = global.navigator,
        plugins = browser && browser.plugins;
    return [+new Date, global, plugins, global.screen, tostring(pool)];
  }
}

//
// tostring()
// Converts an array of charcodes to a string
//
function tostring(a) {
  return String.fromCharCode.apply(0, a);
}

//
// When seedrandom.js is loaded, we immediately mix a few bits
// from the built-in RNG into the entropy pool.  Because we do
// not want to interfere with deterministic PRNG state later,
// seedrandom will not call math.random on its own again after
// initialization.
//
mixkey(math.random(), pool);

//
// Nodejs and AMD support: export the implementation as a module using
// either convention.
//
if ( true && module.exports) {
  module.exports = seedrandom;
  // When in node.js, try using crypto package for autoseeding.
  try {
    nodecrypto = __webpack_require__(6982);
  } catch (ex) {}
} else if (true) {
  !(__WEBPACK_AMD_DEFINE_RESULT__ = (function() { return seedrandom; }).call(exports, __webpack_require__, exports, module),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
} else {}


// End anonymous scope, and pass initial values.
})(
  // global: `self` in browsers (including strict mode and web workers),
  // otherwise `this` in Node and other environments
  (typeof self !== 'undefined') ? self : this,
  [],     // pool: entropy pool starts empty
  Math    // math: package containing random, pow, and seedrandom
);


/***/ }),

/***/ 4057:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var _PendingAccount_account, _UserClientBuilder_instances, _a, _UserClientBuilder_allPending, _UserClientBuilder_pendingOptions, _UserClientBuilder_pendingOperations, _UserClientBuilder_defaultOptions, _UserClientBuilder_rendered, _UserClientBuilder_blocks, _UserClientBuilder_userClient, _UserClientBuilder_defaultAccountOptions_get, _UserClientBuilder_combineAllPendingWithAccountPending, _UserClientBuilder_pushPending, _UserClientBuilder_useOptions, _UserClientBuilder_getMethodAmountFromValue, _UserClientBuilder_getRenderOptionsFromClient, _UserClientBuilder_checkNotZeroAmount;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UserClientBuilder = exports.PendingAccount = void 0;
const lib_1 = __importDefault(__webpack_require__(8568));
const account_1 = __webpack_require__(9415);
const block_1 = __webpack_require__(6158);
const operations_1 = __webpack_require__(2778);
const client_1 = __importDefault(__webpack_require__(3642));
const permissions_1 = __webpack_require__(5860);
const conversion_1 = __webpack_require__(2360);
const helper_1 = __webpack_require__(3208);
const certificate_1 = __webpack_require__(5661);
class PendingAccount {
    constructor() {
        _PendingAccount_account.set(this, void 0);
    }
    static GetValue(data) {
        if (account_1.Account.isInstance(data)) {
            return (data);
        }
        return (data.account);
    }
    set account(account) {
        if (__classPrivateFieldGet(this, _PendingAccount_account, "f")) {
            throw (new Error('Cannot set account on PendingAccount more than once'));
        }
        __classPrivateFieldSet(this, _PendingAccount_account, account, "f");
    }
    get account() {
        if (!__classPrivateFieldGet(this, _PendingAccount_account, "f")) {
            throw (new Error('Cannot get undefined account on PendingAccount class'));
        }
        return (__classPrivateFieldGet(this, _PendingAccount_account, "f"));
    }
    toJSON() {
        return (this.account);
    }
}
exports.PendingAccount = PendingAccount;
_PendingAccount_account = new WeakMap();
PendingAccount.IsInstance = (0, helper_1.checkableGenerator)(PendingAccount);
class UserClientBuilder {
    static async FromPendingJSON(options, getPrivateKey, multiAllPending) {
        const allPending = multiAllPending.flatMap(pending => pending);
        const needToGetPrivateKeys = new account_1.Account.Set();
        for (const { nonRendered } of multiAllPending) {
            for (const [accounts] of nonRendered) {
                needToGetPrivateKeys.add(account_1.Account.fromPublicKeyString(accounts.signer));
            }
        }
        const gotPrivateKeys = {};
        const getPrivateKeyPromises = [];
        for (const needToGetKey of needToGetPrivateKeys) {
            const needToGetKeyKey = needToGetKey.publicKeyAndTypeString;
            getPrivateKeyPromises.push((async () => {
                gotPrivateKeys[needToGetKeyKey] = await getPrivateKey(account_1.Account.toAccount(needToGetKeyKey).assertAccount());
                if (!gotPrivateKeys[needToGetKeyKey].hasPrivateKey) {
                    throw (new client_1.default('CLIENT_BUILDER_REQUIRES_PRIVATE_KEY', 'getPrivateKey() Does not return an account with a private key in FromPendingJSON()'));
                }
            })());
        }
        await Promise.all(getPrivateKeyPromises);
        const receivedBlocks = [];
        const mappedPending = [];
        for (const { renderedBlocks, nonRendered } of allPending) {
            for (const blockString of renderedBlocks) {
                receivedBlocks.push(new block_1.Block(Buffer.from(blockString, 'base64')));
            }
            for (const [accounts, operations] of nonRendered) {
                const account = account_1.Account.toAccount(accounts.account);
                const signerPubKey = account_1.Account.fromPublicKeyString(accounts.signer).publicKeyAndTypeString;
                const signer = gotPrivateKeys[signerPubKey] ?? account_1.Account.toAccount(accounts.signer);
                const pendingOperations = {};
                if (operations.setRep !== undefined) {
                    pendingOperations.setRep = account_1.Account.toAccount(operations.setRep);
                }
                if (operations.info !== undefined) {
                    const newInfo = {
                        name: operations.info.name,
                        description: operations.info.description,
                        metadata: operations.info.metadata
                    };
                    if (operations.info.defaultPermission !== undefined) {
                        const [base, external] = operations.info.defaultPermission.map(function (intString) {
                            return (BigInt(intString));
                        });
                        newInfo.defaultPermission = new permissions_1.Permissions(base, external);
                    }
                    pendingOperations.info = newInfo;
                }
                if (operations.tokenSupply !== undefined) {
                    pendingOperations.tokenSupply = (0, conversion_1.parseHexBigIntString)(operations.tokenSupply);
                }
                if (operations.createIdentifiers !== undefined) {
                    pendingOperations.createIdentifiers = operations.createIdentifiers.map(function ({ type }) {
                        return ({ type });
                    });
                }
                if (operations.send !== undefined) {
                    pendingOperations.send = operations.send.map(function ({ otherParty, token, amount, external }) {
                        return ({
                            otherParty: account_1.Account.toAccount(otherParty),
                            token: account_1.Account.toAccount(token),
                            amount: (0, conversion_1.parseHexBigIntString)(amount),
                            external: external
                        });
                    });
                }
                if (operations.receive !== undefined) {
                    pendingOperations.receive = operations.receive.map(function ({ otherParty, token, amount, exactReceive, forward }) {
                        return ({
                            otherParty: account_1.Account.toAccount(otherParty),
                            token: account_1.Account.toAccount(token),
                            amount: (0, conversion_1.parseHexBigIntString)(amount),
                            exactReceive: exactReceive,
                            forward: account_1.Account.toAccount(forward)
                        });
                    });
                }
                if (operations.adminModifyBalance !== undefined) {
                    pendingOperations.adminModifyBalance = operations.adminModifyBalance.map(function ({ isSet, amount, token }) {
                        return ({ isSet, amount: (0, conversion_1.parseHexBigIntString)(amount), token: account_1.Account.toAccount(token) });
                    });
                }
                if (operations.permissionsChanges !== undefined) {
                    pendingOperations.permissionsChanges = {};
                    for (const accountPubKey in operations.permissionsChanges) {
                        pendingOperations.permissionsChanges[accountPubKey] = {};
                        for (const targetPubKey in operations.permissionsChanges[accountPubKey]) {
                            const updateArray = [];
                            for (const { method, permissions } of operations.permissionsChanges[accountPubKey][targetPubKey]) {
                                updateArray.push({ method, permissions: permissions_1.Permissions.FromAcceptedTypes(permissions) });
                            }
                            pendingOperations.permissionsChanges[accountPubKey][targetPubKey] = updateArray;
                        }
                    }
                }
                if (operations.modifyCertificates !== undefined) {
                    pendingOperations.modifyCertificates = [];
                    for (const { method, certificate, intermediateCertificates } of operations.modifyCertificates) {
                        let intermediates = null;
                        if (intermediateCertificates) {
                            intermediates = new certificate_1.CertificateBundle(intermediateCertificates);
                        }
                        pendingOperations.modifyCertificates.push({
                            method: method,
                            certificate: new certificate_1.Certificate(certificate),
                            intermediateCertificates: intermediates
                        });
                    }
                }
                mappedPending.push([{
                        account: account,
                        signer: signer
                    }, pendingOperations]);
            }
        }
        return (new _a(options, { blocks: receivedBlocks }, mappedPending));
    }
    pendingToJSON() {
        const blockStrings = [];
        for (const block of __classPrivateFieldGet(this, _UserClientBuilder_blocks, "f")) {
            blockStrings.push(Buffer.from(block.toBytes()).toString('base64'));
        }
        const updatedPending = __classPrivateFieldGet(_a, _a, "m", _UserClientBuilder_combineAllPendingWithAccountPending).call(_a, __classPrivateFieldGet(this, _UserClientBuilder_allPending, "f"), __classPrivateFieldGet(this, _UserClientBuilder_pendingOperations, "f"), __classPrivateFieldGet(this, _UserClientBuilder_pendingOptions, "f"));
        const toUsePending = [];
        for (const [accountSigner, pendingOperations] of updatedPending ?? __classPrivateFieldGet(this, _UserClientBuilder_allPending, "f")) {
            let modifyCertificates;
            if (pendingOperations.modifyCertificates !== undefined) {
                modifyCertificates = pendingOperations.modifyCertificates.map(function (modifyRequest) {
                    let intermediates = null;
                    if (modifyRequest.intermediateCertificates) {
                        intermediates = modifyRequest.intermediateCertificates.getDERBuffer().toString('base64');
                    }
                    return ({
                        ...modifyRequest,
                        certificate: modifyRequest.certificate.toPEM(),
                        intermediateCertificates: intermediates
                    });
                });
            }
            toUsePending.push([accountSigner, { ...pendingOperations, modifyCertificates }]);
        }
        return ((0, conversion_1.toJSONSerializable)({ renderedBlocks: blockStrings, nonRendered: toUsePending }));
    }
    constructor(options, previousRender, previousPending = []) {
        _UserClientBuilder_instances.add(this);
        _UserClientBuilder_allPending.set(this, void 0);
        _UserClientBuilder_pendingOptions.set(this, void 0);
        _UserClientBuilder_pendingOperations.set(this, {});
        _UserClientBuilder_defaultOptions.set(this, void 0);
        _UserClientBuilder_rendered.set(this, true);
        _UserClientBuilder_blocks.set(this, []);
        _UserClientBuilder_userClient.set(this, void 0);
        if (!options.signer.hasPrivateKey) {
            throw (new client_1.default('CLIENT_BUILDER_REQUIRES_PRIVATE_KEY', 'Client Builder Requires Signer with Private Key'));
        }
        __classPrivateFieldSet(this, _UserClientBuilder_allPending, previousPending, "f");
        __classPrivateFieldSet(this, _UserClientBuilder_defaultOptions, options, "f");
        __classPrivateFieldSet(this, _UserClientBuilder_pendingOptions, __classPrivateFieldGet(this, _UserClientBuilder_instances, "a", _UserClientBuilder_defaultAccountOptions_get), "f");
        if (previousPending.length > 0) {
            __classPrivateFieldSet(this, _UserClientBuilder_rendered, false, "f");
        }
        if (previousRender) {
            __classPrivateFieldGet(this, _UserClientBuilder_blocks, "f").push(...previousRender.blocks);
        }
        __classPrivateFieldSet(this, _UserClientBuilder_userClient, options.userClient, "f");
    }
    get defaultOptions() {
        return (__classPrivateFieldGet(this, _UserClientBuilder_defaultOptions, "f"));
    }
    updateAccounts(accountOptions) {
        const newAccountOptions = {
            account: __classPrivateFieldGet(this, _UserClientBuilder_instances, "a", _UserClientBuilder_defaultAccountOptions_get).account,
            signer: __classPrivateFieldGet(this, _UserClientBuilder_instances, "a", _UserClientBuilder_defaultAccountOptions_get).signer,
            ...accountOptions
        };
        __classPrivateFieldGet(this, _UserClientBuilder_instances, "m", _UserClientBuilder_useOptions).call(this, newAccountOptions);
        __classPrivateFieldGet(this, _UserClientBuilder_defaultOptions, "f").account = newAccountOptions.account;
        __classPrivateFieldGet(this, _UserClientBuilder_defaultOptions, "f").signer = newAccountOptions.signer;
    }
    async clone() {
        const accountsWithPrivateKeys = {};
        const collectedAccounts = [];
        for (const [{ account, signer }] of __classPrivateFieldGet(this, _UserClientBuilder_allPending, "f")) {
            collectedAccounts.push(account, signer);
        }
        collectedAccounts.push(__classPrivateFieldGet(this, _UserClientBuilder_defaultOptions, "f").account, __classPrivateFieldGet(this, _UserClientBuilder_defaultOptions, "f").signer);
        collectedAccounts.push(__classPrivateFieldGet(this, _UserClientBuilder_pendingOptions, "f").account, __classPrivateFieldGet(this, _UserClientBuilder_pendingOptions, "f").signer);
        for (const toCheck of collectedAccounts) {
            if (!toCheck) {
                continue;
            }
            if (!toCheck.isAccount() || !toCheck.hasPrivateKey) {
                continue;
            }
            if (accountsWithPrivateKeys[toCheck.publicKeyAndTypeString] === undefined) {
                accountsWithPrivateKeys[toCheck.publicKeyAndTypeString] = toCheck;
            }
        }
        const getPrivateKey = (async (inputAccount) => {
            if (inputAccount.hasPrivateKey) {
                return (inputAccount);
            }
            const found = accountsWithPrivateKeys[inputAccount.publicKeyAndTypeString];
            if (found) {
                return (found);
            }
            throw (new client_1.default('CLIENT_BUILDER_REQUIRES_PRIVATE_KEY', `Unable to locate private key for ${inputAccount.publicKeyString.toString()}`));
        });
        return (await _a.FromPendingJSON(__classPrivateFieldGet(this, _UserClientBuilder_defaultOptions, "f"), getPrivateKey, [this.pendingToJSON()]));
    }
    async publish(options, client) {
        if (client === undefined) {
            client = __classPrivateFieldGet(this, _UserClientBuilder_userClient, "f");
        }
        if (client === undefined) {
            throw (new client_1.default('CLIENT_BUILDER_USER_CLIENT_REQUIRED', 'UserClient is required to publish blocks'));
        }
        let retval;
        if ('publishBuilder' in client && client.publishBuilder !== undefined) {
            retval = await client.publishBuilder(this);
        }
        else {
            const blocks = await this.computeBlocks(client);
            retval = await client.client.transmit(blocks.blocks, options);
        }
        return (retval);
    }
    async computeFeeBlock(staple, options = {}, renderOptions) {
        __classPrivateFieldGet(this, _UserClientBuilder_instances, "m", _UserClientBuilder_useOptions).call(this, options);
        if (renderOptions === undefined) {
            renderOptions = __classPrivateFieldGet(this, _UserClientBuilder_userClient, "f");
        }
        if (renderOptions === undefined) {
            throw (new client_1.default('CLIENT_BUILDER_USER_CLIENT_REQUIRED', 'UserClient is required to compute blocks'));
        }
        if (!('getPrevious' in renderOptions)) {
            renderOptions = __classPrivateFieldGet(this, _UserClientBuilder_instances, "m", _UserClientBuilder_getRenderOptionsFromClient).call(this, renderOptions);
        }
        const previousByKey = {};
        for (const existing of staple.blocks) {
            const previous = existing.previous.toString();
            const pubKey = existing.account.publicKeyString.get();
            if (!previousByKey[pubKey] || previousByKey[pubKey].toString() === previous) {
                previousByKey[pubKey] = existing.hash.toString();
            }
        }
        const { account, signer } = __classPrivateFieldGet(this, _UserClientBuilder_pendingOptions, "f");
        const accountPubKey = account.publicKeyString.get();
        let previous = previousByKey[accountPubKey];
        if (!previous) {
            previous = await renderOptions.getPrevious(account) ?? block_1.Block.NO_PREVIOUS;
        }
        const { baseToken } = lib_1.default.Account.generateBaseAddresses(renderOptions.network);
        const operations = [];
        for (const vote of staple.votes) {
            if (vote.fee !== undefined) {
                operations.push({
                    type: operations_1.OperationType.SEND,
                    amount: vote.fee.amount,
                    to: vote.fee.payTo ?? vote.issuer,
                    token: vote.fee.token ?? baseToken
                });
            }
        }
        const block = await new block_1.Block.Builder({
            version: 2,
            purpose: block_1.BlockPurpose.FEE,
            account: account,
            signer: signer,
            network: renderOptions.network,
            previous: previous,
            operations: operations
        }).seal();
        return (block);
    }
    async computeBlocks(renderOptions) {
        if (this.rendered) {
            return ({ blocks: this.blocks });
        }
        if (renderOptions === undefined) {
            renderOptions = __classPrivateFieldGet(this, _UserClientBuilder_userClient, "f");
        }
        if (renderOptions === undefined) {
            throw (new client_1.default('CLIENT_BUILDER_USER_CLIENT_REQUIRED', 'UserClient is required to compute blocks'));
        }
        if (!('getPrevious' in renderOptions)) {
            renderOptions = __classPrivateFieldGet(this, _UserClientBuilder_instances, "m", _UserClientBuilder_getRenderOptionsFromClient).call(this, renderOptions);
        }
        __classPrivateFieldGet(this, _UserClientBuilder_instances, "m", _UserClientBuilder_pushPending).call(this);
        const blocks = [...__classPrivateFieldGet(this, _UserClientBuilder_blocks, "f")];
        const previousByKey = {};
        for (const existing of blocks) {
            const previous = existing.previous.toString();
            const pubKey = existing.account.publicKeyString.get();
            if (!previousByKey[pubKey] || previousByKey[pubKey].toString() === previous) {
                previousByKey[pubKey] = existing.hash.toString();
            }
        }
        for (const [{ account, signer }, pending] of __classPrivateFieldGet(this, _UserClientBuilder_allPending, "f")) {
            const operations = [];
            const accountPubKey = account.publicKeyString.get();
            let previous = previousByKey[accountPubKey];
            if (!previous) {
                previous = await renderOptions.getPrevious(account) ?? block_1.Block.NO_PREVIOUS;
            }
            for (const { type, toResolve } of (pending.createIdentifiers ?? [])) {
                const createdAddress = account.generateIdentifier(type, previous, operations.length);
                if (PendingAccount.IsInstance(toResolve)) {
                    toResolve.account = createdAddress;
                }
                operations.push({
                    type: block_1.Block.OperationType.CREATE_IDENTIFIER,
                    identifier: createdAddress
                });
            }
            const allSends = {};
            for (const { otherParty, token, amount, external } of pending.send ?? []) {
                if (amount === 0n) {
                    continue;
                }
                const otherPartyPubKey = PendingAccount.GetValue(otherParty).publicKeyString.get();
                const tokenPubKey = PendingAccount.GetValue(token).publicKeyString.get();
                // Create keys if they do not exist on allSends and allReceives
                allSends[otherPartyPubKey] = { ...allSends[otherPartyPubKey] };
                if (!allSends[otherPartyPubKey][tokenPubKey]) {
                    allSends[otherPartyPubKey][tokenPubKey] = 0n;
                }
                if (!external) {
                    allSends[otherPartyPubKey][tokenPubKey] += amount;
                }
                else {
                    // If an amount has an external value, do not aggregate it
                    operations.push({
                        token: PendingAccount.GetValue(token),
                        amount: amount,
                        type: block_1.Block.OperationType.SEND,
                        external: external,
                        to: otherPartyPubKey
                    });
                }
            }
            const receiveOperations = [];
            for (const { otherParty, token, amount, exactReceive, forward } of pending.receive ?? []) {
                if (amount === 0n) {
                    continue;
                }
                let forwardValue;
                if (forward) {
                    forwardValue = PendingAccount.GetValue(forward);
                }
                receiveOperations.push({
                    type: block_1.Block.OperationType.RECEIVE,
                    from: PendingAccount.GetValue(otherParty),
                    forward: forwardValue,
                    exact: exactReceive,
                    amount: amount,
                    token: PendingAccount.GetValue(token)
                });
            }
            for (const otherParty in allSends) {
                for (const token in allSends[otherParty]) {
                    const amount = allSends[otherParty][token];
                    if (amount === 0n) {
                        // Skip zero-sum sends
                        continue;
                    }
                    operations.push({
                        token: account_1.Account.toAccount(token).assertKeyType(account_1.AccountKeyAlgorithm.TOKEN),
                        amount: amount,
                        type: block_1.Block.OperationType.SEND,
                        to: otherParty
                    });
                }
            }
            operations.push(...receiveOperations);
            if (pending.info) {
                operations.push({
                    type: block_1.Block.OperationType.SET_INFO,
                    name: pending.info.name,
                    description: pending.info.description,
                    metadata: pending.info.metadata,
                    defaultPermission: pending.info.defaultPermission
                });
            }
            if (pending.setRep) {
                operations.push({
                    type: block_1.Block.OperationType.SET_REP,
                    to: pending.setRep
                });
            }
            if (pending.tokenSupply) {
                const { method, amount } = __classPrivateFieldGet(_a, _a, "m", _UserClientBuilder_getMethodAmountFromValue).call(_a, pending.tokenSupply);
                operations.push({
                    type: block_1.Block.OperationType.TOKEN_ADMIN_SUPPLY,
                    method, amount
                });
            }
            for (const { method, certificate, intermediateCertificates } of pending.modifyCertificates ?? []) {
                let intermediates = undefined;
                if (method === block_1.Block.AdjustMethod.ADD) {
                    intermediates = intermediateCertificates;
                }
                operations.push({
                    type: lib_1.default.Block.OperationType.MANAGE_CERTIFICATE,
                    method: method,
                    certificateOrHash: certificate,
                    intermediateCertificates: intermediates
                });
            }
            const modifyBalanceResolved = {};
            for (const { isSet, token, amount } of pending.adminModifyBalance ?? []) {
                const tokenPubKey = PendingAccount.GetValue(token).publicKeyString.get();
                if (isSet) {
                    modifyBalanceResolved[tokenPubKey] = { isSet, amount };
                    continue;
                }
                if (!modifyBalanceResolved[tokenPubKey]) {
                    modifyBalanceResolved[tokenPubKey] = { isSet: false, amount: 0n };
                }
                modifyBalanceResolved[tokenPubKey].amount += amount;
            }
            for (const tokenPubKey in modifyBalanceResolved) {
                const data = modifyBalanceResolved[tokenPubKey];
                let method;
                let amount;
                if (data.isSet) {
                    method = block_1.Block.AdjustMethod.SET;
                    amount = data.amount;
                }
                else {
                    const methodAmount = __classPrivateFieldGet(_a, _a, "m", _UserClientBuilder_getMethodAmountFromValue).call(_a, data.amount);
                    method = methodAmount.method;
                    amount = methodAmount.amount;
                }
                operations.push({
                    type: block_1.Block.OperationType.TOKEN_ADMIN_MODIFY_BALANCE,
                    token: account_1.Account.toAccount(tokenPubKey).assertKeyType(account_1.AccountKeyAlgorithm.TOKEN),
                    method: method,
                    amount: amount
                });
            }
            for (const principalPubKey in pending.permissionsChanges) {
                for (const targetPubKey in pending.permissionsChanges[principalPubKey]) {
                    for (const change of pending.permissionsChanges[principalPubKey][targetPubKey]) {
                        const { method, permissions } = change;
                        let target;
                        if (!account.comparePublicKey(targetPubKey)) {
                            target = account_1.Account.fromPublicKeyString(targetPubKey);
                        }
                        operations.push({
                            type: block_1.Block.OperationType.MODIFY_PERMISSIONS,
                            principal: account_1.Account.fromPublicKeyString(principalPubKey),
                            target: target,
                            method: method,
                            permissions: permissions
                        });
                    }
                }
            }
            if (operations.length === 0) {
                continue;
            }
            const block = await new block_1.Block.Builder({
                account: account,
                signer: signer,
                network: renderOptions.network,
                previous: previous,
                operations: operations
            }).seal();
            blocks.push(block);
            previousByKey[accountPubKey] = block.hash;
        }
        __classPrivateFieldSet(this, _UserClientBuilder_rendered, true, "f");
        __classPrivateFieldSet(this, _UserClientBuilder_allPending, [], "f");
        __classPrivateFieldSet(this, _UserClientBuilder_blocks, blocks, "f");
        return ({ blocks });
    }
    send(recipient, amount, token, external, options = {}) {
        __classPrivateFieldGet(this, _UserClientBuilder_instances, "m", _UserClientBuilder_useOptions).call(this, options);
        __classPrivateFieldGet(this, _UserClientBuilder_instances, "m", _UserClientBuilder_checkNotZeroAmount).call(this, amount);
        if (!__classPrivateFieldGet(this, _UserClientBuilder_pendingOperations, "f").send) {
            __classPrivateFieldGet(this, _UserClientBuilder_pendingOperations, "f").send = [];
        }
        const otherParty = recipient;
        __classPrivateFieldGet(this, _UserClientBuilder_pendingOperations, "f").send.push({ otherParty, amount, token, external });
    }
    receive(from, amount, token, exact = false, forward, options = {}) {
        __classPrivateFieldGet(this, _UserClientBuilder_instances, "m", _UserClientBuilder_useOptions).call(this, options);
        __classPrivateFieldGet(this, _UserClientBuilder_instances, "m", _UserClientBuilder_checkNotZeroAmount).call(this, amount);
        if (!__classPrivateFieldGet(this, _UserClientBuilder_pendingOperations, "f").receive) {
            __classPrivateFieldGet(this, _UserClientBuilder_pendingOperations, "f").receive = [];
        }
        const otherParty = from;
        const exactReceive = exact;
        __classPrivateFieldGet(this, _UserClientBuilder_pendingOperations, "f").receive.push({ otherParty, amount, token, exactReceive, forward });
    }
    updatePermissions(principal, permissions, target, method, options = {}) {
        __classPrivateFieldGet(this, _UserClientBuilder_instances, "m", _UserClientBuilder_useOptions).call(this, options);
        method = method ?? block_1.Block.AdjustMethod.SET;
        const principalPubKey = principal.publicKeyString.get();
        const targetPubKey = (target ?? __classPrivateFieldGet(this, _UserClientBuilder_pendingOptions, "f").account).publicKeyString.get();
        if (!__classPrivateFieldGet(this, _UserClientBuilder_pendingOperations, "f").permissionsChanges) {
            __classPrivateFieldGet(this, _UserClientBuilder_pendingOperations, "f").permissionsChanges = {};
        }
        if (!__classPrivateFieldGet(this, _UserClientBuilder_pendingOperations, "f").permissionsChanges[principalPubKey]) {
            __classPrivateFieldGet(this, _UserClientBuilder_pendingOperations, "f").permissionsChanges[principalPubKey] = {};
        }
        if (!__classPrivateFieldGet(this, _UserClientBuilder_pendingOperations, "f").permissionsChanges[principalPubKey][targetPubKey]) {
            __classPrivateFieldGet(this, _UserClientBuilder_pendingOperations, "f").permissionsChanges[principalPubKey][targetPubKey] = [];
        }
        __classPrivateFieldGet(this, _UserClientBuilder_pendingOperations, "f").permissionsChanges[principalPubKey][targetPubKey].push({
            method: method,
            permissions: permissions_1.Permissions.FromAcceptedTypes(permissions)
        });
    }
    modifyCertificate(method, certificate, intermediateCertificates = null, options = {}) {
        __classPrivateFieldGet(this, _UserClientBuilder_instances, "m", _UserClientBuilder_useOptions).call(this, options);
        if (__classPrivateFieldGet(this, _UserClientBuilder_pendingOperations, "f").modifyCertificates === undefined) {
            __classPrivateFieldGet(this, _UserClientBuilder_pendingOperations, "f").modifyCertificates = [];
        }
        __classPrivateFieldGet(this, _UserClientBuilder_pendingOperations, "f").modifyCertificates.push({
            method: method,
            certificate: certificate,
            intermediateCertificates: intermediateCertificates
        });
    }
    modifyTokenSupply(amount, options = {}) {
        __classPrivateFieldGet(this, _UserClientBuilder_instances, "m", _UserClientBuilder_useOptions).call(this, options);
        if (__classPrivateFieldGet(this, _UserClientBuilder_pendingOptions, "f").account.keyType !== account_1.AccountKeyAlgorithm.TOKEN) {
            throw (new Error('The current account when using modifyTokenSupply() must be a token account'));
        }
        if (!__classPrivateFieldGet(this, _UserClientBuilder_pendingOperations, "f").tokenSupply) {
            __classPrivateFieldGet(this, _UserClientBuilder_pendingOperations, "f").tokenSupply = 0n;
        }
        __classPrivateFieldGet(this, _UserClientBuilder_pendingOperations, "f").tokenSupply += amount;
    }
    modifyTokenBalance(token, amount, isSet = false, options = {}) {
        __classPrivateFieldGet(this, _UserClientBuilder_instances, "m", _UserClientBuilder_useOptions).call(this, options);
        if (!__classPrivateFieldGet(this, _UserClientBuilder_pendingOperations, "f").adminModifyBalance) {
            __classPrivateFieldGet(this, _UserClientBuilder_pendingOperations, "f").adminModifyBalance = [];
        }
        __classPrivateFieldGet(this, _UserClientBuilder_pendingOperations, "f").adminModifyBalance.push({ isSet, amount, token });
    }
    setInfo(info, options = {}) {
        __classPrivateFieldGet(this, _UserClientBuilder_instances, "m", _UserClientBuilder_useOptions).call(this, options);
        __classPrivateFieldGet(this, _UserClientBuilder_pendingOperations, "f").info = {
            ...(__classPrivateFieldGet(this, _UserClientBuilder_pendingOperations, "f").info ?? {}),
            ...info
        };
    }
    setRep(to, options = {}) {
        __classPrivateFieldGet(this, _UserClientBuilder_instances, "m", _UserClientBuilder_useOptions).call(this, options);
        __classPrivateFieldGet(this, _UserClientBuilder_pendingOperations, "f").setRep = to;
    }
    generateIdentifier(type, options = {}) {
        __classPrivateFieldGet(this, _UserClientBuilder_instances, "m", _UserClientBuilder_useOptions).call(this, options);
        if (!__classPrivateFieldGet(this, _UserClientBuilder_pendingOperations, "f").createIdentifiers) {
            __classPrivateFieldGet(this, _UserClientBuilder_pendingOperations, "f").createIdentifiers = [];
        }
        const toResolve = new PendingAccount();
        __classPrivateFieldGet(this, _UserClientBuilder_pendingOperations, "f").createIdentifiers.push({ type, toResolve });
        return (toResolve);
    }
    get blocks() {
        if (!__classPrivateFieldGet(this, _UserClientBuilder_rendered, "f")) {
            throw (new client_1.default('CLIENT_BUILDER_CANNOT_READ_BEFORE_RENDER', 'Cannot read UserClientBuilder.blocks before blocks are rendered'));
        }
        return (__classPrivateFieldGet(this, _UserClientBuilder_blocks, "f"));
    }
    get rendered() {
        return (__classPrivateFieldGet(this, _UserClientBuilder_rendered, "f"));
    }
}
exports.UserClientBuilder = UserClientBuilder;
_a = UserClientBuilder, _UserClientBuilder_allPending = new WeakMap(), _UserClientBuilder_pendingOptions = new WeakMap(), _UserClientBuilder_pendingOperations = new WeakMap(), _UserClientBuilder_defaultOptions = new WeakMap(), _UserClientBuilder_rendered = new WeakMap(), _UserClientBuilder_blocks = new WeakMap(), _UserClientBuilder_userClient = new WeakMap(), _UserClientBuilder_instances = new WeakSet(), _UserClientBuilder_defaultAccountOptions_get = function _UserClientBuilder_defaultAccountOptions_get() {
    const signer = __classPrivateFieldGet(this, _UserClientBuilder_defaultOptions, "f").signer;
    return ({
        account: __classPrivateFieldGet(this, _UserClientBuilder_defaultOptions, "f").account ?? signer,
        signer: signer
    });
}, _UserClientBuilder_combineAllPendingWithAccountPending = function _UserClientBuilder_combineAllPendingWithAccountPending(current, nextOperations, nextOptions) {
    if (Object.values(nextOperations).findIndex(value => value !== undefined) === -1) {
        return (null);
    }
    return ([
        ...current,
        [
            { ...nextOptions },
            { ...nextOperations }
        ]
    ]);
}, _UserClientBuilder_pushPending = function _UserClientBuilder_pushPending() {
    const updated = __classPrivateFieldGet(_a, _a, "m", _UserClientBuilder_combineAllPendingWithAccountPending).call(_a, __classPrivateFieldGet(this, _UserClientBuilder_allPending, "f"), __classPrivateFieldGet(this, _UserClientBuilder_pendingOperations, "f"), __classPrivateFieldGet(this, _UserClientBuilder_pendingOptions, "f"));
    if (updated === null) {
        return;
    }
    __classPrivateFieldSet(this, _UserClientBuilder_rendered, false, "f");
    __classPrivateFieldSet(this, _UserClientBuilder_allPending, updated, "f");
    __classPrivateFieldSet(this, _UserClientBuilder_pendingOptions, __classPrivateFieldGet(this, _UserClientBuilder_instances, "a", _UserClientBuilder_defaultAccountOptions_get), "f");
    __classPrivateFieldSet(this, _UserClientBuilder_pendingOperations, {}, "f");
}, _UserClientBuilder_useOptions = function _UserClientBuilder_useOptions(options) {
    __classPrivateFieldSet(this, _UserClientBuilder_rendered, false, "f");
    let shouldPush = false;
    const newOptions = { ...__classPrivateFieldGet(this, _UserClientBuilder_pendingOptions, "f") };
    const newAccount = options.account ?? __classPrivateFieldGet(this, _UserClientBuilder_instances, "a", _UserClientBuilder_defaultAccountOptions_get).account;
    if (!__classPrivateFieldGet(this, _UserClientBuilder_pendingOptions, "f").account.comparePublicKey(newAccount)) {
        newOptions.account = newAccount;
        shouldPush = true;
    }
    const newSigner = options.signer ?? __classPrivateFieldGet(this, _UserClientBuilder_instances, "a", _UserClientBuilder_defaultAccountOptions_get).signer;
    if (!__classPrivateFieldGet(this, _UserClientBuilder_pendingOptions, "f").signer.comparePublicKey(newSigner)) {
        newOptions.signer = newSigner;
        shouldPush = true;
    }
    if (shouldPush) {
        __classPrivateFieldGet(this, _UserClientBuilder_instances, "m", _UserClientBuilder_pushPending).call(this);
    }
    __classPrivateFieldSet(this, _UserClientBuilder_pendingOptions, newOptions, "f");
}, _UserClientBuilder_getMethodAmountFromValue = function _UserClientBuilder_getMethodAmountFromValue(amount) {
    amount = BigInt(amount);
    let method = lib_1.default.Block.AdjustMethod.ADD;
    if (amount < 0n) {
        method = lib_1.default.Block.AdjustMethod.SUBTRACT;
        amount *= -1n;
    }
    return ({ method, amount });
}, _UserClientBuilder_getRenderOptionsFromClient = function _UserClientBuilder_getRenderOptionsFromClient(client) {
    /*
     * Handle the UserClient case, which has a head
     * function
     */
    if ('head' in client) {
        return ({
            network: client.network,
            getPrevious: async (acct) => {
                if (typeof acct === 'string') {
                    acct = account_1.Account.toAccount(acct);
                }
                const blockHash = await client.head({
                    account: acct
                });
                return (blockHash);
            }
        });
    }
    /*
     * Otherwise we have a client and network
     */
    return ({
        network: client.network,
        getPrevious: async (acct) => {
            if (typeof acct === 'string') {
                acct = account_1.Account.toAccount(acct);
            }
            const accountInfo = await client.client.getAccountInfo(acct);
            const blockHash = accountInfo.currentHeadBlock;
            return (blockHash);
        }
    });
}, _UserClientBuilder_checkNotZeroAmount = function _UserClientBuilder_checkNotZeroAmount(amount) {
    if (amount === 0n) {
        throw (new client_1.default('CLIENT_BUILDER_AMOUNT_IS_ZERO', 'Amount should be greater than 0 for send/receive'));
    }
};
UserClientBuilder.isInstance = (0, helper_1.checkableGenerator)(_a);
UserClientBuilder.PendingAccount = PendingAccount;


/***/ }),

/***/ 9994:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var _Client_instances, _Client_reps, _Client_weightOrderedReps, _Client_intervals, _Client_updateRepsPromise, _Client_apiRaw, _Client_api, _Client_requestVoteOrQuote, _Client_requestQuotes, _Client_requestVotes, _Client_getVotes, _Client_getBuilderRenderOptions, _Client_urlSeparatedAccounts, _Client_formatAllBalances, _Client_parseResponsePermissions, _Client_formatAccountInfo, _Client_parseAccountInfo, _Client_parsePermissionEntries, _Client_mapCertificateWithBundleResult, _Client_parseRepInfo, _UserClient_instances, _UserClient_config, _UserClient_client, _UserClient_listeners, _UserClient_intervals, _UserClient_previousAccountChangeData, _UserClient_socketPromise, _UserClient_filteredWebSocket, _UserClient_changePromise, _UserClient_reconnectAttempts, _UserClient_RECONNECT_TIMEOUT, _UserClient_transientUserClients, _UserClient_getAccount, _UserClient_publishAidURL_get, _UserClient_publishWithPublishAid, _UserClient_reconnectWebSocket, _UserClient_setupFilteredWebSocket, _UserClient_emit, _UserClient_emitAccountInfoIfChanged;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.lib = exports.UserClient = exports.Client = void 0;
exports.blockGenerator = blockGenerator;
exports.emitBlocks = emitBlocks;
/**
 * JavaScript and TypeScript SDK for the KeetaNet network.
 *
 * This SDK provides a low- and high-level interfaces to the KeetaNet network.
 *
 * See the [Getting Started](../../docs/GETTING-STARTED.md) guide for an overview of how to
 * get started with the SDK.
 *
 * @module KeetaNetSDK
 */
const lib_1 = __importDefault(__webpack_require__(8568));
const account_1 = __importStar(__webpack_require__(9415));
const block_1 = __importStar(__webpack_require__(6158));
const helper_1 = __webpack_require__(3208);
const conversion_1 = __webpack_require__(2360);
const hash_1 = __webpack_require__(7908);
const Config = __importStar(__webpack_require__(1491));
const helper_2 = __webpack_require__(3208);
const node_1 = __webpack_require__(5337);
const version_1 = __webpack_require__(5672);
const initial_1 = __webpack_require__(3750);
const builder_1 = __webpack_require__(4057);
const isomorphic_ws_1 = __importDefault(__webpack_require__(2465));
const uuid = __importStar(__webpack_require__(5827));
const error_1 = __webpack_require__(5390);
const common_1 = __webpack_require__(5663);
const operations_1 = __webpack_require__(2778);
const effects_1 = __webpack_require__(7346);
const client_1 = __importDefault(__webpack_require__(3642));
const certificate_1 = __webpack_require__(5661);
const certificate_2 = __webpack_require__(5661);
const vote_1 = __webpack_require__(1130);
const ledger_1 = __webpack_require__(452);
function isGetAccountStateAPIResponseFailure(object) {
    if (typeof object !== 'object' || object === null) {
        return (false);
    }
    if (Object.keys(object).length !== 2) {
        return (false);
    }
    if (!('account' in object) || typeof object.account !== 'string') {
        return (false);
    }
    if (!('error' in object) || typeof object.error !== 'string') {
        return (false);
    }
    return (true);
}
/**
 *   The Client class provides a low-level interface to the KeetaNet network.
 *   It handles sending messages to the KeetaNet representatives and parsing
 *   the responses.
 *
 *   It does not handle any of the higher-level logic of the KeetaNet network,
 *   for that there is the {@link UserClient} class.
 *
 * @summary
 *   Low-level access to the KeetaNet network
 *
 * @example
 *   ```typescript
 *   import { Client } from '@keetanetwork/keetanet-client';
 *   const client = Client.fromNetwork('test');
 *   const blocks = await client.getChain('keeta_...');
 *   ```
 */
class Client {
    /**
     * Construct a new instance of the {@link Client} class from the given
     * network name.  This will use the default representatives for the
     * network based on the configuration.
     *
     * New instances should be cleaned up with the {@link destroy}() method
     * when they are no longer needed.
     *
     * This is the recommended way to create a new instance of the {@link Client} class.
     *
     * @param network The network to use for this instance of the {@link Client} class
     * @return A new instance of the {@link Client} class
     * @expandType Config.Networks
     */
    static fromNetwork(network) {
        const { representatives } = Config.getDefaultConfig(network);
        return (new Client(representatives));
    }
    /**
     * Create a new instance of the {@link Client} class from the given set
     * of representatives.  This is used to create a new instance of the
     * {@link Client} class with a custom set of representatives.
     *
     * New instances should be cleaned up with the {@link destroy}() method
     * when they are no longer needed.
     *
     * In general this is not needed and the {@link Client.fromNetwork}()
     * method should be used instead.
     *
     * @param reps The representatives to use for this instance of the {@link Client} class
     * @return A new instance of the {@link Client} class
     * @expandType ClientRepresentative
     */
    constructor(reps) {
        _Client_instances.add(this);
        /**
         * The logger to use for this instance of the {@link Client} class.  This
         * is defined by the `Client.DefaultLogger` property, but can be overridden
         * by the application.
         */
        this.logger = Client.DefaultLogger;
        /**
         * Indication of whether or not this client has been destroyed.
         */
        this.destroyed = false;
        _Client_reps.set(this, void 0);
        _Client_weightOrderedReps.set(this, []);
        _Client_intervals.set(this, void 0);
        _Client_updateRepsPromise.set(this, void 0);
        /**
         * Stats for this instance of the client
         */
        this.stats = {
            /**
             * Breakdown of the API calls made
             */
            api: {
                /**
                 * The total number of times the API was called
                 */
                called: 0,
                /**
                 * The number of times the API failed
                 */
                failures: 0
            }
        };
        /**
         * Testing interface to the client API direct method
         * @internal
         */
        this._testing_api = __classPrivateFieldGet(this, _Client_instances, "m", _Client_apiRaw).bind(this);
        __classPrivateFieldSet(this, _Client_reps, reps, "f");
        __classPrivateFieldSet(this, _Client_updateRepsPromise, undefined, "f");
        __classPrivateFieldSet(this, _Client_intervals, {}, "f");
        // Update Reps immediately and then every 5 minutes
        __classPrivateFieldSet(this, _Client_updateRepsPromise, this.updateReps().catch(function () {
            // Ignore any errors
        }), "f");
        if (__classPrivateFieldGet(this, _Client_intervals, "f").updateReps === undefined) {
            __classPrivateFieldGet(this, _Client_intervals, "f").updateReps = setInterval(() => {
                __classPrivateFieldSet(this, _Client_updateRepsPromise, this.updateReps().catch(function () {
                    // Ignore any errors
                }), "f");
            }, Client.updateRepsInterval);
        }
    }
    /**
     * Destroy this instance of the {@link Client} class.  This will clean up
     * any resources used by the instance and stop any background tasks.
     */
    async destroy() {
        if (this.destroyed) {
            return;
        }
        this.destroyed = true;
        if (__classPrivateFieldGet(this, _Client_updateRepsPromise, "f") !== undefined) {
            await __classPrivateFieldGet(this, _Client_updateRepsPromise, "f");
        }
        // Get Interval IDs and clear them
        const intervalIds = Object.values(__classPrivateFieldGet(this, _Client_intervals, "f"));
        for (const interval of intervalIds) {
            clearInterval(interval);
        }
        // Clear Variables
        __classPrivateFieldSet(this, _Client_intervals, {}, "f");
    }
    /**
     * This enables the use of `using` to automatically clean up the
     * instance of the {@link Client} class when it is no longer needed.
     *
     * It calls the {@link destroy}() method to clean up the instance when
     * it goes out of scope.
     */
    async [(_Client_reps = new WeakMap(), _Client_weightOrderedReps = new WeakMap(), _Client_intervals = new WeakMap(), _Client_updateRepsPromise = new WeakMap(), _Client_instances = new WeakSet(), Symbol.asyncDispose)]() {
        return (await this.destroy());
    }
    /**
     * Create a new instance of the {@link UserClientBuilder} class.  This
     * is a convenience method to create a new instance of the builder
     * class.
     *
     * The builder class is used to create blocks in a high-level way.
     *
     * @param options The options to use for the builder
     * @expandType BuilderOptions
     */
    makeBuilder(options) {
        return (new builder_1.UserClientBuilder(options));
    }
    /**
     * Compute the blocks for a given builder.  This will take the
     * pending operations and compute the blocks for them.
     *
     * This will additionally mutate the state of the builder to "seal" the
     * blocks meaning new operations will be added to new blocks.
     *
     * @param network The network to use for the builder
     * @param builder The builder to use for the computation
     * @return The blocks that were computed
     */
    async computeBuilderBlocks(network, builder) {
        return (await builder.computeBlocks(__classPrivateFieldGet(this, _Client_instances, "m", _Client_getBuilderRenderOptions).call(this, network)));
    }
    /**
     * Transmit a set of blocks to the network.  This will request short
     * votes and permanent votes for the blocks and then publish them to
     * the network.
     *
     * The `blocks` builder will be computed using {@link computeBuilderBlocks} and then transmitted.
     *
     * @param builder The UserClientBuilder to compute and transmit transmit
     * @param network The network to use for the builder (if using a builder)
     * @return The result of the publish operation
     */
    async transmitBuilder(builder, network, options) {
        const blocks = await this.computeBuilderBlocks(network, builder);
        return (await this.transmit(blocks.blocks, options));
    }
    /**
     * Transmit a set of blocks to the network.  This will request short
     * votes and permanent votes for the blocks and then publish them to
     * the network.  Optionally it will generate a fee block from a user
     * provided function if fees are required.
     *
     * @param blocks The blocks to transmit
     * @param options User provided options {@link PublishOptions }
     * @return The result of the publish operation
     */
    async transmit(blocks, options) {
        const tempVotes = await __classPrivateFieldGet(this, _Client_instances, "m", _Client_requestVotes).call(this, blocks, undefined, undefined, options?.quotes);
        let requiresFee = false;
        for (const vote of tempVotes) {
            if (vote.fee !== undefined) {
                requiresFee = true;
            }
        }
        if (requiresFee) {
            if (options?.generateFeeBlock === undefined) {
                throw (new Error('Votes require fees but generateFeeBlock was not defined'));
            }
            const staple = vote_1.VoteStaple.fromVotesAndBlocks(tempVotes, blocks);
            const feeBlock = await options.generateFeeBlock(staple);
            blocks.push(feeBlock);
        }
        const permVotes = await __classPrivateFieldGet(this, _Client_instances, "m", _Client_requestVotes).call(this, blocks, tempVotes);
        const votesAndBlocks = lib_1.default.Vote.Staple.fromVotesAndBlocks(permVotes, blocks);
        return (await this.transmitStaple(votesAndBlocks));
    }
    /**
     * Publish a Vote Staple to the network.  This will publish the votes
     * and blocks to the network.
     *
     * If `reps` is not defined then the highest weight representative
     * will be used.  If `reps` is defined then the votes and blocks
     * will be published to all representatives in the list.
     *
     * @param votesAndBlocks The votes and blocks to publish
     * @param reps The representatives to publish to
     * @returns The result of the publish operation as well as the vote staple
     * @expandType ClientRepresentative
     */
    async transmitStaple(votesAndBlocks, reps) {
        // If reps are not defined then publish to the highest weight rep
        if (!reps || reps.length === 0) {
            await __classPrivateFieldGet(this, _Client_updateRepsPromise, "f");
            reps = [__classPrivateFieldGet(this, _Client_weightOrderedReps, "f")[0]];
        }
        const publishPromises = [];
        for (const rep of reps) {
            publishPromises.push((async () => {
                const apiResult = await __classPrivateFieldGet(this, _Client_instances, "m", _Client_api).call(this, rep, 'POST /node/publish', {
                    body: {
                        votesAndBlocks: Buffer.from(votesAndBlocks.toBytes()).toString('base64')
                    }
                });
                return (apiResult);
            })());
        }
        const publishObjects = await Promise.allSettled(publishPromises);
        let retval = false;
        let publishError;
        for (const publishObjectWrapperSettled of publishObjects) {
            // As long as one publish succeeded we can return true
            if (publishObjectWrapperSettled.status === 'fulfilled') {
                retval = true;
                break;
            }
            else {
                publishError = publishObjectWrapperSettled.reason;
            }
        }
        if (!retval && publishError) {
            throw (new Error(publishError));
        }
        return ({
            voteStaple: votesAndBlocks,
            publish: retval,
            from: 'direct'
        });
    }
    /**
     * Get statistics about the preferred representative
     * @expandType LedgerStatistics
     * @expandType P2PSwitchStatistics
     */
    async getNodeStats() {
        const nodeStats = await __classPrivateFieldGet(this, _Client_instances, "m", _Client_api).call(this, 'ANY', 'GET /node/stats');
        return (nodeStats);
    }
    /**
     * Get the supply of a token.  This will return the total supply of the
     * specified token.
     *
     * @param token The token to get the supply for
     * @return The total supply of the token
     */
    async getTokenSupply(token) {
        token = lib_1.default.Account.toAccount(token);
        if (token.keyType !== lib_1.default.Account.AccountKeyAlgorithm.TOKEN) {
            throw (new Error('Cannot get supply for non token account'));
        }
        const { info: { supply } } = await this.getAccountInfo(token);
        if (typeof supply !== 'bigint') {
            throw (new Error('Error fetching supply'));
        }
        return (supply);
    }
    /**
     * Fetch the account information for a given account.  This will return
     * the account information including the current head block, representative,
     * balances, and metadata.
     *
     * @param account The account to fetch the information for
     * @return The account information
     */
    async getAccountInfo(account, rep = 'ANY') {
        account = account_1.default.toAccount(account);
        const accountPubKey = account.publicKeyString.get();
        const result = await __classPrivateFieldGet(this, _Client_instances, "m", _Client_api).call(this, rep, 'GET /node/ledger/account/:account', {
            args: {
                account: accountPubKey
            }
        });
        return (__classPrivateFieldGet(this, _Client_instances, "m", _Client_parseAccountInfo).call(this, account, result));
    }
    /**
     * Fetch the account information for multiple accounts.  This will return
     * the account information including the current head block, representative,
     * balances, and metadata for each account.
     *
     * @param accounts The accounts to fetch the information for
     * @return The account information for each account, as an object
     *         with the account as the key and the account information as the value
     */
    async getAccountsInfo(accounts) {
        const joinedTargets = __classPrivateFieldGet(this, _Client_instances, "m", _Client_urlSeparatedAccounts).call(this, accounts);
        const result = await __classPrivateFieldGet(this, _Client_instances, "m", _Client_api).call(this, 'ANY', 'GET /node/ledger/accounts/:accounts', {
            args: {
                accounts: joinedTargets
            }
        });
        const accountsInfo = {};
        for (const accountStateResult of result) {
            accountsInfo[accountStateResult.account] = __classPrivateFieldGet(this, _Client_instances, "m", _Client_parseAccountInfo).call(this, accountStateResult.account, accountStateResult);
        }
        return (accountsInfo);
    }
    /**
     * List the ACLs that have been set for a given account that are
     * targeting a particular set of accounts.  This will return the ACLs
     * including the principal, entity, and permissions for each ACL entry.
     *
     * @param account The account to list the ACLs for
     * @param entities The accounts to filter the ACLs by
     * @return The ACLs for the account where the target is one of the
     *         specified accounts
     */
    async listACLsByPrincipal(account, entities = []) {
        account = lib_1.default.Account.toPublicKeyString(account);
        const joinedTargets = __classPrivateFieldGet(this, _Client_instances, "m", _Client_urlSeparatedAccounts).call(this, entities);
        const result = await __classPrivateFieldGet(this, _Client_instances, "m", _Client_api).call(this, 'ANY', 'GET /node/ledger/account/:account/acl/:entityList', {
            args: {
                account,
                entityList: joinedTargets
            }
        });
        return (__classPrivateFieldGet(this, _Client_instances, "m", _Client_parsePermissionEntries).call(this, result.permissions));
    }
    /**
     * List the ACLs that have been set for a given account that are
     * targeting a particular set of accounts.  This will return the ACLs
     * including the principal, entity, and permissions for each ACL entry.
     *
     * @param account The account to list the ACLs for
     * @param targets The accounts to filter the ACLs by
     * @return The ACLs for the account where the target is one of the
     *         specified accounts with additional information
     */
    async listACLsByPrincipalWithInfo(account, targets = []) {
        account = lib_1.default.Account.toPublicKeyString(account);
        const joinedTargets = __classPrivateFieldGet(this, _Client_instances, "m", _Client_urlSeparatedAccounts).call(this, targets);
        const response = await __classPrivateFieldGet(this, _Client_instances, "m", _Client_api).call(this, 'ANY', 'GET /node/ledger/account/:account/acl/additional/:entityList', {
            args: {
                account,
                entityList: joinedTargets
            }
        });
        const parsed = response.access.map((entry) => {
            return ({
                entity: lib_1.default.Account.fromPublicKeyString(entry.entity),
                info: __classPrivateFieldGet(this, _Client_instances, "m", _Client_formatAccountInfo).call(this, entry.info),
                balances: __classPrivateFieldGet(this, _Client_instances, "m", _Client_formatAllBalances).call(this, entry.balances),
                principals: __classPrivateFieldGet(this, _Client_instances, "m", _Client_parsePermissionEntries).call(this, entry.principals)
            });
        });
        return (parsed);
    }
    /**
     * List the ACLs that have been set on a given account by any other
     * account.  This will return the ACLs including the principal.
     *
     * @param entity The account to list the ACLs for
     * @return The ACLs for the account where the entity is the
     *         specified account
     */
    async listACLsByEntity(entity) {
        entity = lib_1.default.Account.toPublicKeyString(entity);
        const response = await __classPrivateFieldGet(this, _Client_instances, "m", _Client_api).call(this, 'ANY', 'GET /node/ledger/account/:account/acl/granted', {
            args: {
                account: entity
            }
        });
        return (__classPrivateFieldGet(this, _Client_instances, "m", _Client_parsePermissionEntries).call(this, response.permissions));
    }
    /**
     * Get the balance of a given account for a given token.
     *
     * @param account The account to get the balance for
     * @param token The token to get the balance of for the given account
     * @return The balance of the account for the given token
     */
    async getBalance(account, token) {
        token = lib_1.default.Account.toPublicKeyString(token);
        account = lib_1.default.Account.toPublicKeyString(account);
        const result = await __classPrivateFieldGet(this, _Client_instances, "m", _Client_api).call(this, 'ANY', 'GET /node/ledger/account/:account/balance/:token', {
            args: {
                account,
                token
            }
        });
        return (BigInt(result.balance));
    }
    /**
     * Get the balance of a given account for all tokens.
     *
     * @param account The account to get the balance for
     * @return An array of objects which specify the token and the balance
     *         for each token the user holds a balance for
     */
    async getAllBalances(account) {
        account = lib_1.default.Account.toPublicKeyString(account);
        const result = await __classPrivateFieldGet(this, _Client_instances, "m", _Client_api).call(this, 'ANY', 'GET /node/ledger/account/:account/balance', {
            args: {
                account
            }
        });
        return (__classPrivateFieldGet(this, _Client_instances, "m", _Client_formatAllBalances).call(this, result.balances));
    }
    /**
     * List all certificates for a given account.  This will return
     * all certificates that have been added by and issued to the account, including
     * any intermediate certificates that have been issued.
     * @param account Account to lookup certificates for
     * @returns An array of objects containing the certificate and any intermediates associated with the specified account
     */
    async getAllCertificates(account) {
        account = account_1.default.toPublicKeyString(account);
        const result = await __classPrivateFieldGet(this, _Client_instances, "m", _Client_api).call(this, 'ANY', `GET /node/ledger/account/:account/certificates`, {
            args: {
                account
            }
        });
        const certificates = [];
        for (const certificate of result.certificates) {
            certificates.push(__classPrivateFieldGet(this, _Client_instances, "m", _Client_mapCertificateWithBundleResult).call(this, certificate));
        }
        return (certificates);
    }
    /**
     * Get a certificate by its hash for a given account.  This will return
     * the certificate and any intermediate certificates that have been issued.
     *
     * @param account The account to get the certificate for
     * @param certificateHash The hash of the certificate to get
     * @return The certificate and any intermediates or null if the certificate was not found
     */
    async getCertificateByHash(account, certificateHash) {
        account = account_1.default.toPublicKeyString(account);
        let hashString = certificateHash;
        if (typeof hashString !== 'string') {
            hashString = hashString.toString();
        }
        const result = await __classPrivateFieldGet(this, _Client_instances, "m", _Client_api).call(this, 'ANY', 'GET /node/ledger/account/:account/certificates/:certificateHash', {
            args: {
                account,
                certificateHash: hashString
            }
        });
        if (!result.certificate) {
            return (null);
        }
        return (__classPrivateFieldGet(this, _Client_instances, "m", _Client_mapCertificateWithBundleResult).call(this, result));
    }
    /**
     * Get the current head block for a given account.  This will return the
     * entire block, or null if the account has not created any blocks.
     *
     * An account with no blocks may still have a balance because other users
     * may have sent tokens to it.
     *
     * @param account The account to get the head block for
     * @param rep The representative to get the head block from -- this is generally "ANY" in which case the best representative will be used, but it is possible to request a specific representative
     * @return The head block for the account or null if the account has
     *         not created any blocks
     */
    async getHeadBlock(account, rep = 'ANY') {
        account = lib_1.default.Account.toPublicKeyString(account);
        const result = await __classPrivateFieldGet(this, _Client_instances, "m", _Client_api).call(this, rep, 'GET /node/ledger/account/:account/head', {
            args: {
                account
            }
        });
        if (result.block === null) {
            return (null);
        }
        const block = new lib_1.default.Block(result.block);
        return (block);
    }
    /**
     * @param blockhash The block hash to get the block for
     * @param side The side of the ledger to get the block from -- this is generally "main", but it is possible to request "side" ledger blocks
     * @param rep The representative to get the block from -- this is generally "ANY" in which case the best representative will be used, but it is possible to request a specific representative
     * @return The block for the given block hash or null if the block does not exist on the given ledger
     */
    async getBlock(blockhash, side, rep = 'ANY') {
        if (typeof blockhash !== 'string') {
            blockhash = blockhash.toString();
        }
        const info = await __classPrivateFieldGet(this, _Client_instances, "m", _Client_api).call(this, rep, 'GET /node/ledger/block/:blockhash', {
            args: {
                blockhash
            },
            queryParams: {
                side: side
            }
        });
        if (info.block === null) {
            return (null);
        }
        const block = new lib_1.default.Block(info.block);
        return (block);
    }
    /**
     * @param blockhash The block hash to get the vote staple for
     * @param side The side of the ledger to get the vote staple from -- this is generally "main", but it is possible to request "side" ledger blocks
     * @param rep The representative to get the staple from -- this is generally "ANY" in which case the best representative will be used, but it is possible to request a specific representative
     * @return The vote staple for the given block hash or null if the vote staple does not exist on the given ledger
     */
    async getVoteStaple(blockhash, side, rep = 'ANY') {
        const votes = await __classPrivateFieldGet(this, _Client_instances, "m", _Client_getVotes).call(this, blockhash, side, rep);
        if (votes === null) {
            return (null);
        }
        /**
         * Pick a representative Vote from the list, all votes will be
         * of the same set of Blocks so any one will do
         */
        const sampleVote = votes[0];
        /**
         * Fetch all the blocks referenced
         */
        const blocksPromises = [];
        for (const voteBlockhash of sampleVote.blocks) {
            blocksPromises.push(this.getBlock(voteBlockhash, side, rep));
        }
        /**
         * If there are blocks mentioned that do not exist or
         * cannot be fetched, refuse to create a staple
         */
        const blocksOrNull = await Promise.all(blocksPromises);
        for (const block of blocksOrNull) {
            if (block === null) {
                return (null);
            }
        }
        /**
         * Because we errored out on any null blocks above, we have
         * only Blocks now
         */
        const blocks = [];
        for (const block of blocksOrNull) {
            if (block === null) {
                throw (new Error('Impossible'));
            }
            blocks.push(block);
        }
        const voteStaple = lib_1.default.Vote.Staple.fromVotesAndBlocks(votes, blocks);
        return (voteStaple);
    }
    /**
     * Get the chain for a given account.  This is the set of blocks that
     * the account has created.  This will return the blocks in reverse
     * order, with the most recent block first.
     *
     * This is a paginated request and may return only a partial set of
     * blocks for a given request if there are more blocks to be fetched
     * from the representative.  The `startBlock` parameter can be used to
     * fetch the next set of blocks.  Once all blocks have been fetched
     * an empty array will be returned.
     *
     * The `depth` parameter can be used to limit the number of blocks
     * returned.  The default is to leave it up to the representative to
     * determine the number of blocks to return.  The representative
     * may return fewer than the requested number of blocks even if there
     * are more blocks available, except that it will always return at
     * least 1 block if there are any blocks available.
     *
     * @param account The account to get the chain for
     * @param options The options to use for the request
     * @param options.startBlock The block hash to start from -- this is used to paginate the request
     * @param options.endBlock The block hash to stop on -- this is used to limit the chain to a specific range of blocks
     * @param options.depth The maximum number of blocks to return -- this is used to limit the number of blocks returned
     * @return The chain of blocks for the given account, in reverse order starting with the most recent block
     */
    async getChain(account, options = {}) {
        const { depth = Infinity, startBlock, endBlock } = options;
        account = account_1.default.toPublicKeyString(account);
        const query = {
            start: 'HEAD',
            limit: String(Math.min(depth, 200))
        };
        if (startBlock !== undefined) {
            query.start = startBlock.toString();
        }
        if (endBlock !== undefined) {
            query.end = endBlock.toString();
        }
        const retval = [];
        while (retval.length < depth) {
            const chain = await __classPrivateFieldGet(this, _Client_instances, "m", _Client_api).call(this, 'ANY', 'GET /node/ledger/account/:account/chain', {
                args: {
                    account
                },
                queryParams: query
            });
            for (const blockInfo of chain.blocks) {
                const blockJSON = blockInfo.block;
                const blockBytes = Buffer.from(blockJSON['$binary'], 'base64');
                const block = new block_1.default(blockBytes);
                retval.push(block);
                if (retval.length >= depth) {
                    break;
                }
            }
            if (chain.nextKey === null) {
                break;
            }
            query.start = chain.nextKey;
        }
        return (retval);
    }
    /**
     * Get the history for a given account.  This is the set of vote
     * staples that have interacted with the account.  This is different
     * from the chain in that it includes vote staples that have affected
     * this account but are not directly created by this account.
     *
     * This is a paginated request and may return only a partial set of
     * vote staples for a given request if there are more vote staples
     * to be fetched from the representative.  The `startBlocksHash`
     * parameter can be used to fetch the next set of vote staples.
     * It can be computed from the last entry in the previous
     * response's `blocksHash` field.  Once all vote staples have been
     * fetched an empty array will be returned.
     *
     * The `depth` parameter can be used to limit the number of vote
     * staples returned.  The default is to leave it up to the
     * representative to determine the number of vote staples to return.
     * The representative may return fewer than the requested number of
     * vote staples even if there are more vote staples available, except
     * that it will always return at least 1 vote staple if there are any
     * vote staples available.
     *
     * @param account The account to get the history for -- if null then the history for all accounts will be returned
     * @param options The options to use for the request
     * @param options.startBlocksHash The block hash to start from -- this is used to paginate the request
     * @param options.depth The maximum number of vote staples to return -- this is used to limit the number of vote staples returned
     * @return The history of vote staples for the given account, in reverse order starting with the most recent vote staple
     */
    async getHistory(account, options = {}) {
        const { depth = Infinity, startBlocksHash } = options;
        account = account_1.default.toPublicKeyString(account);
        let startVoteStapleID = undefined;
        if (startBlocksHash !== undefined) {
            if (typeof startBlocksHash === 'string') {
                startVoteStapleID = startBlocksHash;
            }
            else {
                startVoteStapleID = startBlocksHash.toString();
            }
        }
        const retval = [];
        while (retval.length < depth) {
            const limit = Math.min(depth - retval.length, 200);
            const query = {
                limit: String(limit)
            };
            if (startVoteStapleID !== undefined) {
                query.start = startVoteStapleID;
            }
            let history;
            if (account === null) {
                history = await __classPrivateFieldGet(this, _Client_instances, "m", _Client_api).call(this, 'ANY', 'GET /node/ledger/history', {
                    queryParams: query
                });
            }
            else {
                history = await __classPrivateFieldGet(this, _Client_instances, "m", _Client_api).call(this, 'ANY', 'GET /node/ledger/account/:account/history', {
                    args: {
                        account
                    },
                    queryParams: query
                });
            }
            if (history.history.length === 0) {
                break;
            }
            for (const historyEntry of history.history) {
                const voteStapleInfo = historyEntry.voteStaple;
                if (voteStapleInfo['$binary'] === undefined) {
                    throw (new Error('Vote Staple is missing binary data'));
                }
                const voteStapleBinary = Buffer.from(voteStapleInfo['$binary'], 'base64');
                const voteStaple = new lib_1.default.Vote.Staple(voteStapleBinary);
                retval.push({
                    voteStaple: voteStaple
                });
                if (retval.length >= depth) {
                    break;
                }
            }
            startVoteStapleID = history.history.slice(-1)[0]['$id'];
        }
        return (retval);
    }
    /**
     * Get the representative information for a given representative account
     *
     * @param rep The representative account to get the information for
     * @return The representative information
     */
    async getSingleRepresentativeInfo(rep) {
        const repPublicKey = account_1.default.toPublicKeyString(rep);
        let repInfo;
        if (repPublicKey === undefined) {
            repInfo = await __classPrivateFieldGet(this, _Client_instances, "m", _Client_api).call(this, 'ANY', 'GET /node/ledger/representative');
        }
        else {
            repInfo = await __classPrivateFieldGet(this, _Client_instances, "m", _Client_api).call(this, 'ANY', 'GET /node/ledger/representative/:rep', {
                args: {
                    rep: repPublicKey
                }
            });
        }
        return (__classPrivateFieldGet(this, _Client_instances, "m", _Client_parseRepInfo).call(this, repInfo));
    }
    /**
     * Get a list of peers that the node is connected to.
     *
     * @returns The list of peers that the node is connected to
     */
    async getPeers() {
        const peers = await __classPrivateFieldGet(this, _Client_instances, "m", _Client_api).call(this, 'ANY', 'GET /node/peers');
        return (peers);
    }
    /**
     * Get a list of all representatives that the node is aware of
     * and their weights.  This will fetch the information from all
     * representatives
     *
     * @return The list of all representatives and their weights
     */
    async getAllRepresentativeInfo() {
        const repInfo = [];
        const representatives = this.representatives;
        await Promise.all(representatives.map(async (singleRep) => {
            const singleRepInfo = await __classPrivateFieldGet(this, _Client_instances, "m", _Client_api).call(this, singleRep, 'GET /node/ledger/representative');
            repInfo.push(singleRepInfo);
        }));
        return (repInfo.map(info => __classPrivateFieldGet(this, _Client_instances, "m", _Client_parseRepInfo).call(this, info)));
    }
    /**
     * Get the list of representatives that the CLIENT is aware of
     *
     * @returns The list of representatives that the client is aware of
     */
    get representatives() {
        return (__classPrivateFieldGet(this, _Client_reps, "f"));
    }
    /**
     * Get the network status of all representatives
     *
     * @param timeout Maximum time to wait for a response from a representative in milliseconds
     */
    async getNetworkStatus(timeout = 5000) {
        const reps = __classPrivateFieldGet(this, _Client_reps, "f");
        const repsInfo = reps.map(async (rep) => {
            const repInfo = await Promise.race([
                (async () => {
                    try {
                        const nodeStats = await __classPrivateFieldGet(this, _Client_instances, "m", _Client_api).call(this, rep, 'GET /node/stats', {
                            maxRetries: 0
                        });
                        return (nodeStats);
                    }
                    catch {
                        return;
                    }
                })(),
                (0, helper_1.asleep)(timeout)
            ]);
            if (repInfo === undefined) {
                return ({
                    rep: rep,
                    online: false
                });
            }
            else {
                return ({
                    ...repInfo,
                    rep: rep,
                    online: true
                });
            }
        });
        const retval = await Promise.all(repsInfo);
        return (retval);
    }
    /**
     * Update this client's view of the network representatives.
     * This will fetch the list of representatives from the
     * network and update the list of representatives that this
     * client will use.
     *
     * @param addNewReps If true, add any new representatives to the list of representatives
     */
    async updateReps(addNewReps = false) {
        const repsResponse = await __classPrivateFieldGet(this, _Client_instances, "m", _Client_api).call(this, 'ANY', 'GET /node/ledger/representatives');
        const weightedReps = [];
        for (const rep of repsResponse.representatives) {
            const repAccount = lib_1.default.Account.fromPublicKeyString(rep.representative).assertAccount();
            const repIndex = __classPrivateFieldGet(this, _Client_reps, "f").findIndex(repInfo => {
                return (repInfo.key.comparePublicKey(repAccount));
            });
            const repInfo = {
                key: repAccount,
                weight: BigInt(rep.weight),
                endpoints: rep.endpoints
            };
            if (repIndex === -1) {
                if (addNewReps) {
                    // TODO - make addNewReps default true when rep tracking is stable
                    // If we are adding new reps, also add them to weight sorted reps
                    __classPrivateFieldGet(this, _Client_reps, "f").push(repInfo);
                    weightedReps.push(repInfo);
                }
            }
            else {
                // Update the weight for the defined reps
                __classPrivateFieldGet(this, _Client_reps, "f")[repIndex].weight = repInfo.weight;
                // Add the repInfo to weight ordered reps
                weightedReps.push(repInfo);
            }
        }
        weightedReps.sort((rep1, rep2) => {
            if (rep2.weight > rep1.weight) {
                return (1);
            }
            if (rep2.weight < rep1.weight) {
                return (-1);
            }
            return (0);
        });
        __classPrivateFieldSet(this, _Client_weightOrderedReps, weightedReps, "f");
    }
    /**
     * Get a list of vote staples that have been added to the
     * representative's ledger since a given moment in time.
     *
     * This method is used to bootstrap a new node with the
     * vote staples that have been added to the ledger since
     * the last time the node was updated.
     *
     * It is a paginated request and may return only a partial set of
     * vote staples for a given request if there are more vote staples
     * to be fetched from the representative.  The `moment` parameter
     * can be used to fetch the next set of vote staples, and the
     * `bloomFilter` parameter can be used to tell the server not to
     * include any duplicate vote staples that have already been sent
     * as part of the last page in the case of a `moment` overlap.
     * Once all vote staples have been fetched an empty array will be
     * returned.
     *
     * The bloom filter is constructed from the bytes of the vote staples
     * to exclude.
     *
     * @param moment The moment in time to get the vote staples after
     * @param limit The maximum number of vote staples to return
     * @param bloomFilter The bloom filter to use to filter the vote staples which have already been sent
     * @return The list of vote staples that have been added to the representative's ledger since the given moment in time
     */
    async getVoteStaplesAfter(moment, limit, bloomFilter) {
        const query = {
            start: moment.toISOString()
        };
        if (limit) {
            query.limit = limit.toString(10);
        }
        if (bloomFilter) {
            query.bloomFilter = bloomFilter;
        }
        const votesInfo = await __classPrivateFieldGet(this, _Client_instances, "m", _Client_api).call(this, 'ANY', 'GET /node/bootstrap/votes', {
            queryParams: query
        });
        const retval = [];
        for (const voteStr of votesInfo.voteStaples) {
            const voteStaple = new lib_1.default.Vote.Staple(voteStr);
            retval.push(voteStaple);
        }
        return (retval);
    }
    /**
     * Get the pending block for a given account.  This will return the
     * block on the representative's side ledger that is pending vote
     * completion.  This is used to recover the pending block for an
     * account that has not been published yet.
     *
     * @param account The account to get the pending block for
     * @return The pending block for the account or null if there is no
     *         pending block
     */
    async getPendingBlock(account) {
        const accountPubKey = account.publicKeyString.get();
        const getPendingAccountBlock = async (rep) => {
            const pending = await __classPrivateFieldGet(this, _Client_instances, "m", _Client_api).call(this, rep, 'GET /node/ledger/account/:account/pending', {
                args: {
                    account: accountPubKey
                }
            });
            if (!account.comparePublicKey(pending.account)) {
                throw (new Error('Invalid account data received'));
            }
            if (isGetAccountStateAPIResponseFailure(pending)) {
                throw (new Error(pending.error));
            }
            return (pending);
        };
        const pendingPromises = [];
        for (const rep of __classPrivateFieldGet(this, _Client_reps, "f")) {
            pendingPromises.push(getPendingAccountBlock(rep));
        }
        const pendingResults = await Promise.allSettled(pendingPromises);
        const pendingBlocks = {};
        let successorBlock;
        for (const result of pendingResults) {
            if (result.status === 'fulfilled') {
                const block = result.value.block;
                if (block !== null) {
                    pendingBlocks[block.$hash]++;
                    // Return the first block or the block that is repeated on the most reps
                    if (!successorBlock || pendingBlocks[block.$hash] > pendingBlocks[successorBlock.hash.toString()]) {
                        successorBlock = new block_1.default(block);
                    }
                }
            }
        }
        if (successorBlock === undefined) {
            return (null);
        }
        return (successorBlock);
    }
    /**
     * Get the successor block for a given block.  This will return the
     * block on the representative's ledger that comes after the given block
     *
     * @param blockOrHash The block or hash to get the successor for
     * @param rep The representative account to get the successor block from
     * @return The successor block for the block or null if there is no
     *         successor block
     */
    async getSuccessorBlock(blockOrHash, rep = 'ANY') {
        let blockHash;
        if (block_1.default.isInstance(blockOrHash)) {
            blockHash = blockOrHash.hash.toString();
        }
        else if (block_1.BlockHash.isInstance(blockOrHash)) {
            blockHash = blockOrHash.toString();
        }
        else {
            blockHash = blockOrHash;
        }
        const successor = await __classPrivateFieldGet(this, _Client_instances, "m", _Client_api).call(this, rep, 'GET /node/ledger/block/:blockhash/successor', {
            args: {
                blockhash: blockHash
            }
        });
        if (successor.successorBlock) {
            return (new block_1.default(successor.successorBlock));
        }
        return (null);
    }
    /**
     * Recover any unpublished or half-publish account artifacts
     *
     * @param account Account to recover
     * @param publish Publish the recovered staple to the network (default is true)
     */
    async recoverAccount(account, publish = true) {
        const successorBlock = await this.getPendingBlock(account);
        if (!successorBlock) {
            return (null);
        }
        const getVotes = async (rep, hash) => {
            let votes = null;
            try {
                votes = await __classPrivateFieldGet(this, _Client_instances, "m", _Client_getVotes).call(this, hash, 'side', rep);
            }
            catch {
                /* Ignore */
            }
            return ({
                rep: rep,
                votes: votes
            });
        };
        const votePromises = [];
        for (const rep of __classPrivateFieldGet(this, _Client_reps, "f")) {
            votePromises.push(getVotes(rep, successorBlock.hash));
        }
        const votesInfo = await Promise.all(votePromises);
        if (votesInfo.length === 0) {
            return (null);
        }
        /* Arrays of permanent or temporary votes from reps */
        let permVotes = [];
        let tempVotes = [];
        /* Arrays of reps that generated permanent or temporary votes */
        const permReps = [];
        const tempReps = [];
        /* Any reps that did not generate any vote */
        const missingReps = [];
        for (const repInfo of votesInfo) {
            const repVotes = repInfo.votes;
            if (repVotes === null) {
                missingReps.push(repInfo.rep);
            }
            else {
                for (const vote of repVotes) {
                    if (vote.$permanent === true) {
                        permVotes.push(vote);
                        permReps.push(repInfo.rep);
                    }
                    else {
                        tempVotes.push(vote);
                        tempReps.push(repInfo.rep);
                    }
                }
            }
        }
        /*
         * Go fetch all the blocks being voted on, since the successor
         * is just the "next" block but the vote could have been for
         * many blocks
         */
        let foundVote = permVotes[0];
        if (foundVote === undefined) {
            foundVote = tempVotes[0];
        }
        const blockHashes = foundVote.blocks;
        const votedOnBlocksOrNull = await Promise.all(blockHashes.map(async (blockHash) => {
            for (const repInfo of __classPrivateFieldGet(this, _Client_reps, "f")) {
                const block = await this.getBlock(blockHash, 'both', repInfo);
                if (block !== null) {
                    return (block);
                }
            }
            return (null);
        }));
        const containsNull = votedOnBlocksOrNull.find(function (blockOrNull) {
            return (blockOrNull === null);
        });
        if (containsNull !== undefined) {
            const blockHashesStr = blockHashes.map(function (blockHash) {
                return (blockHash.toString());
            });
            const votedOnBlocksStr = votedOnBlocksOrNull.map(function (blockOrNull) {
                if (blockOrNull === null) {
                    return ('null');
                }
                return (blockOrNull.hash.toString());
            });
            throw (new Error(`FATAL: Unable to recover ${account.publicKeyString.get()} because we are not able to get one of the blocks that was voted on, set: ${blockHashesStr.join(', ')}, found ${votedOnBlocksStr.join(', ')}`));
        }
        const votedOnBlocks = votedOnBlocksOrNull.filter(function (blockOrNull) {
            return (blockOrNull !== null);
        });
        /*
         * If additional permanent votes are needed, go get them
         */
        if (permVotes.length !== __classPrivateFieldGet(this, _Client_reps, "f").length) {
            let newTempVotes = [];
            if (tempVotes.length !== __classPrivateFieldGet(this, _Client_reps, "f").length) {
                try {
                    newTempVotes = await __classPrivateFieldGet(this, _Client_instances, "m", _Client_requestVotes).call(this, votedOnBlocks, undefined, missingReps);
                }
                catch {
                    /* Ignore */
                }
                tempVotes = [...tempVotes, ...newTempVotes];
            }
            const missingPermReps = __classPrivateFieldGet(this, _Client_reps, "f").filter(rep => !permReps.includes(rep));
            try {
                const newPermVotes = await __classPrivateFieldGet(this, _Client_instances, "m", _Client_requestVotes).call(this, votedOnBlocks, tempVotes, missingPermReps);
                permVotes = [...permVotes, ...newPermVotes];
            }
            catch {
                /* Ignore */
            }
        }
        /*
         * Construct the vote staple from the recovered blocks and full set of votes
         */
        const voteStaple = lib_1.default.Vote.Staple.fromVotesAndBlocks(permVotes, votedOnBlocks);
        if (publish) {
            /*
             * Try to publish the staple
             */
            await this.transmitStaple(voteStaple);
        }
        return (voteStaple);
    }
    /**
     * Sync any partially-published account artifacts
     *
     * @param account Account to sync
     * @param publish Publish the synced staple to the network (default is true)
     */
    async syncAccount(account, publish = true, reps) {
        await __classPrivateFieldGet(this, _Client_updateRepsPromise, "f");
        if (reps === undefined) {
            reps = this.representatives;
        }
        const repAccountInfoPromises = [];
        for (const rep of reps) {
            repAccountInfoPromises.push((async () => {
                const info = await this.getAccountInfo(account, rep);
                return ({
                    rep,
                    info
                });
            })());
        }
        const accountInfoSettled = await Promise.allSettled(repAccountInfoPromises);
        const accountInfo = [];
        for (const info of accountInfoSettled) {
            if (info.status === 'fulfilled') {
                accountInfo.push(info.value);
            }
        }
        const accountInfoSorted = accountInfo.sort(function (a, b) {
            return (Number(BigInt(a.info.currentHeadBlockHeight ?? -1) - BigInt(b.info.currentHeadBlockHeight ?? -1)));
        });
        if (accountInfoSorted[0].info.currentHeadBlockHeight === accountInfoSorted[accountInfoSorted.length - 1].info.currentHeadBlockHeight) {
            // Block Heights match so return
            return (null);
        }
        let lowestHead = accountInfoSorted[0].info.currentHeadBlock;
        if (lowestHead === null) {
            lowestHead = block_1.default.getAccountOpeningHash(account).toString();
        }
        // Get the missing successor block and vote staple from the rep with the highest block height
        const successorBlock = await this.getSuccessorBlock(lowestHead, accountInfoSorted[accountInfoSorted.length - 1].rep);
        if (successorBlock === null) {
            return (null);
        }
        const successorStaple = await this.getVoteStaple(successorBlock.hash, 'main', accountInfoSorted[accountInfoSorted.length - 1].rep);
        if (successorStaple === null) {
            return (null);
        }
        if (publish === true) {
            await this.transmitStaple(successorStaple, [accountInfoSorted[0].rep]);
        }
        const updatedAccountInfo = await this.getAccountInfo(account, accountInfoSorted[0].rep);
        if (updatedAccountInfo.currentHeadBlockHeight === accountInfoSorted[0].info.currentHeadBlockHeight) {
            throw (new client_1.default('CLIENT_SYNC_PUBLISH_FAILED', `Client sync found a missing staple: ${successorStaple.blocksHash}, but it could not be published to rep: ${accountInfoSorted[0].rep.key.publicKeyString.get()}`));
        }
        return (successorStaple);
    }
    async getVoteQuotes(blocks) {
        return (await __classPrivateFieldGet(this, _Client_instances, "m", _Client_requestQuotes).call(this, blocks));
    }
    /** Work in progress */
    async getLedgerChecksum(rep = 'ANY') {
        const checksumResponse = await __classPrivateFieldGet(this, _Client_instances, "m", _Client_api).call(this, rep, 'GET /node/ledger/checksum');
        return (checksumResponse);
    }
    /**
     * Get the version of the node for a given representative, if no
     * representative is specified then the version of the "best"
     * representative will be returned.
     */
    async getVersion(rep = 'ANY') {
        const version = await __classPrivateFieldGet(this, _Client_instances, "m", _Client_api).call(this, rep, 'GET /node/version');
        return (version);
    }
}
exports.Client = Client;
_Client_apiRaw = 
/**
 * API dispatching routine
 */
async function _Client_apiRaw(rep, api, method, options = {}) {
    const startTime = Date.now();
    options = {
        maxRetries: 32,
        ...options
    };
    let delay = 1;
    let result;
    let resultThrow;
    for (let retry = 0; retry < Number.MAX_SAFE_INTEGER; retry++) {
        if (rep === 'ANY') {
            if (__classPrivateFieldGet(this, _Client_weightOrderedReps, "f").length === 0) {
                await __classPrivateFieldGet(this, _Client_updateRepsPromise, "f");
            }
            rep = __classPrivateFieldGet(this, _Client_weightOrderedReps, "f")[0] ?? __classPrivateFieldGet(this, _Client_reps, "f")[0];
        }
        const repURL = rep.endpoints.api;
        let fetchURL = `${repURL}${api}`;
        let shouldFail = false;
        resultThrow = undefined;
        try {
            this.stats.api.called++;
            let requestBody;
            if (options.body !== undefined) {
                requestBody = JSON.stringify(options.body);
            }
            let queryParams;
            if (options.queryParams !== undefined) {
                const normalizedParams = Object.fromEntries(Object.entries(options.queryParams).filter(function (keyValue) {
                    const value = keyValue[1];
                    if (value === undefined) {
                        return (false);
                    }
                    return (true);
                }));
                if (Object.keys(normalizedParams).length === 0) {
                    queryParams = undefined;
                }
                else {
                    queryParams = normalizedParams;
                }
            }
            if (queryParams !== undefined) {
                const urlParams = new URLSearchParams(queryParams);
                fetchURL = `${fetchURL}?${urlParams.toString()}`;
            }
            if (fetchURL.length > 8192) {
                shouldFail = true;
                throw (new Error('#api() URL Must not be over 8KiB'));
            }
            const response = await fetch(fetchURL, {
                method: method,
                headers: {
                    'content-type': 'application/json',
                    'user-agent': `KeetaNet/v${version_1.version} (JS)`
                },
                body: requestBody
            });
            if (response === undefined) {
                throw (new Error('Failed to publish (undefined)'));
            }
            if (!response.ok) {
                try {
                    const errorInfo = await response.json();
                    if (errorInfo.error === true) {
                        const keetaNetError = error_1.KeetaNetError.fromJSON(errorInfo);
                        try {
                            if (ledger_1.KeetaNetLedgerVoteError.isInstance(keetaNetError)) {
                                for (const account of keetaNetError.accounts) {
                                    await this.syncAccount(account);
                                }
                                continue;
                            }
                        }
                        catch {
                            // ignored error parsing KeetaNet Error just return original
                        }
                        resultThrow = keetaNetError;
                        break;
                    }
                }
                catch (errorResponse) {
                    /* Ignored */
                }
                /**
                 * If we get a fatal error, give up
                 */
                if (response.status >= 500) {
                    shouldFail = true;
                }
                let errorMessage = 'Failed to make API call (not ok)';
                try {
                    errorMessage = `${errorMessage}: ${await response.text()}`;
                }
                catch {
                    /* Ignore any errors, we will just have an incomplete error message */
                }
                throw (new Error(errorMessage));
            }
            const data = await response.json();
            if (!data) {
                throw (new Error('Failed to make API call (no data)'));
            }
            if (typeof data !== 'object' || data === null) {
                throw (new Error('Failed to make API call (malformed data)'));
            }
            if (Array.isArray(data)) {
                result = [...data];
            }
            else {
                result = { ...data };
            }
        }
        catch (publishError) {
            this.stats.api.failures++;
            const now = Date.now();
            if ((now - startTime) > 5000) {
                this.logger.warn(`API Request to ${fetchURL} failed.  It has been failing for ${now - startTime}ms, latest error: (publish)`, publishError, '(throw)', resultThrow);
            }
            if (options.maxRetries !== undefined) {
                if (retry > options.maxRetries) {
                    shouldFail = true;
                }
            }
            if (shouldFail) {
                if (!resultThrow) {
                    resultThrow = publishError;
                }
                break;
            }
            delay *= 2;
            if (delay > 500) {
                delay = 500;
            }
            await (0, helper_1.asleep)(delay);
            continue;
        }
        break;
    }
    if (resultThrow) {
        const toThrow = error_1.KeetaNetError.fromJSON(resultThrow);
        throw (toThrow);
    }
    return (result);
}, _Client_api = async function _Client_api(rep, api, options = {}) {
    // eslint-disable-next-line @typescript-eslint/consistent-type-assertions
    const method = api.split(' ')[0];
    let path = api.split(' ').slice(1).join(' ').replace('/_root', '');
    if (options.args !== undefined) {
        for (const key in options.args) {
            path = path.replace(`:${key}`, encodeURIComponent(options.args[key]));
        }
    }
    // eslint-disable-next-line @typescript-eslint/consistent-type-assertions
    return await __classPrivateFieldGet(this, _Client_instances, "m", _Client_apiRaw).call(this, rep, path, method, options);
}, _Client_requestVoteOrQuote = async function _Client_requestVoteOrQuote(api, request, reps = __classPrivateFieldGet(this, _Client_reps, "f"), quotes = []) {
    let recentVotingError;
    let recentVotingErrorWeight;
    const quoteMap = new Map();
    for (const quote of quotes) {
        quoteMap.set(quote.issuer.publicKeyAndTypeString, quote);
    }
    const votePromises = [];
    for (const rep of reps) {
        const quote = quoteMap.get(rep.key.publicKeyAndTypeString);
        if (quote !== undefined) {
            request.quote = Buffer.from(quote.toBytes()).toString('base64');
        }
        votePromises.push((async () => {
            try {
                const apiResult = await __classPrivateFieldGet(this, _Client_instances, "m", _Client_api).call(this, rep, api, {
                    body: request
                });
                return (apiResult);
            }
            catch (voteError) {
                const weight = rep.weight ?? 0n;
                if (recentVotingErrorWeight === undefined || weight > recentVotingErrorWeight) {
                    recentVotingError = voteError;
                    recentVotingErrorWeight = weight;
                }
            }
            return (undefined);
        })());
    }
    const votesObjects = await Promise.allSettled(votePromises);
    const retval = [];
    let voteSettlementError;
    for (const voteObjectWrapperSettled of votesObjects) {
        if (voteObjectWrapperSettled.status === 'rejected') {
            voteSettlementError = voteObjectWrapperSettled.reason;
            continue;
        }
        const voteObjectWrapper = voteObjectWrapperSettled.value;
        if (voteObjectWrapper === undefined) {
            continue;
        }
        if ('vote' in voteObjectWrapper) {
            const voteObject = voteObjectWrapper['vote'];
            const voteBin = Buffer.from(voteObject['$binary'], 'base64');
            const vote = new lib_1.default.Vote(voteBin);
            retval.push(vote);
        }
        else if ('quote' in voteObjectWrapper) {
            const voteObject = voteObjectWrapper['quote'];
            const quoteBin = Buffer.from(voteObject['$binary'], 'base64');
            const quote = new lib_1.default.Vote.Quote(quoteBin);
            retval.push(quote);
        }
        else {
            throw (new Error('Vote or Quote not in response'));
        }
    }
    if (retval.length === 0 && recentVotingError !== undefined) {
        if (recentVotingError !== undefined) {
            /*
             * We're re-throwing this error, it is one
             * of the rejected promises
             */
            throw (recentVotingError);
        }
        else if (voteSettlementError !== undefined) {
            /*
             * We're re-throwing this error, it is one
             * of the rejected promises
             */
            throw (voteSettlementError);
        }
        else {
            throw (new Error('Unknown error requesting all votes'));
        }
    }
    return (retval);
}, _Client_requestQuotes = async function _Client_requestQuotes(blocks, reps = __classPrivateFieldGet(this, _Client_reps, "f")) {
    // Wait for reps promise to ensure we have the right list of reps and their weight
    await __classPrivateFieldGet(this, _Client_updateRepsPromise, "f");
    const request = {
        blocks: blocks.map(function (block) {
            return (Buffer.from(block.toBytes()).toString('base64'));
        })
    };
    const quotes = await __classPrivateFieldGet(this, _Client_instances, "m", _Client_requestVoteOrQuote).call(this, 'POST /vote/quote', request, reps);
    return (quotes);
}, _Client_requestVotes = async function _Client_requestVotes(blocks, otherVotes, reps = __classPrivateFieldGet(this, _Client_reps, "f"), quotes) {
    // Wait for reps promise to ensure we have the right list of reps and their weight
    await __classPrivateFieldGet(this, _Client_updateRepsPromise, "f");
    const request = {
        blocks: blocks.map(function (block) {
            return (Buffer.from(block.toBytes()).toString('base64'));
        })
    };
    if (otherVotes !== undefined) {
        if (otherVotes.length === 0) {
            throw (new Error('requestVotes() otherVotes must not have a length of 0'));
        }
        request.votes = otherVotes.map(function (vote) {
            return (Buffer.from(vote.toBytes()).toString('base64'));
        });
        if (reps === __classPrivateFieldGet(this, _Client_reps, "f")) {
            reps = otherVotes.map((vote) => {
                const voteRepPubKey = vote.issuer.publicKeyString.get();
                return (__classPrivateFieldGet(this, _Client_reps, "f").find(function (rep) {
                    const checkRepPubKey = rep.key.publicKeyString.get();
                    if (checkRepPubKey === voteRepPubKey) {
                        return (true);
                    }
                    return (false);
                }));
            }).filter(function (rep) {
                if (rep === undefined) {
                    return (false);
                }
                return (true);
            });
        }
    }
    const votes = await __classPrivateFieldGet(this, _Client_instances, "m", _Client_requestVoteOrQuote).call(this, 'POST /vote/_root', request, reps, quotes);
    return (votes);
}, _Client_getVotes = async function _Client_getVotes(blockhash, side = 'main', rep = 'ANY') {
    const query = {
        side: (0, common_1.assertLedgerStorage)(side)
    };
    if (blockhash === null || blockhash === undefined) {
        throw (new Error('"blockhash" must be a string or BlockHash'));
    }
    if (typeof blockhash !== 'string') {
        blockhash = blockhash.toString();
    }
    /**
     * Get all the vote information for a given block
     */
    const votesInfo = await __classPrivateFieldGet(this, _Client_instances, "m", _Client_api).call(this, rep, 'GET /vote/:blockhash', {
        queryParams: query,
        args: {
            blockhash: blockhash
        }
    });
    /**
     * If the response looks malformed, return that we couldn't look this up
     */
    if (votesInfo.blockhash === null) {
        throw (new Error('Vote Response Is Malformed'));
    }
    /**
     * If there are no votes, refuse to attempt to create a staple
     */
    const votesJSON = votesInfo.votes;
    if (votesJSON === null) {
        return (null);
    }
    /**
     * Construct a Vote object from every vote
     */
    const votes = votesJSON.map(function (voteJSON) {
        const voteBinary = Buffer.from(voteJSON['$binary'], 'base64');
        const vote = new lib_1.default.Vote(voteBinary);
        return (vote);
    });
    /**
     * If there are no votes return null
     */
    if (votes.length === 0) {
        return (null);
    }
    return (votes);
}, _Client_getBuilderRenderOptions = function _Client_getBuilderRenderOptions(network) {
    return ({
        network,
        getPrevious: async (acct) => {
            const { currentHeadBlock } = await this.getAccountInfo(acct);
            return (currentHeadBlock);
        }
    });
}, _Client_urlSeparatedAccounts = function _Client_urlSeparatedAccounts(accounts) {
    const pubKeys = accounts.map(account => account_1.default.toPublicKeyString(account));
    return (pubKeys.join(','));
}, _Client_formatAllBalances = function _Client_formatAllBalances(balances) {
    return (balances.map(function (entry) {
        return ({
            token: lib_1.default.Account.fromPublicKeyString(entry.token).assertKeyType(account_1.AccountKeyAlgorithm.TOKEN),
            balance: BigInt(entry.balance)
        });
    }));
}, _Client_parseResponsePermissions = function _Client_parseResponsePermissions(permissions) {
    const [base, external] = permissions.map(val => BigInt(val));
    return (new lib_1.default.Permissions(base, external));
}, _Client_formatAccountInfo = function _Client_formatAccountInfo(raw) {
    const info = {
        name: raw.name,
        description: raw.description,
        metadata: raw.metadata
    };
    if (raw.supply !== undefined) {
        info.supply = BigInt(raw.supply);
    }
    if (raw.defaultPermission !== undefined) {
        info.defaultPermission = __classPrivateFieldGet(this, _Client_instances, "m", _Client_parseResponsePermissions).call(this, raw.defaultPermission);
    }
    return (info);
}, _Client_parseAccountInfo = function _Client_parseAccountInfo(account, accountInfo) {
    account = account_1.default.toAccount(account);
    if (!account.comparePublicKey(accountInfo.account)) {
        throw (new Error('Invalid account data received'));
    }
    if (isGetAccountStateAPIResponseFailure(accountInfo)) {
        throw (new Error(accountInfo.error));
    }
    let currentHeadBlock = null;
    if (accountInfo.currentHeadBlock !== null) {
        currentHeadBlock = new block_1.BlockHash(accountInfo.currentHeadBlock).toString();
    }
    let currentRepresentative = null;
    if (accountInfo.representative) {
        currentRepresentative = lib_1.default.Account.fromPublicKeyString(accountInfo.representative).assertAccount();
    }
    return ({
        account: lib_1.default.Account.fromPublicKeyString(accountInfo.account),
        currentHeadBlock: currentHeadBlock,
        currentHeadBlockHeight: accountInfo.currentHeadBlockHeight,
        representative: currentRepresentative,
        info: __classPrivateFieldGet(this, _Client_instances, "m", _Client_formatAccountInfo).call(this, accountInfo.info),
        balances: __classPrivateFieldGet(this, _Client_instances, "m", _Client_formatAllBalances).call(this, accountInfo.balances)
    });
}, _Client_parsePermissionEntries = function _Client_parsePermissionEntries(entries) {
    return (entries.map(entry => {
        return ({
            principal: lib_1.default.Account.fromPublicKeyString(entry.principal),
            entity: lib_1.default.Account.fromPublicKeyString(entry.entity),
            permissions: __classPrivateFieldGet(this, _Client_instances, "m", _Client_parseResponsePermissions).call(this, entry.permissions),
            target: lib_1.default.Account.fromPublicKeyString(entry.target)
        });
    }));
}, _Client_mapCertificateWithBundleResult = function _Client_mapCertificateWithBundleResult(input) {
    let intermediates = null;
    if (input.intermediates) {
        const intermediateCertificates = input.intermediates.map(function (intermediate) {
            return (new certificate_1.Certificate(intermediate));
        });
        intermediates = new certificate_2.CertificateBundle(intermediateCertificates);
    }
    return ({
        certificate: new certificate_1.Certificate(input.certificate),
        intermediates: intermediates
    });
}, _Client_parseRepInfo = function _Client_parseRepInfo(info) {
    return ({
        ...info,
        weight: BigInt(info.weight)
    });
};
/**
 * A reference to the {@link UserClientBuilder} class, which is the high-level
 * interface to building blocks.
 */
Client.Builder = builder_1.UserClientBuilder;
/**
 * A reference to the {@link Config} class, which provides access to
 * the KeetaNet configuration utilities.
 */
Client.Config = Config;
/**
 * The default logger to use for new instances of the {@link Client} class.
 * This is set to the `console` object by default, but can be changed
 * by the application.
 */
Client.DefaultLogger = console;
Client.updateRepsInterval = 5 * 60 * 1000; // 5 minutes
/**
 * Check if the given object is an instance of the {@link Client} class.
 * This is preferred to using the `instanceof` operator because it will
 * work across different contexts.
 */
Client.isInstance = (0, helper_2.checkableGenerator)(Client);
const defaultListenerOptions = {
    change: {
        fallbackFrequency: 60 * 1000
    }
};
// Type guard function to check if a string is a valid UserClientEventName
function isUserClientEventName(eventName) {
    return (eventName === 'change'); // Add checks here for each valid key of UserClientListenerTypes
}
/**
 *   The UserClient class provides a high-level interface, user-oriented
 *   interface to the Keeta network.  It is designed to be easy to use and
 *   handle the most common cases for applications building on top of the
 *   Keeta network.
 *
 * @summary
 *  High-level, user-oriented interface to the KeetaNet network.
 *
 * @example
 *   ```typescript
 *   import { UserClient } from '@keetanetwork/keetanet-client';
 *   import { lib as KeetaNetLib } from '@keetanetwork/keetanet-client`;
 *   const seed = '...'; // 64 character hex seed
 *   const account = KeetaNetLib.Account.fromSeed(seed, 0);
 *   const client = UserClient.fromNetwork('test');
 *   const blocks = await client.chain();
 *   ```
 */
class UserClient {
    /**
     * Create an instance of the UserClient class from a specific
     * representative.  This will use the given representative to
     * initialize the connection to the network, however it will
     * find other representatives to use for the network as well.
     *
     * This is useful for testing and development purposes, but in
     * general it is recommended to use the {@link fromNetwork}
     * method to create a new instance of the UserClient class.
     */
    static fromSimpleSingleRep(hostname, ssl, repKey, networkID, networkAlias, signer, options) {
        let sslString = '';
        if (ssl) {
            sslString = 's';
        }
        const client = new Client([
            {
                key: account_1.default.toAccount(repKey),
                endpoints: {
                    api: `http${sslString}://${hostname}/api`,
                    p2p: `ws${sslString}://${hostname}/p2p`
                }
            }
        ]);
        return (new UserClient({
            client,
            signer,
            network: networkID,
            networkAlias: networkAlias,
            ...options
        }));
    }
    /**
     * A helper method to get the configuration from the network alias
     * and options.  This will use the default representatives for the
     * network based on the {@link Config | configuration}.
     *
     * @param network The {@link Config.Networks | network} to use to generate the configuration
     * @param options The {@link UserClientOptions | options} to use to generate the configuration
     * @return The configuration object for the {@link UserClient} class
     */
    static getConfigFromNetwork(network, options) {
        const config = Config.getDefaultConfig(network);
        const client = new Client(config.representatives);
        return ({
            client: client,
            network: config.network,
            networkAlias: network,
            publishAidURL: config.publishAidURL,
            ...options
        });
    }
    /**
     * Construct a new instance of the {@link UserClient} class from the given
     * network name.  This will use the default representatives for the
     * network based on the configuration.
     *
     * New instances should be cleaned up with the {@link destroy}() method
     * when they are no longer needed.
     *
     * This is the recommended way to create a new instance of the {@link UserClient} class.
     *
     * @param network The network to use for this instance of the {@link UserClient} class
     * @param signer The account to use for this instance of the {@link UserClient} class, or null if this is a read-only client
     * @param options The options to use for this instance of the {@link UserClient} class
     * @return A new instance of the {@link UserClient} class
     * @expandType Config.Networks
     * @expandType UserClientOptions
     */
    static fromNetwork(network, signer, options) {
        const config = {
            ...UserClient.getConfigFromNetwork(network, options),
            signer: signer
        };
        return (new UserClient(config));
    }
    /**
     * Helper method to filter a list of vote staples into
     * a list of blocks and operations that are related to
     * a given account.
     *
     * @param voteStaples The list of vote staples to filter
     * @param account The account to search for operations related to
     * @return An array of filtered operations for the given account, ordered by vote staple hash, then by block, and then containing each operation
     */
    static filterStapleOperations(voteStaples, account) {
        const filteredOperations = {};
        // For each staple
        for (const staple of voteStaples) {
            const stapleHash = staple.blocksHash.toString();
            filteredOperations[stapleHash] = [];
            // For each block
            for (const block of staple.blocks) {
                const blockOperations = [];
                // If block is produced by the account being filtered, included all operations
                if (block.account.comparePublicKey(account)) {
                    blockOperations.push(...block.operations);
                }
                else {
                    // If the block is for another account then filter the operations for the given account
                    for (const ops in block.operations) {
                        const operation = block.operations[ops];
                        const principals = [];
                        switch (operation.type) {
                            case operations_1.OperationType.SEND:
                            case operations_1.OperationType.SET_REP:
                                principals.push(operation.to);
                                break;
                            case operations_1.OperationType.MODIFY_PERMISSIONS:
                                principals.push(operation.principal);
                                break;
                            case operations_1.OperationType.CREATE_IDENTIFIER:
                                principals.push(operation.identifier);
                                break;
                            case operations_1.OperationType.TOKEN_ADMIN_MODIFY_BALANCE:
                            case operations_1.OperationType.SET_INFO:
                            case operations_1.OperationType.TOKEN_ADMIN_SUPPLY:
                            case operations_1.OperationType.MANAGE_CERTIFICATE:
                                // Do nothing for these, they don't reference an account directly
                                break;
                            case operations_1.OperationType.RECEIVE:
                                principals.push(operation.from);
                                if (operation.forward) {
                                    principals.push(operation.forward);
                                }
                                break;
                        }
                        if (principals.length > 0 && principals.some(principal => principal.comparePublicKey(account))) {
                            blockOperations.push(operation);
                        }
                    }
                }
                filteredOperations[stapleHash].push({
                    block,
                    filteredOperations: blockOperations
                });
            }
        }
        return (filteredOperations);
    }
    /**
     * Construct a new instance of the {@link UserClient} class from the given
     * configuration.  This will use the default representatives for the
     * network based on the configuration.
     *
     * New instances should be cleaned up with the {@link destroy} method
     * when they are no longer needed.
     *
     * The recommended way to create a new instance of the {@link UserClient} class
     * is to use the {@link fromNetwork} method.
     */
    constructor(config) {
        _UserClient_instances.add(this);
        _UserClient_config.set(this, void 0);
        _UserClient_client.set(this, void 0);
        _UserClient_listeners.set(this, void 0);
        _UserClient_intervals.set(this, void 0);
        _UserClient_previousAccountChangeData.set(this, void 0);
        _UserClient_socketPromise.set(this, void 0);
        _UserClient_filteredWebSocket.set(this, void 0);
        _UserClient_changePromise.set(this, void 0);
        // Tracking reconnection attempts
        _UserClient_reconnectAttempts.set(this, 0);
        _UserClient_RECONNECT_TIMEOUT.set(this, 1000);
        _UserClient_transientUserClients.set(this, new Set());
        /**
         * Indication of whether or not this client has been destroyed.
         */
        this.destroyed = false;
        if (config.signer !== null) {
            if (!config.signer.hasPrivateKey) {
                throw (new client_1.default('CLIENT_SIGNER_REQUIRES_PRIVATE_KEY', 'User Client Signer does not have a private key for signing'));
            }
            if (config.signer.isIdentifier()) {
                throw (new Error('Cannot construct UserClient with an identifier account'));
            }
        }
        __classPrivateFieldSet(this, _UserClient_client, config.client, "f");
        const { networkAddress, baseToken } = lib_1.default.Account.generateBaseAddresses(config.network);
        this.networkAddress = networkAddress;
        this.baseToken = baseToken;
        __classPrivateFieldSet(this, _UserClient_config, {
            generateFeeBlock: async (staple) => {
                const builder = this.initBuilder();
                const block = await builder.computeFeeBlock(staple);
                return (block);
            },
            ...config
        }, "f");
        // For event listeners/polling
        __classPrivateFieldSet(this, _UserClient_listeners, {}, "f");
        __classPrivateFieldSet(this, _UserClient_intervals, {}, "f");
        __classPrivateFieldSet(this, _UserClient_changePromise, undefined, "f");
    }
    /**
     * Generate and publish the blocks needed to initialize a new network
     * with the given parameters.
     *
     * This is generally only needed once per network and is used to
     * initialize the network with a base token and a representative
     * in order to start-up the network.
     *
     * @param initOpts The options to use for the initialization
     * @param initOpts.addSupplyAmount The amount of supply to add to the network of the base token
     * @param initOpts.delegateTo The representative account to delegate the supply to
     * @param initOpts.voteSerial The serial number to use for the vote -- must never be reused by the representative
     * @param options The options to use for the request
     * @returns The vote staple that was generated and whether it was able to be published
     */
    async initializeNetwork(initOpts, options = {}) {
        const { delegateTo = this.client.representatives[0].key, addSupplyAmount, voteSerial = 0n, baseTokenInfo } = initOpts;
        if (this.signer === null) {
            throw (new Error('May not initialize chain with a read-only UserClient (signer is null)'));
        }
        const { voteStaple } = await (0, initial_1.generateInitialVoteStaple)({
            network: this.network,
            initialTrustedAccount: this.signer,
            voteSerial: voteSerial,
            addSupply: {
                delegate: true,
                delegateTo: delegateTo,
                recipient: __classPrivateFieldGet(this, _UserClient_instances, "m", _UserClient_getAccount).call(this, options).assertAccount(),
                amount: addSupplyAmount
            },
            baseTokenInfo
        });
        return (await this.client.transmitStaple(voteStaple));
    }
    /**
     * Modify both the token supply (mint/burn) and account balance
     * for a given account of a given token.
     *
     * This will mint if a positive amount is given and burn if a negative
     * amount is given, and the add or subtract the same amount from the
     * account balance.
     *
     * @param amount The amount to add or subtract from the token supply and account balance
     * @param token The token to modify the supply and balance for
     * @param options The options to use for the request
     * @return The vote staple that was generated and whether it was able to be published
     */
    async modTokenSupplyAndBalance(amount, token, options = {}) {
        const builder = this.initBuilder(options);
        // If amount is negative then reduce account balance before modifying token supply otherwise increase in reverse order
        const negative = amount < 0n;
        if (negative) {
            builder.modifyTokenBalance(token, amount, false, { account: options.account });
        }
        builder.modifyTokenSupply(amount, { account: token });
        if (!negative) {
            builder.modifyTokenBalance(token, amount, false, { account: options.account });
        }
        const retval = await this.publishBuilder(builder);
        return (retval);
    }
    /**
     * Create a new {@link UserClientBuilder} instance for this client.  This
     * is used to create a new builder for adding operations to which are then
     * converted into the appropriate set of blocks.
     *
     * @param options The options to use for the builder
     * @return A new {@link UserClientBuilder} instance
     */
    initBuilder(options = {}) {
        if (this.signer === null) {
            throw (new Error('May not construct blocks with a read-only UserClient (signer is null)'));
        }
        /*
         * If a publish aid is requested for a builder we need a new
         * user client to manage that
         */
        // eslint-disable-next-line @typescript-eslint/no-this-alias
        let userClient = this;
        if (options.usePublishAid !== __classPrivateFieldGet(this, _UserClient_config, "f").usePublishAid || options.publishAidURL !== __classPrivateFieldGet(this, _UserClient_config, "f").publishAidURL) {
            userClient = new UserClient({
                ...__classPrivateFieldGet(this, _UserClient_config, "f"),
                client: __classPrivateFieldGet(this, _UserClient_client, "f"),
                account: this.account,
                signer: this.signer,
                ...options
            });
            __classPrivateFieldGet(this, _UserClient_transientUserClients, "f").add(new WeakRef(userClient));
        }
        return (__classPrivateFieldGet(this, _UserClient_client, "f").makeBuilder({
            signer: this.signer,
            account: __classPrivateFieldGet(this, _UserClient_instances, "m", _UserClient_getAccount).call(this, options),
            userClient: userClient
        }));
    }
    /**
     * Compute the blocks needed to publish a given builder.  This will
     * update the state of the builder and any new operations added after
     * this will generate new blocks.
     *
     * @param builder The builder to compute the blocks for
     * @return The blocks that were computed
     * @deprecated Use {@link UserClientBuilder.computeBlocks} instead
     */
    async computeBuilderBlocks(builder) {
        return (await __classPrivateFieldGet(this, _UserClient_client, "f").computeBuilderBlocks(this.network, builder));
    }
    /**
     * Compute the blocks needed to publish a given builder and then
     * publish those blocks to the network.  The builder should generally
     * not be used after this method is called as the blocks will
     * be published and the builder will be in an invalid state.
     *
     * In general, the {@link UserClientBuilder.publish} method should be used
     * instead of this one.
     *
     * @param builder The builder to publish
     * @param options options for publishing {@link PublishOptions }
     * @return The vote staple that was generated and whether it was able to be published
     */
    async publishBuilder(builder, options = {}) {
        if (options.generateFeeBlock === undefined) {
            options.generateFeeBlock = __classPrivateFieldGet(this, _UserClient_config, "f").generateFeeBlock;
        }
        if (!__classPrivateFieldGet(this, _UserClient_config, "f").usePublishAid) {
            return (await __classPrivateFieldGet(this, _UserClient_client, "f").transmitBuilder(builder, this.network, options));
        }
        await __classPrivateFieldGet(this, _UserClient_client, "f").computeBuilderBlocks(this.network, builder);
        const retval = await __classPrivateFieldGet(this, _UserClient_instances, "m", _UserClient_publishWithPublishAid).call(this, builder.blocks);
        return ({
            blocks: builder.blocks,
            publish: retval.publish,
            from: 'publish-aid'
        });
    }
    /**
     * Set the metadata for an account and publish the blocks to the
     * network.
     *
     * @param info The account info to set
     * @param options The options to use for the request
     * @return The vote staple that was generated and whether it was able to be published
     */
    async setInfo(info, options = {}) {
        const builder = this.initBuilder(options);
        builder.setInfo(info);
        return (await this.publishBuilder(builder));
    }
    async modifyCertificate(method, certificate, intermediates, options = {}) {
        const builder = this.initBuilder(options);
        builder.modifyCertificate(method, certificate, intermediates);
        return (await this.publishBuilder(builder));
    }
    async getCertificates(certificateHash, options = {}) {
        const account = options.account ?? this.account;
        if (certificateHash !== undefined) {
            return (await __classPrivateFieldGet(this, _UserClient_client, "f").getCertificateByHash(account, certificateHash));
        }
        return (await __classPrivateFieldGet(this, _UserClient_client, "f").getAllCertificates(account));
    }
    /**
     * Send some tokens from this account to another account.
     *
     * If an `external` identifier is provided, it will be included in the
     * Send operation and can be used by the recipient to identify the
     * transaction.
     *
     * @param to The account to send the tokens to
     * @param amount The amount of tokens to send (in base units)
     * @param token The token to send
     * @param external The external identifier to use for the transaction
     * @param options The options to use for the request
     * @param retries The number of times the request has been retried
     * @return The vote staple that was generated and whether it was able to be published
     */
    async send(to, amount, token, external, options = {}, retries = 0) {
        try {
            const builder = this.initBuilder(options);
            builder.send(account_1.default.toAccount(to), BigInt(amount), account_1.default.toAccount(token), external);
            const publish = await this.publishBuilder(builder);
            return (publish);
        }
        catch (transmitError) {
            let error = true;
            if (retries < 2) {
                if (error_1.KeetaNetError.isInstance(transmitError)) {
                    if (transmitError.code === 'LEDGER_SUCCESSOR_VOTE_EXISTS') {
                        const staple = await this.recover(true, options);
                        if (staple) {
                            error = false;
                            return (await this.send(to, amount, token, external, options, retries + 1));
                        }
                    }
                }
            }
            if (error) {
                throw (transmitError);
            }
        }
        throw (new Error('Unreachable code reached in UserClient.send'));
    }
    /**
     * Gets a quote for the cost for a given set of blocks from each representative
     * @param blocks
     * @returns A list of quotes from representatives the client knows about
     */
    async getQuotes(blocks) {
        return (await __classPrivateFieldGet(this, _UserClient_client, "f").getVoteQuotes(blocks));
    }
    /**
     * Generate a new identifier for the given type and publish the blocks
     *
     * @param type The type of identifier to generate
     * @param options The options to use for the request
     * @return The identifier that was generated
     */
    async generateIdentifier(type, options = {}) {
        const builder = this.initBuilder(options);
        const generated = builder.generateIdentifier(type);
        await this.publishBuilder(builder);
        return (generated);
    }
    /**
     * Update the permissions for a given account.  This will publish the
     * changes to the network.
     *
     * @param principal The account to update the permissions regarding for this account
     * @param permissions The permissions to set for the account
     * @param target The account to set the permissions for, if applicable for this permission
     * @param method The method to use for the permission, defaults to SET
     * @param options The options to use for the request
     * @return The vote staple that was generated and whether it was able to be published
     */
    async updatePermissions(principal, permissions, target, method, options = {}) {
        const builder = this.initBuilder(options);
        builder.updatePermissions(account_1.default.toAccount(principal), permissions, account_1.default.toAccount(target), method, options);
        return (await this.publishBuilder(builder));
    }
    /**
     * Get all the balances for the given account.  See {@link Client.getAllBalances}
     * for more information.
     *
     * @param options The options to use for the request
     * @return The balances for the account
     */
    async allBalances(options = {}) {
        return (await __classPrivateFieldGet(this, _UserClient_client, "f").getAllBalances(__classPrivateFieldGet(this, _UserClient_instances, "m", _UserClient_getAccount).call(this, options)));
    }
    /**
     * Get the balance for a given token for the given account.  See
     * {@link Client.getBalance} for more information.
     *
     * @param token The token to get the balance for
     * @param options The options to use for the request
     * @return The balance for the account of the given token
     */
    async balance(token, options = {}) {
        return (await __classPrivateFieldGet(this, _UserClient_client, "f").getBalance(__classPrivateFieldGet(this, _UserClient_instances, "m", _UserClient_getAccount).call(this, options), token));
    }
    /**
     * Get the current head block for the given account.  This will return
     * the hash of the current head block for the account or null if the
     * account has no blocks.
     *
     * @param options The options to use for the request
     * @return The hash of the current head block for the account or null
     *         if the account has no blocks
     */
    async head(options = {}) {
        const { currentHeadBlock } = await this.state(options);
        if (currentHeadBlock === null) {
            return (currentHeadBlock);
        }
        return (new block_1.default.Hash(currentHeadBlock));
    }
    /**
     * Get a specific block by its hash.  This will return the block
     * if it is known to the network or null if it is not.
     *
     * @param blockhash The hash of the block to get
     * @return The block if it is known to the network or null if it is not
     */
    async block(blockhash) {
        return (await __classPrivateFieldGet(this, _UserClient_client, "f").getBlock(blockhash));
    }
    /**
     * Get the chain for the given account.  This will return the chain
     * as {@link Client.getChain} does.
     *
     * @param query The query to use for the chain
     * @param options The options to use for the request
     * @return The chain for the account, paginated
     */
    async chain(query, options = {}) {
        return (await __classPrivateFieldGet(this, _UserClient_client, "f").getChain(__classPrivateFieldGet(this, _UserClient_instances, "m", _UserClient_getAccount).call(this, options), query));
    }
    /**
     * Get the history for the given account.  This will return the
     * history as {@link Client.getHistory} does.
     *
     * @param query The query to use for the history
     * @param options The options to use for the request
     * @return The history for the account, paginated
     */
    async history(query, options = {}) {
        const voteStapleEntries = await __classPrivateFieldGet(this, _UserClient_client, "f").getHistory(__classPrivateFieldGet(this, _UserClient_instances, "m", _UserClient_getAccount).call(this, options), query);
        const initialTrustedAccount = UserClient.Config.getDefaultConfig(__classPrivateFieldGet(this, _UserClient_config, "f").networkAlias).initialTrustedAccount;
        const retval = voteStapleEntries.map((voteStapleEntry) => {
            const effects = (0, effects_1.computeEffectOfBlocks)(voteStapleEntry.voteStaple.blocks, {
                baseToken: this.baseToken,
                networkAddress: this.networkAddress,
                initialTrustedAccount: initialTrustedAccount
            });
            return ({
                voteStaple: voteStapleEntry.voteStaple,
                effects: effects
            });
        });
        return (retval);
    }
    /**
     * Filter the given vote staples for the user client account.  See {@link UserClient.filterStapleOperations}
     * for more information.
     *
     * @param voteStaples The vote staples to filter
     * @param options The options to use for the request
     * @return The filtered operations for the given account, ordered by vote staple hash, then by block, and then containing each operation
     */
    filterStapleOperations(voteStaples, options = {}) {
        const account = __classPrivateFieldGet(this, _UserClient_instances, "m", _UserClient_getAccount).call(this, options);
        return (UserClient.filterStapleOperations(voteStaples, account));
    }
    /**
     * Get the current live state of the account.  This will return the
     * current state of the account as {@link Client.getAccountInfo} does.
     *
     * @param options The options to use for the request
     * @return The current state of the account
     */
    state(options = {}) {
        return (__classPrivateFieldGet(this, _UserClient_client, "f").getAccountInfo(__classPrivateFieldGet(this, _UserClient_instances, "m", _UserClient_getAccount).call(this, options)));
    }
    /**
     * List ACLs for the given account.  This will return the ACLs
     * that relate to specified entities.  See {@link Client.listACLsByPrincipal}
     * for more information.
     *
     * @param entities The list of entities to get the ACLs for
     * @param options The options to use for the request
     * @return The ACLs for the account
     */
    listACLsByPrincipal(entities = [], options = {}) {
        return (__classPrivateFieldGet(this, _UserClient_client, "f").listACLsByPrincipal(__classPrivateFieldGet(this, _UserClient_instances, "m", _UserClient_getAccount).call(this, options), entities));
    }
    /**
     * List ACLs for the given account.  This will return the ACLs
     * the account has set. See {@link Client.listACLsByEntity}
     * for more information.
     *
     * @param options The options to use for the request
     * @return The ACLs for the account
     */
    listACLsByEntity(options = {}) {
        return (__classPrivateFieldGet(this, _UserClient_client, "f").listACLsByEntity(__classPrivateFieldGet(this, _UserClient_instances, "m", _UserClient_getAccount).call(this, options)));
    }
    /**
     * List ACLs that others have set for the given account.  See {@link Client.listACLsByEntity}
     * for more information.
     *
     * @param options The options to use for the request
     * @return The ACLs applied for the account
     */
    listACLsByPrincipalWithInfo(options = {}) {
        return (__classPrivateFieldGet(this, _UserClient_client, "f").listACLsByPrincipalWithInfo(__classPrivateFieldGet(this, _UserClient_instances, "m", _UserClient_getAccount).call(this, options)));
    }
    /**
     * Get the pending block for the given account.  This will return
     * any side-ledger block for that account, or null if there is no
     * pending block.
     *
     * @param options The options to use for the request
     * @return The pending block for the account or null if there is no
     *         pending block
     */
    async pendingBlock(options = {}) {
        return (await __classPrivateFieldGet(this, _UserClient_client, "f").getPendingBlock(__classPrivateFieldGet(this, _UserClient_instances, "m", _UserClient_getAccount).call(this, options)));
    }
    /**
     * Recover any unpublished or half-publish account artifacts
     *
     * @param publish Publish the recovered staple to the network
     *        (default: true)
     * @param options User client options (common options)
     */
    async recover(publish, options = {}) {
        return (await __classPrivateFieldGet(this, _UserClient_client, "f").recoverAccount(__classPrivateFieldGet(this, _UserClient_instances, "m", _UserClient_getAccount).call(this, options), publish));
    }
    /**
     * Sync any partially-published account artifacts
     *
     * @param publish Publish the recovered staple to the network
     *        (default: true)
     * @param options User client options (common options)
     */
    async sync(publish, options = {}) {
        return (await __classPrivateFieldGet(this, _UserClient_client, "f").syncAccount(__classPrivateFieldGet(this, _UserClient_instances, "m", _UserClient_getAccount).call(this, options), publish));
    }
    /**
     * Register a callback for change messages and set up a websocket filtered to our account only.
     * Also set up long timeout polling for changes in case the websocket misses a change update
     * Check that parameters of function complies with respective event function
     */
    on(event, handler, listenerOptions) {
        const id = Symbol('callbackID');
        // Setup options
        const options = {
            ...defaultListenerOptions[event],
            ...(listenerOptions ?? {})
        };
        // Initialize listeners function array if does not exist
        if (__classPrivateFieldGet(this, _UserClient_listeners, "f")[event] === undefined) {
            __classPrivateFieldGet(this, _UserClient_listeners, "f")[event] = new Map();
        }
        // Push Listener to array of handlers
        __classPrivateFieldGet(this, _UserClient_listeners, "f")[event].set(id, handler);
        switch (event) {
            case 'change':
                // Setup filtered WebSocket to receive messages signalling a change
                void (async () => {
                    try {
                        await __classPrivateFieldGet(this, _UserClient_instances, "m", _UserClient_setupFilteredWebSocket).call(this);
                    }
                    catch (error) {
                        console.error(`Failed to setup filtered websocket ${error}`);
                    }
                })();
                // Setup polling as well
                if (!__classPrivateFieldGet(this, _UserClient_intervals, "f").change) {
                    __classPrivateFieldGet(this, _UserClient_intervals, "f").change = setInterval(() => {
                        __classPrivateFieldSet(this, _UserClient_changePromise, __classPrivateFieldGet(this, _UserClient_instances, "m", _UserClient_emitAccountInfoIfChanged).call(this), "f");
                    }, options.fallbackFrequency);
                }
                break;
        }
        return (id);
    }
    /**
     * Cancel a previously registered callback from {@link on}
     */
    off(id) {
        // Find which event this id belongs to
        for (const eventName in __classPrivateFieldGet(this, _UserClient_listeners, "f")) {
            if (isUserClientEventName(eventName)) {
                const listeners = __classPrivateFieldGet(this, _UserClient_listeners, "f")[eventName];
                if (listeners?.has(id)) {
                    // Remove event listener
                    listeners.delete(id);
                }
            }
        }
        let hasAnyListeners = false;
        for (const eventName in __classPrivateFieldGet(this, _UserClient_listeners, "f")) {
            if (isUserClientEventName(eventName)) {
                const listeners = __classPrivateFieldGet(this, _UserClient_listeners, "f")[eventName];
                if (listeners && listeners.size > 0) {
                    hasAnyListeners = true;
                    break;
                }
            }
        }
        // Only disconnect WebSocket if no listeners remain for ANY event
        if (!hasAnyListeners) {
            __classPrivateFieldGet(this, _UserClient_filteredWebSocket, "f")?.close();
            __classPrivateFieldSet(this, _UserClient_filteredWebSocket, undefined, "f");
        }
    }
    /**
     * Destroy this instance -- this is required to clean up all resources.
     */
    async destroy() {
        if (this.destroyed) {
            return;
        }
        this.destroyed = true;
        await this.client.destroy();
        if (__classPrivateFieldGet(this, _UserClient_changePromise, "f") !== undefined) {
            await __classPrivateFieldGet(this, _UserClient_changePromise, "f");
        }
        // Get Interval IDs and clear them
        const intervalIds = Object.values(__classPrivateFieldGet(this, _UserClient_intervals, "f"));
        for (const interval of intervalIds) {
            clearInterval(interval);
        }
        // Clear Variables
        __classPrivateFieldSet(this, _UserClient_intervals, {}, "f");
        __classPrivateFieldSet(this, _UserClient_listeners, {}, "f");
        __classPrivateFieldSet(this, _UserClient_previousAccountChangeData, undefined, "f");
        __classPrivateFieldGet(this, _UserClient_filteredWebSocket, "f")?.close();
        __classPrivateFieldSet(this, _UserClient_filteredWebSocket, undefined, "f");
        /* Clean up transient clients */
        for (const transientClient of __classPrivateFieldGet(this, _UserClient_transientUserClients, "f")) {
            const client = transientClient.deref();
            await client?.destroy();
        }
    }
    /**
     * This enables the use of `using` to automatically clean up the
     * instance of the {@link UserClient} class when it is no longer
     * needed.
     *
     * It calls the {@link destroy}() method to clean up the instance when
     * it goes out of scope.
     */
    async [(_UserClient_config = new WeakMap(), _UserClient_client = new WeakMap(), _UserClient_listeners = new WeakMap(), _UserClient_intervals = new WeakMap(), _UserClient_previousAccountChangeData = new WeakMap(), _UserClient_socketPromise = new WeakMap(), _UserClient_filteredWebSocket = new WeakMap(), _UserClient_changePromise = new WeakMap(), _UserClient_reconnectAttempts = new WeakMap(), _UserClient_RECONNECT_TIMEOUT = new WeakMap(), _UserClient_transientUserClients = new WeakMap(), _UserClient_instances = new WeakSet(), _UserClient_getAccount = function _UserClient_getAccount(options = {}) {
        const retval = options.account ?? __classPrivateFieldGet(this, _UserClient_config, "f").account ?? this.signer;
        if (retval === null) {
            throw (new Error('No signer available in a read-only UserClient'));
        }
        return (retval);
    }, _UserClient_publishAidURL_get = function _UserClient_publishAidURL_get() {
        const { usePublishAid, publishAidURL, networkAlias } = __classPrivateFieldGet(this, _UserClient_config, "f");
        if (!usePublishAid) {
            throw (new Error('Cannot get publishAidUrl when usePublishAid is not set to true'));
        }
        return (publishAidURL || `https://publish-aid.${networkAlias}.api.keeta.com/api/publish`);
    }, _UserClient_publishWithPublishAid = async function _UserClient_publishWithPublishAid(blocks) {
        try {
            const result = await fetch(__classPrivateFieldGet(this, _UserClient_instances, "a", _UserClient_publishAidURL_get), {
                method: 'POST',
                headers: {
                    'content-type': 'application/json',
                    'user-agent': `KeetaNet/v${version_1.version} (JS)`
                },
                body: JSON.stringify({
                    network: __classPrivateFieldGet(this, _UserClient_config, "f").networkAlias,
                    blocks: blocks.map(block => Buffer.from(block.toBytes()).toString('base64'))
                })
            });
            if (!result.ok) {
                throw (new Error(`publish error: ${result.statusText}`));
            }
            const json = await result.json();
            if (typeof json !== 'object' || json === null) {
                throw (new client_1.default('CLIENT_PUBLISH_AID_NOT_AVAILABLE', 'Unknown JSON response from publish aid'));
            }
            if (!('publish' in json) || typeof json.publish !== 'boolean') {
                throw (new client_1.default('CLIENT_PUBLISH_AID_NOT_AVAILABLE', 'Invalid JSON response from publish aid'));
            }
            return ({
                publish: json.publish
            });
        }
        catch (publishError) {
            if (error_1.KeetaNetError.isInstance(publishError)) {
                throw (publishError);
            }
            else if (publishError instanceof Error) {
                throw (new client_1.default('CLIENT_PUBLISH_AID_NOT_AVAILABLE', `Publish Aid not available: ${publishError.message}`));
            }
            else {
                throw (new client_1.default('CLIENT_PUBLISH_AID_NOT_AVAILABLE', 'Publish Aid not available (unknown error)'));
            }
        }
    }, _UserClient_reconnectWebSocket = function _UserClient_reconnectWebSocket() {
        if (!__classPrivateFieldGet(this, _UserClient_filteredWebSocket, "f") || !Object.values(__classPrivateFieldGet(this, _UserClient_listeners, "f")).some(listener => listener.size > 0)) {
            return;
        }
        __classPrivateFieldSet(this, _UserClient_filteredWebSocket, undefined, "f");
        // Exponential backoff
        const timeout = __classPrivateFieldGet(this, _UserClient_RECONNECT_TIMEOUT, "f") * Math.pow(2, __classPrivateFieldGet(this, _UserClient_reconnectAttempts, "f"));
        setTimeout(async () => {
            var _a;
            __classPrivateFieldSet(this, _UserClient_reconnectAttempts, (_a = __classPrivateFieldGet(this, _UserClient_reconnectAttempts, "f"), _a++, _a), "f");
            await __classPrivateFieldGet(this, _UserClient_instances, "m", _UserClient_setupFilteredWebSocket).call(this);
        }, timeout);
    }, _UserClient_setupFilteredWebSocket = async function _UserClient_setupFilteredWebSocket() {
        if (__classPrivateFieldGet(this, _UserClient_socketPromise, "f")) {
            return;
        }
        const p2pEndpoint = __classPrivateFieldGet(this, _UserClient_client, "f").representatives[0].endpoints.p2p;
        const ws = new isomorphic_ws_1.default(p2pEndpoint);
        const filter = this.account.publicKeyString.toString();
        const greeting = {
            id: uuid.v4(),
            greeting: {
                kind: node_1.NodeKind.PARTICIPANT,
                filter: filter
            }
        };
        __classPrivateFieldSet(this, _UserClient_socketPromise, new Promise((resolve, reject) => {
            ws.onerror = function () {
                try {
                    ws.close();
                }
                catch {
                    // Ignore this error
                }
                reject();
            };
            ws.onopen = function () {
                ws.send(JSON.stringify(greeting));
                ws.onmessage = event => {
                    try {
                        const messageString = event.data.toString('utf-8');
                        const messageObj = JSON.parse(messageString);
                        // We are only interested in the greeting message
                        if (messageObj.greeting) {
                            resolve(ws);
                        }
                    }
                    catch {
                        reject();
                    }
                };
            };
        }), "f");
        try {
            const socket = await __classPrivateFieldGet(this, _UserClient_socketPromise, "f");
            __classPrivateFieldSet(this, _UserClient_reconnectAttempts, 0, "f");
            socket.onclose = () => {
                __classPrivateFieldGet(this, _UserClient_instances, "m", _UserClient_reconnectWebSocket).call(this);
            };
            socket.onmessage = async (event) => {
                try {
                    const messageString = event.data.toString('utf-8');
                    // const messageString = Buffer.from(rawData, 'utf-8').toString();
                    const messageObj = JSON.parse(messageString);
                    // We are only interested in the add message
                    if (messageObj.add) {
                        // Emit AccountInfo if changed
                        await __classPrivateFieldGet(this, _UserClient_instances, "m", _UserClient_emitAccountInfoIfChanged).call(this);
                    }
                }
                catch (error) {
                    console.error('Error processing WebSocket message:', error);
                }
            };
            __classPrivateFieldSet(this, _UserClient_filteredWebSocket, socket, "f");
        }
        catch {
            __classPrivateFieldGet(this, _UserClient_instances, "m", _UserClient_reconnectWebSocket).call(this);
        }
        __classPrivateFieldSet(this, _UserClient_socketPromise, undefined, "f");
    }, _UserClient_emit = function _UserClient_emit(event, ...data) {
        const handlers = __classPrivateFieldGet(this, _UserClient_listeners, "f")[event];
        if (handlers === undefined) {
            return;
        }
        for (const handler of handlers.values()) {
            /*
             * TypeScript thinks the "data" types are incorrect but they are correct
             */
            // @ts-ignore
            handler(...data);
        }
    }, _UserClient_emitAccountInfoIfChanged = async function _UserClient_emitAccountInfoIfChanged() {
        const accountInfo = await __classPrivateFieldGet(this, _UserClient_client, "f").getAccountInfo(this.account);
        const objectBuffer = (0, conversion_1.objectToBuffer)(accountInfo);
        const accountHashBuffer = (0, hash_1.Hash)(objectBuffer);
        const accountHashString = accountHashBuffer.toString();
        if (__classPrivateFieldGet(this, _UserClient_previousAccountChangeData, "f") !== accountHashString) {
            // Change detected, Emit and update previous value;
            __classPrivateFieldGet(this, _UserClient_instances, "m", _UserClient_emit).call(this, 'change', accountInfo);
            __classPrivateFieldSet(this, _UserClient_previousAccountChangeData, accountHashString, "f");
        }
    }, Symbol.asyncDispose)]() {
        return (await this.destroy());
    }
    /**
     * Get the configuration for this UserClient instance.
     */
    get config() {
        return (__classPrivateFieldGet(this, _UserClient_config, "f"));
    }
    /**
     * Get the low-level {@link Client | client} for this instance.
     */
    get client() {
        return (__classPrivateFieldGet(this, _UserClient_client, "f"));
    }
    /**
     * Get the signer for this instance, if it was set.  This is the
     * account that will be used to sign blocks and transactions.
     * If this is null, then the client is readonly and will not be
     * able to publish blocks or transactions.
     */
    get signer() {
        return (__classPrivateFieldGet(this, _UserClient_config, "f").signer);
    }
    /**
     * Get the account for this instance.  This is the account that will
     * be affected by the blocks and transactions that are published.
     */
    get account() {
        return (__classPrivateFieldGet(this, _UserClient_instances, "m", _UserClient_getAccount).call(this));
    }
    /**
     * Get the network ID for this instance.  This is the network that
     * this instance is connected to.
     */
    get network() {
        return (__classPrivateFieldGet(this, _UserClient_config, "f").network);
    }
    /**
     * Whether or not this client is "readonly".  This is true if the
     * signer is null.
     */
    get readonly() {
        if (this.signer === null) {
            return (true);
        }
        return (false);
    }
}
exports.UserClient = UserClient;
/**
 * Reference to the {@link Config} class for the client.  This is used to
 * access the Configuration operations which may be needed for the
 * UserClient.
 */
UserClient.Config = Config;
/**
 * Determine if a given object is an instance of the UserClient class.
 * This is preferred over using `instanceof` because it works across
 * different contexts.
 */
UserClient.isInstance = (0, helper_2.checkableGenerator)(UserClient);
/** @hidden */
async function blockGenerator(seed, index, transactionCount, network = 1413829460n) {
    const acct = lib_1.default.Account.fromSeed(seed, index);
    const operations = [];
    const { baseToken } = account_1.default.generateBaseAddresses(network);
    for (let opCount = 0; opCount < transactionCount; opCount++) {
        operations.push({
            type: lib_1.default.Block.OperationType.SEND,
            to: acct,
            token: baseToken,
            amount: 1n
        });
    }
    const block = await new lib_1.default.Block.Builder({
        previous: lib_1.default.Block.NO_PREVIOUS,
        account: acct,
        network: network,
        operations: operations
    }).seal();
    const voteWIP = new lib_1.default.Vote.Builder(acct);
    voteWIP.addBlock(block);
    const expiry = new Date();
    expiry.setUTCFullYear(expiry.getUTCFullYear() + 1000);
    const vote = await voteWIP.seal(BigInt(1000 + index), expiry);
    const staple = lib_1.default.Vote.Staple.fromVotesAndBlocks([vote], [block]);
    return (staple);
}
/** @hidden */
async function emitBlocks(client, blocks, seed, index, transactionCount, network = 1413829460n) {
    for (let x = 0; x < blocks; x++) {
        const staple = await blockGenerator(seed, index + x, transactionCount, network);
        try {
            await client.transmitStaple(staple);
        }
        catch (_ignoredPublishError) {
            /* Ignored */
        }
    }
}
/**
 * Utilities needed for working with KeetaNet
 * @summary
 * Utilities needed for working with KeetaNet
 */
exports.lib = lib_1.default;


/***/ }),

/***/ 1491:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.baseValidationConfig = exports.NetworkIDs = exports.networksArray = void 0;
exports.getNetworkAlias = getNetworkAlias;
exports.getValidation = getValidation;
exports.getDefaultConfig = getDefaultConfig;
exports.isNetwork = isNetwork;
const account_1 = __importDefault(__webpack_require__(9415));
const never_1 = __webpack_require__(8692);
/**
 * Known Networks that exist in the configuration database
 */
exports.networksArray = ['main', 'staging', 'test', 'dev'];
exports.NetworkIDs = {
    'main': BigInt('0x5382'),
    'staging': BigInt('0x538201'),
    'test': BigInt('0x54455354'),
    'dev': BigInt('0x444556')
};
exports.baseValidationConfig = {
    accountInfoFieldRules: {
        name: {
            maxLength: 50,
            regex: /^[A-Z_]*$/
        },
        description: {
            maxLength: 250,
            regex: /^[\w!"#$%&'()*+,\-./:;?@\\^_‚Äò~:; ]*$/
        },
        metadata: {
            regex: /^[-A-Za-z0-9+/=]+$/,
            maxLength: 5464,
            canBeEmpty: true
        },
        supply: {
            maxValue: (10n ** 200n) - 1n
        },
        blockSignerCount: { maxValue: 16n },
        blockSignerDepth: { maxValue: 3n }
    },
    permissions: {
        maxExternalOffset: 32
    },
    blockOperations: {
        external: {
            maxLength: 256,
            regex: /^[-_A-Za-z0-9+/= ]+$/,
            canBeEmpty: true
        }
    }
};
function getNetworkAlias(networkOrID) {
    if (typeof networkOrID !== 'bigint') {
        return (networkOrID);
    }
    let networkAlias;
    for (networkAlias in exports.NetworkIDs) {
        if (exports.NetworkIDs[networkAlias] === networkOrID) {
            return (networkAlias);
        }
    }
    throw (new Error(`Could not call getNetwork() with ${networkOrID}`));
}
function getValidation(networkOrID) {
    // Default Network ID for Testing
    if (networkOrID === 0n) {
        return (exports.baseValidationConfig);
    }
    const networkAlias = getNetworkAlias(networkOrID);
    switch (networkAlias) {
        case 'main':
        case 'staging':
        case 'test':
        case 'dev':
            return (exports.baseValidationConfig);
        default:
            (0, never_1.assertNever)(networkAlias);
            throw (new Error(`Could not get validation for ${networkOrID}`));
    }
}
/**
 * Get the Default Configuration for a network in the configuration database
 */
function getDefaultConfig(network) {
    let initialTrustedAccount;
    const validation = getValidation(network);
    const representatives = [];
    let publishAidURL = `https://publish-aid.${network}.api.keeta.com/api/publish`;
    switch (network) {
        case 'main':
            {
                initialTrustedAccount = 'keeta_aabk62tezl4whordlviamlx3zrdgux6lk63cghay45vkzdatyemzvqqjuj5resa';
                const reps = [
                    'keeta_aabwip6zeo2fnzfxp5hssrrqtascs2277w2zk7vqd6d3k3m4dkt2flcbca2mqki',
                    'keeta_aabvmwxttv4q56gbfveighwfwp3yvitlrdfsacic3ckqc7lqelsspvmhc7oldmq',
                    'keeta_aabwqf5fnta4t2v2atieis545b3rqoq6z7x5w3geugiilqlz5jdsb5og2rmxvdq',
                    'keeta_aablpogflko72eusdhuuqgsto2rwcvy2m5mo5snmvrmbacz3qczwjtwpmzf5ufq'
                ];
                for (let index = 0; index < reps.length; index++) {
                    const repID = index + 1;
                    const repKey = reps[index];
                    representatives.push({
                        key: account_1.default.fromPublicKeyString(repKey).assertAccount(),
                        endpoints: {
                            api: `https://rep${repID}.main.network.api.keeta.com/api`,
                            p2p: `wss://rep${repID}.main.network.api.keeta.com/p2p`
                        }
                    });
                }
            }
            break;
        case 'staging':
            {
                initialTrustedAccount = 'keeta_aabhtbqmg7whgpvbgii6twdjlyq5vlrtwaa47nb5b2gj6an5kvjbwvvw2mdwjjy';
                const reps = [
                    'keeta_aabaagdrwrwnkzox4u3qh6uukre6lckax6kb5fwyxd4vtpua6vrjc6nuhb75fji',
                    'keeta_aabgizanf4agmioyrswbg4wsl7nmjlrakwd4piuks7cqagfccnxc2fscm25hw7i',
                    'keeta_aab2gw2zmtazqgtromyfmhjn5h67ep23676zq62obgtqaw65x5l5krn252w57ma',
                    'keeta_aabue4mdj22i5o6774tlszcxy2sxyvpninbm54nfhxn6dkmsvtryd7oha4bzh2i'
                ];
                for (let index = 0; index < reps.length; index++) {
                    const repID = index + 1;
                    const repKey = reps[index];
                    representatives.push({
                        key: account_1.default.fromPublicKeyString(repKey).assertAccount(),
                        endpoints: {
                            api: `https://rep${repID}.staging.network.api.keeta.com/api`,
                            p2p: `wss://rep${repID}.staging.network.api.keeta.com/p2p`
                        }
                    });
                }
            }
            break;
        case 'test':
            {
                initialTrustedAccount = 'keeta_aabmvemiol5wrs67e4rfiyibopwav4e77sleiqaqvbdprbuxrifn7fgg4cchhia';
                publishAidURL = `https://publish-aid.${network}.network.api.keeta.com/api/publish`;
                const reps = [
                    'keeta_aabi4bd3f7jrt67mxcq44ozj65bh4bp2mygmrkedxggu2rxwn2ztuw3b6exivbq',
                    'keeta_aabf7dz5asq2n2lrldct33x2ww65cophxp7egfiixbb7tbyat5r3kcbcez7ftpi',
                    'keeta_aab3cxegizwhtim3zlyuwjhiqd5ikkhxg42smhwc3wx6yn7ep2t6lwo6emvw4wa',
                    'keeta_aabznoicrzvte6ql5rxbgugmfrjqubbnjuo5l6ivopowy4rpkqgs5fco3oaezcq'
                ];
                for (let index = 0; index < reps.length; index++) {
                    const repID = index + 1;
                    const repKey = reps[index];
                    representatives.push({
                        key: account_1.default.fromPublicKeyString(repKey).assertAccount(),
                        endpoints: {
                            api: `https://rep${repID}.${network}.network.api.keeta.com/api`,
                            p2p: `wss://rep${repID}.${network}.network.api.keeta.com/p2p`
                        }
                    });
                }
            }
            break;
        case 'dev':
            {
                const seed = '1000000000000000000000000000000000000000000000000000000000000000';
                initialTrustedAccount = account_1.default.fromSeed(seed, 0xffffffff).publicKeyString.get();
                for (let repID = 1; repID <= 4; repID++) {
                    representatives.push({
                        key: account_1.default.fromSeed(seed, repID),
                        endpoints: {
                            api: `https://rep${repID}.${network}.api.keeta.com/api`,
                            p2p: `wss://rep${repID}.${network}.api.keeta.com/p2p`
                        }
                    });
                }
            }
            break;
        default:
            (0, never_1.assertNever)(network);
            throw (new Error(`Unsupported default configuration: ${network}`));
    }
    return ({
        networkAlias: network,
        network: exports.NetworkIDs[network],
        initialTrustedAccount: account_1.default.toAccount(initialTrustedAccount),
        representatives: representatives,
        validation: validation,
        publishAidURL: publishAidURL
    });
}
function isNetwork(network) {
    return (exports.networksArray.includes(network));
}


/***/ }),

/***/ 9415:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var _PublicKeyString_publicKeyString, _PublicKeyString_publicKeyPair, _ExternalKeyPair_functions, _ExternalKeyPair_keyType, _ExternalKeyPair_publicKey, _ExternalKeyPair_baseAccount, _a, _ECDSASECP256K1KeyPair_keyType, _ECDSASECP256K1KeyPair_privateKey, _ECDSASECP256K1KeyPair_publicKey, _ECDSASECP256K1KeyPair_privateKeyInternalValue, _ECDSASECP256K1KeyPair_publicKeyInternalValue, _ECDSASECP256K1KeyPair_curve, _b, _ECDSASECP256R1KeyPair_keyType, _ECDSASECP256R1KeyPair_privateKey, _ECDSASECP256R1KeyPair_publicKey, _ECDSASECP256R1KeyPair_privateKeyInternalValue, _ECDSASECP256R1KeyPair_publicKeyInternalValue, _ECDSASECP256R1KeyPair_curve, _c, _ED25519KeyPair_privateKey, _ED25519KeyPair_publicKey, _ED25519KeyPair_curve, _IdentifierKeyPair_key, _IdentifierKeyPair_identifierType, _Account_privateKeyPair, _Account_publicKeyPair, _Account_keyType, _Account_keyPairHandlesHashing, _Account_publicKeyString, _Account_publicKeyAndTypeString;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AccountTesting = exports.Account = exports.ExternalKeyPair = exports.AccountKeyAlgorithm = void 0;
const futoin_hkdf_1 = __importDefault(__webpack_require__(6871));
const crypto_1 = __importDefault(__webpack_require__(6982));
const secp256k1_1 = __importDefault(__webpack_require__(560));
const elliptic_1 = __importDefault(__webpack_require__(6729));
const ecies = __importStar(__webpack_require__(9625));
const eciesK1 = __importStar(__webpack_require__(341));
const eciesR1 = __importStar(__webpack_require__(9303));
const ed25519_1 = __webpack_require__(459);
const p256_1 = __webpack_require__(5897);
const buffer_1 = __webpack_require__(3310);
const helper_1 = __webpack_require__(3208);
const hash_1 = __webpack_require__(7908);
const asn1_1 = __webpack_require__(6045);
const block_1 = __importStar(__webpack_require__(6158));
const account_1 = __importDefault(__webpack_require__(4642));
const helper_2 = __webpack_require__(3208);
const ed2curve_1 = __webpack_require__(9240);
/**
 * Account encoding prefixes
 */
const AccountPrefixes = ['keeta_', 'tyblocks_']; // cspell:disable-line -- ignore tyblocks
/**
 * Account key algorithms specify how the key should be used for validation,
 * signing, and encoding.
 */
var AccountKeyAlgorithm;
(function (AccountKeyAlgorithm) {
    AccountKeyAlgorithm[AccountKeyAlgorithm["ECDSA_SECP256K1"] = 0] = "ECDSA_SECP256K1";
    AccountKeyAlgorithm[AccountKeyAlgorithm["ED25519"] = 1] = "ED25519";
    AccountKeyAlgorithm[AccountKeyAlgorithm["NETWORK"] = 2] = "NETWORK";
    AccountKeyAlgorithm[AccountKeyAlgorithm["TOKEN"] = 3] = "TOKEN";
    AccountKeyAlgorithm[AccountKeyAlgorithm["STORAGE"] = 4] = "STORAGE";
    AccountKeyAlgorithm[AccountKeyAlgorithm["ECDSA_SECP256R1"] = 6] = "ECDSA_SECP256R1";
    AccountKeyAlgorithm[AccountKeyAlgorithm["MULTISIG"] = 7] = "MULTISIG";
})(AccountKeyAlgorithm || (exports.AccountKeyAlgorithm = AccountKeyAlgorithm = {}));
/**
 * ASN.1 Schema for Public Keys
 *
 * @internal
 */
const publicKeyASN1Schema = [
    { sequenceOf: asn1_1.BufferStorageASN1.Validate.IsOID },
    asn1_1.BufferStorageASN1.Validate.IsBitString
];
/**
 * Validate the {@link publicKeyASN1} type against the {@link publicKeyASN1Schema}
 * and statically check that they are the same
 *
 * @internal
 */
// eslint-disable-next-line @typescript-eslint/no-unused-vars
function _ignore_static_checks() {
    // eslint-disable-next-line @typescript-eslint/no-unused-vars,@typescript-eslint/consistent-type-assertions
    const _ignore_static_check_forward_in = {};
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    const _ignore_static_check_forward_out = _ignore_static_check_forward_in;
    // eslint-disable-next-line @typescript-eslint/no-unused-vars,@typescript-eslint/consistent-type-assertions
    const _ignore_static_check_reverse_in = {};
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    const _ignore_static_check_reverse_out = _ignore_static_check_reverse_in;
}
function assertAccountKeyAlgorithm(algorithm) {
    if (typeof algorithm === 'number' && AccountKeyAlgorithm[algorithm] !== undefined) {
        return (algorithm);
    }
    throw (new Error(`Invalid account key algorithm ${algorithm}`));
}
const identifierKeyTypes = [AccountKeyAlgorithm.NETWORK, AccountKeyAlgorithm.TOKEN, AccountKeyAlgorithm.STORAGE, AccountKeyAlgorithm.MULTISIG];
/**
 * Keys in Ed25519 and EcDSA secp256k1/secp256r1 are 256-bits long
 */
class KeyStorage extends buffer_1.BufferStorage {
    constructor(key) {
        super(key, 32);
    }
}
KeyStorage.isInstance = (0, helper_2.checkableGenerator)(KeyStorage);
class ECDSASECP256K1PrivateKey extends KeyStorage {
}
ECDSASECP256K1PrivateKey.isInstance = (0, helper_2.checkableGenerator)(ECDSASECP256K1PrivateKey);
class ECDSASECP256K1PublicKey extends buffer_1.BufferStorage {
    constructor(key) {
        super(key, 33);
    }
    get ASN1() {
        const key = this.getBuffer();
        const keyASN1 = [
            [
                { type: 'oid', oid: 'ecdsa' },
                { type: 'oid', oid: 'secp256k1' }
            ],
            { type: 'bitstring', value: key }
        ];
        return (new asn1_1.BufferStorageASN1(keyASN1));
    }
}
ECDSASECP256K1PublicKey.isInstance = (0, helper_2.checkableGenerator)(ECDSASECP256K1PublicKey);
class ECDSASECP256R1PrivateKey extends KeyStorage {
}
ECDSASECP256R1PrivateKey.isInstance = (0, helper_2.checkableGenerator)(ECDSASECP256R1PrivateKey);
class ECDSASECP256R1PublicKey extends buffer_1.BufferStorage {
    constructor(key) {
        super(key, 33);
    }
    get ASN1() {
        const key = this.getBuffer();
        const keyASN1 = [
            [
                { type: 'oid', oid: 'ecdsa' },
                { type: 'oid', oid: 'secp256r1' }
            ],
            { type: 'bitstring', value: key }
        ];
        return (new asn1_1.BufferStorageASN1(keyASN1));
    }
}
ECDSASECP256R1PublicKey.isInstance = (0, helper_2.checkableGenerator)(ECDSASECP256R1PublicKey);
class ED25519PrivateKey extends KeyStorage {
}
ED25519PrivateKey.isInstance = (0, helper_2.checkableGenerator)(ED25519PrivateKey);
class ED25519PublicKey extends KeyStorage {
    get ASN1() {
        const key = this.getBuffer();
        const keyASN1 = [
            [
                { type: 'oid', oid: 'ed25519' }
            ],
            { type: 'bitstring', value: key }
        ];
        return (new asn1_1.BufferStorageASN1(keyASN1));
    }
}
ED25519PublicKey.isInstance = (0, helper_2.checkableGenerator)(ED25519PublicKey);
class IdentifierKey extends KeyStorage {
    get ASN1() {
        throw (new Error('Identifier keys do not have public keys'));
    }
}
IdentifierKey.isInstance = (0, helper_2.checkableGenerator)(IdentifierKey);
/**
 * Signatures in ED25519 and ECDSA SECP256K1 and R1 are 512-bits long
 */
class SignatureStorage extends buffer_1.BufferStorage {
    constructor(signature) {
        super(signature, 64);
    }
}
SignatureStorage.isInstance = (0, helper_2.checkableGenerator)(SignatureStorage);
class ECDSASECP256K1Signature extends SignatureStorage {
}
ECDSASECP256K1Signature.isInstance = (0, helper_2.checkableGenerator)(ECDSASECP256K1Signature);
class ECDSASECP256R1Signature extends SignatureStorage {
}
ECDSASECP256R1Signature.isInstance = (0, helper_2.checkableGenerator)(ECDSASECP256R1Signature);
class ED25519Signature extends SignatureStorage {
}
ED25519Signature.isInstance = (0, helper_2.checkableGenerator)(ED25519Signature);
/**
 * Seeds are 256-bit random integers plus 32-bit indexes
 */
class SeedStorage extends buffer_1.BufferStorage {
    constructor(key) {
        super(key, 36);
    }
}
SeedStorage.isInstance = (0, helper_2.checkableGenerator)(SeedStorage);
/**
 * A "public key string" is a base32-encoded string with a prefix and checksum
 * that contains the public key plus the algorithm information
 */
class PublicKeyString {
    constructor(publicKeyString) {
        _PublicKeyString_publicKeyString.set(this, void 0);
        _PublicKeyString_publicKeyPair.set(this, void 0);
        // Although this is not validated, we still want it to be stored in the class generic type
        // eslint-disable-next-line @typescript-eslint/consistent-type-assertions
        __classPrivateFieldSet(this, _PublicKeyString_publicKeyString, publicKeyString, "f");
    }
    get publicKeyPair() {
        if (!__classPrivateFieldGet(this, _PublicKeyString_publicKeyPair, "f")) {
            // This function will not get called before it is defined.
            // eslint-disable-next-line @typescript-eslint/no-use-before-define
            __classPrivateFieldSet(this, _PublicKeyString_publicKeyPair, derivePublicKeyFromPublicKeyString(this), "f");
        }
        return (__classPrivateFieldGet(this, _PublicKeyString_publicKeyPair, "f"));
    }
    get() {
        return (__classPrivateFieldGet(this, _PublicKeyString_publicKeyString, "f"));
    }
    toString() {
        return (__classPrivateFieldGet(this, _PublicKeyString_publicKeyString, "f"));
    }
}
_PublicKeyString_publicKeyString = new WeakMap(), _PublicKeyString_publicKeyPair = new WeakMap();
PublicKeyString.isInstance = (0, helper_2.checkableGenerator)(PublicKeyString);
/**
 * Abstract interface to all kinds of key-related functions
 */
class KeyInterface {
}
/**
 * Create a buffer containing the seed and index combined together.  This can
 * then be used with a key derivation function.
 */
function combineSeedAndIndex(seed, index) {
    if (index === undefined) {
        throw (new account_1.default('ACCOUNT_SEED_INDEX_UNDEFINED', 'Seed index must be defined'));
    }
    if (index < 0) {
        throw (new account_1.default('ACCOUNT_SEED_INDEX_NEGATIVE', 'Seed index must be a positive number'));
    }
    if (!Number.isSafeInteger(index)) {
        throw (new account_1.default('ACCOUNT_SEED_INDEX_NOT_INT', 'Seed index must be an integer '));
    }
    const tempStorage = new buffer_1.BufferStorage(seed, 32);
    const indexedSeed = new Uint8Array(new ArrayBuffer(36));
    indexedSeed.set(new Uint8Array(tempStorage.get()));
    const indexValue = BigInt(index);
    if ((indexValue >> 32n) !== 0n) {
        throw (new account_1.default('ACCOUNT_SEED_INDEX_TOO_LARGE', 'Seed index must fit within 32 bits'));
    }
    indexedSeed[32] = Number((indexValue >> 24n) & 0xffn);
    indexedSeed[33] = Number((indexValue >> 16n) & 0xffn);
    indexedSeed[34] = Number((indexValue >> 8n) & 0xffn);
    indexedSeed[35] = Number((indexValue) & 0xffn);
    return (new SeedStorage(indexedSeed));
}
class ExternalKeyPair extends KeyInterface {
    constructor(functions, publicKey, keyType, driverHandlesHashing = false) {
        super();
        _ExternalKeyPair_functions.set(this, void 0);
        _ExternalKeyPair_keyType.set(this, void 0);
        _ExternalKeyPair_publicKey.set(this, void 0);
        _ExternalKeyPair_baseAccount.set(this, void 0);
        this.driverHandlesHashing = driverHandlesHashing;
        __classPrivateFieldSet(this, _ExternalKeyPair_functions, functions, "f");
        __classPrivateFieldSet(this, _ExternalKeyPair_keyType, keyType, "f");
        switch (keyType) {
            case AccountKeyAlgorithm.ECDSA_SECP256K1:
                __classPrivateFieldSet(this, _ExternalKeyPair_publicKey, new ECDSASECP256K1PublicKey(publicKey), "f");
                break;
            case AccountKeyAlgorithm.ECDSA_SECP256R1:
                __classPrivateFieldSet(this, _ExternalKeyPair_publicKey, new ECDSASECP256R1PublicKey(publicKey), "f");
                break;
            case AccountKeyAlgorithm.ED25519:
                __classPrivateFieldSet(this, _ExternalKeyPair_publicKey, new ED25519PublicKey(publicKey), "f");
                break;
            default:
                throw (new account_1.default('ACCOUNT_INVALID_KEYTYPE_EXTERNAL', `Unsupported key type for ExternalKeyPair: ${keyType}`));
        }
        // eslint-disable-next-line @typescript-eslint/no-use-before-define
        __classPrivateFieldSet(this, _ExternalKeyPair_baseAccount, new Account(__classPrivateFieldGet(this, _ExternalKeyPair_publicKey, "f"), __classPrivateFieldGet(this, _ExternalKeyPair_keyType, "f")).assertAccount(), "f");
    }
    sign(...parameters) {
        return (__classPrivateFieldGet(this, _ExternalKeyPair_functions, "f").sign(...parameters));
    }
    verify(data, signature, options) {
        if (!__classPrivateFieldGet(this, _ExternalKeyPair_functions, "f").verify) {
            return (__classPrivateFieldGet(this, _ExternalKeyPair_baseAccount, "f").verify(data, signature, { ...options, raw: true }));
        }
        let isRaw = true;
        if (this.driverHandlesHashing) {
            isRaw = options?.raw ?? false;
        }
        return (__classPrivateFieldGet(this, _ExternalKeyPair_functions, "f").verify(data, signature, { ...options, raw: isRaw }));
    }
    encrypt(...parameters) {
        if (!__classPrivateFieldGet(this, _ExternalKeyPair_functions, "f").supportsEncryption) {
            throw (new account_1.default('ACCOUNT_ENCRYPTION_NOT_SUPPORTED', 'Encryption is not supported by this external key pair'));
        }
        if (!__classPrivateFieldGet(this, _ExternalKeyPair_functions, "f").encrypt) {
            return (__classPrivateFieldGet(this, _ExternalKeyPair_baseAccount, "f").encrypt(...parameters));
        }
        return (__classPrivateFieldGet(this, _ExternalKeyPair_functions, "f").encrypt(...parameters));
    }
    decrypt(...parameters) {
        if (!__classPrivateFieldGet(this, _ExternalKeyPair_functions, "f").supportsEncryption) {
            throw (new account_1.default('ACCOUNT_ENCRYPTION_NOT_SUPPORTED', 'Encryption is not supported by this external key pair'));
        }
        return (__classPrivateFieldGet(this, _ExternalKeyPair_functions, "f").decrypt(...parameters));
    }
    get supportsEncryption() {
        return (true);
    }
    get keyType() {
        return (__classPrivateFieldGet(this, _ExternalKeyPair_keyType, "f"));
    }
    get publicKey() {
        return (__classPrivateFieldGet(this, _ExternalKeyPair_publicKey, "f"));
    }
    get hasPrivateKey() {
        return (true);
    }
    _checkPrivateKey(_ignore_checkKey) {
        /*
         * It is always undecidable if a key is equal to an external
         * key by direct inspection since external keys are not
         * inspectable
         */
        return;
    }
}
exports.ExternalKeyPair = ExternalKeyPair;
_ExternalKeyPair_functions = new WeakMap(), _ExternalKeyPair_keyType = new WeakMap(), _ExternalKeyPair_publicKey = new WeakMap(), _ExternalKeyPair_baseAccount = new WeakMap();
ExternalKeyPair.isInstance = (0, helper_2.checkableGenerator)(ExternalKeyPair);
/**
 * Generic ECDSA Key interface
 */
class ECDSAKeyPair extends KeyInterface {
    constructor() {
        super(...arguments);
        this.supportsEncryption = true;
    }
    /**
    * Construct an SEC-like signature from a DER encoded ECDSA [R,S] structure
    */
    static signatureFromDERRaw(values) {
        const signatureDER = (new Uint8Array(values)).buffer;
        const signatureStructured = (0, asn1_1.ASN1toJS)(signatureDER);
        if (!Array.isArray(signatureStructured) ||
            signatureStructured.length !== 2 ||
            !signatureStructured.every((val) => typeof val === 'bigint')) {
            throw (new Error('Signature was not properly decoded.'));
        }
        const sigSECValues = [];
        const sigR = (0, asn1_1.ASN1BigIntToBuffer)(signatureStructured[0]);
        sigSECValues.push(new Uint8Array(sigR));
        const sigS = (0, asn1_1.ASN1BigIntToBuffer)(signatureStructured[1]);
        sigSECValues.push(new Uint8Array(sigS));
        /**
         * ASN.1 encoded Integers are arbitrary sized, force it to fit
         * into an exactly 32-byte buffer
         */
        for (const sigSECValueIndex in sigSECValues) {
            const sigSECValue = sigSECValues[sigSECValueIndex];
            if (sigSECValue.length > 32) {
                sigSECValues[sigSECValueIndex] = sigSECValue.slice(-32);
            }
            else if (sigSECValue.length < 32) {
                const paddedValue = new Uint8Array(32);
                paddedValue.set(sigSECValue, 32 - sigSECValue.length);
                sigSECValues[sigSECValueIndex] = paddedValue;
            }
        }
        const sigSEC = new Uint8Array(64);
        sigSEC.set(sigSECValues[0]);
        sigSEC.set(sigSECValues[1], 32);
        return (sigSEC);
    }
    /**
     * Construct an ASN.1-encoded [R,S] struct from the SEC-like value
     */
    static signatureToDER(signature) {
        const signatureRaw = new Uint8Array(signature.get());
        const sigR = Buffer.from(signatureRaw.slice(0, 32));
        const sigS = Buffer.from(signatureRaw.slice(32));
        const sigRInt = BigInt(`0x${sigR.toString('hex')}`);
        const sigSInt = BigInt(`0x${sigS.toString('hex')}`);
        const sigSEC = Buffer.from((0, asn1_1.JStoASN1)([
            sigRInt,
            sigSInt
        ]).toBER(false));
        const sigSECValues = [...sigSEC];
        return (sigSECValues);
    }
}
class ECDSASECP256K1KeyPair extends ECDSAKeyPair {
    static derivePrivateKeyFromSeed(seed, index) {
        const seedBuffer = combineSeedAndIndex(seed, index);
        const hashLength = futoin_hkdf_1.default.hash_length(hash_1.Hash.functionName);
        const privateKey = futoin_hkdf_1.default.expand(hash_1.Hash.functionName, hashLength, seedBuffer.getBuffer(), hashLength, '');
        return (new ECDSASECP256K1PrivateKey(privateKey));
    }
    static fromSeed(seed, index) {
        const privateKey = _a.derivePrivateKeyFromSeed(seed, index);
        return (new _a(privateKey));
    }
    static derivePublicKeyFromPrivateKey(key) {
        const curve = __classPrivateFieldGet(_a, _a, "f", _ECDSASECP256K1KeyPair_curve);
        const privateKey = curve.keyFromPrivate(key.getBuffer());
        const publicKey = privateKey.getPublic().encode('hex', true);
        return (new ECDSASECP256K1PublicKey(publicKey));
    }
    static signatureFromDER(signature) {
        return (new ECDSASECP256K1Signature(super.signatureFromDERRaw(signature)));
    }
    static signatureToDER(signature) {
        return (this.signatureToDER(signature));
    }
    constructor(privateKey, publicKey) {
        super();
        _ECDSASECP256K1KeyPair_keyType.set(this, AccountKeyAlgorithm.ECDSA_SECP256K1);
        _ECDSASECP256K1KeyPair_privateKey.set(this, void 0);
        _ECDSASECP256K1KeyPair_publicKey.set(this, void 0);
        _ECDSASECP256K1KeyPair_privateKeyInternalValue.set(this, void 0);
        _ECDSASECP256K1KeyPair_publicKeyInternalValue.set(this, void 0);
        if (privateKey) {
            if (ECDSASECP256K1PrivateKey.isInstance(privateKey)) {
                __classPrivateFieldSet(this, _ECDSASECP256K1KeyPair_privateKey, privateKey, "f");
            }
            else {
                __classPrivateFieldSet(this, _ECDSASECP256K1KeyPair_privateKey, new ECDSASECP256K1PrivateKey(privateKey), "f");
            }
            __classPrivateFieldSet(this, _ECDSASECP256K1KeyPair_publicKey, _a.derivePublicKeyFromPrivateKey(__classPrivateFieldGet(this, _ECDSASECP256K1KeyPair_privateKey, "f")), "f");
            return;
        }
        if (!publicKey) {
            throw (new Error('Either the private key or the public key must be provided'));
        }
        __classPrivateFieldSet(this, _ECDSASECP256K1KeyPair_privateKey, null, "f");
        if (ECDSASECP256K1PublicKey.isInstance(publicKey)) {
            __classPrivateFieldSet(this, _ECDSASECP256K1KeyPair_publicKey, publicKey, "f");
        }
        else {
            __classPrivateFieldSet(this, _ECDSASECP256K1KeyPair_publicKey, new ECDSASECP256K1PublicKey(publicKey), "f");
        }
    }
    async sign(data, options) {
        options = { ...options };
        if (!__classPrivateFieldGet(this, _ECDSASECP256K1KeyPair_privateKey, "f")) {
            throw (new Error('May not sign without a private key'));
        }
        if (!__classPrivateFieldGet(this, _ECDSASECP256K1KeyPair_privateKeyInternalValue, "f")) {
            __classPrivateFieldSet(this, _ECDSASECP256K1KeyPair_privateKeyInternalValue, new Uint8Array(__classPrivateFieldGet(this, _ECDSASECP256K1KeyPair_privateKey, "f").get()), "f");
        }
        const toSign = new Uint8Array(data);
        const { signature } = secp256k1_1.default.ecdsaSign(toSign, __classPrivateFieldGet(this, _ECDSASECP256K1KeyPair_privateKeyInternalValue, "f"));
        const signatureDER = secp256k1_1.default.signatureExport(signature);
        if (options.forCert) {
            const signatureDERBuffer = new buffer_1.BufferStorage(signatureDER, signatureDER.length);
            return (signatureDERBuffer);
        }
        const signatureDERNumbers = [...signatureDER];
        const signatureSEC = _a.signatureFromDER(signatureDERNumbers);
        return (signatureSEC);
    }
    verify(data, signature, options) {
        options = { ...options };
        let signatureArrayBuffer;
        if (options.forCert) {
            let signatureDER;
            /*
             * When handling X.509 certificates, we must process DER encoded data
             */
            if (ECDSASECP256K1Signature.isInstance(signature)) {
                throw (new Error('Unable to process Secp256K1Signature signature when processing a DER-encoded buffer'));
            }
            if (buffer_1.BufferStorage.isInstance(signature)) {
                signatureDER = [...signature.getBuffer()];
            }
            else {
                signatureDER = [...Buffer.from(new Uint8Array(signature))];
            }
            signatureArrayBuffer = _a.signatureFromDER(signatureDER).get();
        }
        else {
            if (!ECDSASECP256K1Signature.isInstance(signature)) {
                if (buffer_1.BufferStorage.isInstance(signature)) {
                    throw (new Error('BufferStorage may only be used when processing DER-encoded buffers'));
                }
                signature = new ECDSASECP256K1Signature(signature);
            }
            signatureArrayBuffer = signature.get();
        }
        if (!__classPrivateFieldGet(this, _ECDSASECP256K1KeyPair_publicKeyInternalValue, "f")) {
            __classPrivateFieldSet(this, _ECDSASECP256K1KeyPair_publicKeyInternalValue, new Uint8Array(__classPrivateFieldGet(this, _ECDSASECP256K1KeyPair_publicKey, "f").get()), "f");
        }
        const dataU8Array = new Uint8Array(data);
        const signatureU8Array = new Uint8Array(signatureArrayBuffer);
        let retval = false;
        try {
            retval = secp256k1_1.default.ecdsaVerify(signatureU8Array, dataU8Array, __classPrivateFieldGet(this, _ECDSASECP256K1KeyPair_publicKeyInternalValue, "f"));
        }
        catch (_ignored_error) {
            /* Ignore the error */
        }
        return (retval);
    }
    async encrypt(data) {
        const curve = __classPrivateFieldGet(_a, _a, "f", _ECDSASECP256K1KeyPair_curve);
        const publicKey = curve.keyFromPublic(__classPrivateFieldGet(this, _ECDSASECP256K1KeyPair_publicKey, "f").getBuffer());
        const publicKeyHex = publicKey.getPublic().encode('hex', false);
        const encrypted = await eciesK1.encrypt(Buffer.from(publicKeyHex, 'hex'), Buffer.from(data));
        return ((0, helper_1.bufferToArrayBuffer)(encrypted));
    }
    async decrypt(data) {
        if (!__classPrivateFieldGet(this, _ECDSASECP256K1KeyPair_privateKey, "f")) {
            throw (new Error('Cannot decrypt on ECDSASECP256K1KeyPair without a private key'));
        }
        const decrypted = await eciesK1.decrypt(__classPrivateFieldGet(this, _ECDSASECP256K1KeyPair_privateKey, "f").getBuffer(), Buffer.from(data));
        return ((0, helper_1.bufferToArrayBuffer)(decrypted));
    }
    get keyType() {
        return (__classPrivateFieldGet(this, _ECDSASECP256K1KeyPair_keyType, "f"));
    }
    get publicKey() {
        return (__classPrivateFieldGet(this, _ECDSASECP256K1KeyPair_publicKey, "f"));
    }
    get hasPrivateKey() {
        if (__classPrivateFieldGet(this, _ECDSASECP256K1KeyPair_privateKey, "f") !== null) {
            return (true);
        }
        return (false);
    }
    _checkPrivateKey(checkKey) {
        const checkKeyBuffer = Buffer.from(checkKey);
        if (!__classPrivateFieldGet(this, _ECDSASECP256K1KeyPair_privateKey, "f")) {
            return;
        }
        if (checkKeyBuffer.toString('hex').toUpperCase() === __classPrivateFieldGet(this, _ECDSASECP256K1KeyPair_privateKey, "f").getBuffer().toString('hex').toUpperCase()) {
            return (true);
        }
        return (false);
    }
}
_a = ECDSASECP256K1KeyPair, _ECDSASECP256K1KeyPair_keyType = new WeakMap(), _ECDSASECP256K1KeyPair_privateKey = new WeakMap(), _ECDSASECP256K1KeyPair_publicKey = new WeakMap(), _ECDSASECP256K1KeyPair_privateKeyInternalValue = new WeakMap(), _ECDSASECP256K1KeyPair_publicKeyInternalValue = new WeakMap();
_ECDSASECP256K1KeyPair_curve = { value: new elliptic_1.default.ec('secp256k1') };
ECDSASECP256K1KeyPair.isInstance = (0, helper_2.checkableGenerator)(_a);
class ECDSASECP256R1KeyPair extends ECDSAKeyPair {
    static derivePrivateKeyFromSeed(seed, index) {
        const seedBuffer = combineSeedAndIndex(seed, index);
        const hashLength = futoin_hkdf_1.default.hash_length(hash_1.Hash.functionName);
        const privateKey = futoin_hkdf_1.default.expand(hash_1.Hash.functionName, hashLength, seedBuffer.getBuffer(), hashLength, '');
        return (new ECDSASECP256R1PrivateKey(privateKey));
    }
    static fromSeed(seed, index) {
        const privateKey = _b.derivePrivateKeyFromSeed(seed, index);
        return (new _b(privateKey));
    }
    static derivePublicKeyFromPrivateKey(key) {
        const curve = __classPrivateFieldGet(_b, _b, "f", _ECDSASECP256R1KeyPair_curve);
        const privateKey = curve.keyFromPrivate(key.getBuffer());
        const publicKey = privateKey.getPublic().encode('hex', true);
        return (new ECDSASECP256R1PublicKey(publicKey));
    }
    /**
    * Construct an SEC-like signature from a DER encoded ECDSA [R,S] structure
    */
    static signatureFromDER(signature) {
        return (new ECDSASECP256R1Signature(super.signatureFromDERRaw(signature)));
    }
    /**
     * Construct an ASN.1-encoded [R,S] struct from the SEC-like value
     */
    static signatureToDER(signature) {
        return (super.signatureToDER(signature));
    }
    constructor(privateKey, publicKey) {
        super();
        _ECDSASECP256R1KeyPair_keyType.set(this, AccountKeyAlgorithm.ECDSA_SECP256R1);
        _ECDSASECP256R1KeyPair_privateKey.set(this, void 0);
        _ECDSASECP256R1KeyPair_publicKey.set(this, void 0);
        _ECDSASECP256R1KeyPair_privateKeyInternalValue.set(this, void 0);
        _ECDSASECP256R1KeyPair_publicKeyInternalValue.set(this, void 0);
        if (privateKey) {
            if (ECDSASECP256R1PrivateKey.isInstance(privateKey)) {
                __classPrivateFieldSet(this, _ECDSASECP256R1KeyPair_privateKey, privateKey, "f");
            }
            else {
                __classPrivateFieldSet(this, _ECDSASECP256R1KeyPair_privateKey, new ECDSASECP256R1PrivateKey(privateKey), "f");
            }
            __classPrivateFieldSet(this, _ECDSASECP256R1KeyPair_publicKey, _b.derivePublicKeyFromPrivateKey(__classPrivateFieldGet(this, _ECDSASECP256R1KeyPair_privateKey, "f")), "f");
            return;
        }
        if (!publicKey) {
            throw (new Error('Either the private key or the public key must be provided'));
        }
        __classPrivateFieldSet(this, _ECDSASECP256R1KeyPair_privateKey, null, "f");
        if (ECDSASECP256R1PublicKey.isInstance(publicKey)) {
            __classPrivateFieldSet(this, _ECDSASECP256R1KeyPair_publicKey, publicKey, "f");
        }
        else {
            __classPrivateFieldSet(this, _ECDSASECP256R1KeyPair_publicKey, new ECDSASECP256R1PublicKey(publicKey), "f");
        }
    }
    async sign(data, options) {
        options = { ...options };
        if (!__classPrivateFieldGet(this, _ECDSASECP256R1KeyPair_privateKey, "f")) {
            throw (new Error('May not sign without a private key'));
        }
        if (!__classPrivateFieldGet(this, _ECDSASECP256R1KeyPair_privateKeyInternalValue, "f")) {
            __classPrivateFieldSet(this, _ECDSASECP256R1KeyPair_privateKeyInternalValue, new Uint8Array(__classPrivateFieldGet(this, _ECDSASECP256R1KeyPair_privateKey, "f").get()), "f");
        }
        const toSign = Buffer.from(data);
        const signature = p256_1.secp256r1.sign(toSign, Buffer.from(__classPrivateFieldGet(this, _ECDSASECP256R1KeyPair_privateKeyInternalValue, "f")));
        const signatureDER = Uint8Array.from(signature.toDERRawBytes());
        if (options.forCert) {
            const signatureDERBuffer = new buffer_1.BufferStorage(Buffer.from(signatureDER), signatureDER.length);
            return (signatureDERBuffer);
        }
        const signatureDERNumbers = [...signatureDER];
        const signatureSEC = _b.signatureFromDER(signatureDERNumbers);
        return (signatureSEC);
    }
    verify(data, signature, options) {
        options = { ...options };
        let signatureArrayBuffer;
        if (options.forCert) {
            let signatureDER;
            /*
             * When handling X.509 certificates, we must process DER encoded data
             */
            if (ECDSASECP256R1Signature.isInstance(signature)) {
                throw (new Error('Unable to process Secp256R1Signature signature when processing a DER-encoded buffer'));
            }
            if (buffer_1.BufferStorage.isInstance(signature)) {
                signatureDER = [...signature.getBuffer()];
            }
            else {
                signatureDER = [...Buffer.from(new Uint8Array(signature))];
            }
            signatureArrayBuffer = _b.signatureFromDER(signatureDER).get();
        }
        else {
            if (!ECDSASECP256R1Signature.isInstance(signature)) {
                if (buffer_1.BufferStorage.isInstance(signature)) {
                    throw (new Error('BufferStorage may only be used when processing DER-encoded buffers'));
                }
                signature = new ECDSASECP256R1Signature(signature);
            }
            signatureArrayBuffer = signature.get();
        }
        if (!__classPrivateFieldGet(this, _ECDSASECP256R1KeyPair_publicKeyInternalValue, "f")) {
            __classPrivateFieldSet(this, _ECDSASECP256R1KeyPair_publicKeyInternalValue, new Uint8Array(__classPrivateFieldGet(this, _ECDSASECP256R1KeyPair_publicKey, "f").get()), "f");
        }
        const dataU8Array = new Uint8Array(data);
        const signatureU8Array = new Uint8Array(signatureArrayBuffer);
        let retval = false;
        try {
            retval = p256_1.secp256r1.verify(signatureU8Array, dataU8Array, __classPrivateFieldGet(this, _ECDSASECP256R1KeyPair_publicKeyInternalValue, "f"));
        }
        catch (_ignored_error) {
            /* Ignore the error */
        }
        return (retval);
    }
    async encrypt(data) {
        const pub2 = __classPrivateFieldGet(_b, _b, "f", _ECDSASECP256R1KeyPair_curve).keyFromPublic(__classPrivateFieldGet(this, _ECDSASECP256R1KeyPair_publicKey, "f").getBuffer()).getPublic();
        const encrypted = await eciesR1.ECIES.encryptBytes(pub2, Uint8Array.from(Buffer.from(data)));
        return ((0, helper_1.bufferToArrayBuffer)(Buffer.from(encrypted)));
    }
    async decrypt(data) {
        if (!__classPrivateFieldGet(this, _ECDSASECP256R1KeyPair_privateKey, "f")) {
            throw (new Error('Cannot decrypt with a ECDSASECP256R1KeyPair without a curve private key'));
        }
        const priv = __classPrivateFieldGet(_b, _b, "f", _ECDSASECP256R1KeyPair_curve).keyFromPrivate(__classPrivateFieldGet(this, _ECDSASECP256R1KeyPair_privateKey, "f").getBuffer()).getPrivate();
        const decrypted = eciesR1.ECIES.decryptBytes(priv, Uint8Array.from(Buffer.from(data)));
        return ((0, helper_1.bufferToArrayBuffer)(Buffer.from(decrypted)));
    }
    get keyType() {
        return (__classPrivateFieldGet(this, _ECDSASECP256R1KeyPair_keyType, "f"));
    }
    get publicKey() {
        return (__classPrivateFieldGet(this, _ECDSASECP256R1KeyPair_publicKey, "f"));
    }
    get hasPrivateKey() {
        if (__classPrivateFieldGet(this, _ECDSASECP256R1KeyPair_privateKey, "f") !== null) {
            return (true);
        }
        return (false);
    }
    _checkPrivateKey(checkKey) {
        const checkKeyBuffer = Buffer.from(checkKey);
        if (!__classPrivateFieldGet(this, _ECDSASECP256R1KeyPair_privateKey, "f")) {
            return;
        }
        if (checkKeyBuffer.toString('hex').toUpperCase() === __classPrivateFieldGet(this, _ECDSASECP256R1KeyPair_privateKey, "f").getBuffer().toString('hex').toUpperCase()) {
            return (true);
        }
        return (false);
    }
}
_b = ECDSASECP256R1KeyPair, _ECDSASECP256R1KeyPair_keyType = new WeakMap(), _ECDSASECP256R1KeyPair_privateKey = new WeakMap(), _ECDSASECP256R1KeyPair_publicKey = new WeakMap(), _ECDSASECP256R1KeyPair_privateKeyInternalValue = new WeakMap(), _ECDSASECP256R1KeyPair_publicKeyInternalValue = new WeakMap();
_ECDSASECP256R1KeyPair_curve = { value: new elliptic_1.default.ec('p256') };
ECDSASECP256R1KeyPair.isInstance = (0, helper_2.checkableGenerator)(_b);
/**
 * ED25519 Key Interface
 */
class ED25519KeyPair extends KeyInterface {
    static derivePrivateKeyFromSeed(seed, index) {
        const seedBuffer = combineSeedAndIndex(seed, index);
        const privateKeyRawBuffer = Buffer.from(seedBuffer.get());
        const privateKeyRaw = (0, hash_1.Hash)(privateKeyRawBuffer);
        /*
         * Perform clamping
         */
        const privateKeyArray = new Uint8Array(privateKeyRaw);
        privateKeyArray[0] &= 248;
        privateKeyArray[31] &= 127;
        privateKeyArray[31] |= 64;
        const privateKeyBuffer = Buffer.from(privateKeyArray);
        const privateKey = new ED25519PrivateKey(privateKeyBuffer);
        return (privateKey);
    }
    static fromSeed(seed, index) {
        const privateKey = _c.derivePrivateKeyFromSeed(seed, index);
        return (new _c(privateKey));
    }
    static derivePublicKeyFromPrivateKey(key) {
        const curve = __classPrivateFieldGet(_c, _c, "f", _ED25519KeyPair_curve);
        const privateKey = curve.keyFromSecret(key.getBuffer());
        const publicKey = privateKey.getPublic();
        return (new ED25519PublicKey(publicKey));
    }
    constructor(privateKey, publicKey) {
        super();
        _ED25519KeyPair_privateKey.set(this, void 0);
        _ED25519KeyPair_publicKey.set(this, void 0);
        this.supportsEncryption = true;
        if (privateKey) {
            if (ED25519PrivateKey.isInstance(privateKey)) {
                __classPrivateFieldSet(this, _ED25519KeyPair_privateKey, privateKey, "f");
            }
            else {
                __classPrivateFieldSet(this, _ED25519KeyPair_privateKey, new ED25519PrivateKey(privateKey), "f");
            }
            __classPrivateFieldSet(this, _ED25519KeyPair_publicKey, _c.derivePublicKeyFromPrivateKey(__classPrivateFieldGet(this, _ED25519KeyPair_privateKey, "f")), "f");
            return;
        }
        if (!publicKey) {
            throw (new Error('Either the private key or the public key must be provided'));
        }
        __classPrivateFieldSet(this, _ED25519KeyPair_privateKey, null, "f");
        if (ED25519PublicKey.isInstance(publicKey)) {
            __classPrivateFieldSet(this, _ED25519KeyPair_publicKey, publicKey, "f");
        }
        else {
            __classPrivateFieldSet(this, _ED25519KeyPair_publicKey, new ED25519PublicKey(publicKey), "f");
        }
    }
    async sign(data) {
        if (!__classPrivateFieldGet(this, _ED25519KeyPair_privateKey, "f")) {
            throw (new Error('May not sign without a private key'));
        }
        const privateKey = __classPrivateFieldGet(this, _ED25519KeyPair_privateKey, "f").toString('hex');
        const message = Uint8Array.from(Buffer.from(data));
        const signature = ed25519_1.ed25519.sign(message, privateKey);
        return (new ED25519Signature(Buffer.from(signature)));
    }
    verify(data, signature) {
        if (buffer_1.BufferStorage.isInstance(signature)) {
            signature = signature.get();
        }
        if (!ED25519Signature.isInstance(signature)) {
            signature = new ED25519Signature(signature);
        }
        const hexSignature = signature.toString('hex');
        const message = Uint8Array.from(Buffer.from(data));
        const publicKey = __classPrivateFieldGet(this, _ED25519KeyPair_publicKey, "f").toString('hex');
        return (ed25519_1.ed25519.verify(hexSignature, message, publicKey));
    }
    async encrypt(data) {
        const publicKeyBuf = new Uint8Array(__classPrivateFieldGet(this, _ED25519KeyPair_publicKey, "f").get());
        const twistedPublicKey = (0, ed2curve_1.convertPublicKey)(publicKeyBuf);
        if (!twistedPublicKey) {
            throw (new Error('Could not convert (twist) ED25519 public key'));
        }
        const encrypted = await ecies.encrypt(new Uint8Array(data), twistedPublicKey);
        return (encrypted.buffer);
    }
    async decrypt(data) {
        if (!__classPrivateFieldGet(this, _ED25519KeyPair_privateKey, "f")) {
            throw (new Error('Cannot use decrypt on ED25519KeyPair without a private key'));
        }
        const privateKeyBuf = new Uint8Array(__classPrivateFieldGet(this, _ED25519KeyPair_privateKey, "f").get());
        const twistedPrivateKey = (0, ed2curve_1.convertSecretKey)(privateKeyBuf);
        if (!twistedPrivateKey) {
            throw (new Error('Could not convert (twist) ED25519 private key'));
        }
        const decrypted = await ecies.decrypt(new Uint8Array(data), twistedPrivateKey);
        return (decrypted.buffer);
    }
    get keyType() {
        return (AccountKeyAlgorithm.ED25519);
    }
    get publicKey() {
        return (__classPrivateFieldGet(this, _ED25519KeyPair_publicKey, "f"));
    }
    get hasPrivateKey() {
        if (__classPrivateFieldGet(this, _ED25519KeyPair_privateKey, "f") !== null) {
            return (true);
        }
        return (false);
    }
    _checkPrivateKey(checkKey) {
        const checkKeyBuffer = Buffer.from(checkKey);
        if (!__classPrivateFieldGet(this, _ED25519KeyPair_privateKey, "f")) {
            return;
        }
        if (checkKeyBuffer.toString('hex').toUpperCase() === __classPrivateFieldGet(this, _ED25519KeyPair_privateKey, "f").getBuffer().toString('hex').toUpperCase()) {
            return (true);
        }
        return (false);
    }
}
_c = ED25519KeyPair, _ED25519KeyPair_privateKey = new WeakMap(), _ED25519KeyPair_publicKey = new WeakMap();
_ED25519KeyPair_curve = { value: new elliptic_1.default.eddsa('ed25519') };
ED25519KeyPair.isInstance = (0, helper_2.checkableGenerator)(_c);
class IdentifierKeyPair extends KeyInterface {
    static derivePrivateKeyFromSeed(seed, index) {
        const seedBuffer = combineSeedAndIndex(seed, index);
        const privateKeyRawBuffer = Buffer.from(seedBuffer.get());
        const privateKeyRaw = (0, hash_1.Hash)(privateKeyRawBuffer);
        const privateKeyBuffer = Buffer.from(privateKeyRaw);
        const privateKey = new IdentifierKey(privateKeyBuffer);
        return (privateKey);
    }
    static derivePublicKeyFromPrivateKey(key) {
        return (key);
    }
    constructor(key, identifierType) {
        super();
        _IdentifierKeyPair_key.set(this, void 0);
        _IdentifierKeyPair_identifierType.set(this, void 0);
        this.supportsEncryption = false;
        if (!IdentifierKey.isInstance(key)) {
            key = new IdentifierKey(key);
        }
        __classPrivateFieldSet(this, _IdentifierKeyPair_identifierType, identifierType, "f");
        __classPrivateFieldSet(this, _IdentifierKeyPair_key, key, "f");
    }
    async sign(_ignored_data) {
        throw (new account_1.default('ACCOUNT_NO_IDENTIFIER_SIGN', 'May not sign from an identifier key'));
    }
    verify(_ignored_data, _ignored_signature) {
        throw (new account_1.default('ACCOUNT_NO_IDENTIFIER_VERIFY', 'Cannot verify from an identifier key'));
    }
    get publicKey() {
        return (__classPrivateFieldGet(this, _IdentifierKeyPair_key, "f"));
    }
    get hasPrivateKey() {
        return (false);
    }
    get keyType() {
        return (__classPrivateFieldGet(this, _IdentifierKeyPair_identifierType, "f"));
    }
    static fromSeed(seed, index, type) {
        if (type === undefined) {
            throw (new account_1.default('ACCOUNT_INVALID_IDENTIFIER_CONSTRUCTION', 'Cannot call IdentifierKeyPair.fromSeed() without a type provided'));
        }
        const privateKey = IdentifierKeyPair.derivePrivateKeyFromSeed(seed, index);
        return (new IdentifierKeyPair(privateKey, type));
    }
    _checkPrivateKey(_ignored_checkKey) {
        return (undefined);
    }
    encrypt(..._ignored_parameters) {
        throw (new account_1.default('ACCOUNT_ENCRYPTION_NOT_SUPPORTED', 'Encryption not supported for identifier keys'));
    }
    decrypt(..._ignored_parameters) {
        throw (new account_1.default('ACCOUNT_ENCRYPTION_NOT_SUPPORTED', 'Encryption not supported for identifier keys'));
    }
}
_IdentifierKeyPair_key = new WeakMap(), _IdentifierKeyPair_identifierType = new WeakMap();
IdentifierKeyPair.isInstance = (0, helper_2.checkableGenerator)(IdentifierKeyPair);
/**
 * Compute public key value from an encoded public key string
 */
function derivePublicKeyFromPublicKeyString(key_str) {
    let key = key_str.get();
    /*
     * Remove any of the acceptable prefixes
     */
    let prefixMatched = false;
    for (const checkPrefix of AccountPrefixes) {
        if (key.startsWith(checkPrefix) === false) {
            continue;
        }
        key = key.slice(checkPrefix.length);
        prefixMatched = true;
        break;
    }
    if (!prefixMatched) {
        throw (new account_1.default('ACCOUNT_INVALID_PREFIX', 'Unable to parse account information'));
    }
    let pubKeySize;
    switch (key.length) {
        case 61:
            pubKeySize = 38;
            break;
        case 63:
            pubKeySize = 39;
            break;
        default:
            throw (new Error(`Key is the wrong length (${key.length})`));
    }
    const pubKeyValuesBuffer = (0, buffer_1.DecodeBase32)(key, pubKeySize);
    /*
     * Verify the embedded checksum
     */
    const checksumOf = Buffer.from(pubKeyValuesBuffer.slice(0, -5));
    const checksum = Buffer.from(pubKeyValuesBuffer.slice(-5)).toString('hex');
    const checksumCheck = Buffer.from((0, hash_1.Hash)(checksumOf, 5)).toString('hex');
    if (checksum !== checksumCheck) {
        throw (new Error(`Invalid checksum while parsing public key string: ${key_str.get()}  got ${checksum} expected ${checksumCheck}`));
    }
    /*
     * Parse out the relevant parts
     */
    const pubKeyValuesArray = new Uint8Array(pubKeyValuesBuffer);
    const pubKeyValues = new Uint8Array(pubKeyValuesBuffer.slice(1, -5));
    const keyType = pubKeyValuesArray[0];
    switch (keyType) {
        case AccountKeyAlgorithm.ECDSA_SECP256K1:
            return (new ECDSASECP256K1KeyPair(undefined, Buffer.from(pubKeyValues)));
        case AccountKeyAlgorithm.ECDSA_SECP256R1:
            return (new ECDSASECP256R1KeyPair(undefined, Buffer.from(pubKeyValues)));
        case AccountKeyAlgorithm.ED25519:
            return (new ED25519KeyPair(undefined, Buffer.from(pubKeyValues)));
        case AccountKeyAlgorithm.NETWORK:
        case AccountKeyAlgorithm.TOKEN:
        case AccountKeyAlgorithm.STORAGE:
        case AccountKeyAlgorithm.MULTISIG:
            return (new IdentifierKeyPair(Buffer.from(pubKeyValues), keyType));
    }
    throw (new account_1.default('ACCOUNT_INVALID_KEYTYPE', `Invalid key type (${keyType}) while parsing public key string: ${key_str.get()}`));
}
/**
 * Compute a public key string (prefix, key type, public key, and checksum)
 * from a public key
 */
function derivePublicKeyStringFromPublicKey(key, keyType) {
    /*
     * Construct the array of public key bytes
     */
    const pubKeyValues = [
        keyType,
        ...(new Uint8Array(key.get()))
    ];
    /*
     * Append the checksum
     */
    const checksumOf = Buffer.from(new Uint8Array(pubKeyValues));
    const checksum = (0, hash_1.Hash)(checksumOf, 5);
    pubKeyValues.push(...(new Uint8Array(checksum)));
    /**
     * Ensure we have the right size
     *
     * 32 bytes or 33 bytes for the public key,
     * 5 bytes for the checksum,
     * 1 byte for the 4 bits which store the account type
     */
    if (pubKeyValues.length !== (32 + 5 + 1) && pubKeyValues.length !== (33 + 5 + 1)) {
        throw (new Error(`internal error: Got incorrect length for public key: ${pubKeyValues.length} !== 38 or 39`));
    }
    const accountPrefix = AccountPrefixes[0];
    const output = (0, buffer_1.EncodeBase32)(new Uint8Array(pubKeyValues));
    return (new PublicKeyString(`${accountPrefix}${output}`));
}
/**
 * Account class, which is used to represent a key pair or an identifier
 * account (which have no private key) such as tokens.
 *
 * @template T - The type of the key algorithm used for this account.
 */
class Account {
    static fromPublicKeyString(key) {
        return (new Account(new PublicKeyString(key)));
    }
    /**
     * Construct an account from an ECDSA private key for SECP256K1.
     */
    static fromECDSASECP256K1PrivateKey(key) {
        return (new Account(new ECDSASECP256K1PrivateKey(key)));
    }
    /**
     * Construct an account from an ECDSA private key for SECP256R1.
     */
    static fromECDSASECP256R1PrivateKey(key) {
        return (new Account(new ECDSASECP256R1PrivateKey(key)));
    }
    /**
     * Construct an account from an ED25519 private key.
     */
    static fromED25519PrivateKey(key) {
        return (new Account(new ED25519PrivateKey(key)));
    }
    /**
     * Construct an account from an ECDSA public key for SECP256K1.
     */
    static fromECDSASECP256K1PublicKey(key) {
        return (new Account(new ECDSASECP256K1PublicKey(key)));
    }
    /**
     * Construct an account from an ECDSA public key for SECP256R1.
     */
    static fromECDSASECP256R1PublicKey(key) {
        return (new Account(new ECDSASECP256R1PublicKey(key)));
    }
    /**
     * Construct an identifier account from the input key and the identifier algo
     */
    static fromIdentifierPublicKey(key, type) {
        return (new Account(new IdentifierKeyPair(new IdentifierKey(key), type)));
    }
    /**
     * Construct an account from a network identifier public key
     */
    static fromNetworkPublicKey(key) {
        return (this.fromIdentifierPublicKey(key, AccountKeyAlgorithm.NETWORK));
    }
    /**
     * Construct an account from a token identifier public key
     */
    static fromTokenPublicKey(key) {
        return (this.fromIdentifierPublicKey(key, AccountKeyAlgorithm.TOKEN));
    }
    /**
     * Construct an account from a storage identifier public key
     */
    static fromStoragePublicKey(key) {
        return (this.fromIdentifierPublicKey(key, AccountKeyAlgorithm.STORAGE));
    }
    /**
     * Construct an account from a multisig identifier public key
     */
    static fromMultisigPublicKey(key) {
        return (this.fromIdentifierPublicKey(key, AccountKeyAlgorithm.MULTISIG));
    }
    /**
     * Construct an account from an ED25519 public key.
     */
    static fromED25519PublicKey(key) {
        return (new Account(new ED25519PublicKey(key)));
    }
    static fromPublicKeyAndType(keyData) {
        if (typeof keyData === 'string') {
            keyData = Buffer.from(keyData.slice(2), 'hex');
        }
        const keyType = assertAccountKeyAlgorithm(keyData[0]);
        const key = keyData.slice(1);
        let constructorFunction;
        switch (keyType) {
            case AccountKeyAlgorithm.ECDSA_SECP256K1:
                constructorFunction = Account.fromECDSASECP256K1PublicKey.bind(Account);
                break;
            case AccountKeyAlgorithm.ECDSA_SECP256R1:
                constructorFunction = Account.fromECDSASECP256R1PublicKey.bind(Account);
                break;
            case AccountKeyAlgorithm.ED25519:
                constructorFunction = Account.fromED25519PublicKey.bind(Account);
                break;
            case AccountKeyAlgorithm.NETWORK:
            case AccountKeyAlgorithm.TOKEN:
            case AccountKeyAlgorithm.STORAGE:
            case AccountKeyAlgorithm.MULTISIG:
                constructorFunction = (function (input) {
                    return (Account.fromIdentifierPublicKey.bind(Account)(input, keyType));
                });
                break;
        }
        if (constructorFunction === undefined) {
            throw (new account_1.default('ACCOUNT_INVALID_KEYTYPE', `Unsupported keyType: ${keyType}`));
        }
        const account = constructorFunction(key);
        // eslint-disable-next-line @typescript-eslint/consistent-type-assertions
        return account;
    }
    /**
     * Construct a new account from a public key encoded in DER-encoded ASN.1
     */
    static fromASN1(asn1) {
        let asn1Data;
        if (asn1 instanceof ArrayBuffer) {
            const data = new asn1_1.BufferStorageASN1(asn1, publicKeyASN1Schema);
            asn1Data = data.getASN1();
        }
        else {
            asn1Data = asn1;
        }
        const keyInfo = asn1Data[0];
        const publicKey = asn1Data[1].value;
        switch (keyInfo[0].oid) {
            case 'ecdsa':
                switch (keyInfo[1].oid) {
                    case 'secp256k1':
                        return (Account.fromECDSASECP256K1PublicKey(publicKey.toString('hex')));
                    case 'secp256r1':
                        return (Account.fromECDSASECP256R1PublicKey(publicKey.toString('hex')));
                }
                break;
            case 'ed25519':
                return (Account.fromED25519PublicKey(publicKey.toString('hex')));
        }
        throw (new account_1.default('ACCOUNT_INVALID_KEYTYPE', `Unsupported keyType: ${keyInfo[0].oid} ${keyInfo[1].oid}`));
    }
    static fromSeed(seed, index, keyType = AccountKeyAlgorithm.ECDSA_SECP256K1) {
        if (typeof seed === 'bigint') {
            seed = new buffer_1.BufferStorage(seed, 32).get();
        }
        let privateKey;
        switch (keyType) {
            case AccountKeyAlgorithm.ECDSA_SECP256K1:
                privateKey = ECDSASECP256K1KeyPair.fromSeed(seed, index);
                break;
            case AccountKeyAlgorithm.ECDSA_SECP256R1:
                privateKey = ECDSASECP256R1KeyPair.fromSeed(seed, index);
                break;
            case AccountKeyAlgorithm.ED25519:
                privateKey = ED25519KeyPair.fromSeed(seed, index);
                break;
            case AccountKeyAlgorithm.NETWORK:
            case AccountKeyAlgorithm.TOKEN:
            case AccountKeyAlgorithm.STORAGE:
            case AccountKeyAlgorithm.MULTISIG:
                privateKey = IdentifierKeyPair.fromSeed(seed, index, keyType);
                break;
        }
        return (new Account(privateKey));
    }
    // Create a network address from the network ID
    static generateNetworkAddress(networkId) {
        return (Account.fromSeed(networkId, 0, AccountKeyAlgorithm.NETWORK));
    }
    static generateBaseAddresses(networkId) {
        const networkAddress = this.generateNetworkAddress(networkId);
        const baseToken = networkAddress.generateIdentifier(AccountKeyAlgorithm.TOKEN, undefined, 0);
        return ({ networkAddress, baseToken });
    }
    static generateRandomSeed(options = { asString: false }) {
        let retval;
        if (typeof window !== 'undefined') {
            if (window && window.crypto && window.crypto.getRandomValues) {
                const buffer = new Uint8Array(new ArrayBuffer(32));
                const retvalArray = window.crypto.getRandomValues(buffer);
                const retvalArrayBuffer = retvalArray.buffer;
                if (options.asString) {
                    retval = Buffer.from(retvalArrayBuffer).toString('hex').toUpperCase();
                }
                else {
                    retval = retvalArrayBuffer;
                }
                return (retval);
            }
        }
        const randomBytes = crypto_1.default.randomBytes(32);
        if (options.asString) {
            retval = randomBytes.toString('hex').toUpperCase();
        }
        else {
            retval = (0, helper_1.bufferToArrayBuffer)(randomBytes);
        }
        return (retval);
    }
    static async seedFromPassphrase(passphrase, options = { asString: false }) {
        /**
         * The BIP39 english word list is 2048 words long, so
         * we can encode 11 bits per word.  The average word
         * length is 5.4 characters, so we can encode 121 bits
         * in 60 bytes (an average of 11 words).
         */
        const minPassphraseLength = 60;
        const cleanPassphrase = passphrase.toLowerCase().replace(/ /g, '');
        const cleanPassphraseBuffer = Buffer.from(cleanPassphrase, 'utf-8');
        if (cleanPassphraseBuffer.byteLength < minPassphraseLength) {
            throw (new account_1.default('ACCOUNT_PASSPHRASE_WEAK', `Invalid passphrase, must be at least ${minPassphraseLength} bytes after internal processing, got ${cleanPassphraseBuffer.byteLength}`));
        }
        const seed = await new Promise(function (resolve, reject) {
            crypto_1.default.pbkdf2(cleanPassphraseBuffer, cleanPassphraseBuffer, 64000, 32, 'sha256', function (error, derivedKey) {
                if (error !== null) {
                    reject(error);
                    return;
                }
                resolve(derivedKey);
            });
        });
        let retval;
        if (options.asString) {
            retval = seed.toString('hex').toUpperCase();
        }
        else {
            retval = (0, helper_1.bufferToArrayBuffer)(seed);
        }
        return (retval);
    }
    static toAccount(acct) {
        if (acct === undefined || acct === null) {
            return (acct);
        }
        if (typeof acct === 'string') {
            if (acct.startsWith('0x')) {
                // eslint-disable-next-line @typescript-eslint/consistent-type-assertions
                return (Account.fromPublicKeyAndType(acct));
            }
            return (Account.fromPublicKeyString(acct));
        }
        return (acct);
    }
    static toPublicKeyString(acct) {
        if (acct === undefined || acct === null) {
            return (acct);
        }
        return (this.toAccount(acct).publicKeyString.get());
    }
    static comparePublicKeys(acct1, acct2) {
        if (!acct1 || !acct2) {
            return (false);
        }
        return (this.toPublicKeyString(acct1) === this.toPublicKeyString(acct2));
    }
    constructor(key, requiredKeyType) {
        _Account_privateKeyPair.set(this, void 0);
        _Account_publicKeyPair.set(this, void 0);
        _Account_keyType.set(this, void 0);
        _Account_keyPairHandlesHashing.set(this, false);
        _Account_publicKeyString.set(this, void 0);
        _Account_publicKeyAndTypeString.set(this, void 0);
        if (Account.isInstance(key)) {
            __classPrivateFieldSet(this, _Account_privateKeyPair, key._getPrivateKey(), "f");
            __classPrivateFieldSet(this, _Account_publicKeyPair, key._getPublicKey(), "f");
        }
        else if (ECDSASECP256K1PrivateKey.isInstance(key)) {
            __classPrivateFieldSet(this, _Account_privateKeyPair, new ECDSASECP256K1KeyPair(key), "f");
            __classPrivateFieldSet(this, _Account_publicKeyPair, __classPrivateFieldGet(this, _Account_privateKeyPair, "f"), "f");
        }
        else if (ECDSASECP256R1PrivateKey.isInstance(key)) {
            __classPrivateFieldSet(this, _Account_privateKeyPair, new ECDSASECP256R1KeyPair(key), "f");
            __classPrivateFieldSet(this, _Account_publicKeyPair, __classPrivateFieldGet(this, _Account_privateKeyPair, "f"), "f");
        }
        else if (ECDSASECP256K1PublicKey.isInstance(key)) {
            __classPrivateFieldSet(this, _Account_privateKeyPair, null, "f");
            __classPrivateFieldSet(this, _Account_publicKeyPair, new ECDSASECP256K1KeyPair(undefined, key), "f");
        }
        else if (ECDSASECP256R1PublicKey.isInstance(key)) {
            __classPrivateFieldSet(this, _Account_privateKeyPair, null, "f");
            __classPrivateFieldSet(this, _Account_publicKeyPair, new ECDSASECP256R1KeyPair(undefined, key), "f");
        }
        else if (ECDSASECP256K1KeyPair.isInstance(key)) {
            __classPrivateFieldSet(this, _Account_privateKeyPair, key, "f");
            __classPrivateFieldSet(this, _Account_publicKeyPair, key, "f");
        }
        else if (ECDSASECP256R1KeyPair.isInstance(key)) {
            __classPrivateFieldSet(this, _Account_privateKeyPair, key, "f");
            __classPrivateFieldSet(this, _Account_publicKeyPair, key, "f");
        }
        else if (ED25519PrivateKey.isInstance(key)) {
            __classPrivateFieldSet(this, _Account_privateKeyPair, new ED25519KeyPair(key), "f");
            __classPrivateFieldSet(this, _Account_publicKeyPair, __classPrivateFieldGet(this, _Account_privateKeyPair, "f"), "f");
        }
        else if (ED25519PublicKey.isInstance(key)) {
            __classPrivateFieldSet(this, _Account_privateKeyPair, null, "f");
            __classPrivateFieldSet(this, _Account_publicKeyPair, new ED25519KeyPair(undefined, key), "f");
        }
        else if (ED25519KeyPair.isInstance(key)) {
            __classPrivateFieldSet(this, _Account_privateKeyPair, key, "f");
            __classPrivateFieldSet(this, _Account_publicKeyPair, key, "f");
        }
        else if (IdentifierKeyPair.isInstance(key)) {
            __classPrivateFieldSet(this, _Account_publicKeyPair, key, "f");
            __classPrivateFieldSet(this, _Account_privateKeyPair, null, "f");
        }
        else if (ExternalKeyPair.isInstance(key)) {
            __classPrivateFieldSet(this, _Account_keyPairHandlesHashing, key.driverHandlesHashing ?? false, "f");
            __classPrivateFieldSet(this, _Account_privateKeyPair, key, "f");
            __classPrivateFieldSet(this, _Account_publicKeyPair, key, "f");
        }
        else if (PublicKeyString.isInstance(key)) {
            __classPrivateFieldSet(this, _Account_privateKeyPair, null, "f");
            __classPrivateFieldSet(this, _Account_publicKeyPair, key.publicKeyPair, "f");
            // We know the type is valid here, the compiler just does not know it
            // eslint-disable-next-line @typescript-eslint/consistent-type-assertions
            __classPrivateFieldSet(this, _Account_publicKeyString, key, "f");
        }
        else {
            throw (new account_1.default('ACCOUNT_INVALID_CONSTRUCTION', 'Unsupported construction'));
        }
        if (__classPrivateFieldGet(this, _Account_publicKeyPair, "f").keyType !== requiredKeyType && requiredKeyType !== undefined) {
            throw (new Error('keytype not valid'));
        }
        // This is the correct way to assert, the compiler just does not know it
        // eslint-disable-next-line @typescript-eslint/consistent-type-assertions
        __classPrivateFieldSet(this, _Account_keyType, __classPrivateFieldGet(this, _Account_publicKeyPair, "f").keyType, "f");
    }
    /**
     * Sign some data and generate a detached signature in SEC format
     */
    sign(data, options) {
        options = {
            raw: false,
            forCert: false,
            ...options
        };
        if (this.isIdentifier()) {
            throw (new account_1.default('ACCOUNT_NO_IDENTIFIER_SIGN', 'May not sign from an identifier account'));
        }
        if (__classPrivateFieldGet(this, _Account_privateKeyPair, "f") === null) {
            throw (new Error('May not sign unless a private key is available'));
        }
        if (!__classPrivateFieldGet(this, _Account_keyPairHandlesHashing, "f") && !options.raw) {
            data = (0, hash_1.Hash)(Buffer.from(data));
        }
        return (__classPrivateFieldGet(this, _Account_privateKeyPair, "f").sign(data, options));
    }
    /**
     * Verify a detached signature against some data
     */
    verify(data, signature, options) {
        options = {
            raw: false,
            forCert: false,
            ...options
        };
        if (!__classPrivateFieldGet(this, _Account_keyPairHandlesHashing, "f") && !options.raw) {
            data = (0, hash_1.Hash)(Buffer.from(data));
        }
        return (__classPrivateFieldGet(this, _Account_publicKeyPair, "f").verify(data, signature, options));
    }
    encrypt(data) {
        return (__classPrivateFieldGet(this, _Account_publicKeyPair, "f").encrypt(data));
    }
    decrypt(data) {
        if (!this.hasPrivateKey || !__classPrivateFieldGet(this, _Account_privateKeyPair, "f")) {
            throw (new Error('Cannot decrypt without having a private key in Account'));
        }
        return (__classPrivateFieldGet(this, _Account_privateKeyPair, "f").decrypt(data));
    }
    get supportsEncryption() {
        return (__classPrivateFieldGet(this, _Account_publicKeyPair, "f").supportsEncryption);
    }
    /**
     * Internal helper method to copy accounts
     */
    _getPrivateKey() {
        return (__classPrivateFieldGet(this, _Account_privateKeyPair, "f"));
    }
    /**
     * Internal helper method to copy accounts
     */
    _getPublicKey() {
        return (__classPrivateFieldGet(this, _Account_publicKeyPair, "f"));
    }
    comparePublicKey(acct) {
        return (Account.comparePublicKeys(this, acct));
    }
    /**
     * Get token relative to account blockOrder and operationIndex
     */
    generateIdentifier(type, blockHash, operationIndex) {
        const accountOpeningHash = block_1.default.getAccountOpeningHash(this);
        const isOpeningString = typeof blockHash === 'string' && blockHash === block_1.default.NO_PREVIOUS;
        const isOpeningHash = accountOpeningHash.compareHexString(blockHash);
        const isOpening = isOpeningString || isOpeningHash || blockHash === undefined;
        if (blockHash === undefined || isOpening) {
            blockHash = accountOpeningHash;
        }
        if (!block_1.BlockHash.isInstance(blockHash)) {
            blockHash = new block_1.BlockHash(blockHash);
        }
        if (this.isIdentifier()) {
            // A valid first token must be NO_PREVIOUS, generating from a network identifier, and have an operation index of 0
            const selfIsNetwork = __classPrivateFieldGet(this, _Account_keyType, "f") === AccountKeyAlgorithm.NETWORK;
            const isGeneratingToken = type === AccountKeyAlgorithm.TOKEN;
            const isFirstOperation = operationIndex === 0;
            const validFirstToken = selfIsNetwork && isGeneratingToken && isFirstOperation && isOpening;
            // If this account is an identifier account and it is not a valid first token, we should throw
            if (!validFirstToken) {
                throw (new Error('Cannot generate identifier from another identifier, aside from a network identifier generating the first base token'));
            }
        }
        const seed = (0, hash_1.Hash)(Buffer.from([...this.publicKeyAndType, ...blockHash.getBuffer()]));
        // Create a new account with the seed, and the operation index as the index
        return (Account.fromSeed(seed, operationIndex, type));
    }
    /**
     * Get the encoded public key string
     */
    get publicKeyString() {
        if (!__classPrivateFieldGet(this, _Account_publicKeyString, "f")) {
            __classPrivateFieldSet(this, _Account_publicKeyString, derivePublicKeyStringFromPublicKey(__classPrivateFieldGet(this, _Account_publicKeyPair, "f").publicKey, __classPrivateFieldGet(this, _Account_keyType, "f")), "f");
        }
        return (__classPrivateFieldGet(this, _Account_publicKeyString, "f"));
    }
    /**
     * Get the type of key for this account (SECP256K1 / R1 or ED25519)
     */
    get keyType() {
        return (__classPrivateFieldGet(this, _Account_keyType, "f"));
    }
    /**
     * Get the public key for this account
     */
    get publicKey() {
        return (__classPrivateFieldGet(this, _Account_publicKeyPair, "f").publicKey);
    }
    get publicKeyAndType() {
        const retval = new Uint8Array([
            this.keyType,
            ...this.publicKey.getBuffer()
        ]);
        const retvalBuffer = Buffer.from(retval);
        return (retvalBuffer);
    }
    get publicKeyAndTypeString() {
        if (__classPrivateFieldGet(this, _Account_publicKeyAndTypeString, "f")) {
            return (__classPrivateFieldGet(this, _Account_publicKeyAndTypeString, "f"));
        }
        // eslint-disable-next-line @typescript-eslint/consistent-type-assertions
        __classPrivateFieldSet(this, _Account_publicKeyAndTypeString, '0x' + Buffer.from(this.publicKeyAndType).toString('hex').toUpperCase(), "f");
        return (__classPrivateFieldGet(this, _Account_publicKeyAndTypeString, "f"));
    }
    /**
     * Determine if this account has a private key associated with it
     */
    get hasPrivateKey() {
        if (__classPrivateFieldGet(this, _Account_privateKeyPair, "f") !== null) {
            return (true);
        }
        return (false);
    }
    /**
     * Determine the size of signatures (in bytes) or null if the key
     * type cannot produce signatures
     */
    get signatureSize() {
        /** EcDSA and Ed25519 both have 64-byte signatures, so hard code this value for now */
        switch (__classPrivateFieldGet(this, _Account_keyType, "f")) {
            case AccountKeyAlgorithm.ECDSA_SECP256K1:
            case AccountKeyAlgorithm.ECDSA_SECP256R1:
            case AccountKeyAlgorithm.ED25519:
                return (64);
            default:
                return (null);
        }
    }
    /**
     * Determine if a key type is an identifier key type
     */
    static isIdentifierKeyType(keyType) {
        return (identifierKeyTypes.includes(keyType));
    }
    /**
     * Determine if an account is an identifier
     */
    isIdentifier() {
        // We are checking here, so it is safe to assert the type
        // eslint-disable-next-line @typescript-eslint/consistent-type-assertions
        return (identifierKeyTypes.includes(this.keyType));
    }
    isAccount() {
        return (!this.isIdentifier());
    }
    isKeyType(checkKeyType) {
        // We need to assert this type because we are changing what the constructed type is
        // eslint-disable-next-line @typescript-eslint/consistent-type-assertions
        return (this.keyType === checkKeyType);
    }
    isStorage() {
        return (this.isKeyType(AccountKeyAlgorithm.STORAGE));
    }
    isNetwork() {
        return (this.isKeyType(AccountKeyAlgorithm.NETWORK));
    }
    isToken() {
        return (this.isKeyType(AccountKeyAlgorithm.TOKEN));
    }
    isMultisig() {
        return (this.isKeyType(AccountKeyAlgorithm.MULTISIG));
    }
    assertKeyType(keyType) {
        // We need to assert this type because we are changing what the constructed type is
        // eslint-disable-next-line @typescript-eslint/consistent-type-assertions
        if (this.keyType !== keyType) {
            throw (new Error(`Operation required ${AccountKeyAlgorithm[keyType]} but got ${AccountKeyAlgorithm[this.keyType]}`));
        }
        // We need to assert this type because we are changing what the constructed type is
        // eslint-disable-next-line @typescript-eslint/consistent-type-assertions
        return this;
    }
    assertAccount() {
        if (this.isIdentifier() !== false) {
            throw (new Error('Required Account but got Identifier'));
        }
        // We need to assert this type because we are changing what the constructed type is
        // eslint-disable-next-line @typescript-eslint/consistent-type-assertions
        return this;
    }
    assertIdentifier() {
        if (this.isIdentifier() !== true) {
            throw (new Error(`Required Identifier but got Account, ${this.keyType}`));
        }
        // We need to assert this type because we are changing what the constructed type is
        // eslint-disable-next-line @typescript-eslint/consistent-type-assertions
        return this;
    }
    toJSON() {
        return (this.publicKeyString.get());
    }
}
exports.Account = Account;
_Account_privateKeyPair = new WeakMap(), _Account_publicKeyPair = new WeakMap(), _Account_keyType = new WeakMap(), _Account_keyPairHandlesHashing = new WeakMap(), _Account_publicKeyString = new WeakMap(), _Account_publicKeyAndTypeString = new WeakMap();
/*
 * Make the things we export static methods since this is our default export
 */
Account.AccountKeyAlgorithm = AccountKeyAlgorithm;
Account.ExternalKeyPair = ExternalKeyPair;
Account.isInstance = (0, helper_2.checkableGenerator)(Account);
Account.Set = (0, helper_1.setGenerator)(Account, function (account) {
    const retval = account.publicKeyAndTypeString;
    return (retval);
}, function (publicKeyAndType) {
    const retval = Account.fromPublicKeyAndType(publicKeyAndType);
    return (retval);
});
exports["default"] = Account;
/** @internal */
exports.AccountTesting = {
    KeyStorage,
    SeedStorage,
    SignatureStorage,
    ECDSASECP256K1PrivateKey,
    ECDSASECP256K1PublicKey,
    ECDSASECP256R1PrivateKey,
    ECDSASECP256R1PublicKey,
    ED25519PrivateKey,
    ED25519PublicKey,
    ECDSASECP256K1Signature,
    ECDSASECP256R1Signature,
    ED25519Signature,
    PublicKeyString,
    ECDSASECP256K1KeyPair,
    ECDSASECP256R1KeyPair,
    ED25519KeyPair
};


/***/ }),

/***/ 6158:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var _Block_instances, _a, _Block_valueBytes, _Block_valueHash, _Block_getSortedRequiredSigners, _Block_validateOperationsPurpose, _Block_validateSignerField, _Block_validateSignatures, _BlockBuilder_block;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BlockBuilder = exports.Block = exports.BlockHash = exports.AdjustMethod = exports.BlockPurpose = void 0;
exports.toAdjustMethod = toAdjustMethod;
const account_1 = __importStar(__webpack_require__(9415));
const buffer_1 = __webpack_require__(3310);
const hash_1 = __webpack_require__(7908);
const ASN1 = __importStar(__webpack_require__(6045));
const helper_1 = __webpack_require__(3208);
const util_1 = __webpack_require__(9023);
const Operations = __importStar(__webpack_require__(2778));
const block_1 = __importDefault(__webpack_require__(7412));
const common_1 = __webpack_require__(5663);
const NO_PREVIOUS = '9bd05fa2-8e59-42a2-8153-26d8e8c10143:NO_PREVIOUS';
var BlockPurpose;
(function (BlockPurpose) {
    BlockPurpose[BlockPurpose["GENERIC"] = 0] = "GENERIC";
    BlockPurpose[BlockPurpose["FEE"] = 1] = "FEE";
})(BlockPurpose || (exports.BlockPurpose = BlockPurpose = {}));
function toBlockPurpose(value) {
    if (typeof value === 'bigint') {
        value = Number(value);
    }
    if (typeof value !== 'number') {
        throw (new Error(`Invalid BlockPurpose supplied: got ${value} -- ${typeof value}`));
    }
    // We add this type assertion to make sure the switch is exhaustive
    // eslint-disable-next-line @typescript-eslint/consistent-type-assertions
    switch (value) {
        case BlockPurpose.GENERIC:
        case BlockPurpose.FEE:
            return (value);
    }
    throw (new Error(`Invalid BlockPurpose supplied: got ${value} -- ${typeof value}`));
}
var AdjustMethod;
(function (AdjustMethod) {
    AdjustMethod[AdjustMethod["ADD"] = 0] = "ADD";
    AdjustMethod[AdjustMethod["SUBTRACT"] = 1] = "SUBTRACT";
    AdjustMethod[AdjustMethod["SET"] = 2] = "SET";
})(AdjustMethod || (exports.AdjustMethod = AdjustMethod = {}));
function toAdjustMethod(value) {
    if (typeof value === 'bigint') {
        value = Number(value);
    }
    if (typeof value !== 'number') {
        throw (new Error(`Invalid AdjustMethod supplied: got ${value} -- ${typeof value}`));
    }
    // We add this type assertion to make sure the switch is exhaustive
    // eslint-disable-next-line @typescript-eslint/consistent-type-assertions
    switch (value) {
        case AdjustMethod.ADD:
        case AdjustMethod.SET:
        case AdjustMethod.SUBTRACT:
            return (value);
    }
    throw (new Error(`Invalid AdjustMethod supplied: got ${value} -- ${typeof value}`));
}
/**
 * Block hash
 */
class BlockHash extends buffer_1.BufferStorage {
    static getAccountOpeningHash(account) {
        return (new BlockHash((0, hash_1.Hash)(account.publicKey.getBuffer())));
    }
    fromData(data) {
        const blockhash = (0, hash_1.Hash)(data);
        return (new BlockHash(blockhash));
    }
    get hashFunctionName() {
        return (hash_1.Hash.functionName);
    }
    constructor(blockhash) {
        super(blockhash, 32);
    }
    toJSON() {
        return (this.toString());
    }
    toString() {
        // eslint-disable-next-line @typescript-eslint/consistent-type-assertions
        return super.toString('hex');
    }
}
exports.BlockHash = BlockHash;
BlockHash.isInstance = (0, helper_1.checkableGenerator)(BlockHash);
BlockHash.Set = (0, helper_1.setGenerator)(BlockHash, function (value) {
    return (value.toString());
}, function (value) {
    return (new BlockHash(Buffer.from(value, 'hex')));
});
/** @internal */
const BlockV1ASN1Schema = [
    0n,
    ASN1.BufferStorageASN1.Validate.IsInteger,
    { choice: [ASN1.BufferStorageASN1.Validate.IsInteger, ASN1.BufferStorageASN1.Validate.IsNull] },
    { type: 'date', kind: 'general' },
    ASN1.BufferStorageASN1.Validate.IsOctetString,
    { choice: [ASN1.BufferStorageASN1.Validate.IsOctetString, ASN1.BufferStorageASN1.Validate.IsNull] },
    ASN1.BufferStorageASN1.Validate.IsOctetString,
    { sequenceOf: { choice: Object.values(Operations.BlockOperationASN1Schema) } },
    ASN1.BufferStorageASN1.Validate.IsOctetString
];
const multisigSignerInfoASN1Schema = [
    ASN1.BufferStorageASN1.Validate.IsOctetString,
    {
        sequenceOf: {
            choice: [
                // XXX:TODO We need to use a type assertion here because the ASN1 schema does not support recursive types
                // eslint-disable-next-line @typescript-eslint/consistent-type-assertions
                (() => multisigSignerInfoASN1Schema),
                ASN1.BufferStorageASN1.Validate.IsOctetString
            ]
        }
    }
];
function parseBlockSignerFieldContainer(input, state) {
    if (!state) {
        state = { depth: 0 };
    }
    else if (state.depth > 3) {
        throw (new block_1.default('BLOCK_INVALID_MULTISIG_SIGNER_DEPTH', 'Multisig signer depth exceeded maximum allowed depth'));
    }
    const multisigAccount = account_1.default.fromPublicKeyAndType(input[0]).assertKeyType(account_1.AccountKeyAlgorithm.MULTISIG);
    const signers = [];
    // XXX:TODO We need to use a type assertion here because the ASN1 schema does not support recursive types properly
    // eslint-disable-next-line @typescript-eslint/consistent-type-assertions
    for (const signer of input[1]) {
        let parsedSigner;
        if (Buffer.isBuffer(signer)) {
            parsedSigner = account_1.default.fromPublicKeyAndType(signer).assertAccount();
        }
        else if (signer && Array.isArray(signer)) {
            if (signer.length !== 2) {
                throw (new Error('Multisig signer must have two items'));
            }
            if (!Buffer.isBuffer(signer[0])) {
                throw (new Error('Multisig signer first item must be a buffer'));
            }
            if (!Array.isArray(signer[1])) {
                throw (new Error('Multisig signer second item must be an array'));
            }
            // XXX:TODO We need to use a type assertion here because we are not asserting the type recursively
            // eslint-disable-next-line @typescript-eslint/consistent-type-assertions
            const inner = parseBlockSignerFieldContainer(signer, { depth: state.depth + 1 });
            parsedSigner = inner.parsed;
        }
        else {
            throw (new Error('Multisig signer must be a buffer or an array'));
        }
        signers.push(parsedSigner);
    }
    return ({
        parsed: [multisigAccount, signers],
        depth: state.depth
    });
}
function getMultisigSignerContainer(input) {
    const out = [input[0].publicKeyAndType, []];
    for (const signer of input[1]) {
        let parsed;
        if (Array.isArray(signer)) {
            parsed = getMultisigSignerContainer(signer);
        }
        else {
            parsed = signer.publicKeyAndType;
        }
        out[1].push(parsed);
    }
    // XXX:TODO We need to use a type assertion here because the ASN1 schema does not support recursive types properly
    // eslint-disable-next-line @typescript-eslint/consistent-type-assertions
    return out;
}
/** @internal */
const BlockV2ASN1Schema = {
    type: 'context',
    kind: 'explicit',
    value: 1,
    contains: [
        ASN1.BufferStorageASN1.Validate.IsInteger,
        { optional: ASN1.BufferStorageASN1.Validate.IsInteger },
        { type: 'date', kind: 'general' },
        ASN1.BufferStorageASN1.Validate.IsInteger,
        ASN1.BufferStorageASN1.Validate.IsOctetString,
        {
            choice: [
                ASN1.BufferStorageASN1.Validate.IsNull,
                // If principal has a private key, the signature of principal
                ASN1.BufferStorageASN1.Validate.IsOctetString,
                // If principal does not have private key, list of accounts signing on behalf of principal and their signatures
                multisigSignerInfoASN1Schema
            ]
        },
        ASN1.BufferStorageASN1.Validate.IsOctetString,
        { sequenceOf: { choice: Object.values(Operations.BlockOperationASN1Schema) } },
        {
            choice: [
                // If principal has a private key, the signature of principal
                ASN1.BufferStorageASN1.Validate.IsOctetString,
                // If principal does not have private key, list of accounts signing on behalf of principal and their signatures
                { sequenceOf: ASN1.BufferStorageASN1.Validate.IsOctetString }
            ]
        }
    ]
};
const BlockASN1Schema = {
    choice: [
        BlockV1ASN1Schema,
        BlockV2ASN1Schema
    ]
};
function parseBlockSignerFieldJSON(input) {
    if (!Array.isArray(input)) {
        return (account_1.default.toAccount(input).assertAccount());
    }
    if (input.length !== 2) {
        throw (new Error('Multisig signer field must have two items'));
    }
    const signer = account_1.default.toAccount(input[0]).assertKeyType(account_1.AccountKeyAlgorithm.MULTISIG);
    const innerSigners = [];
    for (const signer of input[1]) {
        innerSigners.push(parseBlockSignerFieldJSON(signer));
    }
    return ([signer, innerSigners]);
}
/**
 * Statically assert that the BlockASN1 type is compatible with BlockASN1Schema
 * @internal
 */
// eslint-disable-next-line @typescript-eslint/no-unused-vars
function _ignore_static_checks() {
    // V1 Checks
    // eslint-disable-next-line @typescript-eslint/no-unused-vars,@typescript-eslint/consistent-type-assertions
    const _ignore_check_blockasn1v1_forward_1 = {};
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    const _ignore_check_blockasn1v1_forward_2 = _ignore_check_blockasn1v1_forward_1;
    // eslint-disable-next-line @typescript-eslint/no-unused-vars,@typescript-eslint/consistent-type-assertions
    const _ignore_check_blockasn1v1_reverse_1 = {};
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    const _ignore_check_blockasn1v1_reverse_2 = _ignore_check_blockasn1v1_reverse_1;
    // V2 Checks
    // eslint-disable-next-line @typescript-eslint/no-unused-vars,@typescript-eslint/consistent-type-assertions
    const _ignore_check_blockasn1v2_forward_1 = {};
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    const _ignore_check_blockasn1v2_forward_2 = _ignore_check_blockasn1v2_forward_1;
    // eslint-disable-next-line @typescript-eslint/no-unused-vars,@typescript-eslint/consistent-type-assertions
    const _ignore_check_blockasn1v2_reverse_1 = {};
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    const _ignore_check_blockasn1v2_reverse_2 = _ignore_check_blockasn1v2_reverse_1;
}
function MapV1InputValues(input) {
    const output = {};
    if (input.version !== 1) {
        throw (new Error('MapInputValues should not be called with version != 1'));
    }
    output.version = input.version;
    if (input.date !== undefined) {
        output.date = new Date(input.date);
    }
    /*
     * Import account
     */
    output.account = account_1.default.toAccount(input.account) ?? undefined;
    if (Array.isArray(input.signer)) {
        throw (new Error('V1 block signer must not be a multisig signer'));
    }
    output.signer = account_1.default.toAccount(input.signer);
    if (!output.signer && output.account?.isAccount()) {
        output.signer = output.account;
    }
    /*
     * Import previous block hash
     */
    if (input.previous !== undefined) {
        if (BlockHash.isInstance(input.previous)) {
            output.previous = input.previous;
        }
        else if (input.previous === NO_PREVIOUS) {
            if (output.account !== undefined) {
                output.previous = BlockHash.getAccountOpeningHash(output.account);
            }
        }
        else {
            output.previous = new BlockHash(input.previous);
        }
    }
    /*
     * Import network
     */
    if (input.network !== undefined) {
        if (typeof input.network === 'bigint') {
            output.network = input.network;
        }
        else {
            output.network = BigInt(input.network);
        }
    }
    /*
     * Import Subnet
     */
    if (input.subnet !== undefined) {
        if (typeof input.subnet === 'bigint') {
            output.subnet = input.subnet;
        }
        else {
            output.subnet = BigInt(input.subnet);
        }
    }
    /*
     * Import operations from JSON
     */
    if (input.operations !== undefined) {
        output.operations = Operations.ImportOperationsJSON(input.operations);
    }
    // This is valid, the compiler does not understand that we are adding all of the values in this function
    // eslint-disable-next-line @typescript-eslint/consistent-type-assertions
    return output;
}
function MapV2InputValues(input) {
    const output = {};
    if (input.version !== 2) {
        throw (new Error('MapInputValues should not be called with version != 2'));
    }
    output.version = input.version;
    output.purpose = input.purpose;
    if (input.date !== undefined) {
        output.date = new Date(input.date);
    }
    /*
     * Import account
     */
    output.account = account_1.default.toAccount(input.account) ?? undefined;
    /*
     * Import previous block hash
     */
    if (input.previous !== undefined) {
        if (BlockHash.isInstance(input.previous)) {
            output.previous = input.previous;
        }
        else if (input.previous === NO_PREVIOUS) {
            if (output.account) {
                output.previous = BlockHash.getAccountOpeningHash(output.account);
            }
        }
        else {
            output.previous = new BlockHash(input.previous);
        }
    }
    /*
     * Import network
     */
    if (input.network !== undefined) {
        output.network = BigInt(input.network);
    }
    /*
     * Import Subnet
     */
    if (input.subnet !== undefined) {
        output.subnet = BigInt(input.subnet);
    }
    /*
     * Import operations from JSON
     */
    if (input.operations !== undefined) {
        output.operations = Operations.ImportOperationsJSON(input.operations);
    }
    if (input.signer !== undefined) {
        output.signer = parseBlockSignerFieldJSON(input.signer);
    }
    // This is valid, the compiler does not understand that we are adding all of the values in this function
    // eslint-disable-next-line @typescript-eslint/consistent-type-assertions
    return output;
}
function assertBlockSignatureField(input) {
    if (input.length < 1) {
        throw (new Error('Input must include 1+ signatures'));
    }
}
/**
 * Block:  An item which contains a number of operations (transactions) which
 * originated from an account at a particular instant
 */
class Block {
    get principal() {
        if (Array.isArray(this.signer)) {
            return (this.signer[0]);
        }
        else {
            return (this.signer);
        }
    }
    static async fromUnsignedJSON(input) {
        const inputCheck = input;
        if (typeof inputCheck === 'object' && inputCheck !== null) {
            if ('signature' in inputCheck || 'signatures' in inputCheck) {
                throw (new Error('fromUnsignedJSON() was called when a signature(s) already exists'));
            }
        }
        const container = this.getASN1ContainerWithoutSignature(input);
        // We have to ignore the type here because the ASN1.JStoASN1 function does not handle recursive types well
        // @ts-ignore
        const bytes = ASN1.JStoASN1(container).toBER(false);
        const hash = new BlockHash((0, hash_1.Hash)(Buffer.from(bytes)));
        const signers = __classPrivateFieldGet(this, _a, "m", _Block_getSortedRequiredSigners).call(this, input.signer);
        const signatures = await Promise.all(signers.map(async function (signer) {
            const signature = await signer.sign(hash.getBuffer());
            return (signature.getBuffer());
        }));
        let blockInput;
        if (input.version === 1) {
            blockInput = { ...input, signature: signatures[0] };
        }
        else {
            blockInput = { ...input, signatures };
        }
        return (new _a(blockInput));
    }
    static isValidJSON(block, version) {
        if (!block || typeof block !== 'object' || Array.isArray(block)) {
            return (false);
        }
        if (!('version' in block)) {
            return (false);
        }
        if (version !== undefined && block.version !== version) {
            return (false);
        }
        const checkFields = ['date', 'previous', 'network', 'network', 'account', 'signer', 'operations'];
        if (block.version === 1) {
            checkFields.push('signature');
        }
        else if (block.version === 2) {
            checkFields.push('signatures');
            checkFields.push('purpose');
        }
        else {
            return (false);
        }
        for (const checkField of checkFields) {
            // eslint-disable-next-line @typescript-eslint/consistent-type-assertions
            if (!(checkField in block) || block[checkField] === undefined) {
                return (false);
            }
        }
        return (true);
    }
    constructor(input) {
        _Block_instances.add(this);
        _Block_valueBytes.set(this, void 0);
        _Block_valueHash.set(this, void 0);
        // Extra attributes
        this.$opening = false;
        if (typeof input === 'string') {
            input = Buffer.from(input, 'base64');
        }
        if ((0, helper_1.isBuffer)(input)) {
            input = (0, helper_1.bufferToArrayBuffer)(input);
        }
        if (util_1.types.isArrayBuffer(input)) {
            const data = new ASN1.BufferStorageASN1(input, BlockASN1Schema).getASN1();
            if (Array.isArray(data)) {
                if (data[0] !== 0n) {
                    throw (new Error('Invalid block version without context tag'));
                }
                this.version = 1;
                this.purpose = BlockPurpose.GENERIC;
                this.network = data[1];
                this.subnet = data[2] ?? undefined;
                this.date = data[3].date;
                const signerContainer = data[4];
                this.signer = account_1.default.fromPublicKeyAndType(signerContainer).assertAccount();
                const acctItem = data[5];
                if (acctItem === null) {
                    this.account = this.signer;
                }
                else {
                    this.account = account_1.default.fromPublicKeyAndType(acctItem);
                    if (this.account.comparePublicKey(this.signer)) {
                        throw (new Error('Account should not be in block when it is same as signer, we cannot use this block'));
                    }
                }
                const prevHashBuf = data[6];
                this.previous = new BlockHash(prevHashBuf);
                this.operations = Operations.ImportOperationsASN1(data[7], this.network);
                this.signatures = [data[8]];
            }
            else if (data.value === 1) {
                this.version = 2;
                const container = data.contains;
                this.network = container[0];
                this.subnet = container[1] ?? undefined;
                this.date = container[2].date;
                this.purpose = toBlockPurpose(container[3]);
                this.account = account_1.default.fromPublicKeyAndType(container[4]);
                const signersContainer = container[5];
                if (signersContainer === null) {
                    this.signer = this.account.assertAccount();
                }
                else if (Buffer.isBuffer(signersContainer)) {
                    this.signer = account_1.default.fromPublicKeyAndType(signersContainer).assertAccount();
                    if (this.account.comparePublicKey(this.signer)) {
                        throw (new Error('Signer should not be in block when it is same as account, we cannot use this block'));
                    }
                }
                else {
                    this.signer = parseBlockSignerFieldContainer(signersContainer).parsed;
                }
                this.previous = new BlockHash(container[6]);
                this.operations = Operations.ImportOperationsASN1(container[7], this.network);
                const signatureContainer = container[8];
                if (Buffer.isBuffer(signatureContainer)) {
                    this.signatures = [signatureContainer];
                }
                else {
                    if (signatureContainer.length <= 1) {
                        throw (new Error('Signature field invalid, must be greater than one when using sequence of'));
                    }
                    assertBlockSignatureField(signatureContainer);
                    this.signatures = signatureContainer;
                }
            }
            else {
                throw (new Error('Unknown block version'));
            }
            __classPrivateFieldSet(this, _Block_valueBytes, input, "f");
        }
        else {
            if (_a.isInstance(input)) {
                this.version = input.version;
                this.purpose = input.purpose;
                this.date = input.date;
                this.previous = input.previous;
                this.network = input.network;
                this.subnet = input.subnet;
                this.account = input.account;
                this.operations = input.operations;
                this.signer = input.signer;
                this.signatures = input.signatures;
            }
            else if (_a.isValidJSON(input, 1)) {
                /*
                * Map input to our values
                */
                const { version, date, previous, network, subnet, account, operations, signer } = MapV1InputValues(input);
                this.version = version;
                this.purpose = BlockPurpose.GENERIC;
                this.date = date;
                this.previous = previous;
                this.network = network;
                this.subnet = subnet;
                this.account = account;
                this.operations = operations;
                this.signer = signer;
                /*
                * We must handle the signature last because we will
                * sign the hash of the block based on what has been
                * processed
                */
                if (input.signature === undefined) {
                    throw (new Error('Cannot construct block without a signature and explicit direction to sign'));
                }
                let signature;
                if (typeof input.signature === 'string') {
                    signature = Buffer.from(input.signature, 'hex');
                }
                else {
                    signature = Buffer.from(input.signature);
                }
                this.signatures = [signature];
            }
            else if (_a.isValidJSON(input, 2)) {
                /*
                * Map input to our values
                */
                const { version, date, previous, network, subnet, account, operations, signer, purpose } = MapV2InputValues(input);
                this.version = version;
                this.purpose = purpose;
                this.date = date;
                this.previous = previous;
                this.network = network;
                this.subnet = subnet;
                this.account = account;
                this.signer = signer;
                this.operations = operations;
                /*
                * We must handle the signature last because we will
                * sign the hash of the block based on what has been
                * processed
                */
                if (input.signatures === undefined) {
                    throw (new Error('Cannot construct block without a signature and explicit direction to sign'));
                }
                const signatures = input.signatures.map(function (signature) {
                    if (typeof signature === 'string') {
                        return (Buffer.from(signature, 'hex'));
                    }
                    else {
                        return (Buffer.from(signature));
                    }
                });
                assertBlockSignatureField(signatures);
                this.signatures = signatures;
            }
            else {
                throw (new Error('Cannot construct block, it is not a valid Block JSON object'));
            }
            /* XXX:TODO: Verify that no extra keys were passed in */
        }
        if (this.previous.compareHexString(this.hash)) {
            throw (new block_1.default('BLOCK_PREVIOUS_SELF', 'internal error: Block references itself'));
        }
        const checkAccountOpening = _a.getAccountOpeningHash(this.account);
        this.$opening = this.previous.compareHexString(checkAccountOpening);
        if (this.network < 0n) {
            throw (new Error('Network ID must be a positive number'));
        }
        if (this.subnet !== undefined) {
            if (this.subnet < 0n) {
                throw (new Error('Subnet ID must be a positive number'));
            }
        }
        if (this.version !== 1 && this.version !== 2) {
            throw (new block_1.default('BLOCK_INVALID_VERSION', 'We only support Blocks Version 1-2'));
        }
        if (this.account.isMultisig()) {
            throw (new block_1.default('BLOCK_NO_MULTISIG_OP', 'Cannot create a block for a multisig account'));
        }
        if (this.account.isMultisig()) {
            throw (new block_1.default('BLOCK_NO_MULTISIG_OP', 'Cannot create a block for a multisig account'));
        }
        __classPrivateFieldGet(this, _Block_instances, "m", _Block_validateSignerField).call(this);
        __classPrivateFieldGet(this, _Block_instances, "m", _Block_validateOperationsPurpose).call(this);
        __classPrivateFieldGet(this, _Block_instances, "m", _Block_validateSignatures).call(this);
    }
    static getAccountOpeningHash(account) {
        return (BlockHash.getAccountOpeningHash(account));
    }
    toBytes(includeSignatures = true) {
        if (__classPrivateFieldGet(this, _Block_valueBytes, "f") !== undefined && includeSignatures) {
            return (__classPrivateFieldGet(this, _Block_valueBytes, "f"));
        }
        const sharedBlockValues = {
            previous: this.previous,
            operations: this.operations,
            account: this.account,
            network: this.network,
            subnet: this.subnet,
            date: this.date
        };
        let container;
        if (this.version === 1) {
            if (Array.isArray(this.signer) || this.signatures.length !== 1) {
                throw (new Error('Block v1 only supports single signer'));
            }
            container = _a.getV1ASN1ContainerWithoutSignature({
                ...sharedBlockValues,
                version: 1,
                signer: this.signer
            });
            if (includeSignatures) {
                container.push(this.signatures[0]);
            }
        }
        else {
            const versionTag = this.version - 1;
            if (versionTag !== 1) {
                // We only support version 2
                throw (new block_1.default('BLOCK_INVALID_VERSION', 'We only support version 1/2 blocks'));
            }
            const v2Container = _a.getV2ASN1ContainerWithoutSignature({
                ...sharedBlockValues,
                purpose: this.purpose,
                version: this.version,
                signer: this.signer
            });
            const baseContextTag = {
                type: 'context',
                kind: 'explicit',
                value: versionTag
            };
            if (includeSignatures) {
                let signatureContainer;
                if (this.signatures.length > 1) {
                    signatureContainer = this.signatures;
                }
                else if (this.signatures.length === 1) {
                    signatureContainer = this.signatures[0];
                }
                else {
                    throw (new Error('Block has not been signed'));
                }
                container = { ...baseContextTag, contains: [...v2Container, signatureContainer] };
            }
            else {
                container = { ...baseContextTag, contains: v2Container };
            }
        }
        // We know the container is valid because of the container type, but the ASN1.JStoASN1 function does not handle recursive types well
        // @ts-ignore
        const retval = ASN1.JStoASN1(container).toBER(false);
        if (includeSignatures) {
            __classPrivateFieldSet(this, _Block_valueBytes, retval, "f");
        }
        return (retval);
    }
    static getV1ASN1ContainerWithoutSignature(input) {
        let outputAccount;
        if (input.account.comparePublicKey(input.signer)) {
            outputAccount = null;
        }
        else {
            outputAccount = input.account.publicKeyAndType;
        }
        if (input.version !== 1) {
            throw (new Error('Cannot call getASN1ContainerWithoutSignature when version != 1'));
        }
        return ([
            0n,
            input.network,
            input.subnet ?? null,
            { type: 'date', kind: 'general', date: input.date },
            input.signer.publicKeyAndType,
            outputAccount,
            Buffer.from(input.previous.get()),
            Operations.ExportBlockOperations([...input.operations])
        ]);
    }
    static getV2ASN1ContainerWithoutSignature(input) {
        if (input.version !== 2) {
            throw (new Error('Only version 2 supported'));
        }
        let signerContainer;
        if (Array.isArray(input.signer)) {
            signerContainer = getMultisigSignerContainer(input.signer);
        }
        else if (input.signer.comparePublicKey(input.account)) {
            signerContainer = null;
        }
        else {
            signerContainer = input.signer.publicKeyAndType;
        }
        return ([
            input.network,
            input.subnet,
            { type: 'date', kind: 'general', date: input.date },
            BigInt(input.purpose),
            input.account.publicKeyAndType,
            signerContainer,
            Buffer.from(input.previous.get()),
            Operations.ExportBlockOperations([...input.operations])
        ]);
    }
    static getASN1ContainerWithoutSignature(input) {
        if (input.version === 1) {
            return (this.getV1ASN1ContainerWithoutSignature(input));
        }
        else if (input.version === 2) {
            return ({
                type: 'context',
                kind: 'explicit',
                value: 1,
                contains: this.getV2ASN1ContainerWithoutSignature(input)
            });
        }
        else {
            throw (new block_1.default('BLOCK_INVALID_VERSION', 'Invalid Version'));
        }
    }
    toJSON(options) {
        const additionalFields = {};
        if (options?.addBinary) {
            additionalFields['$binary'] = Buffer.from(this.toBytes()).toString('base64');
        }
        const signatures = this.signatures.map(function (signature) {
            return (signature.toString('hex').toUpperCase());
        });
        if (this.version === 1) {
            additionalFields.signature = signatures[0];
        }
        else {
            additionalFields.signatures = signatures;
        }
        return ({
            version: this.version,
            date: this.date,
            previous: this.previous,
            account: this.account,
            purpose: this.purpose,
            // XXX:TODO We need to use a type assertion here because toJSONSerializable does not support recursive types
            // eslint-disable-next-line @typescript-eslint/consistent-type-assertions
            signer: this.signer,
            network: this.network,
            subnet: this.subnet,
            operations: Operations.ExportOperationsJSON(this.operations),
            $hash: this.hash,
            $opening: this.$opening,
            ...additionalFields
        });
    }
    /**
     * Hash of the block minus the signature
     *
     * XXX:TODO: Should the hash of the block normally include the
     *           signature ?  One reason against is that it would
     *           allow for identical blocks that only differ by
     *           signature (which isn't signed)
     */
    get hash() {
        if (__classPrivateFieldGet(this, _Block_valueHash, "f") !== undefined) {
            return (__classPrivateFieldGet(this, _Block_valueHash, "f"));
        }
        const retval = new BlockHash((0, hash_1.Hash)(Buffer.from(this.toBytes(false))));
        __classPrivateFieldSet(this, _Block_valueHash, retval, "f");
        return (retval);
    }
}
exports.Block = Block;
_a = Block, _Block_valueBytes = new WeakMap(), _Block_valueHash = new WeakMap(), _Block_instances = new WeakSet(), _Block_getSortedRequiredSigners = function _Block_getSortedRequiredSigners(input) {
    const queue = [input];
    const visited = new account_1.default.Set();
    const out = [];
    while (queue.length > 0) {
        // We can assume that the signerFieldQueue is not empty here since the loop condition checks it
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        const cur = queue.shift();
        if (account_1.default.isInstance(cur)) {
            if (visited.has(cur)) {
                continue;
            }
            visited.add(cur);
            out.push(cur);
        }
        else {
            queue.unshift(...cur[1]);
        }
    }
    return (out);
}, _Block_validateOperationsPurpose = function _Block_validateOperationsPurpose() {
    /**
     * Do not allow blocks to contain invalid constructions
     */
    const context = {
        block: this,
        operationIndex: 0
    };
    for (const operation of this.operations) {
        if (this.purpose === BlockPurpose.FEE) {
            if (operation.type !== Operations.OperationType.SEND) {
                throw (new block_1.default('BLOCK_INVALID_PURPOSE_VALIDATION', `Block purpose is FEE, but operation at index ${context.operationIndex} is not a SEND operation`));
            }
        }
        operation.validate(context);
        context.operationIndex++;
    }
}, _Block_validateSignerField = function _Block_validateSignerField() {
    if (!Array.isArray(this.signer)) {
        return;
    }
    const queue = [[1n, this.signer]];
    while (queue.length > 0) {
        // We can assume that the signerFieldQueue is not empty here since the loop condition checks it
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        const [depth, cur] = queue.shift();
        (0, common_1.validateBlockSignerDepth)(depth, this.network);
        if (Array.isArray(cur)) {
            (0, common_1.validateBlockSignerCount)(BigInt(cur[1].length), this.network);
            const seen = new account_1.default.Set();
            for (const innerSigner of cur[1]) {
                let signer;
                if (Array.isArray(innerSigner)) {
                    signer = innerSigner[0];
                    queue.push([depth + 1n, innerSigner]);
                }
                else {
                    signer = innerSigner;
                }
                if (seen.has(signer)) {
                    throw (new block_1.default('BLOCK_INVALID_MULTISIG_SIGNER_DUPLICATE', `Multisig signer at depth ${depth} has duplicate signer ${signer.publicKeyString.get()}`));
                }
                seen.add(signer);
            }
        }
    }
}, _Block_validateSignatures = function _Block_validateSignatures() {
    const signers = __classPrivateFieldGet(_a, _a, "m", _Block_getSortedRequiredSigners).call(_a, this.signer);
    if (this.signatures.length !== signers.length) {
        throw (new block_1.default('BLOCK_INVALID_SIGNER', 'Signer count does not match signature count'));
    }
    for (let i = 0; i < signers.length; i++) {
        const signature = new buffer_1.BufferStorage(this.signatures[i], 64);
        const valid = signers[i].verify(this.hash.get(), signature.get());
        if (valid !== true) {
            throw (new Error(`Unable to validate signature of ${this.hash.toString()} against signature ${this.signatures[i]} for account ${signers[i].publicKeyString.get()}`));
        }
    }
};
Block.isInstance = (0, helper_1.checkableGenerator)(_a);
Block.Hash = BlockHash;
Block.OperationType = Operations.OperationType;
Block.Operation = Operations.Operation;
Block.NO_PREVIOUS = NO_PREVIOUS;
Block.AdjustMethod = AdjustMethod;
Block.Purpose = BlockPurpose;
class BlockBuilder {
    constructor(block) {
        _BlockBuilder_block.set(this, void 0);
        if (Block.isInstance(block)) {
            /*
             * The block is already constructed, make a copy
             */
            __classPrivateFieldSet(this, _BlockBuilder_block, new Block(block), "f");
        }
        else if (util_1.types.isArrayBuffer(block) || Buffer.isBuffer(block) || typeof block === 'string') {
            /**
             * The block is already serialized to bytes in some
             * way, just construct the block object
             */
            __classPrivateFieldSet(this, _BlockBuilder_block, new Block(block), "f");
        }
        else {
            if (block !== undefined && Block.isValidJSON(block, 2)) {
                __classPrivateFieldSet(this, _BlockBuilder_block, new Block(block), "f");
            }
            else {
                const incompleteBlockJSON = {
                    date: (new Date()).toISOString(),
                    version: 1,
                    ...block
                };
                /*
                 * Map input to our values
                 */
                let setPreviousNoBlock = false;
                if (incompleteBlockJSON.previous === BlockBuilder.NO_PREVIOUS) {
                    setPreviousNoBlock = true;
                }
                let newBlockJSON;
                if (incompleteBlockJSON.version === 1) {
                    // We have to use a type assertion here because the MapV1InputValues function does not support recursive types
                    // eslint-disable-next-line @typescript-eslint/consistent-type-assertions
                    newBlockJSON = MapV1InputValues({ ...incompleteBlockJSON, version: 1 });
                }
                else if (incompleteBlockJSON.version === 2) {
                    newBlockJSON = MapV2InputValues({ ...incompleteBlockJSON, version: 2 });
                }
                else {
                    throw (new Error('Cannot construct block, it is not a valid Block JSON object'));
                }
                if (setPreviousNoBlock) {
                    newBlockJSON.previous = BlockBuilder.NO_PREVIOUS;
                }
                __classPrivateFieldSet(this, _BlockBuilder_block, newBlockJSON, "f");
            }
        }
    }
    get currentBlock() {
        return (__classPrivateFieldGet(this, _BlockBuilder_block, "f"));
    }
    get currentWIP() {
        if (Block.isInstance(__classPrivateFieldGet(this, _BlockBuilder_block, "f"))) {
            throw (new Error('May not operate on sealed block'));
        }
        return (__classPrivateFieldGet(this, _BlockBuilder_block, "f"));
    }
    get currentBlockSealed() {
        const currentBlock = __classPrivateFieldGet(this, _BlockBuilder_block, "f");
        if (!Block.isInstance(currentBlock)) {
            throw (new Error('Block is still in progress'));
        }
        return (currentBlock);
    }
    toJSON(opts) {
        if (Block.isInstance(__classPrivateFieldGet(this, _BlockBuilder_block, "f"))) {
            return (__classPrivateFieldGet(this, _BlockBuilder_block, "f").toJSON(opts));
        }
        if (opts?.addBinary) {
            throw (new Error('Cannot add binary within blockBuilder.toJSON'));
        }
        return ({
            version: this.version,
            date: this.date,
            previous: this.previous,
            account: this.account,
            signer: this.signer,
            network: this.network,
            subnet: this.subnet,
            operations: this.operations,
            purpose: this.purpose,
            ['$opening']: this.$opening
        });
    }
    async seal() {
        if (this.version === undefined) {
            throw (new Error('Cannot seal block without version'));
        }
        let input;
        // There is no clean way to tell the compiler which version `this` is, so we have to use a type assertion
        if (this.version === 1) {
            // eslint-disable-next-line @typescript-eslint/consistent-type-assertions
            input = MapV1InputValues(this);
        }
        else {
            // eslint-disable-next-line @typescript-eslint/consistent-type-assertions
            input = MapV2InputValues(this);
        }
        const block = await Block.fromUnsignedJSON(input);
        __classPrivateFieldSet(this, _BlockBuilder_block, block, "f");
        return (block);
    }
    unseal() {
        let retval;
        if (Block.isInstance(__classPrivateFieldGet(this, _BlockBuilder_block, "f"))) {
            __classPrivateFieldSet(this, _BlockBuilder_block, {
                version: __classPrivateFieldGet(this, _BlockBuilder_block, "f").version,
                date: __classPrivateFieldGet(this, _BlockBuilder_block, "f").date,
                previous: __classPrivateFieldGet(this, _BlockBuilder_block, "f").previous,
                account: __classPrivateFieldGet(this, _BlockBuilder_block, "f").account,
                signer: __classPrivateFieldGet(this, _BlockBuilder_block, "f").signer,
                network: __classPrivateFieldGet(this, _BlockBuilder_block, "f").network,
                subnet: __classPrivateFieldGet(this, _BlockBuilder_block, "f").subnet,
                operations: [...__classPrivateFieldGet(this, _BlockBuilder_block, "f").operations]
            }, "f");
            retval = __classPrivateFieldGet(this, _BlockBuilder_block, "f");
        }
        else {
            retval = __classPrivateFieldGet(this, _BlockBuilder_block, "f");
        }
        return (retval);
    }
    get sealed() {
        if (Block.isInstance(__classPrivateFieldGet(this, _BlockBuilder_block, "f"))) {
            return (true);
        }
        return (false);
    }
    get block() {
        if (this.sealed) {
            return (this.currentBlockSealed);
        }
    }
    get hash() {
        const block = this.block;
        if (block !== undefined) {
            return (block.hash);
        }
    }
    set signer(signer) {
        if (signer) {
            this.currentWIP.signer = parseBlockSignerFieldJSON(signer);
        }
        else {
            this.currentWIP.signer = undefined;
        }
    }
    get signer() {
        const signer = __classPrivateFieldGet(this, _BlockBuilder_block, "f").signer;
        if (signer === undefined) {
            if (this.account && this.account.isAccount() && this.account.hasPrivateKey) {
                return (this.account);
            }
        }
        else {
            const queue = [signer];
            while (queue.length > 0) {
                const cur = queue.shift();
                let signer;
                if (Array.isArray(cur)) {
                    signer = cur[0];
                    queue.push(...cur[1]);
                }
                else {
                    signer = cur;
                }
                if (!account_1.default.isInstance(signer)) {
                    throw (new Error('internal error: We only represent signer/multisig-info as their constructed values'));
                }
            }
        }
        return (signer);
    }
    set account(account) {
        this.currentWIP.account = account_1.default.toAccount(account);
    }
    get account() {
        const account = __classPrivateFieldGet(this, _BlockBuilder_block, "f").account;
        if (account !== undefined && !account_1.default.isInstance(account)) {
            throw (new Error('internal error: We only represent account as an Account'));
        }
        if (account === undefined && this.version === 1 || this.version === undefined) {
            if (Array.isArray(this.signer)) {
                throw (new Error('Cannot create a v1 block with a multisig signer'));
            }
            if (typeof this.signer === 'string') {
                throw (new Error('We should only represent signer as an Account'));
            }
            return (this.signer);
        }
        return (account);
    }
    set previous(blockhash) {
        const wip = this.currentWIP;
        if (BlockHash.isInstance(blockhash)) {
            wip.previous = blockhash.toString();
        }
        else {
            wip.previous = blockhash;
        }
    }
    get previous() {
        const block = this.currentBlock;
        if (block === undefined) {
            return;
        }
        const previous = block.previous;
        if (previous === undefined) {
            return (undefined);
        }
        if (BlockHash.isInstance(previous)) {
            return (previous);
        }
        if (previous === BlockBuilder.NO_PREVIOUS) {
            if (this.account !== undefined) {
                return (BlockHash.getAccountOpeningHash(this.account));
            }
            return (undefined);
        }
        return (new BlockHash(previous));
    }
    get $opening() {
        const block = this.currentBlock;
        if (block === undefined) {
            return (undefined);
        }
        const account = this.account;
        if (account === undefined) {
            return (undefined);
        }
        const previous = block.previous;
        if (previous === undefined) {
            return (undefined);
        }
        if (previous === BlockBuilder.NO_PREVIOUS) {
            return (true);
        }
        const sentinel = Block.getAccountOpeningHash(account);
        return (sentinel.compareHexString(previous));
    }
    set date(date) {
        if (date === undefined) {
            this.currentWIP.date = undefined;
        }
        else if (util_1.types.isDate(date)) {
            this.currentWIP.date = date.toISOString();
        }
        else {
            this.currentWIP.date = new Date(date).toISOString();
        }
    }
    get date() {
        if (this.currentBlock.date === undefined) {
            return;
        }
        return (new Date(this.currentBlock.date));
    }
    set version(version) {
        this.currentWIP.version = version;
    }
    get version() {
        return (this.currentBlock.version);
    }
    set purpose(purpose) {
        if (purpose !== undefined && purpose !== BlockPurpose.GENERIC && this.version === 1) {
            throw (new Error('Cannot set purpose (other than generic) on a v1 block'));
        }
        this.currentWIP.purpose = purpose;
    }
    get purpose() {
        if (this.currentBlock.purpose !== undefined) {
            return (this.currentBlock.purpose);
        }
        return (BlockPurpose.GENERIC);
    }
    set network(network) {
        this.currentWIP.network = network;
    }
    get network() {
        if (this.currentBlock.network === undefined) {
            return (this.currentBlock.network);
        }
        if (typeof this.currentBlock.network === 'string') {
            return (BigInt(this.currentBlock.network));
        }
        return (this.currentBlock.network);
    }
    set subnet(subnet) {
        this.currentWIP.subnet = subnet;
    }
    get subnet() {
        if (this.currentBlock.subnet === undefined) {
            return (this.currentBlock.subnet);
        }
        if (typeof this.currentBlock.subnet === 'string') {
            return (BigInt(this.currentBlock.subnet));
        }
        return (this.currentBlock.subnet);
    }
    addOperation(operation) {
        if (!this.currentWIP.operations) {
            this.currentWIP.operations = [];
        }
        this.currentWIP.operations.push(Operations.createBlockOperation(operation));
    }
    get operations() {
        const ret = [];
        for (const op of this.currentBlock.operations ?? []) {
            if (!Operations.isBlockOperation(op)) {
                throw (new Error('internal error: We only represent operations as BlockOperations'));
            }
            ret.push(op);
        }
        return (ret);
    }
}
exports.BlockBuilder = BlockBuilder;
_BlockBuilder_block = new WeakMap();
BlockBuilder.isInstance = (0, helper_1.checkableGenerator)(BlockBuilder);
BlockBuilder.OperationType = Block.OperationType;
BlockBuilder.AdjustMethod = Block.AdjustMethod;
BlockBuilder.Operation = Block.Operation;
BlockBuilder.NO_PREVIOUS = Block.NO_PREVIOUS;
Block.Builder = BlockBuilder;
exports["default"] = Block;


/***/ }),

/***/ 2778:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var _BlockOperationSEND_instances, _BlockOperationSEND_to, _BlockOperationSEND_amount, _BlockOperationSEND_token, _BlockOperationSEND_computeToken, _BlockOperationRECEIVE_instances, _BlockOperationRECEIVE_amount, _BlockOperationRECEIVE_token, _BlockOperationRECEIVE_from, _BlockOperationRECEIVE_forward, _BlockOperationRECEIVE_exact, _BlockOperationRECEIVE_computeExact, _BlockOperationRECEIVE_computeForward, _BlockOperationRECEIVE_computeToken, _BlockOperationTOKEN_ADMIN_MODIFY_BALANCE_instances, _BlockOperationTOKEN_ADMIN_MODIFY_BALANCE_token, _BlockOperationTOKEN_ADMIN_MODIFY_BALANCE_method, _BlockOperationTOKEN_ADMIN_MODIFY_BALANCE_amount, _BlockOperationTOKEN_ADMIN_MODIFY_BALANCE_computeToken, _BlockOperationSET_REP_to, _BlockOperationCREATE_IDENTIFIER_instances, _BlockOperationCREATE_IDENTIFIER_identifier, _BlockOperationCREATE_IDENTIFIER_createArguments, _BlockOperationCREATE_IDENTIFIER_computeIdentifier, _BlockOperationCREATE_IDENTIFIER_computeCreateArguments, _BlockOperationSET_INFO_instances, _BlockOperationSET_INFO_name, _BlockOperationSET_INFO_description, _BlockOperationSET_INFO_metadata, _BlockOperationSET_INFO_defaultPermission, _BlockOperationSET_INFO_validateNameDesc, _BlockOperationMODIFY_PERMISSIONS_instances, _BlockOperationMODIFY_PERMISSIONS_principal, _BlockOperationMODIFY_PERMISSIONS_target, _BlockOperationMODIFY_PERMISSIONS_method, _BlockOperationMODIFY_PERMISSIONS_permissions, _BlockOperationMODIFY_PERMISSIONS_computePermissions, _BlockOperationTOKEN_ADMIN_SUPPLY_instances, _BlockOperationTOKEN_ADMIN_SUPPLY_amount, _BlockOperationTOKEN_ADMIN_SUPPLY_method, _BlockOperationTOKEN_ADMIN_SUPPLY_computeSupplyMethod, _BlockOperationMANAGE_CERTIFICATE_instances, _BlockOperationMANAGE_CERTIFICATE_certificateOrHash, _BlockOperationMANAGE_CERTIFICATE_intermediateCertificates, _BlockOperationMANAGE_CERTIFICATE_method, _BlockOperationMANAGE_CERTIFICATE_asCertificate, _BlockOperationMANAGE_CERTIFICATE_asIntermediateCertificates, _BlockOperationMANAGE_CERTIFICATE_computeCertificateMethod;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Operation = exports.BlockOperationASN1Schema = exports.OperationType = void 0;
exports.createBlockOperation = createBlockOperation;
exports.isBlockOperation = isBlockOperation;
exports.ExportOperationsJSON = ExportOperationsJSON;
exports.ImportOperationsJSON = ImportOperationsJSON;
exports.ExportBlockOperations = ExportBlockOperations;
exports.ImportOperationsASN1 = ImportOperationsASN1;
const asn1_1 = __webpack_require__(6045);
const helper_1 = __webpack_require__(3208);
const account_1 = __importStar(__webpack_require__(9415));
const permissions_1 = __webpack_require__(5860);
const block_1 = __importDefault(__webpack_require__(7412));
const conversion_1 = __webpack_require__(2360);
const _1 = __webpack_require__(6158);
const _2 = __importStar(__webpack_require__(6158));
const config_1 = __webpack_require__(1491);
const certificate_1 = __webpack_require__(5661);
const common_1 = __webpack_require__(5663);
/**
 * All supported operations
 */
var OperationType;
(function (OperationType) {
    OperationType[OperationType["SEND"] = 0] = "SEND";
    OperationType[OperationType["SET_REP"] = 1] = "SET_REP";
    OperationType[OperationType["SET_INFO"] = 2] = "SET_INFO";
    OperationType[OperationType["MODIFY_PERMISSIONS"] = 3] = "MODIFY_PERMISSIONS";
    OperationType[OperationType["CREATE_IDENTIFIER"] = 4] = "CREATE_IDENTIFIER";
    OperationType[OperationType["TOKEN_ADMIN_SUPPLY"] = 5] = "TOKEN_ADMIN_SUPPLY";
    OperationType[OperationType["TOKEN_ADMIN_MODIFY_BALANCE"] = 6] = "TOKEN_ADMIN_MODIFY_BALANCE";
    OperationType[OperationType["RECEIVE"] = 7] = "RECEIVE";
    OperationType[OperationType["MANAGE_CERTIFICATE"] = 8] = "MANAGE_CERTIFICATE";
})(OperationType || (exports.OperationType = OperationType = {}));
function assertOperationType(type) {
    if (isNaN(Number(type)) || !Number.isInteger(type) || type < 0 || typeof OperationType[type] !== 'string') {
        throw (new Error(`internal error: invalid operation type ${type}`));
    }
    return (type);
}
function operationTypeToString(type) {
    // We know that this is valid, but the compiler does not
    // eslint-disable-next-line @typescript-eslint/consistent-type-assertions
    const typeStr = OperationType[type];
    if (!typeStr) {
        throw (new Error(`Found invalid operation ${type}`));
    }
    return (typeStr);
}
function operationTypeToNumber(str) {
    // We know that this is valid, but the compiler does not
    const type = OperationType[str];
    if (!type) {
        throw (new Error(`Found invalid operation ${str}`));
    }
    return (type);
}
/**
 * Schema for each operation as well as names of each field within the block operations
 */
const BlockOperationASN1SchemaBase = {
    'SEND': [
        { name: 'to', schema: asn1_1.ValidateASN1.IsOctetString },
        { name: 'amount', schema: asn1_1.ValidateASN1.IsInteger },
        { name: 'token', schema: asn1_1.ValidateASN1.IsOctetString },
        { name: 'external', schema: { optional: { type: 'string', kind: 'utf8' } } }
    ],
    'RECEIVE': [
        { name: 'amount', schema: asn1_1.ValidateASN1.IsInteger },
        { name: 'token', schema: asn1_1.ValidateASN1.IsOctetString },
        { name: 'from', schema: asn1_1.ValidateASN1.IsOctetString },
        { name: 'exact', schema: asn1_1.ValidateASN1.IsBoolean },
        { name: 'forward', schema: { optional: asn1_1.ValidateASN1.IsOctetString } }
    ],
    'SET_REP': [
        { name: 'to', schema: asn1_1.ValidateASN1.IsOctetString }
    ],
    'SET_INFO': [
        { name: 'name', schema: { type: 'string', kind: 'utf8' } },
        { name: 'description', schema: { type: 'string', kind: 'utf8' } },
        { name: 'metadata', schema: { type: 'string', kind: 'utf8' } },
        { name: 'defaultPermission', schema: { optional: [asn1_1.ValidateASN1.IsInteger, asn1_1.ValidateASN1.IsInteger] } }
    ],
    'MODIFY_PERMISSIONS': [
        { name: 'principal', schema: asn1_1.ValidateASN1.IsOctetString },
        { name: 'method', schema: asn1_1.ValidateASN1.IsInteger },
        { name: 'permissions', schema: {
                choice: [
                    asn1_1.ValidateASN1.IsNull,
                    [asn1_1.ValidateASN1.IsInteger, asn1_1.ValidateASN1.IsInteger]
                ]
            } },
        { name: 'target', schema: { optional: asn1_1.ValidateASN1.IsOctetString } }
    ],
    'CREATE_IDENTIFIER': [
        { name: 'identifier', schema: asn1_1.ValidateASN1.IsOctetString },
        {
            name: 'createArguments',
            schema: {
                optional: {
                    choice: [
                        {
                            type: 'context',
                            kind: 'explicit',
                            value: 7,
                            contains: [
                                { sequenceOf: asn1_1.ValidateASN1.IsOctetString },
                                asn1_1.ValidateASN1.IsInteger
                            ]
                        }
                    ]
                }
            }
        }
    ],
    'TOKEN_ADMIN_SUPPLY': [
        { name: 'amount', schema: asn1_1.ValidateASN1.IsInteger },
        { name: 'method', schema: asn1_1.ValidateASN1.IsInteger }
    ],
    'TOKEN_ADMIN_MODIFY_BALANCE': [
        { name: 'token', schema: asn1_1.ValidateASN1.IsOctetString },
        { name: 'amount', schema: asn1_1.ValidateASN1.IsInteger },
        { name: 'method', schema: asn1_1.ValidateASN1.IsInteger }
    ],
    'MANAGE_CERTIFICATE': [
        { name: 'method', schema: asn1_1.ValidateASN1.IsInteger },
        { name: 'certificateOrHash', schema: asn1_1.ValidateASN1.IsOctetString },
        { name: 'intermediateCertificates', schema: {
                optional: { choice: [asn1_1.ValidateASN1.IsNull, { sequenceOf: asn1_1.ValidateASN1.IsOctetString }] }
            } }
    ]
};
/**
 * Schema for each operation
 */
// eslint-disable-next-line @typescript-eslint/consistent-type-assertions
exports.BlockOperationASN1Schema = Object.fromEntries(Object.entries(BlockOperationASN1SchemaBase).map(function ([key, value]) {
    /* Because we are iterating over BlockOperationASN1SchemaBase, we know that key is a key of BlockOperationASN1SchemaBase */
    // eslint-disable-next-line @typescript-eslint/consistent-type-assertions
    const keyValidated = key;
    const newValue = {
        type: 'context', kind: 'explicit', value: OperationType[keyValidated], contains: value.map(function (fieldSchemaEntry) {
            const fieldSchema = fieldSchemaEntry.schema;
            return (fieldSchema);
        })
    };
    return ([key, newValue]);
}));
/**
 * Statically check that the schema is a valid schema overall
 * @internal
 */
function _static_check_schema_is_valid() {
    const _ignore_check_schema_is_valid = { ...exports.BlockOperationASN1Schema };
}
class BlockOperation {
    validate(_ignored_context) {
        throw (new Error('Cannot Validate On Abstract BlockOperation'));
    }
    computeTo(to, isIdentifier) {
        if (to === undefined || to === null) {
            throw (new Error('internal error: "to" is invalid'));
        }
        to = account_1.default.toAccount(to);
        if (isIdentifier === true) {
            to.assertIdentifier();
        }
        if (isIdentifier === false) {
            to.assertAccount();
        }
        return (to);
    }
    computeAmount(amount) {
        if (amount === undefined || amount === null) {
            throw (new Error('internal error: "amount" is invalid'));
        }
        return (BigInt(amount));
    }
}
BlockOperation.isInstance = (0, helper_1.checkableGenerator)(BlockOperation);
class BlockOperationSEND extends BlockOperation {
    constructor(input) {
        super();
        _BlockOperationSEND_instances.add(this);
        this.type = OperationType.SEND;
        _BlockOperationSEND_to.set(this, void 0);
        _BlockOperationSEND_amount.set(this, void 0);
        _BlockOperationSEND_token.set(this, void 0);
        if (input.type !== OperationType.SEND) {
            throw (new block_1.default('BLOCK_INVALID_TYPE', 'Invalid construction of BlockJSONOperationSEND'));
        }
        __classPrivateFieldSet(this, _BlockOperationSEND_to, this.computeTo(input.to), "f");
        __classPrivateFieldSet(this, _BlockOperationSEND_amount, this.computeAmount(input.amount), "f");
        __classPrivateFieldSet(this, _BlockOperationSEND_token, __classPrivateFieldGet(this, _BlockOperationSEND_instances, "m", _BlockOperationSEND_computeToken).call(this, input.token), "f");
        this.external = input.external;
    }
    set to(to) {
        __classPrivateFieldSet(this, _BlockOperationSEND_to, this.computeTo(to), "f");
    }
    get to() {
        return (__classPrivateFieldGet(this, _BlockOperationSEND_to, "f"));
    }
    set token(token) {
        __classPrivateFieldSet(this, _BlockOperationSEND_token, __classPrivateFieldGet(this, _BlockOperationSEND_instances, "m", _BlockOperationSEND_computeToken).call(this, token), "f");
    }
    get token() {
        return (__classPrivateFieldGet(this, _BlockOperationSEND_token, "f"));
    }
    set amount(amount) {
        __classPrivateFieldSet(this, _BlockOperationSEND_amount, this.computeAmount(amount), "f");
    }
    get amount() {
        return (__classPrivateFieldGet(this, _BlockOperationSEND_amount, "f"));
    }
    validate(context) {
        const { block } = context;
        const account = block.account;
        // Only allow tokens to use send if they are the token being sent
        if (account.keyType === account_1.AccountKeyAlgorithm.TOKEN && this.token.comparePublicKey(account) === false) {
            throw (new block_1.default('BLOCK_NO_TOKEN_OP', 'Tokens cannot use SEND, did you mean to use TOKEN_ADMIN_MODIFY_BALANCE'));
        }
        if (this.to.keyType === account_1.AccountKeyAlgorithm.TOKEN) {
            // Note: This will fail if you are sending the base token to the base token, without specifying the token in operation
            if (this.to.comparePublicKey(this.token) === false) {
                throw (new block_1.default('BLOCK_TOKEN_RECEIVE_DIFFERS', 'Cannot send a token to a token account that is different from itself, if this is invalid, please include the token in the operation'));
            }
        }
        const blockValidationConfig = (0, config_1.getValidation)(context.block.network).blockOperations;
        if (this.external) {
            // Length can not be longer than network config
            if (this.external.length > blockValidationConfig.external.maxLength) {
                throw (new block_1.default('BLOCK_EXTERNAL_TOO_LONG', `External length ${this.external.length} is longer than allowed length of ${blockValidationConfig.external.maxLength}`));
            }
            // Text must match network config regex
            if (!blockValidationConfig.external.regex.test(this.external)) {
                throw (new block_1.default('BLOCK_EXTERNAL_INVALID', 'External has invalid characters'));
            }
        }
        else {
            // If external is not provided and it cannot be empty
            if (blockValidationConfig.external.canBeEmpty === false) {
                throw (new block_1.default('BLOCK_EXTERNAL_MISSING', 'External is required when using SEND'));
            }
        }
    }
    toJSON() {
        return ({
            type: this.type,
            to: this.to,
            amount: this.amount,
            external: this.external,
            token: this.token
        });
    }
}
_BlockOperationSEND_to = new WeakMap(), _BlockOperationSEND_amount = new WeakMap(), _BlockOperationSEND_token = new WeakMap(), _BlockOperationSEND_instances = new WeakSet(), _BlockOperationSEND_computeToken = function _BlockOperationSEND_computeToken(token) {
    const asAccount = this.computeTo(token);
    if (asAccount.keyType !== account_1.AccountKeyAlgorithm.TOKEN) {
        throw (new block_1.default('BLOCK_CANNOT_SEND_NON_TOKEN', 'You cannot send a non token identifier'));
    }
    return (asAccount.assertKeyType(account_1.AccountKeyAlgorithm.TOKEN));
};
BlockOperationSEND.isInstance = (0, helper_1.checkableGenerator)(BlockOperationSEND);
class BlockOperationRECEIVE extends BlockOperation {
    constructor(input) {
        super();
        _BlockOperationRECEIVE_instances.add(this);
        this.type = OperationType.RECEIVE;
        _BlockOperationRECEIVE_amount.set(this, void 0);
        _BlockOperationRECEIVE_token.set(this, void 0);
        _BlockOperationRECEIVE_from.set(this, void 0);
        _BlockOperationRECEIVE_forward.set(this, void 0);
        _BlockOperationRECEIVE_exact.set(this, void 0);
        if (input.type !== OperationType.RECEIVE) {
            throw (new block_1.default('BLOCK_INVALID_TYPE', 'Invalid construction of BlockJSONOperationRECEIVE'));
        }
        __classPrivateFieldSet(this, _BlockOperationRECEIVE_amount, this.computeAmount(input.amount), "f");
        __classPrivateFieldSet(this, _BlockOperationRECEIVE_token, __classPrivateFieldGet(this, _BlockOperationRECEIVE_instances, "m", _BlockOperationRECEIVE_computeToken).call(this, input.token), "f");
        __classPrivateFieldSet(this, _BlockOperationRECEIVE_from, this.computeTo(input.from), "f");
        __classPrivateFieldSet(this, _BlockOperationRECEIVE_forward, __classPrivateFieldGet(this, _BlockOperationRECEIVE_instances, "m", _BlockOperationRECEIVE_computeForward).call(this, input.forward), "f");
        __classPrivateFieldSet(this, _BlockOperationRECEIVE_exact, __classPrivateFieldGet(this, _BlockOperationRECEIVE_instances, "m", _BlockOperationRECEIVE_computeExact).call(this, input.exact), "f");
    }
    set from(from) {
        __classPrivateFieldSet(this, _BlockOperationRECEIVE_from, this.computeTo(from), "f");
    }
    get from() {
        return (__classPrivateFieldGet(this, _BlockOperationRECEIVE_from, "f"));
    }
    set forward(forward) {
        __classPrivateFieldSet(this, _BlockOperationRECEIVE_forward, __classPrivateFieldGet(this, _BlockOperationRECEIVE_instances, "m", _BlockOperationRECEIVE_computeForward).call(this, forward), "f");
    }
    get forward() {
        return (__classPrivateFieldGet(this, _BlockOperationRECEIVE_forward, "f"));
    }
    set exact(exact) {
        __classPrivateFieldSet(this, _BlockOperationRECEIVE_exact, __classPrivateFieldGet(this, _BlockOperationRECEIVE_instances, "m", _BlockOperationRECEIVE_computeExact).call(this, exact), "f");
    }
    get exact() {
        return (__classPrivateFieldGet(this, _BlockOperationRECEIVE_exact, "f"));
    }
    set token(token) {
        __classPrivateFieldSet(this, _BlockOperationRECEIVE_token, __classPrivateFieldGet(this, _BlockOperationRECEIVE_instances, "m", _BlockOperationRECEIVE_computeToken).call(this, token), "f");
    }
    get token() {
        return (__classPrivateFieldGet(this, _BlockOperationRECEIVE_token, "f"));
    }
    set amount(amount) {
        __classPrivateFieldSet(this, _BlockOperationRECEIVE_amount, this.computeAmount(amount), "f");
    }
    get amount() {
        return (__classPrivateFieldGet(this, _BlockOperationRECEIVE_amount, "f"));
    }
    validate(context) {
        const { block } = context;
        const account = block.account;
        if (account.isToken()) {
            throw (new block_1.default('BLOCK_NO_TOKEN_OP', 'Token addresses cannot use RECEIVE'));
        }
        if (this.forward !== undefined) {
            if (this.forward.comparePublicKey(account)) {
                throw (new block_1.default('BLOCK_CANNOT_FORWARD_TO_SELF', 'Cannot use forward field to send to self'));
            }
            if (this.exact !== true) {
                throw (new block_1.default('BLOCK_EXACT_TRUE_WHEN_FORWARDING', 'Cannot use forward field without exact being set to true'));
            }
            if (this.forward.isToken() && this.forward.comparePublicKey(this.token) === false) {
                throw (new block_1.default('BLOCK_TOKEN_RECEIVE_DIFFERS', 'Cannot send a token to a token account that is different from itself'));
            }
        }
    }
    toJSON() {
        return ({
            type: this.type,
            amount: this.amount,
            token: this.token,
            from: this.from,
            exact: this.exact,
            forward: this.forward
        });
    }
}
_BlockOperationRECEIVE_amount = new WeakMap(), _BlockOperationRECEIVE_token = new WeakMap(), _BlockOperationRECEIVE_from = new WeakMap(), _BlockOperationRECEIVE_forward = new WeakMap(), _BlockOperationRECEIVE_exact = new WeakMap(), _BlockOperationRECEIVE_instances = new WeakSet(), _BlockOperationRECEIVE_computeExact = function _BlockOperationRECEIVE_computeExact(exact) {
    if (!exact) {
        return (false);
    }
    return (exact);
}, _BlockOperationRECEIVE_computeForward = function _BlockOperationRECEIVE_computeForward(forward) {
    if (!forward) {
        return (undefined);
    }
    return (this.computeTo(forward));
}, _BlockOperationRECEIVE_computeToken = function _BlockOperationRECEIVE_computeToken(token) {
    token = account_1.default.toAccount(token);
    if (!token.isToken()) {
        throw (new block_1.default('BLOCK_CANNOT_SEND_NON_TOKEN', 'You cannot receive a non token identifier'));
    }
    return (token);
};
BlockOperationRECEIVE.isInstance = (0, helper_1.checkableGenerator)(BlockOperationRECEIVE);
class BlockOperationTOKEN_ADMIN_MODIFY_BALANCE extends BlockOperation {
    constructor(input) {
        super();
        _BlockOperationTOKEN_ADMIN_MODIFY_BALANCE_instances.add(this);
        this.type = OperationType.TOKEN_ADMIN_MODIFY_BALANCE;
        _BlockOperationTOKEN_ADMIN_MODIFY_BALANCE_token.set(this, void 0);
        _BlockOperationTOKEN_ADMIN_MODIFY_BALANCE_method.set(this, void 0);
        _BlockOperationTOKEN_ADMIN_MODIFY_BALANCE_amount.set(this, void 0);
        if (input.type !== OperationType.TOKEN_ADMIN_MODIFY_BALANCE) {
            throw (new block_1.default('BLOCK_INVALID_TYPE', 'Invalid construction of BlockJSONOperationTOKEN_ADMIN_MODIFY_BALANCE'));
        }
        __classPrivateFieldSet(this, _BlockOperationTOKEN_ADMIN_MODIFY_BALANCE_token, __classPrivateFieldGet(this, _BlockOperationTOKEN_ADMIN_MODIFY_BALANCE_instances, "m", _BlockOperationTOKEN_ADMIN_MODIFY_BALANCE_computeToken).call(this, input.token), "f");
        __classPrivateFieldSet(this, _BlockOperationTOKEN_ADMIN_MODIFY_BALANCE_amount, this.computeAmount(input.amount), "f");
        __classPrivateFieldSet(this, _BlockOperationTOKEN_ADMIN_MODIFY_BALANCE_method, input.method, "f");
    }
    set token(token) {
        __classPrivateFieldSet(this, _BlockOperationTOKEN_ADMIN_MODIFY_BALANCE_token, __classPrivateFieldGet(this, _BlockOperationTOKEN_ADMIN_MODIFY_BALANCE_instances, "m", _BlockOperationTOKEN_ADMIN_MODIFY_BALANCE_computeToken).call(this, token), "f");
    }
    get token() {
        return (__classPrivateFieldGet(this, _BlockOperationTOKEN_ADMIN_MODIFY_BALANCE_token, "f"));
    }
    set method(newMethod) {
        __classPrivateFieldSet(this, _BlockOperationTOKEN_ADMIN_MODIFY_BALANCE_method, newMethod, "f");
    }
    get method() {
        return (Number(__classPrivateFieldGet(this, _BlockOperationTOKEN_ADMIN_MODIFY_BALANCE_method, "f")));
    }
    set amount(amount) {
        __classPrivateFieldSet(this, _BlockOperationTOKEN_ADMIN_MODIFY_BALANCE_amount, this.computeAmount(amount), "f");
    }
    get amount() {
        return (__classPrivateFieldGet(this, _BlockOperationTOKEN_ADMIN_MODIFY_BALANCE_amount, "f"));
    }
    validate(context) {
        const { block } = context;
        if (block.account.keyType === account_1.AccountKeyAlgorithm.TOKEN) {
            throw (new block_1.default('BLOCK_NO_TOKEN_OP', 'You cannot use TOKEN_ADMIN_MODIFY_BALANCE on a token account'));
        }
    }
    toJSON() {
        return ({
            type: this.type,
            token: this.token,
            amount: this.amount,
            method: this.method
        });
    }
}
_BlockOperationTOKEN_ADMIN_MODIFY_BALANCE_token = new WeakMap(), _BlockOperationTOKEN_ADMIN_MODIFY_BALANCE_method = new WeakMap(), _BlockOperationTOKEN_ADMIN_MODIFY_BALANCE_amount = new WeakMap(), _BlockOperationTOKEN_ADMIN_MODIFY_BALANCE_instances = new WeakSet(), _BlockOperationTOKEN_ADMIN_MODIFY_BALANCE_computeToken = function _BlockOperationTOKEN_ADMIN_MODIFY_BALANCE_computeToken(token) {
    return (account_1.default.toAccount(token).assertKeyType(account_1.AccountKeyAlgorithm.TOKEN));
};
BlockOperationTOKEN_ADMIN_MODIFY_BALANCE.isInstance = (0, helper_1.checkableGenerator)(BlockOperationTOKEN_ADMIN_MODIFY_BALANCE);
class BlockOperationSET_REP extends BlockOperation {
    constructor(input) {
        super();
        this.type = OperationType.SET_REP;
        _BlockOperationSET_REP_to.set(this, void 0);
        if (input.type !== OperationType.SET_REP) {
            throw (new block_1.default('BLOCK_INVALID_TYPE', 'Invalid construction of BlockJSONOperationSET_REP'));
        }
        __classPrivateFieldSet(this, _BlockOperationSET_REP_to, this.computeTo(input.to, false), "f");
    }
    set to(to) {
        __classPrivateFieldSet(this, _BlockOperationSET_REP_to, this.computeTo(to, false), "f");
    }
    get to() {
        return (__classPrivateFieldGet(this, _BlockOperationSET_REP_to, "f"));
    }
    validate(context) {
        const { block } = context;
        if (block.account.isIdentifier()) {
            throw (new block_1.default('BLOCK_NO_IDENTIFIER_OP', 'Identifier accounts cannot use SET_REP'));
        }
        if (this.to.isIdentifier()) {
            throw (new block_1.default('BLOCK_NO_IDENTIFIER_OP', 'Cannot delegate to an identifier'));
        }
        let foundSET_REP = false;
        for (const singleOperation of block.operations) {
            if (singleOperation.type !== OperationType.SET_REP) {
                continue;
            }
            if (foundSET_REP) {
                throw (new block_1.default('BLOCK_NO_MULTIPLE_SET_REP', 'You cannot use SET_REP more than once per block'));
            }
            foundSET_REP = true;
        }
    }
    toJSON() {
        return ({
            type: this.type,
            to: this.to
        });
    }
}
_BlockOperationSET_REP_to = new WeakMap();
BlockOperationSET_REP.isInstance = (0, helper_1.checkableGenerator)(BlockOperationSET_REP);
class BlockOperationCREATE_IDENTIFIER extends BlockOperation {
    constructor(input) {
        super();
        _BlockOperationCREATE_IDENTIFIER_instances.add(this);
        this.type = OperationType.CREATE_IDENTIFIER;
        _BlockOperationCREATE_IDENTIFIER_identifier.set(this, void 0);
        _BlockOperationCREATE_IDENTIFIER_createArguments.set(this, void 0);
        if (input.type !== OperationType.CREATE_IDENTIFIER) {
            throw (new block_1.default('BLOCK_INVALID_TYPE', 'Invalid construction of BlockOperationCREATE_IDENTIFIER'));
        }
        __classPrivateFieldSet(this, _BlockOperationCREATE_IDENTIFIER_identifier, __classPrivateFieldGet(this, _BlockOperationCREATE_IDENTIFIER_instances, "m", _BlockOperationCREATE_IDENTIFIER_computeIdentifier).call(this, input.identifier), "f");
        __classPrivateFieldSet(this, _BlockOperationCREATE_IDENTIFIER_createArguments, __classPrivateFieldGet(this, _BlockOperationCREATE_IDENTIFIER_instances, "m", _BlockOperationCREATE_IDENTIFIER_computeCreateArguments).call(this, input.createArguments), "f");
    }
    set identifier(identifier) {
        __classPrivateFieldSet(this, _BlockOperationCREATE_IDENTIFIER_identifier, __classPrivateFieldGet(this, _BlockOperationCREATE_IDENTIFIER_instances, "m", _BlockOperationCREATE_IDENTIFIER_computeIdentifier).call(this, identifier), "f");
    }
    get identifier() {
        return (__classPrivateFieldGet(this, _BlockOperationCREATE_IDENTIFIER_identifier, "f"));
    }
    set createArguments(input) {
        __classPrivateFieldSet(this, _BlockOperationCREATE_IDENTIFIER_createArguments, __classPrivateFieldGet(this, _BlockOperationCREATE_IDENTIFIER_instances, "m", _BlockOperationCREATE_IDENTIFIER_computeCreateArguments).call(this, input), "f");
    }
    get createArguments() {
        return (__classPrivateFieldGet(this, _BlockOperationCREATE_IDENTIFIER_createArguments, "f"));
    }
    validate(context) {
        const { block, operationIndex } = context;
        if (block.account.isIdentifier()) {
            throw (new block_1.default('BLOCK_NO_TOKEN_OP', 'Tokens cannot create other tokens'));
        }
        const createdKeyType = this.identifier.keyType;
        if (!account_1.default.isIdentifierKeyType(createdKeyType)) {
            throw (new block_1.default('BLOCK_IDENTIFIER_INVALID', `Provided keytype for identifier is invalid ${createdKeyType}`));
        }
        const validIdentifier = block.account.generateIdentifier(createdKeyType, block.previous, operationIndex);
        if (this.identifier.comparePublicKey(validIdentifier) === false) {
            throw (new block_1.default('BLOCK_IDENTIFIER_INVALID', 'Requested token identifier is not valid'));
        }
        const keyTypesArgumentsRequired = [account_1.AccountKeyAlgorithm.MULTISIG];
        const shouldHaveCreateArguments = keyTypesArgumentsRequired.includes(this.identifier.keyType);
        if ((this.createArguments !== undefined) !== shouldHaveCreateArguments) {
            throw (new block_1.default('BLOCK_INVALID_CREATE_IDENTIFIER_ARGS', `Create arguments set/unset when should not be for key type ${this.identifier.keyType}`));
        }
        if (__classPrivateFieldGet(this, _BlockOperationCREATE_IDENTIFIER_createArguments, "f")) {
            if (!__classPrivateFieldGet(this, _BlockOperationCREATE_IDENTIFIER_identifier, "f").isKeyType(__classPrivateFieldGet(this, _BlockOperationCREATE_IDENTIFIER_createArguments, "f").type)) {
                throw (new block_1.default('BLOCK_INVALID_CREATE_IDENTIFIER_ARGS', 'Invalid create arguments for key type'));
            }
            if (__classPrivateFieldGet(this, _BlockOperationCREATE_IDENTIFIER_createArguments, "f").type === account_1.AccountKeyAlgorithm.MULTISIG) {
                const { signers, quorum } = __classPrivateFieldGet(this, _BlockOperationCREATE_IDENTIFIER_createArguments, "f");
                (0, common_1.validateBlockSignerCount)(BigInt(signers.length), block.network);
                const signerSet = new account_1.default.Set(signers);
                if (signerSet.size !== signers.length) {
                    throw (new block_1.default('BLOCK_INVALID_MULTISIG_SIGNER_DUPLICATE', `Duplicate signer found`));
                }
                if (quorum < 1n || quorum > signerSet.size) {
                    throw (new block_1.default('BLOCK_INVALID_MULTISIG_QUORUM', `Quorum must be between [1, ${signerSet.size}], got ${quorum}`));
                }
            }
            else {
                throw (new Error('Unrecognized createArguments type'));
            }
        }
    }
    toJSON() {
        return ({
            type: this.type,
            identifier: this.identifier,
            createArguments: __classPrivateFieldGet(this, _BlockOperationCREATE_IDENTIFIER_createArguments, "f")
        });
    }
}
_BlockOperationCREATE_IDENTIFIER_identifier = new WeakMap(), _BlockOperationCREATE_IDENTIFIER_createArguments = new WeakMap(), _BlockOperationCREATE_IDENTIFIER_instances = new WeakSet(), _BlockOperationCREATE_IDENTIFIER_computeIdentifier = function _BlockOperationCREATE_IDENTIFIER_computeIdentifier(identifierStr) {
    const account = this.computeTo(identifierStr, true);
    if (account.keyType === account_1.AccountKeyAlgorithm.NETWORK) {
        throw (new Error('BlockOperationCREATE_IDENTIFIER must have a non-network identifier account'));
    }
    return (account);
}, _BlockOperationCREATE_IDENTIFIER_computeCreateArguments = function _BlockOperationCREATE_IDENTIFIER_computeCreateArguments(input) {
    if (input === undefined) {
        return (undefined);
    }
    if (input.type === account_1.AccountKeyAlgorithm.MULTISIG) {
        return ({
            type: account_1.AccountKeyAlgorithm.MULTISIG,
            quorum: BigInt(input.quorum),
            signers: input.signers.map(function (signerInput) {
                const signer = account_1.default.toAccount(signerInput);
                if (!signer.isMultisig() && !signer.isAccount()) {
                    throw (new block_1.default('BLOCK_INVALID_CREATE_IDENTIFIER_ARGS', 'Unsupported key type for multisig signer'));
                }
                return (signer);
            })
        });
    }
    else {
        throw (new block_1.default('BLOCK_INVALID_CREATE_IDENTIFIER_ARGS', 'Unsupported key type for identifier creation args'));
    }
};
BlockOperationCREATE_IDENTIFIER.isInstance = (0, helper_1.checkableGenerator)(BlockOperationCREATE_IDENTIFIER);
class BlockOperationSET_INFO extends BlockOperation {
    constructor(input) {
        super();
        _BlockOperationSET_INFO_instances.add(this);
        this.type = OperationType.SET_INFO;
        _BlockOperationSET_INFO_name.set(this, void 0);
        _BlockOperationSET_INFO_description.set(this, void 0);
        _BlockOperationSET_INFO_metadata.set(this, void 0);
        _BlockOperationSET_INFO_defaultPermission.set(this, void 0);
        if (input.type !== OperationType.SET_INFO) {
            throw (new block_1.default('BLOCK_INVALID_TYPE', 'Invalid construction of BlockJSONOperationSET_INFO'));
        }
        __classPrivateFieldSet(this, _BlockOperationSET_INFO_name, input.name, "f");
        __classPrivateFieldSet(this, _BlockOperationSET_INFO_description, input.description, "f");
        __classPrivateFieldSet(this, _BlockOperationSET_INFO_metadata, input.metadata, "f");
        if (input.defaultPermission !== undefined) {
            __classPrivateFieldSet(this, _BlockOperationSET_INFO_defaultPermission, permissions_1.Permissions.FromAcceptedTypes(input.defaultPermission), "f");
        }
    }
    set name(name) {
        __classPrivateFieldSet(this, _BlockOperationSET_INFO_name, name, "f");
    }
    get name() {
        return (__classPrivateFieldGet(this, _BlockOperationSET_INFO_name, "f"));
    }
    set description(description) {
        __classPrivateFieldSet(this, _BlockOperationSET_INFO_description, description, "f");
    }
    get description() {
        return (__classPrivateFieldGet(this, _BlockOperationSET_INFO_description, "f"));
    }
    set metadata(metadata) {
        __classPrivateFieldSet(this, _BlockOperationSET_INFO_metadata, metadata, "f");
    }
    get metadata() {
        return (__classPrivateFieldGet(this, _BlockOperationSET_INFO_metadata, "f"));
    }
    set defaultPermission(newPerms) {
        if (newPerms) {
            __classPrivateFieldSet(this, _BlockOperationSET_INFO_defaultPermission, permissions_1.Permissions.FromAcceptedTypes(newPerms), "f");
            return;
        }
        __classPrivateFieldSet(this, _BlockOperationSET_INFO_defaultPermission, undefined, "f");
    }
    get defaultPermission() {
        return (__classPrivateFieldGet(this, _BlockOperationSET_INFO_defaultPermission, "f"));
    }
    validate(context) {
        __classPrivateFieldGet(this, _BlockOperationSET_INFO_instances, "m", _BlockOperationSET_INFO_validateNameDesc).call(this, 'name', __classPrivateFieldGet(this, _BlockOperationSET_INFO_name, "f"), context.block.network);
        __classPrivateFieldGet(this, _BlockOperationSET_INFO_instances, "m", _BlockOperationSET_INFO_validateNameDesc).call(this, 'description', __classPrivateFieldGet(this, _BlockOperationSET_INFO_description, "f"), context.block.network);
        __classPrivateFieldGet(this, _BlockOperationSET_INFO_instances, "m", _BlockOperationSET_INFO_validateNameDesc).call(this, 'metadata', __classPrivateFieldGet(this, _BlockOperationSET_INFO_metadata, "f"), context.block.network);
        const defaultPermission = this.defaultPermission;
        const { block } = context;
        if (block.account.isIdentifier()) {
            if (!defaultPermission) {
                throw (new block_1.default('BLOCK_IDENTIFIER_NEED_DEFAULT_PERMISSIONS', 'Identifier accounts need default permissions in SET_INFO'));
            }
            const { base, external } = defaultPermission;
            // XXX:TODO do we want this
            if (external.bigint !== 0n) {
                throw (new block_1.default('BLOCK_GENERAL_FIELD_INVALID', `Cannot set default permissions to have external permissions, ${defaultPermission.external.bigint}`));
            }
            if (!base.isValidForDefault) {
                throw (new block_1.default('BLOCK_PERMISSIONS_INVALID_DEFAULT', 'Invalid default base permissions'));
            }
            const baseFlagsString = `[${base.flags.join(',')}]`;
            if (base.checkAccountMatchesGroup('entity', block.account) !== true) {
                throw (new block_1.default('BLOCK_PERMISSIONS_INVALID_ENTITY', `Incorrect entity for flags ${baseFlagsString}`));
            }
        }
        else if (defaultPermission) {
            throw (new block_1.default('BLOCK_ONLY_IDENTIFIER_OP', 'Non-Identifier accounts cannot have default permissions'));
        }
    }
    toJSON() {
        const val = {
            type: this.type,
            name: __classPrivateFieldGet(this, _BlockOperationSET_INFO_name, "f"),
            description: __classPrivateFieldGet(this, _BlockOperationSET_INFO_description, "f"),
            metadata: __classPrivateFieldGet(this, _BlockOperationSET_INFO_metadata, "f")
        };
        if (this.defaultPermission !== undefined) {
            val.defaultPermission = this.defaultPermission;
        }
        return (val);
    }
}
_BlockOperationSET_INFO_name = new WeakMap(), _BlockOperationSET_INFO_description = new WeakMap(), _BlockOperationSET_INFO_metadata = new WeakMap(), _BlockOperationSET_INFO_defaultPermission = new WeakMap(), _BlockOperationSET_INFO_instances = new WeakSet(), _BlockOperationSET_INFO_validateNameDesc = function _BlockOperationSET_INFO_validateNameDesc(field, value, network) {
    const { regex, maxLength, canBeEmpty } = (0, config_1.getValidation)(network).accountInfoFieldRules[field];
    if (canBeEmpty && value === '') {
        return;
    }
    const exceedsMaxLength = value.length > maxLength;
    const doesNotMatchRegex = !(regex.test(value));
    if (exceedsMaxLength || doesNotMatchRegex) {
        throw (new block_1.default('BLOCK_GENERAL_FIELD_INVALID', `${field} does not fit proper format -- GOT: '${value}' LENGTH: ${value.length}/${maxLength}, Regex: ${regex.toString()}`));
    }
    return;
};
BlockOperationSET_INFO.isInstance = (0, helper_1.checkableGenerator)(BlockOperationSET_INFO);
class BlockOperationMODIFY_PERMISSIONS extends BlockOperation {
    constructor(input) {
        super();
        _BlockOperationMODIFY_PERMISSIONS_instances.add(this);
        this.type = OperationType.MODIFY_PERMISSIONS;
        _BlockOperationMODIFY_PERMISSIONS_principal.set(this, void 0);
        _BlockOperationMODIFY_PERMISSIONS_target.set(this, void 0);
        _BlockOperationMODIFY_PERMISSIONS_method.set(this, void 0);
        _BlockOperationMODIFY_PERMISSIONS_permissions.set(this, void 0);
        if (input.type !== OperationType.MODIFY_PERMISSIONS) {
            throw (new block_1.default('BLOCK_INVALID_TYPE', 'Invalid construction of BlockJSONOperationMODIFY_PERMISSIONS'));
        }
        __classPrivateFieldSet(this, _BlockOperationMODIFY_PERMISSIONS_principal, this.computeTo(input.principal), "f");
        __classPrivateFieldSet(this, _BlockOperationMODIFY_PERMISSIONS_target, account_1.default.toAccount(input.target), "f");
        __classPrivateFieldSet(this, _BlockOperationMODIFY_PERMISSIONS_method, input.method, "f");
        __classPrivateFieldSet(this, _BlockOperationMODIFY_PERMISSIONS_permissions, __classPrivateFieldGet(this, _BlockOperationMODIFY_PERMISSIONS_instances, "m", _BlockOperationMODIFY_PERMISSIONS_computePermissions).call(this, input.permissions), "f");
    }
    set principal(principal) {
        __classPrivateFieldSet(this, _BlockOperationMODIFY_PERMISSIONS_principal, this.computeTo(principal), "f");
    }
    get principal() {
        return (__classPrivateFieldGet(this, _BlockOperationMODIFY_PERMISSIONS_principal, "f"));
    }
    set permissions(newPerms) {
        __classPrivateFieldSet(this, _BlockOperationMODIFY_PERMISSIONS_permissions, __classPrivateFieldGet(this, _BlockOperationMODIFY_PERMISSIONS_instances, "m", _BlockOperationMODIFY_PERMISSIONS_computePermissions).call(this, newPerms), "f");
    }
    get permissions() {
        return (__classPrivateFieldGet(this, _BlockOperationMODIFY_PERMISSIONS_permissions, "f"));
    }
    set target(token) {
        __classPrivateFieldSet(this, _BlockOperationMODIFY_PERMISSIONS_target, account_1.default.toAccount(token), "f");
    }
    get target() {
        return (__classPrivateFieldGet(this, _BlockOperationMODIFY_PERMISSIONS_target, "f"));
    }
    set method(method) {
        __classPrivateFieldSet(this, _BlockOperationMODIFY_PERMISSIONS_method, method, "f");
    }
    get method() {
        return (Number(__classPrivateFieldGet(this, _BlockOperationMODIFY_PERMISSIONS_method, "f")));
    }
    validate(context) {
        const { block } = context;
        if (this.permissions === null) {
            if (this.method !== _2.AdjustMethod.SET) {
                throw (new Error('Method must be SET when permissions = null'));
            }
        }
        else {
            this.permissions.validate(block.network);
            if (!block.account.isIdentifier()) {
                if (this.permissions.has(['OWNER'])) {
                    throw (new block_1.default('BLOCK_ONLY_IDENTIFIER_OP', 'Cannot set/modify owners of non-identifier accounts'));
                }
            }
            const { base } = this.permissions;
            const baseFlagsString = `[${base.flags.join(',')}]`;
            if (!base.checkAccountMatchesGroup('principal', this.principal)) {
                throw (new block_1.default('BLOCK_PERMISSIONS_INVALID_PRINCIPAL', `Incorrect principal for flags ${baseFlagsString}`));
            }
            if (this.target && !base.checkAccountMatchesGroup('target', this.target)) {
                throw (new block_1.default('BLOCK_PERMISSIONS_INVALID_TARGET', `Incorrect target for flags ${baseFlagsString}`));
            }
            if (!base.checkAccountMatchesGroup('entity', block.account)) {
                throw (new block_1.default('BLOCK_PERMISSIONS_INVALID_ENTITY', `Incorrect entity for flags ${baseFlagsString}`));
            }
            const settingAdminOrHigher = this.permissions.has(['ADMIN']);
            if (this.target !== undefined && settingAdminOrHigher) {
                throw (new block_1.default('BLOCK_NO_ADMIN_ON_TARGET', 'Cannot set admin or higher with a target specified'));
            }
            if (this.method !== _2.default.AdjustMethod.SET && !this.permissions.canUseDelegation) {
                throw (new block_1.default('BLOCK_NO_DELEGATE_ADMIN', `Cannot use delegation for ${baseFlagsString}`));
            }
        }
        // Do not allow a set after permissions have already been updated for that account/target
        const foundPrevious = {};
        for (const operation of block.operations) {
            if (operation.type !== OperationType.MODIFY_PERMISSIONS) {
                continue;
            }
            const { principal, target, method } = operation;
            const principalKey = principal.publicKeyString.get();
            const targetKey = (target ?? block.account).publicKeyString.get();
            if (!foundPrevious[principalKey]) {
                foundPrevious[principalKey] = {};
            }
            const foundMethod = foundPrevious[principalKey][targetKey];
            foundPrevious[principalKey][targetKey] = method;
            if (foundMethod === undefined) {
                continue;
            }
            if (method === _2.default.AdjustMethod.SET) {
                throw (new block_1.default('BLOCK_NO_MODIFY_PERMISSION_DUPE', 'Cannot have a SET operation after any other change with the same target in MODIFY_PERMISSIONS'));
            }
        }
    }
    toJSON() {
        return ({
            type: this.type,
            principal: this.principal,
            method: this.method,
            permissions: this.permissions,
            target: this.target
        });
    }
}
_BlockOperationMODIFY_PERMISSIONS_principal = new WeakMap(), _BlockOperationMODIFY_PERMISSIONS_target = new WeakMap(), _BlockOperationMODIFY_PERMISSIONS_method = new WeakMap(), _BlockOperationMODIFY_PERMISSIONS_permissions = new WeakMap(), _BlockOperationMODIFY_PERMISSIONS_instances = new WeakSet(), _BlockOperationMODIFY_PERMISSIONS_computePermissions = function _BlockOperationMODIFY_PERMISSIONS_computePermissions(permissions) {
    if (!permissions) {
        return (null);
    }
    return (permissions_1.Permissions.FromAcceptedTypes(permissions));
};
BlockOperationMODIFY_PERMISSIONS.isInstance = (0, helper_1.checkableGenerator)(BlockOperationMODIFY_PERMISSIONS);
class BlockOperationTOKEN_ADMIN_SUPPLY extends BlockOperation {
    constructor(input) {
        super();
        _BlockOperationTOKEN_ADMIN_SUPPLY_instances.add(this);
        this.type = OperationType.TOKEN_ADMIN_SUPPLY;
        _BlockOperationTOKEN_ADMIN_SUPPLY_amount.set(this, void 0);
        _BlockOperationTOKEN_ADMIN_SUPPLY_method.set(this, void 0);
        if (input.type !== OperationType.TOKEN_ADMIN_SUPPLY) {
            throw (new block_1.default('BLOCK_INVALID_TYPE', 'Invalid construction of BlockJSONOperationTOKEN_ADMIN_SUPPLY'));
        }
        __classPrivateFieldSet(this, _BlockOperationTOKEN_ADMIN_SUPPLY_amount, this.computeAmount(input.amount), "f");
        __classPrivateFieldSet(this, _BlockOperationTOKEN_ADMIN_SUPPLY_method, __classPrivateFieldGet(this, _BlockOperationTOKEN_ADMIN_SUPPLY_instances, "m", _BlockOperationTOKEN_ADMIN_SUPPLY_computeSupplyMethod).call(this, input.method), "f");
    }
    set amount(amount) {
        __classPrivateFieldSet(this, _BlockOperationTOKEN_ADMIN_SUPPLY_amount, this.computeAmount(amount), "f");
    }
    get amount() {
        return (__classPrivateFieldGet(this, _BlockOperationTOKEN_ADMIN_SUPPLY_amount, "f"));
    }
    set method(shouldAdd) {
        __classPrivateFieldSet(this, _BlockOperationTOKEN_ADMIN_SUPPLY_method, __classPrivateFieldGet(this, _BlockOperationTOKEN_ADMIN_SUPPLY_instances, "m", _BlockOperationTOKEN_ADMIN_SUPPLY_computeSupplyMethod).call(this, shouldAdd), "f");
    }
    get method() {
        return (Number(__classPrivateFieldGet(this, _BlockOperationTOKEN_ADMIN_SUPPLY_method, "f")));
    }
    validate(context) {
        const { block } = context;
        if (block.account.keyType !== account_1.AccountKeyAlgorithm.TOKEN) {
            throw (new block_1.default('BLOCK_ONLY_TOKEN_OP', 'Only token accounts can use TOKEN_ADMIN_SUPPLY'));
        }
        (0, common_1.validateSupply)(__classPrivateFieldGet(this, _BlockOperationTOKEN_ADMIN_SUPPLY_amount, "f"), block.network);
    }
    toJSON() {
        return ({
            type: this.type,
            amount: this.amount,
            method: this.method
        });
    }
}
_BlockOperationTOKEN_ADMIN_SUPPLY_amount = new WeakMap(), _BlockOperationTOKEN_ADMIN_SUPPLY_method = new WeakMap(), _BlockOperationTOKEN_ADMIN_SUPPLY_instances = new WeakSet(), _BlockOperationTOKEN_ADMIN_SUPPLY_computeSupplyMethod = function _BlockOperationTOKEN_ADMIN_SUPPLY_computeSupplyMethod(method) {
    const numericMethod = (0, _1.toAdjustMethod)(method);
    if (numericMethod === _2.default.AdjustMethod.SET) {
        throw (new Error('Cannot use AdjustMethod.SET on a TOKEN_ADMIN_SUPPLY operation'));
    }
    return (numericMethod);
};
BlockOperationTOKEN_ADMIN_SUPPLY.isInstance = (0, helper_1.checkableGenerator)(BlockOperationTOKEN_ADMIN_SUPPLY);
class BlockOperationMANAGE_CERTIFICATE extends BlockOperation {
    constructor(input) {
        super();
        _BlockOperationMANAGE_CERTIFICATE_instances.add(this);
        this.type = OperationType.MANAGE_CERTIFICATE;
        _BlockOperationMANAGE_CERTIFICATE_certificateOrHash.set(this, void 0);
        _BlockOperationMANAGE_CERTIFICATE_intermediateCertificates.set(this, void 0);
        _BlockOperationMANAGE_CERTIFICATE_method.set(this, void 0);
        if (input.type !== OperationType.MANAGE_CERTIFICATE) {
            throw (new block_1.default('BLOCK_INVALID_TYPE', 'Invalid construction of BlockJSONOperationMANAGE_CERTIFICATE'));
        }
        __classPrivateFieldSet(this, _BlockOperationMANAGE_CERTIFICATE_certificateOrHash, __classPrivateFieldGet(this, _BlockOperationMANAGE_CERTIFICATE_instances, "m", _BlockOperationMANAGE_CERTIFICATE_asCertificate).call(this, input.certificateOrHash), "f");
        __classPrivateFieldSet(this, _BlockOperationMANAGE_CERTIFICATE_method, __classPrivateFieldGet(this, _BlockOperationMANAGE_CERTIFICATE_instances, "m", _BlockOperationMANAGE_CERTIFICATE_computeCertificateMethod).call(this, input.method), "f");
        if ((input.intermediateCertificates === undefined) === (__classPrivateFieldGet(this, _BlockOperationMANAGE_CERTIFICATE_method, "f") === _2.default.AdjustMethod.ADD)) {
            throw (new block_1.default('BLOCK_INTERMEDIATE_CERTIFICATES_ONLY_ADD', 'Must provide intermediate certificates with a MANAGE_CERTIFICATE operation that is an ADD operation'));
        }
        if (__classPrivateFieldGet(this, _BlockOperationMANAGE_CERTIFICATE_method, "f") === _2.default.AdjustMethod.ADD) {
            __classPrivateFieldSet(this, _BlockOperationMANAGE_CERTIFICATE_intermediateCertificates, __classPrivateFieldGet(this, _BlockOperationMANAGE_CERTIFICATE_instances, "m", _BlockOperationMANAGE_CERTIFICATE_asIntermediateCertificates).call(this, input.intermediateCertificates), "f");
        }
        else {
            __classPrivateFieldSet(this, _BlockOperationMANAGE_CERTIFICATE_intermediateCertificates, undefined, "f");
        }
    }
    get intermediateCertificates() {
        if (__classPrivateFieldGet(this, _BlockOperationMANAGE_CERTIFICATE_method, "f") === _2.default.AdjustMethod.SUBTRACT) {
            return (undefined);
        }
        return (__classPrivateFieldGet(this, _BlockOperationMANAGE_CERTIFICATE_intermediateCertificates, "f"));
    }
    set intermediateCertificates(bundle) {
        __classPrivateFieldSet(this, _BlockOperationMANAGE_CERTIFICATE_intermediateCertificates, __classPrivateFieldGet(this, _BlockOperationMANAGE_CERTIFICATE_instances, "m", _BlockOperationMANAGE_CERTIFICATE_asIntermediateCertificates).call(this, bundle), "f");
    }
    get certificateOrHash() {
        if (certificate_1.CertificateHash.isInstance(__classPrivateFieldGet(this, _BlockOperationMANAGE_CERTIFICATE_certificateOrHash, "f"))) {
            if (__classPrivateFieldGet(this, _BlockOperationMANAGE_CERTIFICATE_method, "f") === _2.default.AdjustMethod.ADD) {
                throw (new block_1.default('BLOCK_INVALID_CERTIFICATE_VALUE', 'Cannot add a certificate by hash, you must provide the full certificate'));
            }
            return (__classPrivateFieldGet(this, _BlockOperationMANAGE_CERTIFICATE_certificateOrHash, "f"));
        }
        if (__classPrivateFieldGet(this, _BlockOperationMANAGE_CERTIFICATE_method, "f") === _2.default.AdjustMethod.SUBTRACT && !certificate_1.CertificateHash.isInstance(__classPrivateFieldGet(this, _BlockOperationMANAGE_CERTIFICATE_certificateOrHash, "f"))) {
            return (__classPrivateFieldGet(this, _BlockOperationMANAGE_CERTIFICATE_certificateOrHash, "f").hash());
        }
        return (__classPrivateFieldGet(this, _BlockOperationMANAGE_CERTIFICATE_certificateOrHash, "f"));
    }
    set certificateOrHash(certificate) {
        __classPrivateFieldSet(this, _BlockOperationMANAGE_CERTIFICATE_certificateOrHash, __classPrivateFieldGet(this, _BlockOperationMANAGE_CERTIFICATE_instances, "m", _BlockOperationMANAGE_CERTIFICATE_asCertificate).call(this, certificate), "f");
    }
    set method(shouldAdd) {
        __classPrivateFieldSet(this, _BlockOperationMANAGE_CERTIFICATE_method, __classPrivateFieldGet(this, _BlockOperationMANAGE_CERTIFICATE_instances, "m", _BlockOperationMANAGE_CERTIFICATE_computeCertificateMethod).call(this, shouldAdd), "f");
    }
    get method() {
        return (__classPrivateFieldGet(this, _BlockOperationMANAGE_CERTIFICATE_method, "f"));
    }
    validate(context) {
        if (this.method === _2.default.AdjustMethod.ADD) {
            if (certificate_1.CertificateHash.isInstance(__classPrivateFieldGet(this, _BlockOperationMANAGE_CERTIFICATE_certificateOrHash, "f"))) {
                throw (new block_1.default('BLOCK_INVALID_CERTIFICATE_VALUE', 'Cannot add a certificate by hash, you must provide the full certificate'));
            }
            if (!context.block.account.comparePublicKey(__classPrivateFieldGet(this, _BlockOperationMANAGE_CERTIFICATE_certificateOrHash, "f").subjectPublicKey)) {
                throw (new block_1.default('BLOCK_CERTIFICATE_SUBJECT_MISMATCH', 'This certificate subject does not match the block account'));
            }
            const intermediateCertificates = __classPrivateFieldGet(this, _BlockOperationMANAGE_CERTIFICATE_intermediateCertificates, "f") ?? null;
            if (intermediateCertificates !== null) {
                const intermediateSet = new Set(intermediateCertificates.getCertificates());
                __classPrivateFieldGet(this, _BlockOperationMANAGE_CERTIFICATE_certificateOrHash, "f").assertCanConstructValidGraph(intermediateSet);
            }
        }
        else {
            if (__classPrivateFieldGet(this, _BlockOperationMANAGE_CERTIFICATE_intermediateCertificates, "f") !== undefined) {
                throw (new block_1.default('BLOCK_INTERMEDIATE_CERTIFICATES_ONLY_ADD', 'Intermediate certificates can only be added, not removed'));
            }
        }
        const seenCertificates = new certificate_1.CertificateHash.Set();
        for (const operation of context.block.operations) {
            if (operation.type === OperationType.MANAGE_CERTIFICATE) {
                let hash;
                if (certificate_1.CertificateHash.isInstance(operation.certificateOrHash)) {
                    hash = operation.certificateOrHash;
                }
                else {
                    hash = operation.certificateOrHash.hash();
                }
                if (seenCertificates.has(hash)) {
                    throw (new block_1.default('BLOCK_NO_DUPLICATE_CERTIFICATE_OPERATION', 'Cannot operate on the same certificate twice'));
                }
                seenCertificates.add(hash);
            }
        }
    }
    toJSON() {
        let intermediateCertificates;
        if (__classPrivateFieldGet(this, _BlockOperationMANAGE_CERTIFICATE_method, "f") === _2.default.AdjustMethod.SUBTRACT) {
            intermediateCertificates = undefined;
        }
        else {
            intermediateCertificates = null;
            if (__classPrivateFieldGet(this, _BlockOperationMANAGE_CERTIFICATE_intermediateCertificates, "f") && __classPrivateFieldGet(this, _BlockOperationMANAGE_CERTIFICATE_intermediateCertificates, "f").bundleSize > 0) {
                intermediateCertificates = __classPrivateFieldGet(this, _BlockOperationMANAGE_CERTIFICATE_intermediateCertificates, "f").getDERBuffer().toString('base64');
            }
        }
        let serializedCertificate;
        if (__classPrivateFieldGet(this, _BlockOperationMANAGE_CERTIFICATE_method, "f") === _2.default.AdjustMethod.SUBTRACT) {
            if (!certificate_1.CertificateHash.isInstance(this.certificateOrHash)) {
                throw (new Error('Invalid response from get certificate, expected a CertificateHash'));
            }
            serializedCertificate = this.certificateOrHash.toString();
        }
        else {
            if (!certificate_1.Certificate.isCertificate(this.certificateOrHash)) {
                throw (new Error('Invalid response from get certificate, expected a Certificate'));
            }
            serializedCertificate = this.certificateOrHash.toPEM();
        }
        return ({
            type: this.type,
            certificateOrHash: serializedCertificate,
            method: this.method,
            intermediateCertificates: intermediateCertificates
        });
    }
}
_BlockOperationMANAGE_CERTIFICATE_certificateOrHash = new WeakMap(), _BlockOperationMANAGE_CERTIFICATE_intermediateCertificates = new WeakMap(), _BlockOperationMANAGE_CERTIFICATE_method = new WeakMap(), _BlockOperationMANAGE_CERTIFICATE_instances = new WeakSet(), _BlockOperationMANAGE_CERTIFICATE_asCertificate = function _BlockOperationMANAGE_CERTIFICATE_asCertificate(certificate) {
    if (certificate_1.Certificate.isCertificate(certificate)) {
        return (certificate);
    }
    if (certificate_1.CertificateHash.isInstance(certificate)) {
        return (certificate);
    }
    try {
        return (new certificate_1.Certificate(certificate));
    }
    catch {
        /* Ignore Errors */
    }
    try {
        return (new certificate_1.CertificateHash(certificate));
    }
    catch {
        /* Ignore Errors */
    }
    throw (new Error('Invalid certificate input, must be a Certificate, CertificateHash, or PEM/DER encoded string'));
}, _BlockOperationMANAGE_CERTIFICATE_asIntermediateCertificates = function _BlockOperationMANAGE_CERTIFICATE_asIntermediateCertificates(bundle) {
    if (bundle === null || bundle === undefined) {
        return (null);
    }
    const bundleObject = new certificate_1.CertificateBundle(bundle);
    if (bundleObject.bundleSize === 0) {
        return (null);
    }
    return (bundleObject);
}, _BlockOperationMANAGE_CERTIFICATE_computeCertificateMethod = function _BlockOperationMANAGE_CERTIFICATE_computeCertificateMethod(method) {
    const numericMethod = (0, _1.toAdjustMethod)(method);
    if (numericMethod === _2.default.AdjustMethod.SET) {
        throw (new Error('Cannot use AdjustMethod.SET on a MANAGE_CERTIFICATE operation.'));
    }
    return (numericMethod);
};
/**
 * Aggregate set of operations
 */
exports.Operation = {
    SEND: BlockOperationSEND,
    SET_REP: BlockOperationSET_REP,
    SET_INFO: BlockOperationSET_INFO,
    MODIFY_PERMISSIONS: BlockOperationMODIFY_PERMISSIONS,
    CREATE_IDENTIFIER: BlockOperationCREATE_IDENTIFIER,
    TOKEN_ADMIN_SUPPLY: BlockOperationTOKEN_ADMIN_SUPPLY,
    TOKEN_ADMIN_MODIFY_BALANCE: BlockOperationTOKEN_ADMIN_MODIFY_BALANCE,
    RECEIVE: BlockOperationRECEIVE,
    MANAGE_CERTIFICATE: BlockOperationMANAGE_CERTIFICATE
};
function createBlockOperation(input) {
    const typeStr = operationTypeToString(input.type);
    // The compiler does not know that this is valid
    // We know it is valid because the typeStr was generated from the input.type, so that function will take input
    // eslint-disable-next-line @typescript-eslint/consistent-type-assertions
    return (new exports.Operation[typeStr](input));
}
function isBlockOperation(input) {
    return (BlockOperation.isInstance(input, false));
}
/**
 * Export the "operations" mapping as something compatible with being
 * serialized to JSON
 */
function ExportOperationsJSON(operations) {
    return ((0, conversion_1.toJSONSerializable)(operations.map(function (operation) {
        return (operation.toJSON());
    })));
}
function ImportOperationsJSON(operations) {
    const newOperations = [];
    for (const operation of operations) {
        let type = operation.type;
        if (typeof type === 'string') {
            type = operationTypeToNumber(type);
        }
        if (OperationType[type] === undefined) {
            throw (new block_1.default('BLOCK_INVALID_TYPE', `Invalid operation type: ${type}`));
        }
        let operationData = operation;
        if (isBlockOperation(operation)) {
            operationData = operation.toJSON();
        }
        newOperations.push(createBlockOperation(operationData));
    }
    return (newOperations);
}
function ExportBlockOperations(operations) {
    const container = [];
    for (const entry of operations) {
        const operationContainer = [];
        const typeStr = operationTypeToString(entry.type);
        const operationSchema = BlockOperationASN1SchemaBase[typeStr];
        if (!typeStr || !operationSchema) {
            throw (new Error(`Unable to serialize operation with type ${entry.type} ${(0, conversion_1.toJSONSerializable)(entry)}`));
        }
        // We want to be able to read any key on the operation, so we need to cast it to any
        const unTypedEntry = entry;
        for (const { name: key, schema } of operationSchema) {
            let valueToWrite = unTypedEntry[key];
            if (valueToWrite === undefined) {
                if (typeof schema === 'object' && schema && !('optional' in schema)) {
                    throw (new Error(`Key ${key} for operation ${typeStr} is not optional but undefined value provided`));
                }
                continue;
            }
            else if (typeStr === 'CREATE_IDENTIFIER' && key === 'createArguments') {
                // We are checking this in other places, and if this argument changes there will be many other things that break beforehand
                // eslint-disable-next-line @typescript-eslint/consistent-type-assertions
                const typedValue = valueToWrite;
                valueToWrite = {
                    type: 'context',
                    kind: 'explicit',
                    value: valueToWrite.type,
                    contains: [
                        typedValue.signers.map(function (signer) {
                            return (signer.publicKeyAndType);
                        }),
                        typedValue.quorum
                    ]
                };
            }
            else if (typeof valueToWrite === 'string') {
                valueToWrite = { type: 'string', kind: 'utf8', value: valueToWrite };
            }
            else if (account_1.default.isInstance(valueToWrite)) {
                valueToWrite = valueToWrite.publicKeyAndType;
            }
            else if (permissions_1.Permissions.isInstance(valueToWrite)) {
                valueToWrite = [valueToWrite.base.bigint, valueToWrite.external.bigint];
            }
            else if (certificate_1.Certificate.isCertificate(valueToWrite)) {
                valueToWrite = Buffer.from(valueToWrite.toDER());
            }
            else if (certificate_1.CertificateHash.isInstance(valueToWrite)) {
                valueToWrite = valueToWrite.getBuffer();
            }
            else if (certificate_1.CertificateBundle.isInstance(valueToWrite)) {
                valueToWrite = valueToWrite.getCertificates().map(function (certificate) {
                    return (Buffer.from(certificate.toDER()));
                });
            }
            operationContainer.push(valueToWrite);
        }
        container.push({
            type: 'context',
            kind: 'explicit',
            value: entry.type,
            contains: operationContainer
        });
    }
    // eslint-disable-next-line @typescript-eslint/consistent-type-assertions
    return container;
}
function ImportOperationsASN1(input, network) {
    const retval = [];
    for (const entryWrapper of input) {
        const operation = {};
        if (!asn1_1.ASN1CheckUtilities.isASN1ContextTag(entryWrapper, 'explicit')) {
            throw (new Error('Invalid createArgs type for CREATE_IDENTIFIER operation'));
        }
        const type = assertOperationType(entryWrapper.value);
        const entry = entryWrapper.contains;
        if (!Array.isArray(entry)) {
            throw (new Error(`Found entry which is not a Sequence ${typeof entry}`));
        }
        const typeStr = operationTypeToString(type);
        const operationSchema = BlockOperationASN1SchemaBase[typeStr];
        if (!operationSchema) {
            throw (new Error(`Found valid operation ${typeStr} with invalid keys`));
        }
        operation.type = type;
        let keyIndex = -1;
        for (const { name: key } of operationSchema) {
            keyIndex++;
            const keyValueIn = entry[keyIndex];
            let keyValueOut = undefined;
            if (keyValueIn === undefined) {
                break;
            }
            else if (['bigint', 'string', 'boolean'].includes(typeof keyValueIn)) {
                keyValueOut = keyValueIn;
            }
            else if (typeof keyValueIn === 'number') {
                keyValueOut = (0, asn1_1.ASN1IntegerToBigInt)(keyValueIn);
            }
            else if (keyValueIn === null) {
                keyValueOut = null;
            }
            else if (Array.isArray(keyValueIn) && key.toLowerCase().includes('permission')) {
                // We are parsing a Permission
                const [base, external] = keyValueIn;
                const newKeyValue = new permissions_1.Permissions(base, external);
                newKeyValue.validate(network);
                keyValueOut = newKeyValue;
            }
            else if (key === 'createArguments' && typeStr === 'CREATE_IDENTIFIER') {
                if (!asn1_1.ASN1CheckUtilities.isASN1ContextTag(keyValueIn, 'explicit')) {
                    throw (new Error('Invalid createArgs type for CREATE_IDENTIFIER operation'));
                }
                if (keyValueIn.value !== account_1.AccountKeyAlgorithm.MULTISIG) {
                    throw (new Error('unrecognized type for multisig create arguments'));
                }
                if (!Array.isArray(keyValueIn.contains) || keyValueIn.contains.length !== 2) {
                    throw (new Error('Invalid createArgs container'));
                }
                if (!Array.isArray(keyValueIn.contains[0])) {
                    throw (new Error('Invalid createArgs container'));
                }
                keyValueOut = {
                    type: keyValueIn.value,
                    signers: keyValueIn.contains[0].map(function (value) {
                        if (!Buffer.isBuffer(value)) {
                            throw (new Error(`Invalid signer value, expected Buffer, got ${typeof value}`));
                        }
                        return (account_1.default.fromPublicKeyAndType(value));
                    }),
                    quorum: keyValueIn.contains[1]
                };
            }
            else if (Array.isArray(keyValueIn) && key === 'intermediateCertificates') {
                keyValueOut = new certificate_1.CertificateBundle(keyValueIn.map(function (certificate) {
                    return (new certificate_1.Certificate(certificate));
                }));
            }
            else if ((0, helper_1.isBuffer)(keyValueIn)) {
                if (type === OperationType.MANAGE_CERTIFICATE && key === 'certificateOrHash') {
                    const method = (0, _1.toAdjustMethod)(operation['method']);
                    if (method === _2.AdjustMethod.SUBTRACT) {
                        keyValueOut = new certificate_1.CertificateHash(keyValueIn);
                    }
                    else if (method === _2.AdjustMethod.ADD) {
                        keyValueOut = new certificate_1.Certificate(keyValueIn);
                    }
                    else {
                        throw (new Error(`Unrecognized method for MANAGE_CERTIFICATE operation: ${method}`));
                    }
                }
                else {
                    keyValueOut = account_1.default.fromPublicKeyAndType(keyValueIn);
                }
            }
            else if (typeof keyValueIn === 'object' && keyValueIn !== null) {
                if (('type' in keyValueIn) && ('kind' in keyValueIn) && ('value' in keyValueIn)) {
                    if (keyValueIn.type === 'string' && keyValueIn.kind === 'utf8') {
                        keyValueOut = keyValueIn.value;
                    }
                }
            }
            if (keyValueOut === undefined) {
                throw (new Error(`Invalid key value for ${key}: ${keyValueIn}`));
            }
            operation[key] = keyValueOut;
        }
        // It is difficult to validate types here, but the next function already validates them
        // eslint-disable-next-line @typescript-eslint/consistent-type-assertions
        retval.push(createBlockOperation(operation));
    }
    return (retval);
}


/***/ }),

/***/ 4642:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FullAccountErrorCodes = exports.AccountErrorCodes = void 0;
const base_1 = __webpack_require__(1096);
const helper_1 = __webpack_require__(3208);
const AccountErrorType = 'ACCOUNT';
exports.AccountErrorCodes = [
    'INVALID_PREFIX',
    'INVALID_KEYTYPE',
    'INVALID_KEYTYPE_EXTERNAL',
    'PASSPHRASE_WEAK',
    'INVALID_CONSTRUCTION',
    'NO_IDENTIFIER_SIGN',
    'NO_IDENTIFIER_VERIFY',
    'INVALID_IDENTIFIER_CONSTRUCTION',
    'SEED_INDEX_UNDEFINED',
    'SEED_INDEX_NEGATIVE',
    'SEED_INDEX_NOT_INT',
    'SEED_INDEX_TOO_LARGE',
    'ENCRYPTION_NOT_SUPPORTED'
];
exports.FullAccountErrorCodes = exports.AccountErrorCodes.map(code => `${AccountErrorType}_${code}`);
class KeetaNetAccountError extends base_1.KeetaNetErrorBase {
    constructor(code, message) {
        super(code, message, { type: AccountErrorType, codes: exports.AccountErrorCodes });
    }
}
KeetaNetAccountError.isInstance = (0, helper_1.checkableGenerator)(KeetaNetAccountError);
exports["default"] = KeetaNetAccountError;


/***/ }),

/***/ 7533:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FullAPIErrorCodes = exports.APIErrorCodes = void 0;
const base_1 = __webpack_require__(1096);
const helper_1 = __webpack_require__(3208);
const APIErrorType = 'API';
exports.APIErrorCodes = [
    'INVALID_LIMIT',
    'INVALID_SIDE',
    'INVALID_START',
    'LIMIT_NOT_NUMBER',
    'LIMIT_NOT_GREATER_THAN_ZERO',
    'REP_MISSING',
    'START_MISSING'
];
exports.FullAPIErrorCodes = exports.APIErrorCodes.map(code => `${APIErrorType}_${code}`);
class KeetaNetAPIError extends base_1.KeetaNetErrorBase {
    constructor(code, message) {
        super(code, message, { type: APIErrorType, codes: exports.APIErrorCodes });
    }
}
KeetaNetAPIError.isInstance = (0, helper_1.checkableGenerator)(KeetaNetAPIError);
exports["default"] = KeetaNetAPIError;


/***/ }),

/***/ 1096:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.KeetaNetErrorBase = void 0;
const helper_1 = __webpack_require__(3208);
class KeetaNetErrorBase extends Error {
    constructor(code, message, validation) {
        super(message);
        const type = validation?.type || 'GENERIC';
        if (validation !== undefined) {
            const prefix = `${validation.type}_`;
            const validPrefix = code.startsWith(prefix);
            const withoutPrefix = code.substring(prefix.length);
            const validCode = validation.codes.includes(withoutPrefix);
            if (!validPrefix || !validCode) {
                throw (new Error(`Invalid construction of KeetaNetError Type: ${validation.type} Code: ${code}, prefix ${prefix} valid ${validPrefix} valid code: ${validCode}`));
            }
        }
        this.code = code;
        this.type = type;
    }
    toJSON() {
        return ({
            type: this.type,
            code: this.code,
            message: this.message
        });
    }
}
exports.KeetaNetErrorBase = KeetaNetErrorBase;
KeetaNetErrorBase.isInstance = (0, helper_1.checkableGenerator)(KeetaNetErrorBase, false);


/***/ }),

/***/ 7412:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FullBlockErrorCodes = exports.BlockErrorCodes = void 0;
const base_1 = __webpack_require__(1096);
const helper_1 = __webpack_require__(3208);
const BlockErrorType = 'BLOCK';
exports.BlockErrorCodes = [
    'INVALID_TYPE',
    'INVALID_VERSION',
    'NO_MULTIPLE_SET_REP',
    'IDENTIFIER_NEED_DEFAULT_PERMISSIONS',
    'CANNOT_SEND_NON_TOKEN',
    'TOKEN_RECEIVE_DIFFERS',
    'ONLY_TOKEN_OP',
    'ONLY_IDENTIFIER_OP',
    'NO_TOKEN_OP',
    'NO_IDENTIFIER_OP',
    'INVALID_SIGNER',
    'INVALID_PURPOSE_VALIDATION',
    'INVALID_MULTISIG_QUORUM',
    'INVALID_MULTISIG_SIGNER_DEPTH',
    'INVALID_MULTISIG_SIGNER_COUNT',
    'INVALID_MULTISIG_SIGNER_DUPLICATE',
    'INVALID_CREATE_IDENTIFIER_ARGS',
    'NO_MULTISIG_OP',
    'IDENTIFIER_INVALID',
    'GENERAL_FIELD_INVALID',
    'PERMISSIONS_INVALID_DEFAULT',
    'PERMISSIONS_INVALID_ENTITY',
    'PERMISSIONS_INVALID_PRINCIPAL',
    'PERMISSIONS_INVALID_TARGET',
    'INVALID_ACCOUNT_TYPE',
    'NO_ADMIN_ON_TARGET',
    'PREVIOUS_SELF',
    'NO_DELEGATE_ADMIN',
    'NO_MODIFY_PERMISSION_DUPE',
    'CANNOT_FORWARD_TO_SELF',
    'EXACT_TRUE_WHEN_FORWARDING',
    'CERTIFICATE_SUBJECT_MISMATCH',
    'NO_DUPLICATE_CERTIFICATE_OPERATION',
    'INTERMEDIATE_CERTIFICATES_ONLY_ADD',
    'INVALID_CERTIFICATE_VALUE',
    'EXTERNAL_TOO_LONG',
    'EXTERNAL_INVALID',
    'EXTERNAL_MISSING',
    'SUPPLY_INVALID'
];
exports.FullBlockErrorCodes = exports.BlockErrorCodes.map(code => `${BlockErrorType}_${code}`);
class KeetaNetBlockError extends base_1.KeetaNetErrorBase {
    constructor(code, message) {
        super(code, message, { type: BlockErrorType, codes: exports.BlockErrorCodes });
    }
}
KeetaNetBlockError.isInstance = (0, helper_1.checkableGenerator)(KeetaNetBlockError);
exports["default"] = KeetaNetBlockError;


/***/ }),

/***/ 9890:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FullCertificateErrorCodes = exports.CertificateErrorCodes = void 0;
const base_1 = __webpack_require__(1096);
const helper_1 = __webpack_require__(3208);
const CertificateErrorType = 'CERTIFICATE';
exports.CertificateErrorCodes = [
    'DUPLICATE_INCLUDED',
    'ORPHAN_FOUND',
    'CYCLE_FOUND',
    'SECONDARY_GRAPH',
    'MISSING_FIELD',
    'SIGNATURE_ALGORITHM_MISMATCH',
    'SELF_SIGNED_VALIDATION_FAILED',
    'CHAIN_VERIFICATION_FAILED',
    'DUPLICATE_EXTENSION',
    'EXTENSION_NOT_PROCESSED',
    'INVALID_SIGNATURE_ALGORITHM',
    'INVALID_GRAPH_COUNT',
    'MOMENT_INVALID',
    'INVALID_VERSION'
];
exports.FullCertificateErrorCodes = exports.CertificateErrorCodes.map(code => `${CertificateErrorType}_${code}`);
class KeetaNetCertificateError extends base_1.KeetaNetErrorBase {
    constructor(code, message) {
        super(code, message, { type: CertificateErrorType, codes: exports.CertificateErrorCodes });
    }
}
KeetaNetCertificateError.isInstance = (0, helper_1.checkableGenerator)(KeetaNetCertificateError);
exports["default"] = KeetaNetCertificateError;


/***/ }),

/***/ 3642:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FullClientErrorCodes = exports.ClientErrorCodes = void 0;
const base_1 = __webpack_require__(1096);
const helper_1 = __webpack_require__(3208);
const ClientErrorType = 'CLIENT';
exports.ClientErrorCodes = [
    'BUILDER_AMOUNT_IS_ZERO',
    'BUILDER_CANNOT_READ_BEFORE_RENDER',
    'BUILDER_REQUIRES_PRIVATE_KEY',
    'BUILDER_USER_CLIENT_REQUIRED',
    'PUBLISH_AID_NOT_AVAILABLE',
    'SIGNER_REQUIRES_PRIVATE_KEY',
    'SYNC_PUBLISH_FAILED'
];
exports.FullClientErrorCodes = exports.ClientErrorCodes.map(code => `${ClientErrorType}_${code}`);
class KeetaNetClientError extends base_1.KeetaNetErrorBase {
    constructor(code, message) {
        super(code, message, { type: ClientErrorType, codes: exports.ClientErrorCodes });
    }
}
KeetaNetClientError.isInstance = (0, helper_1.checkableGenerator)(KeetaNetClientError);
exports["default"] = KeetaNetClientError;


/***/ }),

/***/ 5390:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.KeetaNetError = void 0;
exports.ExpectErrorCode = ExpectErrorCode;
const account_1 = __importDefault(__webpack_require__(9415));
const account_2 = __webpack_require__(4642);
const api_1 = __webpack_require__(7533);
const base_1 = __webpack_require__(1096);
const block_1 = __webpack_require__(7412);
const certificate_1 = __webpack_require__(9890);
const client_1 = __webpack_require__(3642);
const kv_1 = __webpack_require__(9272);
const ledger_1 = __webpack_require__(452);
const permissions_1 = __webpack_require__(2105);
const vote_1 = __webpack_require__(3689);
const allErrorCodesWithoutPrefix = [
    ...account_2.AccountErrorCodes,
    ...api_1.APIErrorCodes,
    ...block_1.BlockErrorCodes,
    ...certificate_1.CertificateErrorCodes,
    ...client_1.ClientErrorCodes,
    ...kv_1.KVErrorCodes,
    ...ledger_1.LedgerBaseErrorCodes,
    ...ledger_1.LedgerVoteErrorCodes,
    ...permissions_1.PermissionsErrorCodes,
    ...vote_1.VoteErrorCodes
];
const allFullErrorCodes = [
    ...account_2.FullAccountErrorCodes,
    ...api_1.FullAPIErrorCodes,
    ...block_1.FullBlockErrorCodes,
    ...certificate_1.FullCertificateErrorCodes,
    ...client_1.FullClientErrorCodes,
    ...kv_1.FullKVErrorCodes,
    ...ledger_1.FullLedgerErrorCodes,
    ...permissions_1.FullPermissionsErrorCodes,
    ...vote_1.FullVoteErrorCodes
];
const errorCodeSet = new Set(allFullErrorCodes);
async function ExpectErrorCode(code, test) {
    await expect(test).rejects.toThrow(expect.objectContaining({
        code: code
    }));
}
class KeetaNetError extends base_1.KeetaNetErrorBase {
    static assertValidErrorCode(code) {
        return (errorCodeSet.has(code));
    }
    static fromJSON(json) {
        if (typeof json === 'object' && json !== null && 'type' in json && 'code' in json && 'message' in json) {
            const { type, code, message } = json;
            if (typeof type !== 'string' || typeof code !== 'string' || typeof message !== 'string') {
                return (new Error('Invalid JSON for KeetaNetError (bad type or code or message)'));
            }
            if (type === 'LEDGER') {
                let shouldRetry;
                let retryDelay;
                if ('shouldRetry' in json) {
                    if (typeof json.shouldRetry !== 'boolean') {
                        return (new Error('Invalid JSON for KeetaNetLedgerError (bad shouldRetry)'));
                    }
                    shouldRetry = json.shouldRetry;
                }
                if ('retryDelay' in json) {
                    if (typeof json.retryDelay !== 'number') {
                        return (new Error('Invalid JSON for KeetaNetLedgerError (bad retryDelay)'));
                    }
                    retryDelay = json.retryDelay;
                }
                if (ledger_1.KeetaNetLedgerVoteError.assertValidLedgerErrorCode(code)) {
                    if (!('accounts' in json) || !Array.isArray(json.accounts)) {
                        return (new Error('Invalid JSON for KeetaNetLedgerVoteError (bad accounts)'));
                    }
                    const accountsArray = json.accounts.map((account) => {
                        return (account_1.default.fromPublicKeyString(account));
                    });
                    const accounts = new account_1.default.Set(accountsArray);
                    return (new ledger_1.KeetaNetLedgerVoteError(code, message, accounts));
                }
                else if (ledger_1.KeetaNetLedgerError.assertValidLedgerErrorCode(code)) {
                    return (new ledger_1.KeetaNetLedgerError(code, message, shouldRetry, retryDelay));
                }
            }
            if (this.assertValidErrorCode(code)) {
                return (new KeetaNetError(code, message, { type, codes: allErrorCodesWithoutPrefix }));
            }
        }
        if (typeof json === 'object' && json !== null && 'message' in json) {
            if (typeof json.message !== 'string') {
                return (new Error('Invalid JSON for KeetaNetError (bad message)'));
            }
            return (new Error(json.message));
        }
        return (new Error('Unknown error'));
    }
}
exports.KeetaNetError = KeetaNetError;


/***/ }),

/***/ 9272:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FullKVErrorCodes = exports.KVErrorCodes = void 0;
const base_1 = __webpack_require__(1096);
const helper_1 = __webpack_require__(3208);
const KVErrorType = 'KV';
exports.KVErrorCodes = [
    'TTL_NOT_SUPPORTED',
    'KEY_ALREADY_EXISTS'
];
exports.FullKVErrorCodes = exports.KVErrorCodes.map(code => `${KVErrorType}_${code}`);
class KeetaNetKVError extends base_1.KeetaNetErrorBase {
    constructor(code, message) {
        super(code, message, { type: KVErrorType, codes: exports.KVErrorCodes });
    }
}
KeetaNetKVError.isInstance = (0, helper_1.checkableGenerator)(KeetaNetKVError);
exports["default"] = KeetaNetKVError;


/***/ }),

/***/ 452:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.KeetaNetLedgerVoteError = exports.KeetaNetLedgerError = exports.FullLedgerVoteErrorCodes = exports.FullLedgerBaseErrorCode = exports.FullLedgerErrorCodes = exports.LedgerVoteErrorCodes = exports.LedgerBaseErrorCodes = void 0;
const base_1 = __webpack_require__(1096);
const helper_1 = __webpack_require__(3208);
const LedgerErrorType = 'LEDGER';
exports.LedgerBaseErrorCodes = [
    'BLOCK_ALREADY_EXISTS',
    'TRANSACTION_ABORTED',
    'INVALID_CHAIN',
    'INVALID_NETWORK',
    'INVALID_SUBNET',
    'INVALID_PERMISSIONS',
    'INVALID_OWNER_COUNT',
    'INVALID_BALANCE',
    'INVALID_SET_REP',
    'OPERATION_NOT_SUPPORTED',
    'NOT_EMPTY',
    'PREVIOUS_ALREADY_USED',
    'PREVIOUS_NOT_SEEN',
    'SUCCESSOR_VOTE_EXISTS',
    'INSUFFICIENT_VOTING_WEIGHT',
    'INVALID_ACCOUNT_INFO_KEY',
    'RECEIVE_NOT_MET',
    'DUPLICATE_VOTE_FOUND',
    'CANNOT_EXCHANGE_PERM_VOTE',
    'BLOCKS_DIFFER_FROM_VOTED_ON',
    'NO_PERM_WITHOUT_SELF_TEMP',
    'DUPLICATE_VOTE_ISSUER_FOUND',
    'OTHER',
    'MISSING_BLOCKS',
    // Fee Errors
    'FEE_AMOUNT_MISMATCH',
    'FEE_TOKEN_MISMATCH',
    'FEE_MISSING',
    'MISSING_REQUIRED_FEE_BLOCK',
    'PERM_VOTE_WITH_QUOTE',
    'QUOTE_MISMATCH',
    'REQUIRED_FEE_MISMATCH'
];
// Errors that can trigger rep sync
exports.LedgerVoteErrorCodes = [
    'NOT_SUCCESSOR',
    'NOT_OPENING'
];
exports.FullLedgerErrorCodes = [...exports.LedgerBaseErrorCodes, ...exports.LedgerVoteErrorCodes].map(code => `${LedgerErrorType}_${code}`);
exports.FullLedgerBaseErrorCode = exports.LedgerBaseErrorCodes.map(code => `${LedgerErrorType}_${code}`);
exports.FullLedgerVoteErrorCodes = exports.LedgerVoteErrorCodes.map(code => `${LedgerErrorType}_${code}`);
const ledgerBaseErrorCodeSet = new Set(exports.FullLedgerBaseErrorCode);
const ledgerVoteErrorCodeSet = new Set(exports.FullLedgerVoteErrorCodes);
class KeetaNetLedgerError extends base_1.KeetaNetErrorBase {
    static assertValidLedgerErrorCode(code) {
        return (ledgerBaseErrorCodeSet.has(code));
    }
    constructor(code, message, shouldRetry = false, retryDelay) {
        super(code, message, { type: LedgerErrorType, codes: exports.LedgerBaseErrorCodes });
        this.type = LedgerErrorType;
        this.shouldRetry = shouldRetry;
        if (shouldRetry && retryDelay !== undefined) {
            this.retryDelay = retryDelay;
        }
    }
}
exports.KeetaNetLedgerError = KeetaNetLedgerError;
KeetaNetLedgerError.isInstance = (0, helper_1.checkableGenerator)(KeetaNetLedgerError);
class KeetaNetLedgerVoteError extends base_1.KeetaNetErrorBase {
    static assertValidLedgerErrorCode(code) {
        return (ledgerVoteErrorCodeSet.has(code));
    }
    constructor(code, message, accounts) {
        super(code, message, { type: LedgerErrorType, codes: exports.LedgerVoteErrorCodes });
        this.type = LedgerErrorType;
        this.shouldRetry = false;
        this.accounts = accounts;
    }
    toJSON() {
        return ({
            ...super.toJSON(),
            accounts: [...this.accounts.values()].map(function (account) {
                return (account.publicKeyString.get());
            })
        });
    }
}
exports.KeetaNetLedgerVoteError = KeetaNetLedgerVoteError;
KeetaNetLedgerVoteError.isInstance = (0, helper_1.checkableGenerator)(KeetaNetLedgerVoteError);


/***/ }),

/***/ 2105:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FullPermissionsErrorCodes = exports.PermissionsErrorCodes = void 0;
const base_1 = __webpack_require__(1096);
const helper_1 = __webpack_require__(3208);
const PermissionsErrorType = 'PERMISSIONS';
exports.PermissionsErrorCodes = [
    'CANNOT_MIX_FLAGS_AND_TYPES',
    'EXTERNAL_OFFSET_TOO_LARGE',
    'INVALID_EXTERNAL_FLAG',
    'INVALID_FLAG',
    'INVALID_FLAG_ASSERTION'
];
exports.FullPermissionsErrorCodes = exports.PermissionsErrorCodes.map(code => `${PermissionsErrorType}_${code}`);
class KeetaNetPermissionsError extends base_1.KeetaNetErrorBase {
    constructor(code, message) {
        super(code, message, { type: PermissionsErrorType, codes: exports.PermissionsErrorCodes });
    }
}
KeetaNetPermissionsError.isInstance = (0, helper_1.checkableGenerator)(KeetaNetPermissionsError);
exports["default"] = KeetaNetPermissionsError;


/***/ }),

/***/ 3689:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FullVoteErrorCodes = exports.VoteErrorCodes = void 0;
const base_1 = __webpack_require__(1096);
const helper_1 = __webpack_require__(3208);
const VoteErrorType = 'VOTE';
exports.VoteErrorCodes = [
    // Errors related to Vote
    'SERIAL_MISMATCH',
    'INVALID_VERSION',
    'INVALID_CONSTRUCTION',
    'INVALID_CONSTRUCTION_JSON',
    'SIGNATURE_INVALID',
    'EXPIRED',
    'INVALID_VALIDITY',
    'MOMENT_BEFORE_VALIDITY_FROM',
    // Errors related to VoteStaple
    'STAPLE_INVALID_CONSTRUCTION',
    'STAPLE_ALL_VOTES_MUST_HAVE_SAME_BLOCKS_COUNT',
    'STAPLE_ALL_VOTES_MUST_HAVE_SAME_BLOCKS_MISSING',
    'STAPLE_ALL_VOTES_MUST_HAVE_SAME_BLOCKS_ORDER',
    'STAPLE_DUPLICATE_VOTE_ISSUER',
    'STAPLE_PERMANENCE_MISMATCH',
    // Errors related to VoteBuilder
    'BUILDER_INVALID_CONSTRUCTION',
    'BUILDER_INVALID_BLOCK_TYPE',
    'BUILDER_INVALID_SERIAL',
    'BUILDER_INVALID_VALID_TO_FROM',
    /**
     * Malformed ASN.1 Errors
     */
    // Errors from constructing a vote
    'MALFORMED_WRAPPER',
    'MALFORMED_VOTE_WRAPPER',
    'MALFORMED_VOTE_CONTENT',
    'MALFORMED_VOTE_CONTENT_EXTRA_DATA',
    'MALFORMED_VOTE_VERSION',
    'MALFORMED_VOTE_SERIAL',
    'MALFORMED_VOTE_SIGNATURE_INFORMATION',
    'MALFORMED_VOTE_ISSUER_INFORMATION',
    'MALFORMED_VOTE_SUBJECT_INFORMATION',
    'MALFORMED_VOTE_VALIDITY_INFORMATION',
    'MALFORMED_VOTE_SERIAL',
    'MALFORMED_VOTE_EXTENSIONS',
    'MALFORMED_VOTE_EXTENSIONS_DATA',
    'MALFORMED_VOTE_EXTENSIONS_VALUE',
    'MALFORMED_VOTE_EXTENSIONS_VALUE_OID',
    'MALFORMED_VOTE_EXTENSIONS_VALUE_CRITICAL',
    'MALFORMED_VOTE_EXTENSIONS_VALUE_CRITICAL_TYPE',
    'MALFORMED_VOTE_SIGNATURE_SCHEME_DOES_NOT_MATCH_ISSUER',
    'MALFORMED_VOTE_SIGNATURE_SCHEME_DOES_NOT_MATCH_WRAPPER',
    'MALFORMED_VOTE_SIGNATURE_SCHEME_ECDSA_INVALID_CURVE',
    'MALFORMED_VOTE_SIGNATURE_UNSUPPORTED_SCHEME',
    'MALFORMED_VOTE_SUBJECT_PUBLIC_KEY_INFORMATION',
    'MALFORMED_VOTE_SIGNATURE_VALUE',
    'MALFORMED_VOTE_NO_BLOCKS_FOUND',
    // Errors from constructing a staple
    'MALFORMED_STAPLE',
    'MALFORMED_STAPLE_BLOCKS',
    'MALFORMED_STAPLE_BLOCKS_AT_LEAST_ONE',
    'MALFORMED_STAPLE_VOTES',
    'MALFORMED_STAPLE_VOTES_AT_LEAST_ONE',
    // Errors created from the findRDN function
    'MALFORMED_FIND_RDN_INVALID_TYPE',
    'MALFORMED_FIND_RDN_MUST_HAVE_ONE',
    'MALFORMED_FIND_RDN_PART_WELL_FORMED',
    'MALFORMED_FIND_RDN_MUST_BE_SET',
    'MALFORMED_FIND_RDN_TYPE_MUST_BE_OID',
    // Errors from the blockHashesFromVote function
    'MALFORMED_HASHES_FROM_VOTE_INVALID_INPUT',
    'MALFORMED_HASHES_FROM_VOTE_INVALID_TYPE',
    'MALFORMED_HASHES_FROM_VOTE_INVALID_CONTEXT_SPECIFIC',
    'MALFORMED_HASHES_FROM_VOTE_DATA_NEEDS_OID',
    'MALFORMED_HASHES_FROM_VOTE_DATA_HASH_DATA_MUST_BE_SEQUENCE',
    'MALFORMED_HASHES_FROM_VOTE_DATA_NOT_TWO_ITEMS',
    'MALFORMED_HASHES_FROM_VOTE_DATA_UNSUPPORTED_HASH_FUNC',
    'MALFORMED_HASHES_FROM_VOTE_DATA_UNSUPPORTED_HASH_TYPE',
    'MALFORMED_HASHES_FROM_VOTE_DATA_SECOND_MUST_BE_SEQUENCE',
    // Errors from the feesFromVote function
    'MALFORMED_FEES_AMOUNT',
    'MALFORMED_FEES_FROM_VOTE_INVALID_INPUT',
    'MALFORMED_FEES_IN_PERMANENT_VOTE',
    'MALFORMED_FEES_PAY_TO_INVALID',
    'MALFORMED_FEES_TOKEN_NOT_TOKEN',
    // Fee Quote Errors
    'FEE_IS_QUOTE',
    'FEE_QUOTE_MISSING_FEES',
    'FEE_NOT_QUOTE',
    'MALFORMED_FEES_KIND_MISSING',
    'MALFORMED_FEES_QUOTE_INVALID'
];
exports.FullVoteErrorCodes = exports.VoteErrorCodes.map(code => `${VoteErrorType}_${code}`);
class KeetaNetVoteError extends base_1.KeetaNetErrorBase {
    constructor(code, message) {
        super(code, message, { type: VoteErrorType, codes: exports.VoteErrorCodes });
    }
}
KeetaNetVoteError.isInstance = (0, helper_1.checkableGenerator)(KeetaNetVoteError);
exports["default"] = KeetaNetVoteError;


/***/ }),

/***/ 8568:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const account_1 = __importDefault(__webpack_require__(9415));
const block_1 = __importDefault(__webpack_require__(6158));
const ledger_1 = __importDefault(__webpack_require__(4796));
const node_1 = __importDefault(__webpack_require__(5337));
const p2p_1 = __importDefault(__webpack_require__(7074));
const stats_1 = __importDefault(__webpack_require__(2127));
const permissions_1 = __webpack_require__(5860);
const vote_1 = __importDefault(__webpack_require__(1130));
const error_1 = __webpack_require__(5390);
const ASN1 = __importStar(__webpack_require__(6045));
const Bloom = __importStar(__webpack_require__(7313));
const Buffer = __importStar(__webpack_require__(3310));
const Hash = __importStar(__webpack_require__(7908));
const Helper = __importStar(__webpack_require__(3208));
const Initial = __importStar(__webpack_require__(3750));
const Conversion = __importStar(__webpack_require__(2360));
const Certificate = __importStar(__webpack_require__(5661));
exports["default"] = {
    /**
     * The `Account` module provides functionality for managing key pairs
     * as well as `identifier` accounts such as tokens.
     */
    Account: account_1.default,
    Block: block_1.default,
    Error: error_1.KeetaNetError,
    Ledger: ledger_1.default,
    Node: node_1.default,
    P2P: p2p_1.default,
    Permissions: permissions_1.Permissions,
    Stats: stats_1.default,
    Vote: vote_1.default,
    Utils: {
        ASN1,
        Bloom,
        Buffer,
        Hash,
        Helper,
        Initial,
        Conversion,
        Certificate
    }
};


/***/ }),

/***/ 3828:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.KVStorageProviderBase = void 0;
const crypto_1 = __webpack_require__(6982);
class KVStorageProviderBase {
    constructor() {
        this.id = (0, crypto_1.randomUUID)();
    }
    async xor(_ignored_arena, key, _ignored_change, _ignored_options) {
        if (key.startsWith('@buffer:')) {
            return;
        }
        throw (new Error('Key provided for XOR must begin with "@buffer"'));
    }
}
exports.KVStorageProviderBase = KVStorageProviderBase;


/***/ }),

/***/ 1557:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _KVStorageProviderMemory_instances, _KVStorageProviderMemory_db, _KVStorageProviderMemory_getArena;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.KVStorageProviderMemory = void 0;
const _1 = __webpack_require__(3828);
const buffer_1 = __webpack_require__(3310);
const nullArena = 'null:43c98976-2282-44c2-819a-769732ceb847';
function deserialize(value) {
    if (buffer_1.BufferStorage.isInstance(value)) {
        value = value.toString('hex');
    }
    return (value);
}
class KVStorageProviderMemory extends _1.KVStorageProviderBase {
    constructor() {
        super();
        _KVStorageProviderMemory_instances.add(this);
        _KVStorageProviderMemory_db.set(this, void 0);
        __classPrivateFieldSet(this, _KVStorageProviderMemory_db, {}, "f");
    }
    async set(arena, key, value, options) {
        const storeArena = __classPrivateFieldGet(this, _KVStorageProviderMemory_instances, "m", _KVStorageProviderMemory_getArena).call(this, arena);
        if (value !== undefined) {
            if (options?.exclusiveCreate) {
                if (storeArena[key] !== undefined) {
                    throw (new Error('unable to exclusively create this item, already exists'));
                }
            }
        }
        let expiry;
        if (options?.ttl !== undefined) {
            expiry = Date.now() + options.ttl;
        }
        if (value === undefined || value === null) {
            delete storeArena[key];
            return;
        }
        storeArena[key] = { value, expiry };
    }
    async get(arena, key) {
        if (arena === null) {
            arena = nullArena;
        }
        const storeArena = __classPrivateFieldGet(this, _KVStorageProviderMemory_instances, "m", _KVStorageProviderMemory_getArena).call(this, arena);
        if (!storeArena[key]) {
            return (undefined);
        }
        const { expiry, value } = storeArena[key];
        if (expiry !== undefined) {
            if (expiry < Date.now()) {
                delete storeArena[key];
                return (undefined);
            }
        }
        const retval = deserialize(value);
        return (retval);
    }
    async getAll(arena) {
        const storeArena = __classPrivateFieldGet(this, _KVStorageProviderMemory_instances, "m", _KVStorageProviderMemory_getArena).call(this, arena);
        const retval = {};
        for (const key in storeArena) {
            const value = await this.get(arena, key);
            if (value === undefined) {
                continue;
            }
            retval[key] = value;
        }
        return (retval);
    }
    async list(arena) {
        const storeArena = __classPrivateFieldGet(this, _KVStorageProviderMemory_instances, "m", _KVStorageProviderMemory_getArena).call(this, arena);
        return (Object.keys(storeArena));
    }
    async incr(arena, key, change) {
        const storeArena = __classPrivateFieldGet(this, _KVStorageProviderMemory_instances, "m", _KVStorageProviderMemory_getArena).call(this, arena);
        const previous = storeArena[key];
        let previousValue = previous?.value ?? 0;
        if (typeof previousValue !== 'number') {
            throw (new Error('May not increment non-number'));
        }
        let newExpiry;
        if (previous?.expiry !== undefined) {
            if (previous.expiry < Date.now()) {
                previousValue = 0;
            }
            else {
                newExpiry = previous.expiry;
            }
        }
        const newVal = previousValue + change;
        storeArena[key] = { value: newVal, expiry: newExpiry };
        return (BigInt(newVal));
    }
    async xor(arena, key, change) {
        await super.xor(arena, key, change);
        const storeArena = __classPrivateFieldGet(this, _KVStorageProviderMemory_instances, "m", _KVStorageProviderMemory_getArena).call(this, nullArena);
        const previous = storeArena[key];
        const value = previous?.value;
        if (value === undefined) {
            storeArena[key] = { value: change };
            return;
        }
        if (!buffer_1.BufferStorage.isInstance(value) || previous.expiry !== undefined) {
            throw (new Error('May only use XOR on keys containing BufferStorage without expiry'));
        }
        const valueBigInt = value.toBigInt();
        const changeBigInt = change.toBigInt();
        const valueLength = Math.max(value.length, change.length);
        const newValue = valueBigInt ^ changeBigInt;
        storeArena[key] = { value: new buffer_1.BufferStorage(newValue, valueLength) };
    }
}
exports.KVStorageProviderMemory = KVStorageProviderMemory;
_KVStorageProviderMemory_db = new WeakMap(), _KVStorageProviderMemory_instances = new WeakSet(), _KVStorageProviderMemory_getArena = function _KVStorageProviderMemory_getArena(arena) {
    if (__classPrivateFieldGet(this, _KVStorageProviderMemory_db, "f")[arena] === undefined) {
        __classPrivateFieldGet(this, _KVStorageProviderMemory_db, "f")[arena] = {};
    }
    return (__classPrivateFieldGet(this, _KVStorageProviderMemory_db, "f")[arena]);
};
exports["default"] = KVStorageProviderMemory;


/***/ }),

/***/ 5834:
/***/ (function(__unused_webpack_module, exports) {

"use strict";

var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _LedgerRequestCache_votesUIDMap, _LedgerRequestCache_votesContentsMap;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LedgerRequestCache = void 0;
class LedgerRequestCache {
    constructor() {
        _LedgerRequestCache_votesUIDMap.set(this, new Map());
        _LedgerRequestCache_votesContentsMap.set(this, new Map());
    }
    addVote(vote, contents) {
        const key = contents ?? vote?.toBytes();
        if (!key) {
            throw (new Error('Vote or Contents are required to cache vote'));
        }
        if (vote) {
            __classPrivateFieldGet(this, _LedgerRequestCache_votesUIDMap, "f").set(vote.$id, vote);
        }
        __classPrivateFieldGet(this, _LedgerRequestCache_votesContentsMap, "f").set(Buffer.from(key).toString('base64'), vote);
        return (vote);
    }
    addVotes(votes) {
        for (const vote of votes) {
            this.addVote(vote);
        }
        return (votes);
    }
    getVote(contents, lookupVote) {
        const cacheCheck = this.getVoteByContents(contents);
        if (cacheCheck !== null) {
            return (cacheCheck);
        }
        if (lookupVote === undefined) {
            return (null);
        }
        const retval = lookupVote();
        this.addVote(retval, contents);
        return (retval);
    }
    getVoteByUID(uid) {
        return (__classPrivateFieldGet(this, _LedgerRequestCache_votesUIDMap, "f").get(uid) ?? null);
    }
    getVoteByContents(contents) {
        return (__classPrivateFieldGet(this, _LedgerRequestCache_votesContentsMap, "f").get(Buffer.from(contents).toString('base64')) ?? null);
    }
}
exports.LedgerRequestCache = LedgerRequestCache;
_LedgerRequestCache_votesUIDMap = new WeakMap(), _LedgerRequestCache_votesContentsMap = new WeakMap();
exports["default"] = LedgerRequestCache;


/***/ }),

/***/ 5663:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var _LedgerStorageBase_instances, _LedgerStorageBase_log;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LedgerStorageBase = void 0;
exports.findPermissionMatch = findPermissionMatch;
exports.validateSupply = validateSupply;
exports.validateBlockSignerCount = validateBlockSignerCount;
exports.validateBlockSignerDepth = validateBlockSignerDepth;
exports.computeLedgerEffect = computeLedgerEffect;
exports.addTimeStatistic = addTimeStatistic;
exports.assertLedgerStorage = assertLedgerStorage;
const account_1 = __importStar(__webpack_require__(9415));
const block_1 = __webpack_require__(6158);
const permissions_1 = __webpack_require__(5860);
const ledger_1 = __webpack_require__(452);
const helper_1 = __webpack_require__(3208);
const config_1 = __webpack_require__(1491);
const block_2 = __importDefault(__webpack_require__(7412));
function findPermissionMatch(lookingFor, entries) {
    const { principal, entity, target } = lookingFor;
    let foundRow;
    for (const entry of entries) {
        if (!principal.comparePublicKey(entry.principal)) {
            continue;
        }
        // We only care about permissions that have the same entity
        if (!entity.comparePublicKey(entry.entity)) {
            continue;
        }
        // We should return entries that match exactly
        if (entry.target.comparePublicKey(target)) {
            return (entry);
        }
        // If the user has access on the entire account
        // We can default to this if they do not have anything on the specific target
        if (entry.target.comparePublicKey(entity)) {
            foundRow = entry;
        }
    }
    return (foundRow);
}
function validateSupply(amount, network) {
    const { maxValue } = (0, config_1.getValidation)(network).accountInfoFieldRules['supply'];
    if (amount > maxValue) {
        throw (new block_2.default('BLOCK_SUPPLY_INVALID', `supply does not fit proper format -- GOT: '${amount}' MaxValue: ${maxValue}`));
    }
}
function validateBlockSignerCount(amount, network) {
    const { maxValue } = (0, config_1.getValidation)(network).accountInfoFieldRules['blockSignerCount'];
    if (amount > maxValue || amount < 1n) {
        throw (new block_2.default('BLOCK_INVALID_MULTISIG_SIGNER_COUNT', `signer count does not fit proper format -- GOT: '${amount}' MaxValue: ${maxValue}`));
    }
}
function validateBlockSignerDepth(depth, network) {
    const { maxValue } = (0, config_1.getValidation)(network).accountInfoFieldRules['blockSignerDepth'];
    if (depth > maxValue) {
        throw (new block_2.default('BLOCK_INVALID_MULTISIG_SIGNER_DEPTH', `signer depth does not fit proper format -- GOT: '${depth}' MaxValue: ${maxValue}`));
    }
}
/**
 * Compute effects on the ledger from block effects
 */
async function computeLedgerEffect(options, effects, storageProvider, network, transaction) {
    const { getFinalNumericValues = false, computePermissions = false, computeWeights = false, checkRangeConstraints = false, baseToken } = options;
    const getBalancePromises = {};
    const getPreviousBalance = async (account, token) => {
        const accountPubKey = account_1.default.toPublicKeyString(account);
        const tokenPubKey = account_1.default.toPublicKeyString(token);
        if (!getBalancePromises[accountPubKey]) {
            getBalancePromises[accountPubKey] = {};
        }
        if (getBalancePromises[accountPubKey][tokenPubKey] === undefined) {
            getBalancePromises[accountPubKey][tokenPubKey] = storageProvider.getBalance(transaction, account, token);
        }
        return (await getBalancePromises[accountPubKey][tokenPubKey]);
    };
    const getWeightPromises = {};
    const getWeight = async (rep) => {
        const repPubKey = account_1.default.toPublicKeyString(rep);
        if (getWeightPromises[repPubKey] === undefined) {
            getWeightPromises[repPubKey] = storageProvider.delegatedWeight(transaction, rep);
        }
        return (await getWeightPromises[repPubKey]);
    };
    const getRepPromises = {};
    const getRep = async (account, readWeight) => {
        const accountPubKey = account_1.default.toPublicKeyString(account);
        if (getRepPromises[accountPubKey] === undefined) {
            getRepPromises[accountPubKey] = storageProvider.getAccountRep(transaction, account);
        }
        const resolvedRep = await getRepPromises[accountPubKey];
        if (resolvedRep && readWeight) {
            await getWeight(resolvedRep);
        }
        return (resolvedRep);
    };
    const getAccountInfoPromises = {};
    const getAccountInfo = async (account) => {
        const accountPubKey = account_1.default.toPublicKeyString(account);
        if (getAccountInfoPromises[accountPubKey] === undefined) {
            getAccountInfoPromises[accountPubKey] = storageProvider.getAccountInfo(transaction, account);
        }
        return (await getAccountInfoPromises[accountPubKey]);
    };
    const getPermissionPromises = {};
    const getPermissions = async (account, entityList) => {
        const accountPubKey = account.publicKeyString.get();
        if (!entityList) {
            return (await getPermissionPromises[accountPubKey]);
        }
        if (getPermissionPromises[accountPubKey] !== undefined) {
            throw (new Error('getPermissions() can only be called once per account'));
        }
        getPermissionPromises[accountPubKey] = storageProvider.listACLsByPrincipal(transaction, account, entityList);
        return (await getPermissionPromises[accountPubKey]);
    };
    const prefetchPromises = [];
    for (const { account, fields } of Object.values(effects)) {
        // Always fetch the supply from accountInfo if it's changing so we can validate the effect
        if ((fields.supply ?? []).length > 0 && (checkRangeConstraints || getFinalNumericValues)) {
            prefetchPromises.push(getAccountInfo(account));
        }
        const accountPubKey = account.publicKeyString.get();
        if (computePermissions && fields.permissions) {
            const toReadEntity = new account_1.default.Set();
            for (const permUpdate of fields.permissions ?? []) {
                if (permUpdate.method === block_1.Block.AdjustMethod.SET || permUpdate.permissions === null) {
                    toReadEntity.delete(permUpdate.entity);
                    continue;
                }
                toReadEntity.add(permUpdate.entity);
            }
            prefetchPromises.push(getPermissions(account, toReadEntity.toArray()));
        }
        const delegationField = effects[accountPubKey]?.fields.delegation;
        const isDelegating = delegationField !== undefined;
        let requestedRep = false;
        if (isDelegating && computeWeights && getFinalNumericValues && account.isAccount()) {
            requestedRep = true;
            prefetchPromises.push(getRep(account, getFinalNumericValues));
            prefetchPromises.push(getWeight(delegationField.delegateTo));
        }
        const rollingChanges = {};
        for (const tokenPubKey in fields.balance ?? {}) {
            for (const balanceUpdate of (fields.balance ?? {})[tokenPubKey]) {
                if (balanceUpdate.isReceive) {
                    continue;
                }
                const { set, value } = balanceUpdate;
                const token = account_1.default.fromPublicKeyString(tokenPubKey).assertKeyType(account_1.AccountKeyAlgorithm.TOKEN);
                if (rollingChanges[tokenPubKey] === undefined) {
                    rollingChanges[tokenPubKey] = 0n;
                }
                if (set) {
                    prefetchPromises.push(getPreviousBalance(token, token));
                    rollingChanges[tokenPubKey] = value;
                }
                else {
                    rollingChanges[tokenPubKey] += value;
                }
                const isBaseToken = baseToken.comparePublicKey(tokenPubKey);
                const possibleNegative = rollingChanges[tokenPubKey] < 0n && checkRangeConstraints;
                if ((possibleNegative && checkRangeConstraints) || set || getFinalNumericValues || (isDelegating && computeWeights)) {
                    prefetchPromises.push(getPreviousBalance(account, token));
                }
                if (computeWeights && isBaseToken && account.isAccount() && !requestedRep) {
                    requestedRep = true;
                    prefetchPromises.push(getRep(account, getFinalNumericValues));
                }
            }
        }
        if (prefetchPromises.length > 70) {
            const toAwait = prefetchPromises.splice(0);
            await Promise.all(toAwait);
        }
    }
    await Promise.all(prefetchPromises);
    const supplies = {};
    const balances = {};
    const weights = {};
    const permissions = [];
    const getBalanceEntry = (account, token) => {
        const accountPubKey = account.publicKeyString.get();
        const tokenPubKey = token.publicKeyString.get();
        if (!balances[accountPubKey]) {
            balances[accountPubKey] = {};
        }
        let entry = balances[accountPubKey][tokenPubKey];
        if (!entry) {
            entry = balances[accountPubKey][tokenPubKey] = { change: 0n, lowestChange: 0n };
        }
        return (entry);
    };
    const modifyBalance = async (account, token, value, isSet) => {
        const accountPubKey = account.publicKeyString.get();
        const tokenPubKey = token.publicKeyString.get();
        const newEntry = getBalanceEntry(account, token);
        if (newEntry.starting === undefined) {
            if (getBalancePromises[accountPubKey] && getBalancePromises[accountPubKey][tokenPubKey] !== undefined) {
                const previous = await getPreviousBalance(account, token);
                newEntry.starting = previous;
                newEntry.final = previous;
            }
        }
        let newChange = value;
        if (isSet) {
            newEntry.starting = await getPreviousBalance(account, token);
            newChange = value - newEntry.starting;
            newEntry.final = value;
        }
        else {
            if (newEntry.final !== undefined) {
                newEntry.final += value;
            }
        }
        newEntry.change += newChange;
        if (newEntry.change < newEntry.lowestChange) {
            newEntry.lowestChange = newEntry.change;
        }
        if (newEntry.lowestChange < 0n && checkRangeConstraints) {
            if (newEntry.starting === undefined) {
                throw (new Error('Starting balance should not be undefined here'));
            }
        }
        if (newEntry.final && newEntry.final < 0n) {
            newEntry.fellNegative = true;
        }
        balances[accountPubKey][tokenPubKey] = newEntry;
        return (newChange);
    };
    const modifyWeight = async (rep, change) => {
        const repPubKey = rep.publicKeyString.get();
        let newEntry = weights[repPubKey];
        if (newEntry === undefined) {
            newEntry = { change: 0n };
            if (getFinalNumericValues) {
                newEntry.final = await getWeight(rep);
            }
        }
        if (newEntry.final !== undefined) {
            newEntry.final += change;
        }
        newEntry.change += change;
        weights[repPubKey] = newEntry;
    };
    const modifySupply = async (token, change) => {
        const tokenPubKey = token.publicKeyString.get();
        let newEntry = supplies[tokenPubKey];
        if (newEntry === undefined) {
            newEntry = { change: 0n };
            if (checkRangeConstraints || getFinalNumericValues) {
                const { supply } = await getAccountInfo(token);
                newEntry.final = supply;
            }
        }
        if (newEntry.final !== undefined) {
            newEntry.final += change;
            validateSupply(newEntry.final, network);
        }
        newEntry.change += change;
        supplies[tokenPubKey] = newEntry;
    };
    for (const { account, fields } of Object.values(effects)) {
        const accountPubKey = account.publicKeyString.get();
        for (const supplyChange of fields.supply ?? []) {
            if (!account.isToken()) {
                throw (new Error('Cannot modify supply of non-token account'));
            }
            await modifySupply(account, supplyChange.value);
        }
        let permissionUpdates = [];
        if (computePermissions && fields.permissions) {
            permissionUpdates = fields.permissions;
        }
        for (const permUpdate of permissionUpdates) {
            if (!permUpdate.principal.comparePublicKey(account)) {
                throw (new Error('permUpdate.principal should not differ current account'));
            }
            if (permUpdate.method === block_1.Block.AdjustMethod.SET || permUpdate.permissions === null) {
                permissions.push(permUpdate);
                continue;
            }
            let newPermissions;
            const previousEntry = findPermissionMatch(permUpdate, await getPermissions(account));
            const previousPermissions = previousEntry?.permissions ?? new permissions_1.Permissions();
            switch (permUpdate.method) {
                case block_1.Block.AdjustMethod.ADD:
                    newPermissions = previousPermissions.combine(permUpdate.permissions);
                    break;
                case block_1.Block.AdjustMethod.SUBTRACT:
                    newPermissions = previousPermissions.remove(permUpdate.permissions);
                    break;
            }
            permissions.push({
                ...permUpdate,
                method: block_1.Block.AdjustMethod.SET,
                permissions: newPermissions
            });
        }
        const delegationField = effects[accountPubKey]?.fields.delegation;
        const isDelegating = delegationField !== undefined;
        if (isDelegating && account.isAccount() && computeWeights) {
            const currentDelegation = await getRep(account, getFinalNumericValues);
            const previousBalance = await getPreviousBalance(account, baseToken);
            await modifyWeight(delegationField.delegateTo, previousBalance);
            if (currentDelegation) {
                await modifyWeight(currentDelegation, -1n * previousBalance);
            }
        }
        const receivable = {};
        for (const tokenPubKey in fields.balance ?? {}) {
            const tokenAcct = account_1.default.fromPublicKeyString(tokenPubKey).assertKeyType(account_1.AccountKeyAlgorithm.TOKEN);
            for (const balanceUpdate of (fields.balance ?? {})[tokenPubKey]) {
                const { isReceive, value, otherAccount } = balanceUpdate;
                if (isReceive) {
                    const receiveFromPubKey = otherAccount.publicKeyString.get();
                    const previousEntry = getBalanceEntry(account, tokenAcct);
                    if (previousEntry.receiveValidated === false) {
                        continue;
                    }
                    let receivableAmount;
                    if (receivable[receiveFromPubKey]) {
                        receivableAmount = receivable[receiveFromPubKey][tokenPubKey];
                    }
                    if (!receivableAmount) {
                        receivableAmount = 0n;
                    }
                    let receiveValid = false;
                    if (balanceUpdate.exact) {
                        receiveValid = value === receivableAmount;
                    }
                    else {
                        receiveValid = value <= receivableAmount;
                    }
                    balances[accountPubKey][tokenPubKey].receiveValidated = receiveValid;
                    continue;
                }
                let balanceChange;
                if (balanceUpdate.set) {
                    balanceChange = await modifyBalance(account, tokenAcct, value, true);
                    await modifyBalance(tokenAcct, tokenAcct, -1n * balanceChange, false);
                }
                else {
                    balanceChange = await modifyBalance(account, tokenAcct, value, false);
                }
                if (balanceUpdate.receivable) {
                    const otherAccountPubKey = otherAccount.publicKeyString.get();
                    // Make sure this is an object and not undefined
                    receivable[otherAccountPubKey] = { ...receivable[otherAccountPubKey] };
                    if (!receivable[otherAccountPubKey][tokenPubKey]) {
                        receivable[otherAccountPubKey][tokenPubKey] = 0n;
                    }
                    receivable[otherAccountPubKey][tokenPubKey] += balanceChange;
                }
                const isBaseToken = baseToken.comparePublicKey(tokenAcct);
                if (isBaseToken && account.isAccount() && computeWeights) {
                    if (isDelegating) {
                        await modifyWeight(delegationField.delegateTo, balanceChange);
                    }
                    else {
                        const currentRep = await getRep(account);
                        if (currentRep) {
                            await modifyWeight(currentRep, balanceChange);
                        }
                    }
                }
            }
        }
    }
    const ret = { balances, supplies };
    // We only return weights if computeWeights is set to true
    if (computeWeights) {
        ret.weights = weights;
    }
    // We only return permissions if computePermissions is set to true
    if (computePermissions) {
        ret.permissions = permissions;
    }
    // We know this type is correct because we only set those values if they are defined
    // eslint-disable-next-line @typescript-eslint/consistent-type-assertions
    return ret;
}
/**
 * Common method for adding a timing data point during processing of a
 * Vote Staple to a Node Stats
 *
 * @param node - A running node
 * @param blocks - Blocks being processed
 * @param to - Ledger being processed
 * @param storageProvider - storage provider that includes getVotes function
 * @param transaction - Current transaction (if any)
 * @param skipPush - Instead of adding to stats immediately, just return what would be added
 * @returns What was added (or would be added, if skipPush is set to true)
 */
async function addTimeStatistic(node, blocks, to, storageProvider, transaction, skipPush = false) {
    const increases = [];
    if (node === undefined) {
        return (increases);
    }
    if (to !== 'main') {
        return (increases);
    }
    const ourPublicKey = node.config.ledgerPrivateKey;
    if (ourPublicKey === undefined) {
        return (increases);
    }
    const ourPublicKeyString = ourPublicKey.publicKeyString.get();
    const now = Date.now();
    const votePromises = blocks.map(function (block) {
        return (storageProvider.getVotes(transaction, block.hash, 'side'));
    });
    const resolvedVotes = await Promise.all(votePromises);
    const ourTemporaryVotes = [];
    for (const checkVotes of resolvedVotes) {
        if (!checkVotes) {
            continue;
        }
        for (const toCheckVote of checkVotes) {
            if (toCheckVote.$permanent) {
                continue;
            }
            if (!toCheckVote.issuer.comparePublicKey(ourPublicKeyString)) {
                continue;
            }
            ourTemporaryVotes.push(toCheckVote);
            const blockVoteTime = toCheckVote.validityFrom.valueOf();
            const settlementTime = now - blockVoteTime;
            const addTimeResp = node.stats.addTimingPoint('ledger', 'settlementTime', settlementTime, skipPush);
            increases.push(addTimeResp);
            break;
        }
    }
    return (increases);
}
class LedgerStorageBase {
    constructor() {
        _LedgerStorageBase_instances.add(this);
        this.config = null;
    }
    async getBlockHeights(transaction, toFetch) {
        const response = await Promise.all(toFetch.map(async ({ blockHash, account }) => {
            return ([
                blockHash.toString(),
                await this.getBlockHeight(transaction, blockHash, account)
            ]);
        }));
        return (Object.fromEntries(response));
    }
    async getAccountsBlockHeightInfo(transaction, toFetch) {
        const response = await Promise.all(toFetch.map(async ({ blockHash, account }) => {
            if (blockHash === undefined) {
                const block = await this.getHeadBlock(transaction, account, 'main');
                if (block !== null) {
                    blockHash = block.hash;
                }
            }
            const retval = [];
            if (blockHash === undefined) {
                retval.push(...[account.publicKeyString.get(), null]);
            }
            else {
                const height = await this.getBlockHeight(transaction, blockHash, account);
                retval.push(...[account.publicKeyString.get(), { blockHash, height }]);
            }
            return (retval);
        }));
        return (Object.fromEntries(response));
    }
    async getHeadBlockHashes(transaction, accounts) {
        const received = await this.getHeadBlocks(transaction, accounts.toArray(), 'both');
        return (Object.fromEntries(Object.entries(received).map(function ([account, value]) {
            if (value) {
                return ([account, value.hash]);
            }
            else {
                return ([account, null]);
            }
        })));
    }
    async preAdjust(input, mayDefer = true, transaction) {
        const allBlockHeightsToFetch = input.blocks.map(block => {
            return ({ blockHash: block.hash, account: block.account });
        });
        const allBlockHeights = await this.getBlockHeights(transaction, allBlockHeightsToFetch);
        // Check if any blocks already exist on the ledger that would cause this staple to fail and exit early
        for (const [blockHash, blockHeight] of Object.entries(allBlockHeights)) {
            if (blockHeight !== null) {
                throw (new ledger_1.KeetaNetLedgerError('LEDGER_BLOCK_ALREADY_EXISTS', `Block Already Exists: ${blockHash.toString()}`));
            }
        }
        const seenBlockHashes = new block_1.BlockHash.Set();
        const blockHeights = {};
        const toFetch = [];
        for (const block of input.blocks) {
            if (seenBlockHashes.has(block.previous)) {
                continue;
            }
            seenBlockHashes.add(block.hash);
            if (block.$opening) {
                blockHeights[block.hash.toString()] = 0n;
            }
            else {
                toFetch.push({ blockHash: block.previous, account: block.account });
            }
        }
        const fetchedBlockHeights = await this.getBlockHeights(transaction, toFetch);
        let mustDefer = false;
        for (const block of input.blocks) {
            const blockHash = block.hash.toString();
            if (blockHeights[blockHash] !== undefined) {
                continue;
            }
            const prevHash = block.previous.toString();
            const prev = blockHeights[prevHash] ?? fetchedBlockHeights[prevHash];
            if (typeof prev === 'bigint') {
                blockHeights[blockHash] = prev + 1n;
                continue;
            }
            mustDefer = true;
            __classPrivateFieldGet(this, _LedgerStorageBase_instances, "m", _LedgerStorageBase_log).call(this, `Asked to insert block (${blockHash}) but previous (${prevHash}) does not exist on chain, must defer`);
            break;
        }
        if (mustDefer) {
            if (!mayDefer) {
                __classPrivateFieldGet(this, _LedgerStorageBase_instances, "m", _LedgerStorageBase_log).call(this, 'We must defer this block but it is already deferred, returning');
                return ({});
            }
            await this.adjustDefer(transaction, input);
            return ({});
        }
        // We can disable this because it would have already deferred if any of the blocks had an undefined height
        // eslint-disable-next-line @typescript-eslint/consistent-type-assertions
        return blockHeights;
    }
    _formatAccountInfoFromRow(account, row = {}) {
        const ret = {
            name: row.name ?? '',
            description: row.description ?? '',
            metadata: row.metadata ?? ''
        };
        if (account.isIdentifier()) {
            let baseSet = row.defaultBasePermission ?? 0;
            if (!permissions_1.Permissions.BaseSet.isInstance(baseSet)) {
                baseSet = BigInt(baseSet);
            }
            let externalSet = row.defaultExternalPermission ?? 0;
            if (!permissions_1.Permissions.ExternalSet.isInstance(externalSet)) {
                externalSet = BigInt(externalSet);
            }
            ret.defaultPermission = new permissions_1.Permissions(baseSet, externalSet);
        }
        if (account.isToken()) {
            ret.supply = BigInt(row.supply ?? 0);
        }
        if (account.isMultisig() && row.multisigQuorum !== undefined) {
            ret.multisigQuorum = BigInt(row.multisigQuorum);
        }
        return (ret);
    }
    _validateAccountInfoKeys(account, info) {
        const validKeys = ['name', 'description', 'metadata'];
        if (account.isIdentifier()) {
            validKeys.push('defaultPermission');
            if (account.isToken()) {
                validKeys.push('supply');
            }
            if (account.isMultisig()) {
                validKeys.push('multisigQuorum');
            }
        }
        const keys = Object.keys(info);
        const foundBannedKey = keys.find(function (key) {
            return (validKeys.includes(key) === false);
        });
        if (foundBannedKey !== undefined) {
            throw (new ledger_1.KeetaNetLedgerError('LEDGER_INVALID_ACCOUNT_INFO_KEY', `Invalid AccountInfo field ${foundBannedKey}`));
        }
    }
    /**
     * @param moment - The date to use as the base for the timestamp.
     * @param momentBits - The number of bits to use for the timestamp
     * @param totalLength - The total length of the generated number in bits
     * @param randomData - A hexadecimal string to use as the random data.
     * @param timestampFuzzMS - The number of milliseconds to fuzz the timestamp by, defaults to 1n (precise).
     * @param optimistic - If true, the timestamp will be incremented by 1 quanta, defaults to false.
     * @returns A bigint representing the noisy timestamp.
     */
    _generateNoisyTimestamp(moment, momentBits, totalLength, randomData, timestampFuzzMS = 1, optimistic = false) {
        if (timestampFuzzMS > Number.MAX_SAFE_INTEGER) {
            throw (new Error('timestampFuzzMs is too large'));
        }
        const timestampFuzz = BigInt(Math.ceil(Math.log2(Number(timestampFuzzMS))));
        const length = totalLength - momentBits;
        if (BigInt(randomData.length * 8) < (length + timestampFuzz)) {
            throw (new Error('randomData is too short for the specified bit length'));
        }
        if (length < 0n) {
            throw (new Error('momentBits should be less than totalLength'));
        }
        const timestamp = BigInt(moment.valueOf()) >> timestampFuzz;
        const mask = (1n << (length + timestampFuzz)) - 1n;
        const upperBits = (timestamp + (optimistic ? 1n : 0n)) << (length + timestampFuzz);
        const lowerBits = (0, helper_1.bufferToBigInt)(randomData) & mask;
        return (upperBits | lowerBits);
    }
    async getHeadBlock(transaction, account, from) {
        const response = await this.getHeadBlocks(transaction, [account], from);
        const pubKey = account.publicKeyString.get();
        if (response[pubKey] !== undefined) {
            return (response[pubKey]);
        }
        return (null);
    }
    async getVotesFromPrevious(transaction, prevBlock, from, issuer) {
        const response = await this.getVotesFromMultiplePrevious(transaction, [prevBlock], from, issuer);
        const hashString = prevBlock.toString();
        if (response[hashString] !== undefined) {
            return (response[hashString]);
        }
        return (null);
    }
    async gc(transaction, timeLimitMS = 280000) {
        let lastGCResult = false;
        for (const startTime = Date.now(); Date.now() - startTime < timeLimitMS;) {
            const gcResult = await this.gcBatch(transaction);
            lastGCResult = gcResult;
            if (!gcResult) {
                return (false);
            }
        }
        return (lastGCResult);
    }
}
exports.LedgerStorageBase = LedgerStorageBase;
_LedgerStorageBase_instances = new WeakSet(), _LedgerStorageBase_log = function _LedgerStorageBase_log(...args) {
    if (this.config !== null) {
        if (this.config.log !== undefined) {
            this.config.log(...args);
        }
    }
};
function assertLedgerStorage(value) {
    if (value === 'main' || value === 'side') {
        return (value);
    }
    throw (new Error(`Received invalid ledger storage: "${value}"`));
}


/***/ }),

/***/ 7346:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.computeEffectOfBlocks = computeEffectOfBlocks;
const account_1 = __importStar(__webpack_require__(9415));
const block_1 = __webpack_require__(6158);
const operations_1 = __webpack_require__(2778);
const permissions_1 = __webpack_require__(5860);
const certificate_1 = __webpack_require__(5661);
;
/**
 * Base Fee Units per Block
 */
const baseBlockFeeUnit = 1000n;
/**
 * Fee Unit for an Opening Block
 */
const openingBlockFeeUnit = 10000n;
/**
 * Operation specific Fee Units
 */
const operationFeeUnitOverrides = {
    [operations_1.OperationType.SEND]: 10n,
    [operations_1.OperationType.SET_REP]: 20n,
    [operations_1.OperationType.SET_INFO]: 100n,
    [operations_1.OperationType.MODIFY_PERMISSIONS]: 20n,
    [operations_1.OperationType.CREATE_IDENTIFIER]: 200n,
    [operations_1.OperationType.TOKEN_ADMIN_SUPPLY]: 10n,
    [operations_1.OperationType.TOKEN_ADMIN_MODIFY_BALANCE]: 10n,
    [operations_1.OperationType.RECEIVE]: 10n,
    [operations_1.OperationType.MANAGE_CERTIFICATE]: 100n
};
/**
 * Get the Fee Unit for a given operation type
 */
function getOperationFeeUnit(operation) {
    return (operationFeeUnitOverrides[operation]);
}
function addOrCombineRequirements(existing, addition, alwaysCombine) {
    const resp = [...existing];
    let additionTarget;
    if (addition.target !== undefined) {
        additionTarget = addition.target.publicKeyString.get();
    }
    for (const existingInd in resp) {
        const existingPerm = resp[existingInd];
        let existingTarget;
        if (existingPerm.target !== undefined) {
            existingTarget = existingPerm.target.publicKeyString.get();
        }
        if (!existingPerm.entity.comparePublicKey(addition.entity)) {
            continue;
        }
        if (existingTarget !== additionTarget) {
            continue;
        }
        let additionMethod = addition.method;
        if (alwaysCombine) {
            additionMethod = block_1.Block.AdjustMethod.ADD;
        }
        let newPermissions;
        const existingPermissions = resp[existingInd].permissions ?? new permissions_1.Permissions();
        if (addition.permissions === null) {
            newPermissions = null;
        }
        else {
            switch (additionMethod) {
                case block_1.Block.AdjustMethod.SUBTRACT:
                    if (resp[existingInd].method === block_1.Block.AdjustMethod.SUBTRACT) {
                        newPermissions = existingPermissions.combine(addition.permissions);
                    }
                    else {
                        newPermissions = existingPermissions.remove(addition.permissions);
                    }
                    break;
                case block_1.Block.AdjustMethod.SET:
                    newPermissions = addition.permissions;
                    break;
                case block_1.Block.AdjustMethod.ADD:
                case undefined:
                    newPermissions = existingPermissions.combine(addition.permissions);
                    break;
            }
        }
        resp[existingInd].permissions = newPermissions;
        return (resp);
    }
    resp.push(addition);
    return (resp);
}
function addPermission(state, addition) {
    const principalPubKey = addition.principal.publicKeyString.get();
    if (state.accounts[principalPubKey] === undefined) {
        state.accounts[principalPubKey] = {
            fields: {},
            account: account_1.default.fromPublicKeyString(principalPubKey)
        };
    }
    if (state.accounts[principalPubKey].fields === undefined) {
        state.accounts[principalPubKey].fields = {};
    }
    if (state.accounts[principalPubKey].fields.permissions === undefined) {
        state.accounts[principalPubKey].fields.permissions = [];
    }
    const existing = state.accounts[principalPubKey].fields.permissions || [];
    state.accounts[principalPubKey].fields.permissions = addOrCombineRequirements(existing, addition);
}
function addPermissionRequirement(state, requirement) {
    const principalPubKey = requirement.principal.publicKeyString.get();
    const entityPubKey = requirement.entity.publicKeyString.get();
    if (state.accounts[principalPubKey] === undefined) {
        state.accounts[principalPubKey] = {
            account: requirement.principal,
            fields: {}
        };
    }
    const alreadyAdded = state.accounts[principalPubKey].fields.permissions ?? [];
    const foundAddedMatch = alreadyAdded.find(function ({ permissions }) {
        if (requirement.permissions === null) {
            return (true);
        }
        return (permissions !== null && permissions.has(requirement.permissions));
    });
    if (foundAddedMatch !== undefined) {
        return;
    }
    if (state.accounts[entityPubKey] !== undefined) {
        const entityInfo = state.accounts[entityPubKey].fields.info;
        if (entityInfo !== undefined) {
            const defaultPermission = entityInfo.defaultPermission;
            if (defaultPermission !== undefined) {
                if (requirement.permissions === null || defaultPermission.has(requirement.permissions)) {
                    return;
                }
            }
        }
    }
    const existing = state.accounts[principalPubKey].fields.permissionRequirements ?? [];
    state.accounts[principalPubKey].fields.permissionRequirements = addOrCombineRequirements(existing, requirement, true);
}
function updateMinSignerSetLength(state, multisigAccount, count) {
    const multisigPublicKey = multisigAccount.publicKeyString.get();
    if (state.accounts[multisigPublicKey] === undefined) {
        state.accounts[multisigPublicKey] = {
            account: multisigAccount,
            fields: {}
        };
    }
    const current = state.accounts[multisigPublicKey].fields.minSignerSetLength;
    if (current === undefined || current > count) {
        state.accounts[multisigPublicKey].fields.minSignerSetLength = count;
    }
}
function modifyBalanceInState(balanceState) {
    const { state, account, token, method, amount, otherAccount } = balanceState;
    const accountPubKey = account.publicKeyString.get();
    const tokenPubKey = token.publicKeyString.get();
    if (state.accounts[accountPubKey] === undefined) {
        state.accounts[accountPubKey] = {
            account: account_1.default.fromPublicKeyString(accountPubKey),
            fields: {}
        };
    }
    /**
     * Effect of balance change
     */
    let accountBalanceInfo = state.accounts[accountPubKey].fields.balance;
    if (accountBalanceInfo === undefined) {
        /**
         * Account balance info initialized to point to the same empty
         * object so that we may mutate it below
         */
        accountBalanceInfo = state.accounts[accountPubKey].fields.balance = {};
    }
    const tokenField = accountBalanceInfo[tokenPubKey] ?? [];
    if (method === 'RECEIVE') {
        if (typeof balanceState.exact !== 'boolean') {
            throw (new Error('Exact must be specified for RECEIVE operation'));
        }
        tokenField.push({
            isReceive: true,
            value: amount,
            otherAccount: otherAccount,
            exact: balanceState.exact
        });
    }
    else {
        tokenField.push({
            isReceive: false,
            value: amount,
            set: method === 'SET',
            otherAccount: otherAccount,
            receivable: balanceState.receivable
        });
    }
    accountBalanceInfo[tokenPubKey] = tokenField;
}
function updateAccountInfoInState(state, account, info) {
    const accountPubKey = account.publicKeyString.get();
    const toUpdate = {
        name: info.name,
        description: info.description,
        metadata: info.metadata
    };
    if (account.isIdentifier()) {
        if (info.defaultPermission !== undefined) {
            toUpdate.defaultPermission = info.defaultPermission;
        }
        if (account.isMultisig() && info.multisigQuorum !== undefined) {
            toUpdate.multisigQuorum = info.multisigQuorum;
        }
    }
    else {
        state.possibleNewAccounts.add(account);
    }
    if (!state.accounts[accountPubKey]) {
        state.accounts[accountPubKey] = {
            account: account,
            fields: {}
        };
    }
    state.accounts[accountPubKey].fields.info = toUpdate;
}
/**
 * Compute the effect of a SEND operation
 */
function computeEffectOfOperationSEND(state, block, operation) {
    // Decrement sender balance
    const senderChange = {
        state,
        account: block.account,
        token: operation.token,
        method: 'CHANGE',
        amount: 0n - operation.amount,
        otherAccount: operation.to,
        receivable: false
    };
    modifyBalanceInState(senderChange);
    // Increment recipient balance
    const recipientChange = {
        state,
        account: operation.to,
        token: operation.token,
        method: 'CHANGE',
        amount: operation.amount,
        otherAccount: block.account,
        receivable: true
    };
    modifyBalanceInState(recipientChange);
}
/**
 * Compute the effect of a RECEIVE operation
 */
function computeEffectOfOperationRECEIVE(state, block, operation) {
    // Increment recipient balance
    const recipientChange = {
        state,
        account: block.account,
        token: operation.token,
        method: 'RECEIVE',
        amount: operation.amount,
        otherAccount: operation.from,
        exact: operation.exact
    };
    modifyBalanceInState(recipientChange);
    if (operation.forward !== undefined) {
        const forwardAccountChange = {
            state,
            account: block.account,
            token: operation.token,
            method: 'CHANGE',
            amount: 0n - operation.amount,
            otherAccount: block.account,
            receivable: false
        };
        modifyBalanceInState(forwardAccountChange);
        const receiverChange = {
            state,
            account: operation.forward,
            token: operation.token,
            method: 'CHANGE',
            amount: operation.amount,
            otherAccount: block.account,
            receivable: true
        };
        modifyBalanceInState(receiverChange);
    }
}
function computeEffectOfOperationTOKEN_ADMIN_MODIFY_BALANCE(state, block, operation) {
    if (operation.method === block_1.Block.AdjustMethod.SET) {
        const setChange = {
            state,
            account: block.account,
            token: operation.token,
            method: 'SET',
            amount: operation.amount,
            otherAccount: operation.token,
            receivable: true
        };
        modifyBalanceInState(setChange);
        return;
    }
    let amount = 0n;
    switch (operation.method) {
        case block_1.Block.AdjustMethod.ADD:
            amount += operation.amount;
            break;
        case block_1.Block.AdjustMethod.SUBTRACT:
            amount -= operation.amount;
            break;
    }
    const accountChange = {
        state,
        account: block.account,
        token: operation.token,
        method: 'CHANGE',
        amount: amount,
        otherAccount: operation.token,
        receivable: true
    };
    modifyBalanceInState(accountChange);
    const tokenChange = {
        state,
        account: operation.token,
        token: operation.token,
        method: 'CHANGE',
        amount: 0n - amount,
        otherAccount: operation.token,
        receivable: false
    };
    modifyBalanceInState(tokenChange);
}
/**
 * Compute the effect of a SET_REP operation
 */
function computeEffectOfOperationSET_REP(state, block, operation) {
    const accountPubKey = block.account.publicKeyString.get();
    state.accounts[accountPubKey].fields.delegation = { delegateTo: operation.to };
    state.possibleNewAccounts.add(operation.to);
}
/**
 * Compute the effect of a CREATE_IDENTIFIER operation
 */
function computeEffectOfOperationCREATE_IDENTIFIER(state, block, operation, context) {
    const accountPubKey = block.account.publicKeyString.get();
    if (state.accounts[accountPubKey].fields.createRequests === undefined) {
        state.accounts[accountPubKey].fields.createRequests = [];
    }
    state.possibleNewAccounts.add(operation.identifier);
    state.accounts[accountPubKey].fields.createRequests?.push({
        createdIdentifier: operation.identifier,
        createArguments: operation.createArguments
    });
    if (operation.identifier.isMultisig()) {
        if (!operation.createArguments || operation.createArguments.type !== account_1.AccountKeyAlgorithm.MULTISIG) {
            throw (new Error('Invalid identifier creation arguments'));
        }
        updateAccountInfoInState(state, operation.identifier, { multisigQuorum: operation.createArguments.quorum });
        for (const multisigSigner of operation.createArguments.signers) {
            state.possibleNewAccounts.add(multisigSigner);
            addPermission(state, {
                principal: multisigSigner,
                entity: operation.identifier,
                method: block_1.Block.AdjustMethod.SET,
                permissions: new permissions_1.Permissions(['MULTISIG_SIGNER'])
            });
        }
    }
    else {
        addPermission(state, {
            principal: block.account,
            entity: operation.identifier,
            method: block_1.Block.AdjustMethod.SET,
            permissions: new permissions_1.Permissions(['OWNER'])
        });
    }
}
function computeEffectOfOperationSET_INFO(state, block, operation) {
    updateAccountInfoInState(state, block.account, {
        name: operation.name,
        description: operation.description,
        metadata: operation.metadata,
        defaultPermission: operation.defaultPermission
    });
}
function computeEffectOfOperationMODIFY_PERMISSIONS(state, block, operation) {
    state.possibleNewAccounts.add(operation.principal);
    if (operation.target) {
        state.possibleNewAccounts.add(operation.target);
    }
    addPermission(state, {
        principal: operation.principal,
        entity: block.account,
        permissions: operation.permissions,
        method: operation.method,
        target: operation.target
    });
}
function computeEffectOfOperationTOKEN_ADMIN_SUPPLY(state, block, operation) {
    const tokenPubKey = block.account.publicKeyString.get();
    let value = 0n;
    switch (operation.method) {
        case block_1.Block.AdjustMethod.ADD:
            value += operation.amount;
            break;
        case block_1.Block.AdjustMethod.SUBTRACT:
            value -= operation.amount;
            break;
        default:
            throw (new Error('Invalid AdjustMethod for TOKEN_ADMIN_SUPPLY'));
    }
    const supplyField = state.accounts[tokenPubKey].fields.supply ?? [];
    supplyField.push({ value });
    state.accounts[tokenPubKey].fields.supply = supplyField;
    if (!block.account.isToken()) {
        throw (new Error('Internal error: TOKEN_ADMIN_SUPPLY called on non-token'));
    }
    const tokenSupplyChange = {
        state,
        account: block.account,
        token: block.account,
        method: 'CHANGE',
        amount: value,
        otherAccount: block.account,
        receivable: true
    };
    modifyBalanceInState(tokenSupplyChange);
}
function computeEffectOfOperationMANAGE_CERTIFICATE(state, block, operation, context) {
    const publicKeyString = block.account.publicKeyString.get();
    if (state.accounts[publicKeyString].fields.certificate === undefined) {
        state.accounts[publicKeyString].fields.certificate = [];
    }
    let operationCertificateHash;
    if (certificate_1.CertificateHash.isInstance(operation.certificateOrHash)) {
        operationCertificateHash = operation.certificateOrHash;
    }
    else {
        operationCertificateHash = operation.certificateOrHash.hash();
    }
    let certificateUpdate;
    if (operation.method === block_1.Block.AdjustMethod.SUBTRACT) {
        certificateUpdate = {
            method: operation.method,
            certificateHash: operationCertificateHash
        };
    }
    else if (operation.method === block_1.Block.AdjustMethod.ADD) {
        if (certificate_1.CertificateHash.isInstance(operation.certificateOrHash)) {
            throw (new Error('Certificate must be an instance of Certificate for ADD operation'));
        }
        certificateUpdate = {
            method: operation.method,
            certificateHash: operationCertificateHash,
            certificate: operation.certificateOrHash,
            intermediateCertificates: operation.intermediateCertificates ?? null
        };
    }
    else {
        throw (new Error('Invalid AdjustMethod for MANAGE_CERTIFICATE'));
    }
    const certificateField = state.accounts[publicKeyString].fields.certificate;
    for (let i = 0; i < certificateField.length; i++) {
        const existingOperation = certificateField[i];
        const certificateMatch = existingOperation.certificateHash.compareHexString(operationCertificateHash);
        if (!certificateMatch) {
            continue;
        }
        certificateField[i] = certificateUpdate;
        return;
    }
    certificateField.push(certificateUpdate);
}
const operationHandlers = {
    [block_1.Block.OperationType.SEND]: {
        effectGenerator: computeEffectOfOperationSEND,
        accountPermissionACL: (block, operation, context) => {
            const baseEffect = {
                entity: operation.token || context.ledger.baseToken
            };
            if (operation.to.keyType !== account_1.AccountKeyAlgorithm.STORAGE) {
                return (baseEffect);
            }
            return ([
                baseEffect,
                // Require that the token identifier was granted access by storage account for it to be able to hold
                {
                    entity: operation.to,
                    principal: operation.token,
                    permissions: new permissions_1.Permissions(['STORAGE_CAN_HOLD'])
                },
                // Require that account sending to storage account was granted access to send to it
                {
                    entity: operation.to,
                    principal: block.account,
                    permissions: new permissions_1.Permissions(['STORAGE_DEPOSIT']),
                    target: operation.token
                }
            ]);
        },
        signerPermissionACL: (block, operation) => {
            return ({
                target: operation.token,
                permissions: new permissions_1.Permissions(['SEND_ON_BEHALF'])
            });
        }
    },
    [block_1.Block.OperationType.RECEIVE]: {
        effectGenerator: computeEffectOfOperationRECEIVE,
        accountPermissionACL: (block, operation) => {
            return ({ entity: operation.token });
        },
        signerPermissionACL: (block, operation) => {
            return ({
                target: operation.token,
                permissions: new permissions_1.Permissions(['SEND_ON_BEHALF'])
            });
        }
    },
    [block_1.Block.OperationType.SET_REP]: {
        effectGenerator: computeEffectOfOperationSET_REP
    },
    [block_1.Block.OperationType.CREATE_IDENTIFIER]: {
        effectGenerator: computeEffectOfOperationCREATE_IDENTIFIER,
        accountPermissionACL: (block, operation, context) => {
            const permissionFlags = [];
            // Different identifier accounts require different permissions to create
            switch (operation.identifier.keyType) {
                case account_1.AccountKeyAlgorithm.TOKEN:
                    permissionFlags.push('TOKEN_ADMIN_CREATE');
                    break;
                case account_1.AccountKeyAlgorithm.STORAGE:
                    permissionFlags.push('STORAGE_CREATE');
                    break;
                case account_1.AccountKeyAlgorithm.MULTISIG:
                    /* No additional permission is required to create a multisig */
                    break;
                default:
                    throw (new Error('Invalid keyType in BlockOperationCREATE_IDENTIFIER'));
            }
            return ({
                entity: context.ledger.networkAddress,
                permissions: new permissions_1.Permissions(permissionFlags)
            });
        }
    },
    [block_1.Block.OperationType.SET_INFO]: {
        effectGenerator: computeEffectOfOperationSET_INFO,
        signerPermissionACL: ['UPDATE_INFO']
    },
    [block_1.Block.OperationType.MODIFY_PERMISSIONS]: {
        effectGenerator: computeEffectOfOperationMODIFY_PERMISSIONS,
        signerPermissionACL: (block, operation) => {
            /**
             * If you are setting permissions, or the permissions
             * include delegate permissions, you must be owner/admin
             */
            if (operation.permissions === null) {
                return ({ permissions: new permissions_1.Permissions(['OWNER']) });
            }
            if (operation.method === block_1.Block.AdjustMethod.SET) {
                return ({ permissions: operation.permissions.toUpdateRequires });
            }
            const necessary = [
                {
                    permissions: operation.permissions,
                    target: operation.target
                }
            ];
            let delegateMethodNeeded;
            switch (operation.method) {
                case block_1.Block.AdjustMethod.SUBTRACT:
                    delegateMethodNeeded = 'PERMISSION_DELEGATE_REMOVE';
                    break;
                case block_1.Block.AdjustMethod.ADD:
                    delegateMethodNeeded = 'PERMISSION_DELEGATE_ADD';
                    break;
            }
            necessary.push({
                permissions: new permissions_1.Permissions([delegateMethodNeeded]),
                target: operation.principal
            });
            return (necessary);
        }
    },
    [block_1.Block.OperationType.TOKEN_ADMIN_SUPPLY]: {
        effectGenerator: computeEffectOfOperationTOKEN_ADMIN_SUPPLY,
        signerPermissionACL: ['TOKEN_ADMIN_SUPPLY']
    },
    [block_1.Block.OperationType.TOKEN_ADMIN_MODIFY_BALANCE]: {
        effectGenerator: computeEffectOfOperationTOKEN_ADMIN_MODIFY_BALANCE,
        signerPermissionACL(block, operation) {
            return ({
                permissions: new permissions_1.Permissions(['TOKEN_ADMIN_MODIFY_BALANCE']),
                entity: operation.token,
                target: block.account
            });
        }
    },
    [block_1.Block.OperationType.MANAGE_CERTIFICATE]: {
        effectGenerator: computeEffectOfOperationMANAGE_CERTIFICATE,
        signerPermissionACL: ['MANAGE_CERTIFICATE']
    }
};
function computePermissionEffect(state, type, effect, block, operation, context) {
    const effectResults = [];
    if (typeof effect === 'function') {
        const effectResult = effect(block, operation, context);
        if (Array.isArray(effectResult)) {
            effectResults.push(...effectResult);
        }
        else {
            effectResults.push(effectResult);
        }
    }
    else {
        const permissionInstance = new permissions_1.Permissions(effect);
        effectResults.push({ permissions: permissionInstance });
    }
    const baseRequirement = {
        permissions: new permissions_1.Permissions(['ACCESS'])
    };
    switch (type) {
        case 'SIGNER':
            baseRequirement.principal = block.principal;
            baseRequirement.entity = block.account;
            break;
        case 'ACCOUNT':
            baseRequirement.principal = block.account;
            break;
    }
    for (const effectResult of effectResults) {
        const requirement = {
            ...baseRequirement,
            ...effectResult
        };
        if (requirement.entity === undefined) {
            throw (new Error('Error computing permission effect: Entity cannot be undefined'));
        }
        if (requirement.principal === undefined) {
            throw (new Error('Error computing permission effect: Principal cannot be undefined'));
        }
        if (requirement.permissions === undefined) {
            throw (new Error('Error computing permission effect: Permissions cannot be undefined'));
        }
        if (requirement.entity.comparePublicKey(requirement.principal)) {
            return;
        }
        /**
         * The initialTrustedAccount is able to bypass all permission requirements signing opening blocks for the networkAddress and the baseToken
         * All blocks after this it does not bypass any requirements
         */
        if (context.ledger.initialTrustedAccount) {
            if (requirement.principal.comparePublicKey(context.ledger.initialTrustedAccount) && context.openingBlock) {
                const isBaseToken = context.ledger.baseToken.comparePublicKey(requirement.entity);
                const isNetworkAddress = context.ledger.networkAddress.comparePublicKey(requirement.entity);
                if (isBaseToken || isNetworkAddress) {
                    return;
                }
            }
        }
        state.touched.add(requirement.entity);
        if (requirement.target) {
            state.touched.add(requirement.target);
        }
        addPermissionRequirement(state, {
            entity: requirement.entity,
            principal: requirement.principal,
            permissions: requirement.permissions,
            target: requirement.target
        });
    }
}
function computeEffectOfBlocks(blocks, ledger) {
    const accumulatedEffects = {
        accounts: {},
        touched: new account_1.default.Set(),
        possibleNewAccounts: new account_1.default.Set(),
        metadata: {
            blockCount: 0,
            operationCount: 0,
            feeUnits: 0n
        }
    };
    let onlyReturnTouched = false;
    if (!ledger) {
        onlyReturnTouched = true;
        const initialTrustedAccount = account_1.default.fromSeed(account_1.default.generateRandomSeed(), 0);
        const { baseToken, networkAddress } = account_1.default.generateBaseAddresses(0n);
        ledger = { initialTrustedAccount, baseToken, networkAddress };
    }
    /**
     * Compute the effect of each block
     */
    for (const block of blocks) {
        accumulatedEffects.metadata.blockCount++;
        accumulatedEffects.metadata.feeUnits += baseBlockFeeUnit;
        const blockAccountPubKey = block.account.publicKeyString.get();
        const signerQueue = [block.signer];
        while (signerQueue.length > 0) {
            // We can assume that the signerFieldQueue is not empty here since the loop condition checks it
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            const signer = signerQueue.shift();
            if (account_1.default.isInstance(signer)) {
                accumulatedEffects.touched.add(signer);
                continue;
            }
            accumulatedEffects.touched.add(signer[0]);
            signerQueue.push(...signer[1]);
        }
        if (block.$opening) {
            accumulatedEffects.possibleNewAccounts.add(block.account);
            accumulatedEffects.metadata.feeUnits += openingBlockFeeUnit;
        }
        if (!(block.principal.comparePublicKey(block.account))) {
            accumulatedEffects.possibleNewAccounts.add(block.principal);
        }
        if (accumulatedEffects.accounts[blockAccountPubKey] === undefined) {
            accumulatedEffects.accounts[blockAccountPubKey] = {
                account: block.account,
                fields: {}
            };
        }
        /**
         * Compute the effect for each operation
         */
        for (const operationIndex in block.operations) {
            const context = {
                ledger,
                operationIndex: Number(operationIndex),
                signedByDifferent: !block.account.comparePublicKey(block.principal),
                openingBlock: block.$opening
            };
            const operation = block.operations[operationIndex];
            const handler = operationHandlers[operation.type];
            accumulatedEffects.metadata.operationCount++;
            accumulatedEffects.metadata.feeUnits += getOperationFeeUnit(operation.type);
            if (handler.accountPermissionACL) {
                computePermissionEffect(accumulatedEffects, 'ACCOUNT', handler.accountPermissionACL, block, operation, context);
            }
            if (context.signedByDifferent) {
                let permissionEffect = ['ADMIN'];
                if (handler.signerPermissionACL) {
                    permissionEffect = handler.signerPermissionACL;
                }
                computePermissionEffect(accumulatedEffects, 'SIGNER', permissionEffect, block, operation, context);
                if (Array.isArray(block.signer)) {
                    const signerFieldQueue = [block.signer];
                    while (signerFieldQueue.length > 0) {
                        // We can assume that the signerFieldQueue is not empty here since the loop condition checks it
                        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                        const [multisig, signers] = signerFieldQueue.shift();
                        updateMinSignerSetLength(accumulatedEffects, multisig, BigInt(signers.length));
                        for (const signer of signers) {
                            let principal;
                            if (account_1.default.isInstance(signer)) {
                                principal = signer;
                            }
                            else {
                                principal = signer[0];
                                signerFieldQueue.push(signer);
                            }
                            addPermissionRequirement(accumulatedEffects, {
                                entity: multisig,
                                principal: principal,
                                permissions: new permissions_1.Permissions(['MULTISIG_SIGNER'])
                            });
                        }
                    }
                }
            }
            handler.effectGenerator(accumulatedEffects, block, operation, context);
        }
    }
    for (const effect of Object.values(accumulatedEffects.accounts)) {
        accumulatedEffects.touched.add(effect.account);
        if (effect.fields.balance) {
            let hasDebit = false;
            let hasCredit = false;
            let hasSet = false;
            for (const balanceChangeArray of Object.values(effect.fields.balance)) {
                for (const change of balanceChangeArray) {
                    if ('set' in change && change.set) {
                        hasSet = true;
                    }
                    else if (change.value < 0n) {
                        hasDebit = true;
                    }
                    else if (change.value >= 0n) {
                        hasCredit = true;
                    }
                }
            }
            if (hasSet || hasCredit) {
                if (!hasDebit) {
                    accumulatedEffects.possibleNewAccounts.add(effect.account);
                }
            }
        }
    }
    if (onlyReturnTouched) {
        return ({
            touched: accumulatedEffects.touched,
            possibleNewAccounts: accumulatedEffects.possibleNewAccounts
        });
    }
    return (accumulatedEffects);
}


/***/ }),

/***/ 4796:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __addDisposableResource = (this && this.__addDisposableResource) || function (env, value, async) {
    if (value !== null && value !== void 0) {
        if (typeof value !== "object" && typeof value !== "function") throw new TypeError("Object expected.");
        var dispose, inner;
        if (async) {
            if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
            dispose = value[Symbol.asyncDispose];
        }
        if (dispose === void 0) {
            if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
            dispose = value[Symbol.dispose];
            if (async) inner = dispose;
        }
        if (typeof dispose !== "function") throw new TypeError("Object not disposable.");
        if (inner) dispose = function() { try { inner.call(this); } catch (e) { return Promise.reject(e); } };
        env.stack.push({ value: value, dispose: dispose, async: async });
    }
    else if (async) {
        env.stack.push({ async: true });
    }
    return value;
};
var __disposeResources = (this && this.__disposeResources) || (function (SuppressedError) {
    return function (env) {
        function fail(e) {
            env.error = env.hasError ? new SuppressedError(e, env.error, "An error was suppressed during disposal.") : e;
            env.hasError = true;
        }
        var r, s = 0;
        function next() {
            while (r = env.stack.pop()) {
                try {
                    if (!r.async && s === 1) return s = 0, env.stack.push(r), Promise.resolve().then(next);
                    if (r.dispose) {
                        var result = r.dispose.call(r.value);
                        if (r.async) return s |= 2, Promise.resolve(result).then(next, function(e) { fail(e); return next(); });
                    }
                    else s |= 1;
                }
                catch (e) {
                    fail(e);
                }
            }
            if (s === 1) return env.hasError ? Promise.reject(env.error) : Promise.resolve();
            if (env.hasError) throw env.error;
        }
        return next();
    };
})(typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
    var e = new Error(message);
    return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
});
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var _LedgerAtomicInterface_instances, _LedgerAtomicInterface_network, _LedgerAtomicInterface_subnet, _LedgerAtomicInterface_kind, _LedgerAtomicInterface_privateKey, _LedgerAtomicInterface_computeFeeFromBlocks, _LedgerAtomicInterface_storage, _LedgerAtomicInterface_ledger, _LedgerAtomicInterface_cache, _LedgerAtomicInterface_operations, _LedgerAtomicInterface_transaction, _LedgerAtomicInterface_assertTransaction, _LedgerAtomicInterface_validateVotingWeight, _LedgerAtomicInterface_listAccountInfo, _LedgerAtomicInterface_checkSingleAccountPermissions, _LedgerAtomicInterface_checkPermissionRequirements, _LedgerAtomicInterface_validateBlockOperations, _LedgerAtomicInterface_validateLedgerOutcome, _LedgerAtomicInterface_validateBlocksForVote, _LedgerAtomicInterface_voteOrQuoteWithFees, _Ledger_storage, _Ledger_config;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Ledger = exports.LedgerStorageTransactionBase = exports.LedgerKind = void 0;
const vote_1 = __webpack_require__(1130);
const block_1 = __webpack_require__(6158);
const account_1 = __importDefault(__webpack_require__(9415));
const common_1 = __webpack_require__(5663);
const helper_1 = __webpack_require__(3208);
const ledger_1 = __webpack_require__(452);
const permissions_1 = __webpack_require__(5860);
const effects_1 = __webpack_require__(7346);
const conversion_1 = __webpack_require__(2360);
const cache_1 = __importDefault(__webpack_require__(5834));
const timing_1 = __webpack_require__(2895);
const operations_1 = __webpack_require__(2778);
const stats_1 = __webpack_require__(2127);
/**
 * Kind of ledger
 */
var LedgerKind;
(function (LedgerKind) {
    LedgerKind[LedgerKind["REPRESENTATIVE"] = 0] = "REPRESENTATIVE";
    LedgerKind[LedgerKind["ACCOUNT"] = 1] = "ACCOUNT";
})(LedgerKind || (exports.LedgerKind = LedgerKind = {}));
class LedgerStorageTransactionBase {
    constructor(options) {
        this.node = options.node;
        this.moment = options.moment ?? new Date();
        this.identifier = options.identifier;
        this.readOnly = options.readOnly ?? true;
        this.statsPending = new stats_1.StatsPending();
    }
}
exports.LedgerStorageTransactionBase = LedgerStorageTransactionBase;
/**
 * Atomic transactional interface to a storage backend
 */
class LedgerAtomicInterface {
    constructor(transaction, storage, config, ledger) {
        _LedgerAtomicInterface_instances.add(this);
        _LedgerAtomicInterface_network.set(this, void 0);
        _LedgerAtomicInterface_subnet.set(this, void 0);
        _LedgerAtomicInterface_kind.set(this, void 0);
        _LedgerAtomicInterface_privateKey.set(this, void 0);
        _LedgerAtomicInterface_computeFeeFromBlocks.set(this, void 0);
        _LedgerAtomicInterface_storage.set(this, void 0);
        _LedgerAtomicInterface_ledger.set(this, void 0);
        _LedgerAtomicInterface_cache.set(this, void 0);
        _LedgerAtomicInterface_operations.set(this, void 0);
        _LedgerAtomicInterface_transaction.set(this, void 0);
        __classPrivateFieldSet(this, _LedgerAtomicInterface_network, config.network, "f");
        __classPrivateFieldSet(this, _LedgerAtomicInterface_subnet, config.subnet, "f");
        __classPrivateFieldSet(this, _LedgerAtomicInterface_kind, config.kind, "f");
        __classPrivateFieldSet(this, _LedgerAtomicInterface_privateKey, config.privateKey, "f");
        __classPrivateFieldSet(this, _LedgerAtomicInterface_computeFeeFromBlocks, config.computeFeeFromBlocks, "f");
        __classPrivateFieldSet(this, _LedgerAtomicInterface_operations, config.operations ?? { enableTokenAdminModifyBalance: false }, "f");
        __classPrivateFieldSet(this, _LedgerAtomicInterface_ledger, ledger, "f");
        __classPrivateFieldSet(this, _LedgerAtomicInterface_storage, storage, "f");
        __classPrivateFieldSet(this, _LedgerAtomicInterface_transaction, transaction, "f");
        /**
         * Link the storage driver's cache to the transaction cache
         */
        let existingCache;
        if ('cache' in storage && storage.cache !== undefined) {
            existingCache = storage.cache(transaction);
        }
        if (existingCache !== undefined) {
            __classPrivateFieldSet(this, _LedgerAtomicInterface_cache, existingCache, "f");
        }
        else {
            __classPrivateFieldSet(this, _LedgerAtomicInterface_cache, new cache_1.default(), "f");
        }
    }
    async commit() {
        const transaction = __classPrivateFieldGet(this, _LedgerAtomicInterface_instances, "m", _LedgerAtomicInterface_assertTransaction).call(this);
        __classPrivateFieldSet(this, _LedgerAtomicInterface_transaction, null, "f");
        await __classPrivateFieldGet(this, _LedgerAtomicInterface_storage, "f").commitTransaction(transaction);
        __classPrivateFieldGet(this, _LedgerAtomicInterface_ledger, "f").node?.stats.merge(transaction.statsPending);
    }
    async abort() {
        const transaction = __classPrivateFieldGet(this, _LedgerAtomicInterface_instances, "m", _LedgerAtomicInterface_assertTransaction).call(this);
        __classPrivateFieldSet(this, _LedgerAtomicInterface_transaction, null, "f");
        await __classPrivateFieldGet(this, _LedgerAtomicInterface_storage, "f").abortTransaction(transaction);
    }
    async vote(blocks, otherVotes, quote) {
        if (blocks.length === 0) {
            throw (new ledger_1.KeetaNetLedgerError('LEDGER_MISSING_BLOCKS', 'At least one block is required to issue a vote'));
        }
        if (!__classPrivateFieldGet(this, _LedgerAtomicInterface_privateKey, "f")) {
            throw (new Error('Cannot vote on block, no private key loaded'));
        }
        if (__classPrivateFieldGet(this, _LedgerAtomicInterface_ledger, "f").ledgerWriteMode !== 'read-write') {
            throw (new Error(`May not issue votes in read-only mode, in ${__classPrivateFieldGet(this, _LedgerAtomicInterface_ledger, "f").ledgerWriteMode} mode`));
        }
        const privateKey = __classPrivateFieldGet(this, _LedgerAtomicInterface_privateKey, "f");
        const ledgerPubKey = privateKey.publicKeyString.get();
        if (quote !== undefined) {
            if (otherVotes !== undefined) {
                throw (new ledger_1.KeetaNetLedgerError('LEDGER_PERM_VOTE_WITH_QUOTE', 'Quote should not be included when requesting permanent votes'));
            }
            if (!quote.issuer.comparePublicKey(ledgerPubKey)) {
                throw (new ledger_1.KeetaNetLedgerError('LEDGER_QUOTE_MISMATCH', 'Provided quote does not match issuer public key'));
            }
        }
        const transaction = __classPrivateFieldGet(this, _LedgerAtomicInterface_instances, "m", _LedgerAtomicInterface_assertTransaction).call(this);
        /**
         * If there are other votes, ensure one of them was issued by
         * us and the blocks are in the same order as the set of
         * blocks we are voting on now
         */
        let hasFeeBlock = false;
        if (otherVotes !== undefined) {
            let foundOurVote = false;
            const seenVoteUIDs = new Set();
            const seenVoteIssuers = new account_1.default.Set();
            let blockCount = blocks.length;
            const possibleFeeBlock = blocks.at(-1);
            if (possibleFeeBlock?.purpose === block_1.BlockPurpose.FEE) {
                hasFeeBlock = true;
                blockCount--;
            }
            const requiredFees = new Map();
            for (const checkVote of otherVotes) {
                if (checkVote.quote === true) {
                    throw (new ledger_1.KeetaNetLedgerError('LEDGER_PERM_VOTE_WITH_QUOTE', 'Cannot request permanent votes with quotes'));
                }
                if (seenVoteUIDs.has(checkVote.$id)) {
                    throw (new ledger_1.KeetaNetLedgerError('LEDGER_DUPLICATE_VOTE_FOUND', 'Duplicate vote UID found'));
                }
                if (seenVoteIssuers.has(checkVote.issuer)) {
                    throw (new ledger_1.KeetaNetLedgerError('LEDGER_DUPLICATE_VOTE_ISSUER_FOUND', 'Multiple votes found from same issuer'));
                }
                seenVoteIssuers.add(checkVote.issuer);
                seenVoteUIDs.add(checkVote.$id);
                if (checkVote.fee !== undefined) {
                    requiredFees.set(checkVote.issuer, checkVote.fee);
                }
                if (checkVote.$permanent) {
                    throw (new ledger_1.KeetaNetLedgerError('LEDGER_CANNOT_EXCHANGE_PERM_VOTE', 'Asked to exchange a permanent vote for a permanent vote'));
                }
                let blocksDifferFromVoteBlocks = checkVote.blocks.length !== blockCount;
                /* If they do not differ from length alone, compare block hashes */
                if (!blocksDifferFromVoteBlocks) {
                    for (let blockIndex = 0; blockIndex < blockCount; blockIndex++) {
                        if (!blocks[blockIndex].hash.compareHexString(checkVote.blocks[blockIndex])) {
                            blocksDifferFromVoteBlocks = true;
                            break;
                        }
                    }
                }
                if (blocksDifferFromVoteBlocks) {
                    throw (new ledger_1.KeetaNetLedgerError('LEDGER_BLOCKS_DIFFER_FROM_VOTED_ON', 'Asked to exchange different number of blocks for a permanent vote'));
                }
                if (checkVote.issuer.comparePublicKey(ledgerPubKey)) {
                    foundOurVote = true;
                }
            }
            if (requiredFees.size > 0) {
                if (!hasFeeBlock) {
                    throw (new ledger_1.KeetaNetLedgerError('LEDGER_MISSING_REQUIRED_FEE_BLOCK', 'Missing fee block but votes require it'));
                }
                if (requiredFees.size !== possibleFeeBlock?.operations.length) {
                    throw (new ledger_1.KeetaNetLedgerError('LEDGER_REQUIRED_FEE_MISMATCH', 'Fee Block Operations do not match required fees'));
                }
            }
            // Verify that all required fees have been included in the fee block
            for (const [issuer, fee] of requiredFees) {
                const foundFee = possibleFeeBlock?.operations.find((operation) => {
                    const expectedPayTo = fee.payTo ?? issuer;
                    const expectedToken = fee.token ?? __classPrivateFieldGet(this, _LedgerAtomicInterface_ledger, "f").baseToken;
                    if (operation.type === operations_1.OperationType.SEND && operation.to.comparePublicKey(expectedPayTo)) {
                        if (operation.amount !== fee.amount) {
                            throw (new ledger_1.KeetaNetLedgerError('LEDGER_FEE_AMOUNT_MISMATCH', `Fee Amount Mismatch, found: ${operation.amount} expected: ${fee.amount}`));
                        }
                        if (!operation.token.comparePublicKey(expectedToken)) {
                            throw (new ledger_1.KeetaNetLedgerError('LEDGER_FEE_TOKEN_MISMATCH', `Fee Token Mismatch, found: ${operation.token.publicKeyString.get()} expected: ${expectedToken.publicKeyString.get()}`));
                        }
                        return (true);
                    }
                    return (false);
                });
                if (foundFee === undefined) {
                    throw (new ledger_1.KeetaNetLedgerError('LEDGER_FEE_MISSING', `Missing Required Fee for ${fee.payTo?.publicKeyString.get() ?? issuer.publicKeyString.get()}`));
                }
            }
            if (!foundOurVote) {
                throw (new ledger_1.KeetaNetLedgerError('LEDGER_NO_PERM_WITHOUT_SELF_TEMP', 'Asked to give a permanent vote without a temporary vote from us'));
            }
        }
        const allLedgerHeads = await __classPrivateFieldGet(this, _LedgerAtomicInterface_instances, "m", _LedgerAtomicInterface_validateBlocksForVote).call(this, blocks);
        const needToGetHeadFor = new account_1.default.Set(allLedgerHeads.keys());
        const allHeads = await __classPrivateFieldGet(this, _LedgerAtomicInterface_storage, "f").getHeadBlockHashes(transaction, needToGetHeadFor);
        for (const [account, expectedBlock] of allLedgerHeads.entries()) {
            const accountHead = allHeads[account.publicKeyString.get()];
            if (accountHead === null) {
                if (!expectedBlock.$opening) {
                    throw (new ledger_1.KeetaNetLedgerVoteError('LEDGER_NOT_OPENING', 'Cannot vote on non-opening block for an empty account', needToGetHeadFor));
                }
                continue;
            }
            if (expectedBlock.$opening) {
                throw (new ledger_1.KeetaNetLedgerError('LEDGER_NOT_EMPTY', 'Cannot vote on opening block for a non-empty account'));
            }
            if (expectedBlock.previous.toString() !== accountHead.toString()) {
                throw (new ledger_1.KeetaNetLedgerVoteError('LEDGER_NOT_SUCCESSOR', 'The block is not the successor to the account head block', needToGetHeadFor));
            }
        }
        /**
         * Ensure we have no active vote for another conflicting successor of this block's parent (previous),
         * which could cause a fork
         */
        const previousToCheckFor = blocks.map(b => b.previous);
        const allPrevious = await __classPrivateFieldGet(this, _LedgerAtomicInterface_storage, "f").getVotesFromMultiplePrevious(transaction, previousToCheckFor, 'both', account_1.default.toAccount(ledgerPubKey));
        for (const block of blocks) {
            const previousVotes = allPrevious[block.previous.toString()];
            if (previousVotes !== null && previousVotes.length > 0) {
                /**
                 * If we do have a previous vote, we can
                 * replace it with a permanent vote if
                 * there is only 1 previous vote, issued by us,
                 * and it's a short vote
                 */
                let mayReplace = false;
                if (previousVotes.length === 1 && otherVotes !== undefined && otherVotes.length !== 0) {
                    const ourVote = previousVotes[0];
                    mayReplace = !ourVote.$permanent && ourVote.issuer.comparePublicKey(ledgerPubKey);
                }
                if (!mayReplace) {
                    throw (new ledger_1.KeetaNetLedgerError('LEDGER_SUCCESSOR_VOTE_EXISTS', `We cannot vote for this block (hash=${block.hash.toString()}), we have an existing vote for a successor (previous votes = ${JSON.stringify((0, conversion_1.toJSONSerializable)(previousVotes))})`));
                }
            }
        }
        /**
         * If no other votes have been supplied, validate that the blocks are valid, and issue a short vote
         */
        if (otherVotes === undefined) {
            const vote = await __classPrivateFieldGet(this, _LedgerAtomicInterface_instances, "m", _LedgerAtomicInterface_voteOrQuoteWithFees).call(this, blocks, 'VOTE', quote);
            const blocksAndVote = vote_1.VoteStaple.fromVotesAndBlocks([vote], blocks);
            await __classPrivateFieldGet(this, _LedgerAtomicInterface_storage, "f").addPendingVote(transaction, blocksAndVote);
            return (vote);
        }
        /**
         * Validate ledger outcome again before permanent votes if blocks includes a fee block
         */
        if (hasFeeBlock) {
            await __classPrivateFieldGet(this, _LedgerAtomicInterface_instances, "m", _LedgerAtomicInterface_validateLedgerOutcome).call(this, blocks);
        }
        /**
         * Validate the votes are sufficient weight and grant
         * our permanent vote
         */
        const votesSufficient = await __classPrivateFieldGet(this, _LedgerAtomicInterface_instances, "m", _LedgerAtomicInterface_validateVotingWeight).call(this, otherVotes);
        if (votesSufficient !== true) {
            throw (new ledger_1.KeetaNetLedgerError('LEDGER_INSUFFICIENT_VOTING_WEIGHT', 'Unable to create a vote from these votes, they do not represent enough voting power'));
        }
        /**
         * Serial number
         */
        const serial = await __classPrivateFieldGet(this, _LedgerAtomicInterface_storage, "f").getNextSerialNumber(__classPrivateFieldGet(this, _LedgerAtomicInterface_transaction, "f"));
        const wipVote = new vote_1.VoteBuilder(privateKey);
        for (const block of blocks) {
            wipVote.addBlock(block);
        }
        const vote = await wipVote.seal(serial, null);
        const blocksAndVote = vote_1.VoteStaple.fromVotesAndBlocks([vote], blocks);
        /**
         * Add this pending vote to our side ledger;
         * Replacing an existing temporary vote with a permanent one
         */
        await __classPrivateFieldGet(this, _LedgerAtomicInterface_storage, "f").addPendingVote(transaction, blocksAndVote);
        return (vote);
    }
    async quote(blocks) {
        await __classPrivateFieldGet(this, _LedgerAtomicInterface_instances, "m", _LedgerAtomicInterface_validateBlocksForVote).call(this, blocks);
        const quote = await __classPrivateFieldGet(this, _LedgerAtomicInterface_instances, "m", _LedgerAtomicInterface_voteOrQuoteWithFees).call(this, blocks, 'QUOTE');
        return (quote);
    }
    async add(votesAndBlocks, from) {
        const transaction = __classPrivateFieldGet(this, _LedgerAtomicInterface_instances, "m", _LedgerAtomicInterface_assertTransaction).call(this);
        switch (__classPrivateFieldGet(this, _LedgerAtomicInterface_ledger, "f").ledgerWriteMode) {
            case 'read-only':
                throw (new Error('Cannot add blocks to a read-only ledger'));
            case 'bootstrap-only':
                if (from === 'bootstrap') {
                    break;
                }
                throw (new Error('Cannot add blocks to a read-only ledger (except for bootstrapping)'));
            case 'read-write':
            case 'no-voting':
                break;
            default:
                throw (new Error(`internal error: invalid ledger write mode: ${__classPrivateFieldGet(this, _LedgerAtomicInterface_ledger, "f").ledgerWriteMode}`));
        }
        const { votes, blocks } = votesAndBlocks;
        if (votes.length < 1) {
            throw (new Error('Must have at least 1 vote in the staple'));
        }
        for (const block of blocks) {
            if (block.network !== __classPrivateFieldGet(this, _LedgerAtomicInterface_network, "f")) {
                throw (new Error('Cannot process block for a different network'));
            }
            if (block.subnet !== __classPrivateFieldGet(this, _LedgerAtomicInterface_subnet, "f")) {
                throw (new Error('Cannot process block for a different subnet'));
            }
        }
        for (const vote of votes) {
            if (!vote.$permanent) {
                throw (new Error('Can only insert permanent votes'));
            }
        }
        const weightTiming = __classPrivateFieldGet(this, _LedgerAtomicInterface_ledger, "f").node?.timing.startTime('db-add/getWeight');
        const votesSufficient = await __classPrivateFieldGet(this, _LedgerAtomicInterface_instances, "m", _LedgerAtomicInterface_validateVotingWeight).call(this, votesAndBlocks.votes);
        if (votesSufficient !== true) {
            throw (new ledger_1.KeetaNetLedgerError('LEDGER_INSUFFICIENT_VOTING_WEIGHT', 'Votes attached do not represent enough voting power'));
        }
        weightTiming?.end();
        const changesTiming = __classPrivateFieldGet(this, _LedgerAtomicInterface_ledger, "f").node?.timing.startTime('db-add/computeEffectOfBlocks');
        const changes = (0, effects_1.computeEffectOfBlocks)(votesAndBlocks.blocks, __classPrivateFieldGet(this, _LedgerAtomicInterface_ledger, "f"));
        changesTiming?.end();
        const adjustTiming = __classPrivateFieldGet(this, _LedgerAtomicInterface_ledger, "f").node?.timing.startTime('db-add/adjust');
        const voteStaples = await __classPrivateFieldGet(this, _LedgerAtomicInterface_storage, "f").adjust(transaction, votesAndBlocks, changes);
        adjustTiming?.end();
        const postambleTiming = __classPrivateFieldGet(this, _LedgerAtomicInterface_ledger, "f").node?.timing.startTime('db-add/postamble');
        /**
         * Add all the block hashes to the node checksum
         */
        for (const staple of voteStaples) {
            for (const block of staple.blocks) {
                transaction.statsPending.xor('ledgerChecksum', block.hash);
            }
        }
        postambleTiming?.end();
        return (voteStaples);
    }
    async getBalance(account, token) {
        const transaction = __classPrivateFieldGet(this, _LedgerAtomicInterface_instances, "m", _LedgerAtomicInterface_assertTransaction).call(this);
        const balance = await __classPrivateFieldGet(this, _LedgerAtomicInterface_storage, "f").getBalance(transaction, account, token);
        if (balance < 0n) {
            throw (new Error(`internal error: Account with negative balance: ${account.publicKeyString.get()}/${account_1.default.toPublicKeyString(token)}: ${balance}`));
        }
        return (balance);
    }
    async getAllBalances(account) {
        const transaction = __classPrivateFieldGet(this, _LedgerAtomicInterface_instances, "m", _LedgerAtomicInterface_assertTransaction).call(this);
        const balances = await __classPrivateFieldGet(this, _LedgerAtomicInterface_storage, "f").getAllBalances(transaction, account);
        for (const { token, balance } of balances) {
            if (balance < 0n) {
                throw (new Error(`internal error: Account with negative balance: ${account.publicKeyString.get()}/${token.publicKeyString.get()}: ${balance}`));
            }
        }
        return (balances);
    }
    async getAccountCertificates(account) {
        __classPrivateFieldGet(this, _LedgerAtomicInterface_instances, "m", _LedgerAtomicInterface_assertTransaction).call(this);
        return (await __classPrivateFieldGet(this, _LedgerAtomicInterface_storage, "f").getAccountCertificates(__classPrivateFieldGet(this, _LedgerAtomicInterface_transaction, "f"), account));
    }
    async getAccountCertificateByHash(account, hash) {
        __classPrivateFieldGet(this, _LedgerAtomicInterface_instances, "m", _LedgerAtomicInterface_assertTransaction).call(this);
        return (await __classPrivateFieldGet(this, _LedgerAtomicInterface_storage, "f").getAccountCertificateByHash(__classPrivateFieldGet(this, _LedgerAtomicInterface_transaction, "f"), account, hash));
    }
    async listACLsByPrincipal(principal, entityList) {
        const transaction = __classPrivateFieldGet(this, _LedgerAtomicInterface_instances, "m", _LedgerAtomicInterface_assertTransaction).call(this);
        const permissions = await __classPrivateFieldGet(this, _LedgerAtomicInterface_storage, "f").listACLsByPrincipal(transaction, principal, entityList);
        return (permissions);
    }
    async listACLsByEntity(entity) {
        const transaction = __classPrivateFieldGet(this, _LedgerAtomicInterface_instances, "m", _LedgerAtomicInterface_assertTransaction).call(this);
        const permissions = await __classPrivateFieldGet(this, _LedgerAtomicInterface_storage, "f").listACLsByEntity(transaction, entity);
        return (permissions);
    }
    async votingPower(rep) {
        const transaction = __classPrivateFieldGet(this, _LedgerAtomicInterface_instances, "m", _LedgerAtomicInterface_assertTransaction).call(this);
        const weight = await __classPrivateFieldGet(this, _LedgerAtomicInterface_storage, "f").delegatedWeight(transaction, rep);
        /* Voting Power = Weight (for now) */
        return (weight);
    }
    async getVotes(block, from = 'main') {
        const transaction = __classPrivateFieldGet(this, _LedgerAtomicInterface_instances, "m", _LedgerAtomicInterface_assertTransaction).call(this);
        const retval = await __classPrivateFieldGet(this, _LedgerAtomicInterface_storage, "f").getVotes(transaction, block, from);
        return (retval);
    }
    async getVotesFromMultiplePrevious(prevBlocks, from = 'main', issuer) {
        const transaction = __classPrivateFieldGet(this, _LedgerAtomicInterface_instances, "m", _LedgerAtomicInterface_assertTransaction).call(this);
        const retval = await __classPrivateFieldGet(this, _LedgerAtomicInterface_storage, "f").getVotesFromMultiplePrevious(transaction, prevBlocks, from, issuer);
        return (retval);
    }
    async getBlockFromPrevious(block, from) {
        const transaction = __classPrivateFieldGet(this, _LedgerAtomicInterface_instances, "m", _LedgerAtomicInterface_assertTransaction).call(this);
        const retval = await __classPrivateFieldGet(this, _LedgerAtomicInterface_storage, "f").getBlockFromPrevious(transaction, block, from);
        return (retval);
    }
    async getHeadBlocks(accounts, from) {
        const transaction = __classPrivateFieldGet(this, _LedgerAtomicInterface_instances, "m", _LedgerAtomicInterface_assertTransaction).call(this);
        const retval = await __classPrivateFieldGet(this, _LedgerAtomicInterface_storage, "f").getHeadBlocks(transaction, accounts, from);
        return (retval);
    }
    async getHeadBlock(account, from) {
        const transaction = __classPrivateFieldGet(this, _LedgerAtomicInterface_instances, "m", _LedgerAtomicInterface_assertTransaction).call(this);
        const retval = await __classPrivateFieldGet(this, _LedgerAtomicInterface_storage, "f").getHeadBlock(transaction, account, from);
        return (retval);
    }
    async getAccountRep(account) {
        const transaction = __classPrivateFieldGet(this, _LedgerAtomicInterface_instances, "m", _LedgerAtomicInterface_assertTransaction).call(this);
        const retval = await __classPrivateFieldGet(this, _LedgerAtomicInterface_storage, "f").getAccountRep(transaction, account);
        return (retval);
    }
    async getAccountInfo(account) {
        const transaction = __classPrivateFieldGet(this, _LedgerAtomicInterface_instances, "m", _LedgerAtomicInterface_assertTransaction).call(this);
        const retval = await __classPrivateFieldGet(this, _LedgerAtomicInterface_storage, "f").getAccountInfo(transaction, account);
        return (retval);
    }
    async getBlock(blockhash, from = 'main') {
        const transaction = __classPrivateFieldGet(this, _LedgerAtomicInterface_instances, "m", _LedgerAtomicInterface_assertTransaction).call(this);
        const retval = await __classPrivateFieldGet(this, _LedgerAtomicInterface_storage, "f").getBlock(transaction, blockhash, from);
        return (retval);
    }
    async getAccountsBlockHeightInfo(toFetch) {
        const transaction = __classPrivateFieldGet(this, _LedgerAtomicInterface_instances, "m", _LedgerAtomicInterface_assertTransaction).call(this);
        const retval = await __classPrivateFieldGet(this, _LedgerAtomicInterface_storage, "f").getAccountsBlockHeightInfo(transaction, toFetch);
        return (retval);
    }
    async getVoteStaple(stapleBlockHash, from = 'main') {
        __classPrivateFieldGet(this, _LedgerAtomicInterface_instances, "m", _LedgerAtomicInterface_assertTransaction).call(this);
        const results = await this.getVoteStaples([stapleBlockHash], from);
        const retval = results.get(stapleBlockHash);
        if (retval === undefined) {
            throw (new Error(`internal error: missing vote staple for ${stapleBlockHash}`));
        }
        return (retval);
    }
    async getVoteStaples(stapleBlockHashes, from = 'main') {
        const transaction = __classPrivateFieldGet(this, _LedgerAtomicInterface_instances, "m", _LedgerAtomicInterface_assertTransaction).call(this);
        if (stapleBlockHashes.length === 0) {
            return (new vote_1.VoteBlockHashMap());
        }
        if (stapleBlockHashes.length > 10000) {
            throw (new Error('Cannot fetch more than 10,000 vote staples at once'));
        }
        const retval = await __classPrivateFieldGet(this, _LedgerAtomicInterface_storage, "f").getVoteStaples(transaction, stapleBlockHashes, from);
        return (retval);
    }
    async getHistory(account, start, limit = 25) {
        const transaction = __classPrivateFieldGet(this, _LedgerAtomicInterface_instances, "m", _LedgerAtomicInterface_assertTransaction).call(this);
        const voteStapleHashes = await __classPrivateFieldGet(this, _LedgerAtomicInterface_storage, "f").getHistory(transaction, account, start, limit);
        const voteStaplesMap = await this.getVoteStaples(voteStapleHashes, 'main');
        const voteStaples = voteStapleHashes.map(function (voteStapleHash) {
            const voteStaple = voteStaplesMap.get(voteStapleHash);
            if (voteStaple === undefined || voteStaple === null) {
                throw (new Error(`internal error: missing vote staple for ${voteStapleHash}`));
            }
            return (voteStaple);
        });
        return (voteStaples);
    }
    async getStaplesFromBlockHashes(hashes) {
        const transaction = __classPrivateFieldGet(this, _LedgerAtomicInterface_instances, "m", _LedgerAtomicInterface_assertTransaction).call(this);
        if (__classPrivateFieldGet(this, _LedgerAtomicInterface_storage, "f").getVoteStaplesFromBlockHash) {
            const retval = await __classPrivateFieldGet(this, _LedgerAtomicInterface_storage, "f").getVoteStaplesFromBlockHash(transaction, hashes, 'main');
            return (retval);
        }
        const staples = [];
        const seenVoteUIDs = new Set();
        const seenBlockHashes = new block_1.BlockHash.Set();
        for (const blockHash of hashes) {
            if (seenBlockHashes.has(blockHash)) {
                continue;
            }
            /**
             * Get all the votes on the same set of blocks (any
             * block can be used for this purpose)
             */
            const relatedVotes = await __classPrivateFieldGet(this, _LedgerAtomicInterface_storage, "f").getVotes(transaction, blockHash, 'main');
            if (!relatedVotes) {
                continue;
            }
            const relatedBlockHashes = relatedVotes[0].blocks;
            /**
             * We do not need to process any blocks within this vote again
             * All of them will be the same staple
             */
            for (const relatedBlockHash of relatedBlockHashes) {
                seenBlockHashes.add(relatedBlockHash);
            }
            if (seenVoteUIDs.has(relatedVotes[0].$id)) {
                continue;
            }
            /**
             * Indicate we have now seen all these votes -- even if
             * we cannot create a VoteStaple from it due to
             * missing blocks, there's no point in retrying that.
             */
            for (const relatedVote of relatedVotes) {
                seenVoteUIDs.add(relatedVote.$id);
            }
            /**
             * Fetch all the blocks mentioned in the vote
             */
            const resolvedVoteBlocks = [];
            let foundInvalidBlock = false;
            const voteBlockPromises = relatedBlockHashes.map(async (relatedHash) => {
                try {
                    const block = await __classPrivateFieldGet(this, _LedgerAtomicInterface_storage, "f").getBlock(transaction, relatedHash, 'main');
                    // We only care about valid blocks
                    if (block_1.Block.isInstance(block)) {
                        resolvedVoteBlocks.push(block);
                        return;
                    }
                }
                catch {
                    /* Ignore the error, we will check for undefined blocks later */
                }
                foundInvalidBlock = true;
            });
            await Promise.all(voteBlockPromises);
            /**
             * If there were any blocks that we don't currently have, we shouldn't construct a staple
             */
            if (foundInvalidBlock) {
                continue;
            }
            /**
             * Construct the staple from the information gathered
             */
            const staple = vote_1.Vote.Staple.fromVotesAndBlocks(relatedVotes, resolvedVoteBlocks);
            staples.push(staple);
        }
        return (staples);
    }
    async getVoteStaplesAfter(moment, limit = 1000, options = {}) {
        const transaction = __classPrivateFieldGet(this, _LedgerAtomicInterface_instances, "m", _LedgerAtomicInterface_assertTransaction).call(this);
        const { bloomFilter, timeout } = options;
        const retval = [];
        const startTime = Date.now();
        let startKey;
        while (retval.length < limit) {
            /**
             * If the timeout is reached and we have at least one
             * result already, return it.
             */
            if (retval.length > 0 && timeout !== undefined) {
                const now = Date.now();
                if ((now - startTime) > timeout) {
                    break;
                }
            }
            /**
             * Compute the maximum number of votes we can fetch from the
             * storage driver in a single page, we request 32x the
             * remaining limit, but no more than 200
             */
            let maxVotesPerPage = (limit - retval.length) * 32;
            if (maxVotesPerPage > 200) {
                maxVotesPerPage = 200;
            }
            /**
             * Get all the votes from the storage driver that occurred on
             * or after the moment specified.
             */
            const page = await __classPrivateFieldGet(this, _LedgerAtomicInterface_storage, "f").getVotesAfter(transaction, moment, startKey, {
                maxVotesPerPage,
                ...options
            });
            startKey = page.nextKey;
            const pageBlockHashes = page.votes.map(vote => vote.blocks);
            // Convert BlockHash[][] to BlockHash[] and remove duplicates
            const seenBlockHashes = new block_1.BlockHash.Set();
            const flattenedHashes = pageBlockHashes.flat().filter(function (hash) {
                return (!seenBlockHashes.has(hash));
            });
            const staples = await this.getStaplesFromBlockHashes(flattenedHashes);
            for (const staple of staples) {
                /**
                 * Break out of the loop if we have reached capacity
                 */
                if (retval.length >= limit) {
                    break;
                }
                /**
                 * If a filter has been supplied, check
                 * it to see if the new vote has already
                 * been sent
                 */
                if (bloomFilter) {
                    if (bloomFilter.has(staple.toBytes())) {
                        continue;
                    }
                }
                retval.push(staple);
            }
            /**
             * If there is no next key, exit the loop
             */
            if (startKey === undefined) {
                break;
            }
        }
        return (retval);
    }
    async gc(timeLimitMS) {
        const transaction = __classPrivateFieldGet(this, _LedgerAtomicInterface_instances, "m", _LedgerAtomicInterface_assertTransaction).call(this);
        return (await __classPrivateFieldGet(this, _LedgerAtomicInterface_storage, "f").gc(transaction, timeLimitMS));
    }
    async getFee(blocks, effectsInput) {
        const effects = effectsInput ?? (0, effects_1.computeEffectOfBlocks)(blocks, __classPrivateFieldGet(this, _LedgerAtomicInterface_ledger, "f"));
        return (__classPrivateFieldGet(this, _LedgerAtomicInterface_computeFeeFromBlocks, "f").call(this, __classPrivateFieldGet(this, _LedgerAtomicInterface_ledger, "f"), blocks, effects));
    }
    async _testingRunStorageFunction(code) {
        const transaction = __classPrivateFieldGet(this, _LedgerAtomicInterface_instances, "m", _LedgerAtomicInterface_assertTransaction).call(this);
        const retval = await code(__classPrivateFieldGet(this, _LedgerAtomicInterface_storage, "f"), transaction);
        return (retval);
    }
}
_LedgerAtomicInterface_network = new WeakMap(), _LedgerAtomicInterface_subnet = new WeakMap(), _LedgerAtomicInterface_kind = new WeakMap(), _LedgerAtomicInterface_privateKey = new WeakMap(), _LedgerAtomicInterface_computeFeeFromBlocks = new WeakMap(), _LedgerAtomicInterface_storage = new WeakMap(), _LedgerAtomicInterface_ledger = new WeakMap(), _LedgerAtomicInterface_cache = new WeakMap(), _LedgerAtomicInterface_operations = new WeakMap(), _LedgerAtomicInterface_transaction = new WeakMap(), _LedgerAtomicInterface_instances = new WeakSet(), _LedgerAtomicInterface_assertTransaction = function _LedgerAtomicInterface_assertTransaction() {
    if (__classPrivateFieldGet(this, _LedgerAtomicInterface_transaction, "f") === null) {
        throw (new Error('Attempt to use closed transaction'));
    }
    return (__classPrivateFieldGet(this, _LedgerAtomicInterface_transaction, "f"));
}, _LedgerAtomicInterface_validateVotingWeight = async function _LedgerAtomicInterface_validateVotingWeight(votes) {
    const transaction = __classPrivateFieldGet(this, _LedgerAtomicInterface_instances, "m", _LedgerAtomicInterface_assertTransaction).call(this);
    const totalVotingPower = await __classPrivateFieldGet(this, _LedgerAtomicInterface_storage, "f").delegatedWeight(transaction);
    /**
     * See if the weight across the network is 0
     * If so, we want to ensure that it has a vote by the trusted account, and only that account
     */
    if (totalVotingPower === 0n) {
        const foundTrustedVote = votes.find((vote) => {
            return (vote.issuer.comparePublicKey(__classPrivateFieldGet(this, _LedgerAtomicInterface_ledger, "f").initialTrustedAccount));
        });
        return (foundTrustedVote !== undefined);
    }
    const twoThirdsOfTotalWeight = ((totalVotingPower / 3n) * 2n);
    const requiredPower = twoThirdsOfTotalWeight + 1n;
    const voters = votes.map(function (vote) {
        return (vote.issuer);
    });
    const votedPowerSum = await __classPrivateFieldGet(this, _LedgerAtomicInterface_storage, "f").delegatedWeight(transaction, new account_1.default.Set(voters));
    return (votedPowerSum >= requiredPower);
}, _LedgerAtomicInterface_listAccountInfo = async function _LedgerAtomicInterface_listAccountInfo(accounts) {
    const transaction = __classPrivateFieldGet(this, _LedgerAtomicInterface_instances, "m", _LedgerAtomicInterface_assertTransaction).call(this);
    const accountInfo = {};
    const permissionPromises = Array.from(accounts).map(async (account) => {
        if (account.isIdentifier() === false) {
            return;
        }
        accountInfo[account.publicKeyString.get()] = await __classPrivateFieldGet(this, _LedgerAtomicInterface_storage, "f").getAccountInfo(transaction, account);
    });
    await Promise.all(permissionPromises);
    return (accountInfo);
}, _LedgerAtomicInterface_checkSingleAccountPermissions = async function _LedgerAtomicInterface_checkSingleAccountPermissions(account, requirements, accountInfos) {
    __classPrivateFieldGet(this, _LedgerAtomicInterface_instances, "m", _LedgerAtomicInterface_assertTransaction).call(this);
    // Remove duplicates in entity
    const unfilteredEntity = requirements.map(acct => acct.entity);
    const entityAccounts = new account_1.default.Set(unfilteredEntity).toArray();
    const gotPermissions = await this.listACLsByPrincipal(account, entityAccounts);
    for (const requirement of requirements) {
        const reqEntityKey = requirement.entity.publicKeyString.get();
        const foundACLRow = (0, common_1.findPermissionMatch)(requirement, gotPermissions);
        let foundPermission;
        if (foundACLRow?.permissions) {
            foundPermission = foundACLRow?.permissions;
        }
        else if (accountInfos[reqEntityKey]?.defaultPermission) {
            foundPermission = accountInfos[reqEntityKey].defaultPermission;
        }
        else {
            foundPermission = new permissions_1.Permissions();
        }
        if (requirement.permissions === null) {
            continue;
        }
        const hasPermissions = foundPermission.has(requirement.permissions);
        if (!hasPermissions) {
            const accountPubKey = account.publicKeyString.get();
            const baseFlagsStr = requirement.permissions.base.flags.join(', ');
            const externalOffsetsStr = requirement.permissions.external.trueOffsets.join(', ');
            const reqTargetKey = requirement.target?.publicKeyString.get();
            throw (new ledger_1.KeetaNetLedgerError('LEDGER_INVALID_PERMISSIONS', `${accountPubKey} does not have required permissions to perform action on ${reqEntityKey}/${reqTargetKey} -- needs [${baseFlagsStr}]/[${externalOffsetsStr}]`));
        }
    }
}, _LedgerAtomicInterface_checkPermissionRequirements = async function _LedgerAtomicInterface_checkPermissionRequirements(effects) {
    __classPrivateFieldGet(this, _LedgerAtomicInterface_instances, "m", _LedgerAtomicInterface_assertTransaction).call(this);
    const newOwners = {};
    const requirementsByPrincipal = {};
    const needToGetAccountInfoFor = new account_1.default.Set();
    const allAccountsChanges = Object.values(effects);
    const foundMultisigSignerLengths = [];
    for (const { account, fields } of allAccountsChanges) {
        if (account.isMultisig()) {
            if (fields.minSignerSetLength !== undefined) {
                needToGetAccountInfoFor.add(account);
                foundMultisigSignerLengths.push([account, fields.minSignerSetLength]);
            }
        }
        for (const singleRequirement of fields.permissionRequirements ?? []) {
            const principal = singleRequirement.principal;
            const principalPubKey = principal.publicKeyString.get();
            if (!requirementsByPrincipal[principalPubKey]) {
                requirementsByPrincipal[principalPubKey] = [];
            }
            requirementsByPrincipal[principalPubKey].push(singleRequirement);
            const { entity, permissions } = singleRequirement;
            const entityKey = entity.publicKeyString.get();
            if (permissions === null) {
                continue;
            }
            if (permissions.has(['OWNER'])) {
                if (newOwners[entityKey] === undefined) {
                    newOwners[entityKey] = {
                        entity, owners: []
                    };
                }
                newOwners[entityKey].owners.push(principal);
            }
            if (permissions.base.isValidForDefault && entity.isIdentifier()) {
                needToGetAccountInfoFor.add(entity);
            }
        }
    }
    const foundAccountInfo = await __classPrivateFieldGet(this, _LedgerAtomicInterface_instances, "m", _LedgerAtomicInterface_listAccountInfo).call(this, needToGetAccountInfoFor);
    for (const [multisig, foundSingerLength] of foundMultisigSignerLengths) {
        const multisigPubKey = multisig.publicKeyString.get();
        const foundInfo = foundAccountInfo[multisigPubKey];
        if (!foundInfo?.multisigQuorum) {
            throw (new Error(`Multisig quorum not found for ${multisigPubKey}`));
        }
        if (foundInfo.multisigQuorum > foundSingerLength) {
            throw (new ledger_1.KeetaNetLedgerError('LEDGER_INVALID_PERMISSIONS', `Quorum of ${foundInfo.multisigQuorum} not reached for ${multisigPubKey} -- got ${foundSingerLength}`));
        }
    }
    const checkPromises = [];
    for (const principalPubKey in requirementsByPrincipal) {
        const accountRequirements = requirementsByPrincipal[principalPubKey];
        const principal = account_1.default.fromPublicKeyString(principalPubKey);
        checkPromises.push(__classPrivateFieldGet(this, _LedgerAtomicInterface_instances, "m", _LedgerAtomicInterface_checkSingleAccountPermissions).call(this, principal, accountRequirements, foundAccountInfo));
    }
    await Promise.all(checkPromises);
    return ({ newOwners });
}, _LedgerAtomicInterface_validateBlockOperations = async function _LedgerAtomicInterface_validateBlockOperations(blocks) {
    if (__classPrivateFieldGet(this, _LedgerAtomicInterface_operations, "f") === undefined) {
        return;
    }
    for (const block of blocks) {
        for (const operation of block.operations) {
            switch (operation.type) {
                case block_1.Block.OperationType.SET_REP:
                    if (__classPrivateFieldGet(this, _LedgerAtomicInterface_operations, "f").setRep !== undefined) {
                        const validRep = await __classPrivateFieldGet(this, _LedgerAtomicInterface_operations, "f").setRep(block.account, operation.to);
                        if (!validRep) {
                            throw (new ledger_1.KeetaNetLedgerError('LEDGER_INVALID_SET_REP', `${operation.to.publicKeyString.get()} is not a valid representative`));
                        }
                    }
                    break;
                case block_1.Block.OperationType.TOKEN_ADMIN_MODIFY_BALANCE:
                    if (!__classPrivateFieldGet(this, _LedgerAtomicInterface_operations, "f").enableTokenAdminModifyBalance) {
                        throw (new ledger_1.KeetaNetLedgerError('LEDGER_OPERATION_NOT_SUPPORTED', 'TOKEN_ADMIN_MODIFY_BALANCE operation not supported'));
                    }
                    break;
                default:
                    break;
            }
        }
    }
}, _LedgerAtomicInterface_validateLedgerOutcome = 
/**
 * Ensure all parts of a transaction do not have a negative outcome
 * Balance/Supply cannot fall negative at any point in transaction
 * Accounts have required permissions to perform actions
 * After permission owner modifications all accounts must have exactly one owner
 */
async function _LedgerAtomicInterface_validateLedgerOutcome(blocks) {
    const transaction = __classPrivateFieldGet(this, _LedgerAtomicInterface_instances, "m", _LedgerAtomicInterface_assertTransaction).call(this);
    await __classPrivateFieldGet(this, _LedgerAtomicInterface_instances, "m", _LedgerAtomicInterface_validateBlockOperations).call(this, blocks);
    const ownersByIdentifier = {};
    // 'ADD' or 'REMOVE' an owner from ownersByIdentifier
    const modifyOwners = (method, entity, principal) => {
        if (entity.isIdentifier() === false || entity.isMultisig()) {
            return;
        }
        const entityPubKey = entity.assertIdentifier().publicKeyString.get();
        if (ownersByIdentifier[entityPubKey] === undefined) {
            ownersByIdentifier[entityPubKey] = { added: new account_1.default.Set(), removed: new account_1.default.Set() };
        }
        switch (method) {
            case 'ADD':
                // If it is not already included, push added owner
                ownersByIdentifier[entityPubKey].added.add(principal);
                ownersByIdentifier[entityPubKey].removed.delete(principal);
                break;
            case 'REMOVE':
                // Remove owner if it is already included
                ownersByIdentifier[entityPubKey].added.delete(principal);
                ownersByIdentifier[entityPubKey].removed.add(principal);
                break;
        }
    };
    const effects = (0, effects_1.computeEffectOfBlocks)(blocks, __classPrivateFieldGet(this, _LedgerAtomicInterface_ledger, "f"));
    const accountEffects = effects.accounts;
    const allAccountsChanges = Object.values(accountEffects);
    /**
     * Ensure all required permissions are met
     * See which accounts are now owners, and add those accounts to the set that we have
     */
    const { newOwners } = await __classPrivateFieldGet(this, _LedgerAtomicInterface_instances, "m", _LedgerAtomicInterface_checkPermissionRequirements).call(this, accountEffects);
    for (const entityPubKey in newOwners) {
        const { entity, owners } = newOwners[entityPubKey];
        for (const newOwner of owners) {
            modifyOwners('ADD', entity, newOwner);
        }
    }
    for (const accountChanges of allAccountsChanges) {
        const { account, fields = {} } = accountChanges;
        /**
         * Newly created identifiers automatically grant the creator ownership.
         */
        const createRequests = fields.createRequests ?? [];
        for (const createRequest of createRequests) {
            modifyOwners('ADD', createRequest.createdIdentifier, account);
        }
        /**
         * If an account was granted permissions, we should take that into effect
         */
        const addedPermissions = fields.permissions ?? [];
        for (const newPerm of addedPermissions) {
            let method = 'ADD';
            if (newPerm.permissions === null || !newPerm.permissions.has(['OWNER'])) {
                method = 'REMOVE';
            }
            modifyOwners(method, newPerm.entity, newPerm.principal);
        }
    }
    /**
     * Ensure there is exactly one owner when permissions were changed
     */
    for (const [identifierPubKey, { added, removed }] of Object.entries(ownersByIdentifier)) {
        let ownerLength = added.size;
        // If more than one owner was granted and not removed, we know it is invalid without checking
        if (ownerLength <= 1) {
            const identifierAccount = account_1.default.fromPublicKeyString(identifierPubKey).assertIdentifier();
            const receivedOwners = await __classPrivateFieldGet(this, _LedgerAtomicInterface_storage, "f").listOwners(transaction, identifierAccount);
            for (const receivedOwner of receivedOwners) {
                // We already know about these owners, we do not care about adding/removing them again
                if (added.has(receivedOwner) || removed.has(receivedOwner)) {
                    continue;
                }
                ownerLength++;
            }
        }
        if (ownerLength === 1) {
            continue;
        }
        throw (new ledger_1.KeetaNetLedgerError('LEDGER_INVALID_OWNER_COUNT', `Invalid number of owners for ${identifierPubKey} - Got ${ownerLength}/1`));
    }
    const { balances } = await (0, common_1.computeLedgerEffect)({
        checkRangeConstraints: true,
        baseToken: __classPrivateFieldGet(this, _LedgerAtomicInterface_ledger, "f").baseToken
    }, accountEffects, __classPrivateFieldGet(this, _LedgerAtomicInterface_storage, "f"), __classPrivateFieldGet(this, _LedgerAtomicInterface_network, "f"), __classPrivateFieldGet(this, _LedgerAtomicInterface_transaction, "f"));
    for (const accountPubKey in balances) {
        const acctBalanceChanges = balances[accountPubKey];
        for (const tokenPubKey in acctBalanceChanges) {
            const { change, fellNegative, receiveValidated } = acctBalanceChanges[tokenPubKey];
            if (fellNegative) {
                throw (new ledger_1.KeetaNetLedgerError('LEDGER_INVALID_BALANCE', `Resulting balance becomes negative at one+ point(s) during this transaction for account/token ${accountPubKey}/${tokenPubKey}: change ${change}`));
            }
            if (receiveValidated === false) {
                throw (new ledger_1.KeetaNetLedgerError('LEDGER_RECEIVE_NOT_MET', `${accountPubKey}/${tokenPubKey} did not receive enough of requested token. change: ${change}`));
            }
        }
    }
    return (effects);
}, _LedgerAtomicInterface_validateBlocksForVote = async function _LedgerAtomicInterface_validateBlocksForVote(blocks) {
    /**
     * Create a map of all blocks by their hash
     */
    const blockHashMap = {};
    for (const block of blocks) {
        blockHashMap[block.hash.toString()] = block;
    }
    const seenBlockHashes = new block_1.BlockHash.Set();
    const usedPreviousBlockHashes = new block_1.BlockHash.Set();
    const allLedgerHeads = new Map();
    for (const block of blocks) {
        const prevBlockHash = block.previous;
        seenBlockHashes.add(block.hash);
        if (block.network !== __classPrivateFieldGet(this, _LedgerAtomicInterface_network, "f")) {
            throw (new ledger_1.KeetaNetLedgerError('LEDGER_INVALID_NETWORK', 'Cannot vote on block for a different network'));
        }
        if (block.subnet !== __classPrivateFieldGet(this, _LedgerAtomicInterface_subnet, "f")) {
            throw (new ledger_1.KeetaNetLedgerError('LEDGER_INVALID_SUBNET', 'Cannot vote on block for a different subnet'));
        }
        if (usedPreviousBlockHashes.has(prevBlockHash)) {
            throw (new ledger_1.KeetaNetLedgerError('LEDGER_PREVIOUS_ALREADY_USED', `Invalid reference to block, previous: ${prevBlockHash} has already been used`));
        }
        usedPreviousBlockHashes.add(prevBlockHash);
        /**
         * Only allow this vote if it is the successor the current
         * HEAD block for the account, or if no blocks exist on the
         * account and its an opening block, or if the predecessor
         * block is also being voted on
         */
        let predecessorBeingVotedOn = false;
        if (!block.$opening) {
            const prevBlock = blockHashMap[prevBlockHash.toString()];
            if (prevBlock !== undefined) {
                predecessorBeingVotedOn = true;
                if (!(prevBlock.account.comparePublicKey(block.account))) {
                    throw (new ledger_1.KeetaNetLedgerError('LEDGER_INVALID_CHAIN', 'Invalid chain, changes accounts'));
                }
                if (!seenBlockHashes.has(prevBlockHash)) {
                    throw (new ledger_1.KeetaNetLedgerError('LEDGER_PREVIOUS_NOT_SEEN', `Invalid reference to block, out-of-order: ${prevBlockHash} has not already been seen`));
                }
            }
        }
        if (!predecessorBeingVotedOn) {
            allLedgerHeads.set(block.account, block);
        }
    }
    return (allLedgerHeads);
}, _LedgerAtomicInterface_voteOrQuoteWithFees = async function _LedgerAtomicInterface_voteOrQuoteWithFees(blocks, type, quote) {
    if (__classPrivateFieldGet(this, _LedgerAtomicInterface_ledger, "f").ledgerWriteMode !== 'read-write') {
        throw (new Error(`May not issue votes in read-only mode, in ${__classPrivateFieldGet(this, _LedgerAtomicInterface_ledger, "f").ledgerWriteMode} mode`));
    }
    if (!__classPrivateFieldGet(this, _LedgerAtomicInterface_privateKey, "f")) {
        throw (new Error('Cannot vote on block, no private key loaded'));
    }
    __classPrivateFieldGet(this, _LedgerAtomicInterface_instances, "m", _LedgerAtomicInterface_assertTransaction).call(this);
    const effects = await __classPrivateFieldGet(this, _LedgerAtomicInterface_instances, "m", _LedgerAtomicInterface_validateLedgerOutcome).call(this, blocks);
    const now = Date.now();
    for (const block of blocks) {
        const blockDate = block.date.valueOf();
        const timeOffset = 5 /* m */ * 60 /* s */ * 1000 /* ms */;
        /**
         * Do not allow short votes on blocks from the distant past
         */
        if (blockDate < (now - timeOffset) || blockDate > (now + timeOffset)) {
            throw (new Error(`Refusing to issue vote for block dated ${block.date.toISOString()}`));
        }
    }
    /**
     * Serial number
     */
    const serial = await __classPrivateFieldGet(this, _LedgerAtomicInterface_storage, "f").getNextSerialNumber(__classPrivateFieldGet(this, _LedgerAtomicInterface_transaction, "f"));
    /**
     * Short expiry (5 minutes)
     */
    const pendingVoteExpiry = new Date();
    pendingVoteExpiry.setUTCMinutes(pendingVoteExpiry.getUTCMinutes() + 5);
    const builderType = (type === 'QUOTE') ? vote_1.VoteQuoteBuilder : vote_1.VoteBuilder;
    const builder = new builderType(__classPrivateFieldGet(this, _LedgerAtomicInterface_privateKey, "f"));
    for (const block of blocks) {
        builder.addBlock(block);
    }
    /**
     * If a quote was provided use it as the fee, otherwise generate new fee
     */
    const fee = quote?.fee ?? await this.getFee(blocks, effects);
    if (fee !== null) {
        builder.addFee(fee);
    }
    const voteOrQuote = await builder.seal(serial, pendingVoteExpiry);
    return (voteOrQuote);
};
/**
 * The core Ledger components
 */
class Ledger {
    constructor(config, node, existingStorage) {
        _Ledger_storage.set(this, void 0);
        _Ledger_config.set(this, void 0);
        __classPrivateFieldSet(this, _Ledger_config, { ...config }, "f");
        const { baseToken, networkAddress } = account_1.default.generateBaseAddresses(config.network);
        this.networkAddress = networkAddress;
        this.baseToken = baseToken;
        this.initialTrustedAccount = config.initialTrustedAccount;
        this.node = node;
        if (config.kind === LedgerKind.REPRESENTATIVE) {
            if (config.privateKey === undefined) {
                throw (new Error('A private key must be provided if this is a Ledger for a representative'));
            }
        }
        if (existingStorage !== undefined) {
            __classPrivateFieldSet(this, _Ledger_storage, existingStorage, "f");
            return;
        }
        __classPrivateFieldSet(this, _Ledger_storage, config.storageDriver, "f");
        __classPrivateFieldGet(this, _Ledger_storage, "f").init(__classPrivateFieldGet(this, _Ledger_config, "f"), this);
    }
    get ledgerWriteMode() {
        const retval = __classPrivateFieldGet(this, _Ledger_config, "f").ledgerWriteMode;
        if (retval === undefined) {
            return ('read-write');
        }
        return (retval);
    }
    copy(newNode) {
        return (new Ledger(__classPrivateFieldGet(this, _Ledger_config, "f"), newNode, __classPrivateFieldGet(this, _Ledger_storage, "f")));
    }
    getFeePayToAndToken(accounts, token) {
        const retval = {};
        if (accounts !== undefined && accounts.length > 0) {
            // Get a random fee account from the set of possible accounts
            const feeAccount = accounts[Math.floor(Math.random() * accounts.length)];
            // If the fee account matches the ledger private key then we can omit the account
            // Fee is then paid to the vote issuer
            if (!feeAccount.comparePublicKey(__classPrivateFieldGet(this, _Ledger_config, "f").privateKey?.publicKeyString.get())) {
                retval.payTo = feeAccount;
            }
        }
        if (token !== undefined) {
            // If base token matches ledger fee token then we can omit the token
            // Fee is then paid using the base token
            if (!this.baseToken.comparePublicKey(token)) {
                retval.token = token;
            }
        }
        return (retval);
    }
    /**
     * Execute some code with a transaction held, if the code fails the
     * transaction is aborted, otherwise it is committed
     *
     * @param code - Code to run
     * @returns The return value from "code"
     */
    async run(identifier, code, readOnly) {
        const env_1 = { stack: [], error: void 0, hasError: false };
        try {
            const _timing = __addDisposableResource(env_1, this.node?.timing.startTime(`run-${identifier}`), false);
            let retryConfig;
            if (__classPrivateFieldGet(this, _Ledger_config, "f").transactionRetries?.maxRetries !== undefined) {
                retryConfig = {
                    mode: 'count',
                    maxRetries: __classPrivateFieldGet(this, _Ledger_config, "f").transactionRetries.maxRetries
                };
            }
            else if (__classPrivateFieldGet(this, _Ledger_config, "f").transactionRetries?.timeout !== undefined) {
                retryConfig = {
                    mode: 'time',
                    timeout: __classPrivateFieldGet(this, _Ledger_config, "f").transactionRetries.timeout
                };
            }
            else {
                /* Legacy default */
                // retryConfig = {
                // 	mode: 'count',
                // 	maxCount: 128
                // };
                retryConfig = {
                    mode: 'time',
                    timeout: 5000
                };
            }
            let retval;
            let retryCount = 0;
            const startTime = Date.now();
            for (;; retryCount++) {
                try {
                    let runError;
                    let threw = false;
                    const transaction = await this.beginTransaction(identifier, readOnly);
                    try {
                        retval = await code(transaction);
                    }
                    catch (e) {
                        threw = true;
                        runError = e;
                    }
                    // If running code was successful, commit, otherwise abort and throw error
                    if (threw === false) {
                        await timing_1.RequestTiming.runTimer(`${identifier}/commit`, this.node?.timing, async () => {
                            await transaction.commit();
                        });
                    }
                    else {
                        await timing_1.RequestTiming.runTimer(`${identifier}/abort`, this.node?.timing, async () => {
                            await transaction.abort();
                        });
                        throw (runError);
                    }
                }
                catch (runError) {
                    const txnError = await __classPrivateFieldGet(this, _Ledger_storage, "f").evaluateError(runError);
                    let shouldTryToRetry = false;
                    if (retryConfig.mode === 'count') {
                        shouldTryToRetry = retryCount < retryConfig.maxRetries;
                    }
                    else if (retryConfig.mode === 'time') {
                        const now = Date.now();
                        shouldTryToRetry = (now - startTime) < retryConfig.timeout;
                    }
                    if (shouldTryToRetry) {
                        if (ledger_1.KeetaNetLedgerError.isInstance(txnError)) {
                            if (txnError.shouldRetry) {
                                let retryDelay = 20;
                                if (txnError.retryDelay) {
                                    retryDelay = txnError.retryDelay;
                                }
                                await (0, helper_1.asleep)(retryDelay);
                                continue;
                            }
                        }
                    }
                    throw (txnError);
                }
                break;
            }
            if (retval === undefined) {
                throw (new Error('Return value for run() is undefined'));
            }
            this.node?.stats.incr('ledger', 'dbRetries', retryCount);
            return (retval);
        }
        catch (e_1) {
            env_1.error = e_1;
            env_1.hasError = true;
        }
        finally {
            __disposeResources(env_1);
        }
    }
    async runReadOnly(identifier, code) {
        return (await this.run(identifier, code, true));
    }
    async beginTransaction(identifier, readOnly = false) {
        const transaction = await __classPrivateFieldGet(this, _Ledger_storage, "f").beginTransaction({ node: this.node, moment: new Date(), identifier, readOnly });
        return (new LedgerAtomicInterface(transaction, __classPrivateFieldGet(this, _Ledger_storage, "f"), __classPrivateFieldGet(this, _Ledger_config, "f"), this));
    }
    async vote(...args) {
        return (await this.run('db-vote', async function (transaction) {
            return (await transaction.vote(...args));
        }));
    }
    async quote(...args) {
        return (await this.run('db-quote', async function (transaction) {
            return (await transaction.quote(...args));
        }));
    }
    async add(...args) {
        return (await this.run('db-add', async function (transaction) {
            return (await transaction.add(...args));
        }));
    }
    async listACLsByPrincipal(...args) {
        return (await this.runReadOnly('db-listACLs', async function (transaction) {
            return (await transaction.listACLsByPrincipal(...args));
        }));
    }
    async listACLsByEntity(...args) {
        return (await this.runReadOnly('db-listACLs', async function (transaction) {
            return (await transaction.listACLsByEntity(...args));
        }));
    }
    async getBalance(...args) {
        return (await this.runReadOnly('db-getBalance', async function (transaction) {
            return (await transaction.getBalance(...args));
        }));
    }
    async getAllBalances(...args) {
        return (await this.runReadOnly('db-getAllBalances', async function (transaction) {
            return (await transaction.getAllBalances(...args));
        }));
    }
    async getAccountCertificates(...args) {
        return (await this.runReadOnly('db-getAccountCertificates', async function (transaction) {
            return (await transaction.getAccountCertificates(...args));
        }));
    }
    async getAccountCertificateByHash(...args) {
        return (await this.runReadOnly('db-getAccountCertificateByHash', async function (transaction) {
            return (await transaction.getAccountCertificateByHash(...args));
        }));
    }
    async votingPower(...args) {
        return (await this.runReadOnly('db-votingPower', async function (transaction) {
            return (await transaction.votingPower(...args));
        }));
    }
    async getVotes(...args) {
        return (await this.runReadOnly('db-getVotes', async function (transaction) {
            return (await transaction.getVotes(...args));
        }));
    }
    async getVotesFromMultiplePrevious(...args) {
        return (await this.runReadOnly('db-getVotesFromMultiplePrevious', async function (transaction) {
            return (await transaction.getVotesFromMultiplePrevious(...args));
        }));
    }
    async getBlockFromPrevious(...args) {
        return (await this.runReadOnly('db-getBlockFromPrevious', async function (transaction) {
            return (await transaction.getBlockFromPrevious(...args));
        }));
    }
    async getHeadBlocks(...args) {
        return (await this.runReadOnly('db-getHeadBlocks', async function (transaction) {
            return (await transaction.getHeadBlocks(...args));
        }));
    }
    async getHeadBlock(...args) {
        return (await this.runReadOnly('db-getHeadBlock', async function (transaction) {
            return (await transaction.getHeadBlock(...args));
        }));
    }
    async getAccountRep(...args) {
        return (await this.runReadOnly('db-getAccountRep', async function (transaction) {
            return (await transaction.getAccountRep(...args));
        }));
    }
    async getAccountInfo(...args) {
        return (await this.runReadOnly('db-getAccountInfo', async function (transaction) {
            return (await transaction.getAccountInfo(...args));
        }));
    }
    async getBlock(...args) {
        return (await this.runReadOnly('db-getBlock', async function (transaction) {
            return (await transaction.getBlock(...args));
        }));
    }
    async getAccountsBlockHeightInfo(...args) {
        return (await this.runReadOnly('db-getAccountsBlockHeightInfo', async function (transaction) {
            return (await transaction.getAccountsBlockHeightInfo(...args));
        }));
    }
    async getVoteStaple(...args) {
        return (await this.runReadOnly('db-getVoteStaple', async function (transaction) {
            return (await transaction.getVoteStaple(...args));
        }));
    }
    async getVoteStaples(...args) {
        return (await this.runReadOnly('db-getVoteStaples', async function (transaction) {
            return (await transaction.getVoteStaples(...args));
        }));
    }
    async getHistory(...args) {
        return (await this.runReadOnly('db-getHistory', async function (transaction) {
            return (await transaction.getHistory(...args));
        }));
    }
    async getStaplesFromBlockHashes(...args) {
        return (await this.runReadOnly('db-getStaplesFromBlockHashes', async function (transaction) {
            return (await transaction.getStaplesFromBlockHashes(...args));
        }));
    }
    async getVoteStaplesAfter(...args) {
        return (await this.runReadOnly('db-getVoteStaplesAfter', async function (transaction) {
            return (await transaction.getVoteStaplesAfter(...args));
        }));
    }
    async gc(...args) {
        return (await this.run('db-gc', async function (transaction) {
            return (await transaction.gc(...args));
        }));
    }
    async getFee(...args) {
        return (await this.runReadOnly('db-getFee', async function (transaction) {
            return (await transaction.getFee(...args));
        }));
    }
    async stats() {
        const env_2 = { stack: [], error: void 0, hasError: false };
        try {
            const _timing = __addDisposableResource(env_2, this.node?.timing.startTime('db-stats'), false);
            const retval = await __classPrivateFieldGet(this, _Ledger_storage, "f").stats();
            return (retval);
        }
        catch (e_2) {
            env_2.error = e_2;
            env_2.hasError = true;
        }
        finally {
            __disposeResources(env_2);
        }
    }
    async _testingRunStorageFunction(code) {
        return (await this.run('db-runStorageFunction', async function (transaction) {
            return (await transaction._testingRunStorageFunction(code));
        }));
    }
}
exports.Ledger = Ledger;
_Ledger_storage = new WeakMap(), _Ledger_config = new WeakMap();
Ledger.Kind = LedgerKind;
Ledger.isInstance = (0, helper_1.checkableGenerator)(Ledger);
exports["default"] = Ledger;


/***/ }),

/***/ 5337:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Node = exports.NodeKind = void 0;
const ledger_1 = __importDefault(__webpack_require__(4796));
const account_1 = __importDefault(__webpack_require__(9415));
const stats_1 = __webpack_require__(2127);
const p2p_1 = __webpack_require__(7074);
const vote_1 = __webpack_require__(1130);
const timing_1 = __importDefault(__webpack_require__(2895));
const helper_1 = __webpack_require__(3208);
const Config = __importStar(__webpack_require__(1491));
const helper_2 = __webpack_require__(3208);
var NodeKind;
(function (NodeKind) {
    NodeKind[NodeKind["PARTICIPANT"] = 0] = "PARTICIPANT";
    NodeKind[NodeKind["REPRESENTATIVE"] = 1] = "REPRESENTATIVE";
    NodeKind[NodeKind["RELAY"] = 2] = "RELAY";
    NodeKind[NodeKind["ARCHIVAL"] = 3] = "ARCHIVAL";
})(NodeKind || (exports.NodeKind = NodeKind = {}));
class Node {
    static getDefaultConfig(network) {
        const config = Config.getDefaultConfig(network);
        return ({
            kind: NodeKind.REPRESENTATIVE,
            ...config
        });
    }
    static main(config) {
        const node = new this(config);
        node.run().then(function () {
            process.exit(0);
        }, function (error) {
            console.error(error);
            process.exit(1);
        });
    }
    constructor(configOrNode) {
        this.log = {
            debug: (from, ...message) => {
                return ((0, helper_2.internalLogger)(this.config?.nodeAlias, 'debug', from, ...message));
            },
            error: (from, ...message) => {
                return ((0, helper_2.internalLogger)(this.config?.nodeAlias, 'error', from, ...message));
            }
        };
        this.timing = new timing_1.default();
        if (Node.isInstance(configOrNode, false)) {
            const node = configOrNode;
            this.config = node.config;
            this.baseToken = node.baseToken;
            this.networkAddress = node.networkAddress;
            this.ledger = node.ledger.copy(this);
            this.switch = node.switch;
            this.stats = node.stats;
            return;
        }
        const config = configOrNode;
        this.log.debug('node', 'Starting up');
        const { networkAddress, baseToken } = account_1.default.generateBaseAddresses(config.network);
        this.networkAddress = networkAddress;
        this.baseToken = baseToken;
        /* XXX:TODO: Compute ledger kind from node kind */
        const ledgerKind = ledger_1.default.Kind.REPRESENTATIVE;
        this.config = config;
        const initialTrustedAccount = config.initialTrustedAccount;
        if (initialTrustedAccount.hasPrivateKey) {
            throw (new Error('There is no reason for us to have the private key in setup of the initialTrustedAccount'));
        }
        this.ledger = new ledger_1.default({
            privateKey: config.ledgerPrivateKey,
            network: config.network,
            subnet: config.subnet,
            initialTrustedAccount: config.initialTrustedAccount,
            kind: ledgerKind,
            log: (...args) => {
                this.log.debug('ledger', ...args);
            },
            ...config.ledger
        }, this);
        this.switch = new p2p_1.P2PSwitch(this);
        this.stats = new stats_1.Stats(config.stats);
        const manualPeers = config.manualPeers;
        if (manualPeers !== undefined) {
            for (const manualPeer of manualPeers) {
                this.log.debug('node', 'Registering manual peer:', manualPeer);
                this.switch.addManualPeer(manualPeer);
            }
        }
    }
    copy() {
        return (new Node(this));
    }
    async run() {
        if (this.config.ledgerPrivateKey === undefined) {
            throw (new Error('internal error: Private key not loaded'));
        }
        this.log.debug('node', 'Network :', this.config.network, `(${this.config.networkAlias})`);
        this.log.debug('node', 'Network Address:', this.networkAddress.publicKeyString.get());
        this.log.debug('node', 'Base Token:', this.baseToken.publicKeyString.get());
        this.log.debug('node', 'Rep ID  :', this.config.ledgerPrivateKey.publicKeyString.get());
        this.log.debug('node', 'Initial Trusted Account  :', this.config.initialTrustedAccount.publicKeyString.get());
    }
    async stop() {
        await this.sync();
        await this.switch.stop();
    }
    async sync() {
        await Promise.all([
            this.stats.sync(),
            this.switch.wait()
        ]);
    }
    async addToLedger(votesAndBlocks, broadcast = true) {
        // Get hashes added from the provided staple
        // Since it wont always be the same as the staple blocks
        const createdStaples = await this.ledger.add(votesAndBlocks);
        if (createdStaples.length === 0) {
            return (false);
        }
        const passedInStapleHash = votesAndBlocks.blocksHash;
        let gotSameStaple = false;
        for (const createdStaple of createdStaples) {
            // Check if the passed in staple matches any of the staples we created
            const createdStapleHash = createdStaple.blocksHash;
            const isPassedIn = passedInStapleHash.compare(createdStapleHash);
            if (isPassedIn) {
                gotSameStaple = true;
            }
            if (broadcast || !isPassedIn) {
                // Send the created staple to our peers
                const messageID = createdStapleHash.toString();
                const createdStapleString = Buffer.from(createdStaple.toBytes()).toString('base64');
                await this.sendMessage(messageID, 'add', createdStapleString, 30);
            }
        }
        return (gotSameStaple);
    }
    async recvMessageFromPeer(from, id, type, data, ttl) {
        /**
         * Handle the message locally
         */
        this.log.debug('node', 'Handling message', { id, type, data, ttl }, 'from', from.peerString);
        switch (type) {
            case 'add':
                {
                    if (typeof data !== 'string') {
                        throw (new Error('Data must be a base64 encoded VoteStaple'));
                    }
                    const voteStaple = new vote_1.VoteStaple(data);
                    let addedToLedger = false;
                    try {
                        addedToLedger = await this.addToLedger(voteStaple, false);
                    }
                    catch (ledgerAddError) {
                        this.log.error('node', 'Error while adding to ledger:', ledgerAddError);
                        addedToLedger = false;
                    }
                    /**
                     * Do not rebroadcast if we cannot add it to our ledger
                     */
                    if (!addedToLedger) {
                        return (false);
                    }
                    // Sync stats
                    await this.sync();
                }
                break;
            case 'peer':
                /* Just rebroadcast peer information */
                break;
            case 'test':
                /* Just rebroadcast test information */
                break;
            default:
                return (false);
        }
        /**
         * Rebroadcast the message
         */
        if (ttl === undefined) {
            return (false);
        }
        /**
         * If the TTL is 0, do not rebroadcast the message
         */
        if (ttl < 1) {
            return (false);
        }
        /**
         * We don't keep track of the result of this promise
         */
        try {
            await this.sendMessage(id, type, data, ttl - 1, [from]);
        }
        catch (sendError) {
            this.log.debug('node', 'Failed to send message ID', id, sendError);
        }
        return (true);
    }
    async sendMessage(id, type, data, ttl, exclude) {
        if (this.config.callbacks && this.config.callbacks.sendMessage) {
            return (await this.config.callbacks.sendMessage(this, null, id, type, data, ttl, exclude));
        }
        else {
            return (await this.switch.sendMessage(null, id, type, data, ttl, exclude));
        }
    }
}
exports.Node = Node;
Node.Kind = NodeKind;
Node.isInstance = (0, helper_1.checkableGenerator)(Node);
exports["default"] = Node;


/***/ }),

/***/ 2895:
/***/ (function(__unused_webpack_module, exports) {

"use strict";

var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var _RequestTiming_timing, _RequestTiming_counter;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RequestTiming = void 0;
/**
 * Support the old way of doing timing where the callers could call
 * startTime/endTime with the same string to terminate a timing section
 *
 * This has been changed so that startTime returns a handle which
 * can be used to end the timing section, but some code may still
 * rely on the old way of doing things.
 *
 * Once those have been updated, this can be removed and the code cleaned up.
 */
const SUPPORT_LEGACY_TIMING = true;
class RequestTiming {
    constructor() {
        _RequestTiming_timing.set(this, new Map());
        _RequestTiming_counter.set(this, 0);
        this.log = RequestTiming.defaultLogger;
    }
    /**
     * Start timing a section of code
     * @param section Name of the section to time -- should be unique within the code base so that it can be identified later
     * @returns A handle which can be used to end the timing section
     */
    startTime(section) {
        const id = Symbol(section);
        const data = {
            id: section,
            name: section,
            start: Date.now()
        };
        __classPrivateFieldGet(this, _RequestTiming_timing, "f").set(id, data);
        return ({
            id,
            end: () => {
                this.endTime(id);
            },
            [Symbol.dispose]: () => {
                this.endTime(id);
            }
        });
    }
    endTime(section, deduplicate = true) {
        if (section === undefined) {
            return;
        }
        if (typeof section === 'object' && section !== null && 'id' in section && 'end' in section) {
            section = section.id;
        }
        if (typeof section === 'symbol') {
            const timingInfo = __classPrivateFieldGet(this, _RequestTiming_timing, "f").get(section);
            if (timingInfo === undefined) {
                this.log.error(`Timing section ${String(section)} does not exist but "end" was called on it!`);
                return;
            }
            if (timingInfo.end !== undefined) {
                this.log.error(`Timing section ${timingInfo.id} already ended but "end" was called on it again!`);
                return;
            }
            timingInfo.end = Date.now();
            /*
             * Suffix the name with a counter to avoid duplicates
             * We couldn't do this initially because legacy timing
             * sections look up based on the ID
             */
            timingInfo.id = `${timingInfo.id}-${this.counter()}`;
            return;
        }
        if (!SUPPORT_LEGACY_TIMING) {
            throw (new Error('Legacy timing support is not enabled'));
        }
        const existingEntry = (() => {
            for (const value of __classPrivateFieldGet(this, _RequestTiming_timing, "f").values()) {
                if (value.id === section) {
                    return (value);
                }
            }
        })();
        if (!existingEntry) {
            this.log.error(`Timing section ${section} does not exist but "end" was called on it!`);
            return;
        }
        existingEntry.end = Date.now();
        if (deduplicate) {
            /*
             * Give this finalized timing a unique name to avoid duplicates
             */
            const newID = `${existingEntry.id}-${this.counter()}`;
            existingEntry.id = newID;
        }
    }
    /**
     * Run a piece of code and time it, returning the result of the code
     *
     * This takes an optional "timing" parameter which is a timing object
     * if one exists, to update -- if this parameter is undefined no timing
     * will be done.
     *
     * @param section Name of the section to time -- should be unique within the code base so that it can be identified later
     * @param timing Timing object to update, if available
     * @param code The code to run
     * @returns The result of the code
     */
    static async runTimer(section, timing, code) {
        if (timing) {
            return (await timing.runTimer(section, code));
        }
        else {
            return (await code());
        }
    }
    async runTimer(section, code) {
        const id = this.startTime(section);
        try {
            return (await code());
        }
        finally {
            this.endTime(id);
        }
    }
    getTiming(section) {
        const sectionInfo = __classPrivateFieldGet(this, _RequestTiming_timing, "f").get(section);
        if (sectionInfo === undefined) {
            return (undefined);
        }
        const { start, end } = sectionInfo;
        if (start === undefined || end === undefined) {
            return (undefined);
        }
        const duration = end - start;
        return ({
            name: sectionInfo.name,
            duration: duration
        });
    }
    getAllTiming() {
        const retval = {};
        for (const section of __classPrivateFieldGet(this, _RequestTiming_timing, "f").keys()) {
            const newSection = __classPrivateFieldGet(this, _RequestTiming_timing, "f").get(section)?.id ?? `${String(section)}${this.counter()}`;
            const sectionTimingData = this.getTiming(section);
            if (sectionTimingData === undefined) {
                continue;
            }
            retval[newSection] = sectionTimingData;
        }
        return (retval);
    }
    counter() {
        var _a, _b;
        return (__classPrivateFieldSet(this, _RequestTiming_counter, (_b = __classPrivateFieldGet(this, _RequestTiming_counter, "f"), _a = _b++, _b), "f"), _a);
    }
}
exports.RequestTiming = RequestTiming;
_RequestTiming_timing = new WeakMap(), _RequestTiming_counter = new WeakMap();
RequestTiming.defaultLogger = console;
exports["default"] = RequestTiming;


/***/ }),

/***/ 7074:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __addDisposableResource = (this && this.__addDisposableResource) || function (env, value, async) {
    if (value !== null && value !== void 0) {
        if (typeof value !== "object" && typeof value !== "function") throw new TypeError("Object expected.");
        var dispose, inner;
        if (async) {
            if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
            dispose = value[Symbol.asyncDispose];
        }
        if (dispose === void 0) {
            if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
            dispose = value[Symbol.dispose];
            if (async) inner = dispose;
        }
        if (typeof dispose !== "function") throw new TypeError("Object not disposable.");
        if (inner) dispose = function() { try { inner.call(this); } catch (e) { return Promise.reject(e); } };
        env.stack.push({ value: value, dispose: dispose, async: async });
    }
    else if (async) {
        env.stack.push({ async: true });
    }
    return value;
};
var __disposeResources = (this && this.__disposeResources) || (function (SuppressedError) {
    return function (env) {
        function fail(e) {
            env.error = env.hasError ? new SuppressedError(e, env.error, "An error was suppressed during disposal.") : e;
            env.hasError = true;
        }
        var r, s = 0;
        function next() {
            while (r = env.stack.pop()) {
                try {
                    if (!r.async && s === 1) return s = 0, env.stack.push(r), Promise.resolve().then(next);
                    if (r.dispose) {
                        var result = r.dispose.call(r.value);
                        if (r.async) return s |= 2, Promise.resolve(result).then(next, function(e) { fail(e); return next(); });
                    }
                    else s |= 1;
                }
                catch (e) {
                    fail(e);
                }
            }
            if (s === 1) return env.hasError ? Promise.reject(env.error) : Promise.resolve();
            if (env.hasError) throw env.error;
        }
        return next();
    };
})(typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
    var e = new Error(message);
    return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
});
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var _P2PHttpConnection_switch, _P2PWebSocket_underlyingSocket, _P2PWebSocket_socket, _P2PWebSocket_switch, _P2PSwitch_instances, _P2PSwitch_connectedPeersCleanup, _P2PSwitch_connectedPeersRemote, _P2PSwitch_connectedPeersLocal, _P2PSwitch_localNode, _P2PSwitch_manualPeersCheckIntervals, _P2PSwitch_asyncSends, _P2PSwitch_messageFilterCache, _P2PSwitch_cachedLocalPeerInfo, _P2PSwitch_cachedLocalPeerSerialized, _P2PSwitch_connectedPeerConnection, _P2PSwitch_connectedPeers, _P2PSwitch_updateLastSeenPeer, _P2PSwitch_peersCacheSet, _P2PSwitch_peersCached, _P2PSwitch_relayActiveState, _P2PSwitch_performPeerCleanup, _P2PSwitch_getLocalPeerInfo, _P2PSwitch_emitOutgoingGreeting, _P2PSwitch_localNodeKeyOrNull, _P2PSwitch_handleIncomingGreeting, _P2PSwitch_updateConnTimeout, _P2PSwitch_connectToPeer, _P2PSwitch_passesFilter;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Testing = exports.P2PSwitch = exports.P2PWebSocket = exports.P2PHttpConnection = void 0;
exports.generateP2PPeerSigned = generateP2PPeerSigned;
exports.P2PPeerFromJSO = P2PPeerFromJSO;
exports.P2PPeerToJSO = P2PPeerToJSO;
exports.randomizeReps = randomizeReps;
exports.formatRepEndpoints = formatRepEndpoints;
const uuid = __importStar(__webpack_require__(5827));
const ws_1 = __webpack_require__(7699);
const util_1 = __webpack_require__(9023);
const node_1 = __importStar(__webpack_require__(5337));
const account_1 = __importDefault(__webpack_require__(9415));
const hash_1 = __webpack_require__(7908);
const asn1_1 = __webpack_require__(6045);
const helper_1 = __webpack_require__(3208);
const kv_memory_1 = __importDefault(__webpack_require__(1557));
const vote_1 = __webpack_require__(1130);
const effects_1 = __webpack_require__(7346);
const version_1 = __webpack_require__(5672);
const defaultP2PConfig = {
    timeoutIdle: 10 /* s */ * 1000 /* ms */,
    timeoutIdleGreeting: 5 /* s */ * 1000 /* ms */,
    timeoutIdleListener: 10 /* m */ * 60 /* s */ * 1000 /* ms */,
    timeoutIdleCheck: 1 /* s */ * 1000 /* ms */,
    manualPeersCheckInFreq: 10 /* m */ * 60 /* s */ * 1000 /* ms */,
    seenMessageTTL: 1 /* m */ * 60 /* s */ * 1000 /* ms */,
    forwardingPeerCount: 16,
    kv: null,
    useHTTPRepublish: false
};
/**
 * Convert a peer to a printable string
 */
function printablePeer(peer, endpoint) {
    if (peer === null) {
        return ('null (not yet greeted)');
    }
    switch (peer.kind) {
        case node_1.NodeKind.PARTICIPANT:
            return (`listener_${peer.id}`);
        case node_1.NodeKind.REPRESENTATIVE:
            return (`rep_${peer.key.publicKeyString.get()}@${endpoint ?? peer.endpoints.p2p}`);
    }
    return (null);
}
function validateP2PPeer(peer) {
    switch (peer.kind) {
        case node_1.NodeKind.REPRESENTATIVE:
            {
                if ('certificate' in peer) {
                    /* XXX:TODO */
                    return (false);
                }
                if ('signature' in peer) {
                    const signatureWrapperJS = (0, asn1_1.ASN1toJS)(peer.signature);
                    if (!Array.isArray(signatureWrapperJS)) {
                        return (false);
                    }
                    if (signatureWrapperJS.length !== 2) {
                        return (false);
                    }
                    const [checkVersion, checkSignature] = signatureWrapperJS;
                    if (typeof checkVersion !== 'bigint' && typeof checkVersion !== 'number') {
                        return (false);
                    }
                    if (BigInt(checkVersion) !== 0n) {
                        return (false);
                    }
                    if (!Buffer.isBuffer(checkSignature)) {
                        return (false);
                    }
                    const toVerifyJS = [
                        checkVersion,
                        peer.endpoints.p2p,
                        peer.endpoints.api,
                        peer.preferUpdates,
                        peer.kind,
                        peer.key.publicKeyAndType
                    ];
                    const toVerify = (0, asn1_1.JStoASN1)(toVerifyJS).toBER();
                    const verification = peer.key.verify(toVerify, checkSignature);
                    return (verification);
                }
            }
            return (false);
        case node_1.NodeKind.PARTICIPANT:
            return (undefined);
    }
    return (undefined);
}
async function generateP2PPeerSignature(peer) {
    switch (peer.kind) {
        case node_1.NodeKind.REPRESENTATIVE:
            {
                const version = 0;
                const toSignJS = [
                    version,
                    peer.endpoints.p2p,
                    peer.endpoints.api,
                    peer.preferUpdates,
                    peer.kind,
                    peer.key.publicKeyAndType
                ];
                const toSign = (0, asn1_1.JStoASN1)(toSignJS).toBER();
                const signature = await peer.key.sign(toSign);
                const signatureWrapperJS = [version, signature.getBuffer()];
                const signatureWrapper = (0, asn1_1.JStoASN1)(signatureWrapperJS).toBER();
                return (signatureWrapper);
            }
        case node_1.NodeKind.PARTICIPANT:
            return (null);
    }
    return (null);
}
async function generateP2PPeerSigned(peer) {
    if (peer.kind === node_1.NodeKind.PARTICIPANT) {
        return (peer);
    }
    const signature = await generateP2PPeerSignature(peer);
    if (signature === null) {
        throw (new Error('Unable to generate signature'));
    }
    const retval = {
        ...peer,
        signature
    };
    return (retval);
}
function P2PPeerFromJSO(object) {
    if (object === undefined || object === null) {
        return (null);
    }
    if (!(object instanceof Object)) {
        return (null);
    }
    if (object.kind === undefined) {
        return (null);
    }
    switch (object.kind) {
        case node_1.NodeKind.REPRESENTATIVE:
            {
                const endpoints = object.endpoints;
                if (typeof endpoints !== 'object') {
                    return (null);
                }
                if (!('p2p' in endpoints) || !('api' in endpoints)) {
                    return (null);
                }
                if (typeof endpoints.p2p !== 'string' || typeof endpoints.api !== 'string') {
                    return (null);
                }
                if (typeof object.preferUpdates !== 'string') {
                    return (null);
                }
                if (object.preferUpdates !== 'http' && object.preferUpdates !== 'websocket') {
                    return (null);
                }
                if (typeof object.key !== 'string') {
                    return (null);
                }
                const retvalUnsigned = {
                    kind: node_1.NodeKind.REPRESENTATIVE,
                    key: account_1.default.fromPublicKeyString(object.key).assertAccount(),
                    endpoints: endpoints,
                    preferUpdates: object.preferUpdates
                };
                let retval;
                if (typeof object.signature === 'string') {
                    try {
                        const signature = (0, helper_1.bufferToArrayBuffer)(Buffer.from(object.signature, 'base64'));
                        retval = {
                            ...retvalUnsigned,
                            signature
                        };
                    }
                    catch {
                        return (null);
                    }
                }
                else if (typeof object.certificate === 'string') {
                    retval = {
                        ...retvalUnsigned,
                        certificate: null
                    };
                }
                if (retval === undefined) {
                    return (null);
                }
                if (!validateP2PPeer(retval)) {
                    return (null);
                }
                // eslint-disable-next-line @typescript-eslint/no-use-before-define
                if (!isP2PPeer(retval)) {
                    throw (new Error('Invalid peer generated'));
                }
                return (retval);
            }
        case node_1.NodeKind.PARTICIPANT:
            return ({
                kind: node_1.NodeKind.PARTICIPANT,
                id: ''
            });
    }
    return (null);
}
function P2PPeerToJSO(peer) {
    switch (peer.kind) {
        case node_1.NodeKind.REPRESENTATIVE:
            {
                let additionalAttributes;
                if ('signature' in peer) {
                    additionalAttributes = {
                        signature: Buffer.from(peer.signature).toString('base64')
                    };
                    if (additionalAttributes.signature === '') {
                        throw (new Error('internal error: signature is required'));
                    }
                }
                else if ('certificate' in peer) {
                    additionalAttributes = {
                        certificate: peer.certificate
                    };
                }
                return ({
                    kind: peer.kind,
                    endpoints: peer.endpoints,
                    preferUpdates: peer.preferUpdates,
                    key: peer.key.publicKeyString.get(),
                    ...additionalAttributes
                });
            }
        case node_1.NodeKind.PARTICIPANT:
            return ({
                kind: peer.kind
            });
    }
}
function isP2PPeer(checkObject) {
    if (checkObject === undefined || checkObject === null) {
        return (false);
    }
    if (!(checkObject instanceof Object)) {
        return (false);
    }
    if (!('kind' in checkObject) || checkObject.kind === undefined) {
        return (false);
    }
    // eslint-disable-next-line @typescript-eslint/switch-exhaustiveness-check
    switch (checkObject.kind) {
        case node_1.NodeKind.REPRESENTATIVE:
            if (!('endpoints' in checkObject) || typeof checkObject.endpoints !== 'object') {
                return (false);
            }
            if (checkObject.endpoints === null) {
                return (false);
            }
            if (!('p2p' in checkObject.endpoints) || !('api' in checkObject.endpoints)) {
                return (false);
            }
            if (!('preferUpdates' in checkObject)) {
                return (false);
            }
            if (checkObject.preferUpdates !== 'http' && checkObject.preferUpdates !== 'websocket') {
                return (false);
            }
            if (!('key' in checkObject)) {
                return (false);
            }
            if (!account_1.default.isInstance(checkObject.key)) {
                return (false);
            }
            if ('signature' in checkObject) {
                if (!util_1.types.isArrayBuffer(checkObject.signature)) {
                    return (false);
                }
            }
            else if ('certificate' in checkObject) {
                if (checkObject.certificate !== null) {
                    return (false);
                }
            }
            else {
                return (false);
            }
            return (true);
        case node_1.NodeKind.PARTICIPANT:
            if (!('id' in checkObject) || typeof checkObject.id !== 'string') {
                return (false);
            }
            return (true);
    }
    return (false);
}
function isSerializedConnection(info) {
    if (!info || typeof info !== 'object' || Array.isArray(info)) {
        return (false);
    }
    if (typeof info.type !== 'string' || typeof info.data !== 'string') {
        return (false);
    }
    return (true);
}
/**
 * Create an ID for a peer
 */
function peerToID(peer) {
    switch (peer.kind) {
        case node_1.NodeKind.REPRESENTATIVE:
            return (peer.key.publicKeyString.get());
        case node_1.NodeKind.PARTICIPANT: {
            let randomID = '';
            while (randomID.length < 64) {
                const buffer = new Uint8Array(32);
                const randomData = crypto.getRandomValues(buffer);
                const hash = (0, hash_1.Hash)(Buffer.from(randomData));
                randomID += Buffer.from(hash).toString('hex');
            }
            const suffix = randomID.slice(0, 64);
            return (`listener_${suffix}`);
        }
        default:
            throw (new Error('Only REPRESENTATIVES and PARTICIPANTS supported for now'));
    }
}
function randomizeReps(reps) {
    const bias = uuid.v4();
    const randomReps = reps.sort(function (repA, repB) {
        const repAKey = repA.key.publicKeyAndTypeString;
        const repBKey = repB.key.publicKeyAndTypeString;
        const repAInValue = Buffer.from(`${bias}_${repAKey}`);
        const repBInValue = Buffer.from(`${bias}_${repBKey}`);
        const repAValueHex = Buffer.from((0, hash_1.Hash)(repAInValue)).toString('hex');
        const repBValueHex = Buffer.from((0, hash_1.Hash)(repBInValue)).toString('hex');
        const repAValue = BigInt(`0x${repAValueHex}`);
        const repBValue = BigInt(`0x${repBValueHex}`);
        if (repAValue < repBValue) {
            return (-1);
        }
        else if (repAValue > repBValue) {
            return (1);
        }
        else {
            return (0);
        }
    });
    return (randomReps);
}
function formatRepEndpoints(peers) {
    const reps = [];
    for (const peer of peers) {
        if (peer.kind === node_1.NodeKind.REPRESENTATIVE) {
            reps.push({
                key: peer.key,
                endpoints: peer.endpoints
            });
        }
    }
    return (reps);
}
/**
 * Wait for a peer to complete its greeting
 */
async function waitForPeer(conn) {
    return (await (new Promise((resolve) => {
        let tryIndex = 0;
        const interval = setInterval(() => {
            tryIndex++;
            if (conn.peer !== null || tryIndex > 500 || conn.abort) {
                clearInterval(interval);
                resolve(conn.peer);
            }
        }, 10);
    })));
}
class P2PHttpConnection {
    /**
     * Initiate an outbound http connection and attach it to the specified switch
     */
    static async initiate(peer, p2pSwitch) {
        if (!('endpoints' in peer)) {
            return (null);
        }
        if (!('api' in peer.endpoints)) {
            return (null);
        }
        if (!('preferUpdates' in peer) || peer.preferUpdates !== 'http') {
            return (null);
        }
        const conn = new P2PHttpConnection(peer, p2pSwitch);
        await p2pSwitch.registerConnection(conn);
        return (conn);
    }
    constructor(peer, p2pSwitch) {
        _P2PHttpConnection_switch.set(this, void 0);
        this.abort = false;
        this.validatedPeer = null;
        this.timeout = 0;
        this.peer = peer;
        __classPrivateFieldSet(this, _P2PHttpConnection_switch, p2pSwitch, "f");
    }
    get connString() {
        if (this.peerString === null) {
            throw (new Error('HTTP Connection should have a peerString'));
        }
        return (this.peerString);
    }
    get peerString() {
        if (this.peer.kind === node_1.NodeKind.PARTICIPANT) {
            throw (new Error('HTTP Connections cannot be participants'));
        }
        return (printablePeer(this.peer, this.peer.endpoints.api));
    }
    async send(messageBuffer) {
        if (this.peer.kind !== node_1.NodeKind.REPRESENTATIVE) {
            return (false);
        }
        __classPrivateFieldGet(this, _P2PHttpConnection_switch, "f")._log.debug(`Called send on http connection: ${this.peerString}`);
        const localGreetingInfo = await __classPrivateFieldGet(this, _P2PHttpConnection_switch, "f").getOutgoingGreetingInfo();
        const fetchURL = `${this.peer.endpoints.api}/p2p/message`;
        try {
            await fetch(fetchURL, {
                method: 'POST',
                headers: {
                    'content-type': 'application/json',
                    'user-agent': `KeetaNet/v${version_1.version} (JS)`
                },
                body: JSON.stringify({
                    message: messageBuffer.toString(),
                    greeting: localGreetingInfo
                })
            });
        }
        catch (postMessageError) {
            __classPrivateFieldGet(this, _P2PHttpConnection_switch, "f")._log.debug(`Failed to post message: ${postMessageError}`);
        }
        return (true);
    }
    async close() {
        this.abort = true;
        __classPrivateFieldGet(this, _P2PHttpConnection_switch, "f")._log.debug(`Called close on http connection: ${this.peerString}`);
        await __classPrivateFieldGet(this, _P2PHttpConnection_switch, "f").unregisterConnection(this);
    }
}
exports.P2PHttpConnection = P2PHttpConnection;
_P2PHttpConnection_switch = new WeakMap();
P2PHttpConnection.isInstance = (0, helper_1.checkableGenerator)(P2PHttpConnection);
/**
 * A P2PConnection using the "ws" package
 */
class P2PWebSocket {
    /**
     * Initiate an outbound websocket connection and attach it to the specified switch
     */
    static async initiate(peer, p2pSwitch) {
        if (!('endpoints' in peer)) {
            return (null);
        }
        if (!('p2p' in peer.endpoints)) {
            return (null);
        }
        let wsAttempt;
        try {
            wsAttempt = new ws_1.WebSocket(peer.endpoints.p2p);
        }
        catch (ignoredConnectError) {
            /* Ignore connection error */
        }
        if (wsAttempt === undefined) {
            return (null);
        }
        const ws = wsAttempt;
        const socketPromise = new Promise((resolve) => {
            let continueOpen = true;
            let timeoutHandle;
            /**
             * Function to fail connection
             */
            const failConnection = function () {
                if (!continueOpen) {
                    return;
                }
                timeoutHandle = null;
                continueOpen = false;
                try {
                    ws.close();
                }
                catch (ignoredError) {
                    /* We ignore this error */
                }
                resolve(null);
            };
            /**
             * After a timeout, do not proceed with the opening
             */
            timeoutHandle = setTimeout(failConnection, p2pSwitch.config.timeoutIdleGreeting);
            /**
             * Wait the connection to be established
             */
            ws.on('open', function () {
                /**
                 * Pause the websocket until we have an event
                 * handler established for it so we don't miss any messages
                 */
                ws.pause();
                if (timeoutHandle) {
                    clearTimeout(timeoutHandle);
                }
                if (!continueOpen) {
                    return;
                }
                continueOpen = false;
                resolve(ws);
            });
            ws.on('error', function () {
                if (timeoutHandle) {
                    clearTimeout(timeoutHandle);
                }
                failConnection();
            });
        });
        const socket = await socketPromise;
        if (socket === null) {
            return (null);
        }
        return (await P2PWebSocket.connectToSwitch(socket, p2pSwitch));
    }
    /**
     * Attach a new "ws" connection to the switch
     */
    static async connectToSwitch(socket, p2pSwitch, underlyingSocket) {
        const conn = new P2PWebSocket(socket, p2pSwitch, underlyingSocket);
        /**
         * Handle termination
         */
        socket.on('close', async () => {
            await p2pSwitch.unregisterConnection(conn);
        });
        socket.on('error', async () => {
            await p2pSwitch.unregisterConnection(conn);
        });
        if (socket.readyState !== socket.OPEN) {
            await new Promise((resolve) => {
                socket.on('open', async () => {
                    /**
                     * Register the connection
                     */
                    resolve(await p2pSwitch.registerConnection(conn));
                });
            });
        }
        else {
            await p2pSwitch.registerConnection(conn);
        }
        return (conn);
    }
    constructor(socket, p2pSwitch, underlyingSocket) {
        _P2PWebSocket_underlyingSocket.set(this, void 0);
        _P2PWebSocket_socket.set(this, void 0);
        _P2PWebSocket_switch.set(this, void 0);
        this.validatedPeer = null;
        if (socket === undefined) {
            throw (new Error('internal error: socket is required'));
        }
        if (p2pSwitch === undefined) {
            throw (new Error('internal error: p2pSwitch is required'));
        }
        __classPrivateFieldSet(this, _P2PWebSocket_socket, socket, "f");
        __classPrivateFieldSet(this, _P2PWebSocket_underlyingSocket, underlyingSocket, "f");
        this.peer = null;
        this.abort = false;
        __classPrivateFieldSet(this, _P2PWebSocket_switch, p2pSwitch, "f");
        this.timeout = Date.now() + 100000;
        __classPrivateFieldGet(this, _P2PWebSocket_socket, "f").on('message', async (data) => {
            if (!Array.isArray(data)) {
                data = [data];
            }
            for (const messageBuffer of data) {
                await __classPrivateFieldGet(this, _P2PWebSocket_switch, "f").recvMessageFromPeer(this, messageBuffer);
            }
        });
        __classPrivateFieldGet(this, _P2PWebSocket_socket, "f").on('close', async () => {
            this.abort = true;
            await this.close();
        });
        __classPrivateFieldGet(this, _P2PWebSocket_socket, "f").on('error', async (error) => {
            this.abort = true;
            __classPrivateFieldGet(this, _P2PWebSocket_switch, "f")._log.error('Peering error:', error);
            await this.close();
        });
        /**
         * Resume processing events from the websocket so we can
         * exchange datagrams
         */
        __classPrivateFieldGet(this, _P2PWebSocket_socket, "f").resume();
    }
    get connString() {
        let connID = __classPrivateFieldGet(this, _P2PWebSocket_socket, "f").url;
        if (connID === undefined) {
            if (__classPrivateFieldGet(this, _P2PWebSocket_underlyingSocket, "f")) {
                connID = `inboundws://${__classPrivateFieldGet(this, _P2PWebSocket_underlyingSocket, "f").remoteAddress}:${__classPrivateFieldGet(this, _P2PWebSocket_underlyingSocket, "f").remotePort}`;
            }
        }
        return (`${connID}@${this.peerString}`);
    }
    get peerString() {
        return (printablePeer(this.peer));
    }
    async send(messageBuffer) {
        const promise = new Promise((resolve) => {
            if (this.abort) {
                __classPrivateFieldGet(this, _P2PWebSocket_switch, "f")._log.error('Attempt to send to aborted connection', this.connString);
                resolve(false);
                return;
            }
            __classPrivateFieldGet(this, _P2PWebSocket_socket, "f").send(messageBuffer.toString('utf-8'), async (error) => {
                if (error) {
                    __classPrivateFieldGet(this, _P2PWebSocket_switch, "f")._log.error('Failed to send to', this.connString, error);
                    await this.close();
                    resolve(false);
                }
                else {
                    resolve(true);
                }
            });
        });
        return (await promise);
    }
    async close() {
        this.abort = true;
        try {
            __classPrivateFieldGet(this, _P2PWebSocket_socket, "f").close();
        }
        catch (_ignored_error) {
            /* We ignore this error */
        }
    }
}
exports.P2PWebSocket = P2PWebSocket;
_P2PWebSocket_underlyingSocket = new WeakMap(), _P2PWebSocket_socket = new WeakMap(), _P2PWebSocket_switch = new WeakMap();
P2PWebSocket.isInstance = (0, helper_1.checkableGenerator)(P2PWebSocket);
/**
 * Shuffle an array's order
 */
function shuffleArray(input) {
    const length = input.length;
    const output = new Array(length);
    const seen = new Array(length);
    for (const item of input) {
        for (let retry = 0; retry < Number.MAX_SAFE_INTEGER; retry++) {
            const newLocation = Math.floor(Math.random() * length);
            if (seen[newLocation]) {
                continue;
            }
            output[newLocation] = item;
            seen[newLocation] = true;
            break;
        }
    }
    return (output);
}
const registeredDeSerializers = {};
/**
 * A P2PSwitch is a method of coordinating messages from peers (either
 * connected or known) with a Node.
 */
class P2PSwitch {
    static RegisterP2PConnectionDeserializer(type, deserializer) {
        registeredDeSerializers[type] = deserializer;
    }
    async DeserializeP2PConnection(connString) {
        const info = await this.config.kv.get('connectedPeers', connString);
        if (info === undefined) {
            return (undefined);
        }
        if (!isSerializedConnection(info)) {
            return (undefined);
        }
        const handler = registeredDeSerializers[info.type];
        if (!handler) {
            return (undefined);
        }
        const newConnection = handler(__classPrivateFieldGet(this, _P2PSwitch_localNode, "f"), info.data);
        return (newConnection);
    }
    constructor(node) {
        _P2PSwitch_instances.add(this);
        _P2PSwitch_connectedPeersCleanup.set(this, void 0);
        _P2PSwitch_connectedPeersRemote.set(this, void 0);
        _P2PSwitch_connectedPeersLocal.set(this, void 0);
        _P2PSwitch_localNode.set(this, void 0);
        _P2PSwitch_manualPeersCheckIntervals.set(this, void 0);
        _P2PSwitch_asyncSends.set(this, []);
        _P2PSwitch_messageFilterCache.set(this, {});
        _P2PSwitch_cachedLocalPeerInfo.set(this, undefined);
        _P2PSwitch_cachedLocalPeerSerialized.set(this, undefined);
        /**
         * Write a debug or error message to the connected node.
         *
         * We can't make it private since P2PConnections that are associated
         * with this switch may need to use it
         *
         * @internal
         */
        this._log = {
            debug: (...message) => {
                return (__classPrivateFieldGet(this, _P2PSwitch_localNode, "f").log.debug('P2P', ...message));
            },
            error: (...message) => {
                return (__classPrivateFieldGet(this, _P2PSwitch_localNode, "f").log.error('P2P', ...message));
            }
        };
        /**
         * Get a list of known peers (with caching)
         */
        _P2PSwitch_peersCacheSet.set(this, null);
        __classPrivateFieldSet(this, _P2PSwitch_localNode, node, "f");
        __classPrivateFieldSet(this, _P2PSwitch_connectedPeersLocal, [], "f");
        __classPrivateFieldSet(this, _P2PSwitch_connectedPeersRemote, null, "f");
        __classPrivateFieldSet(this, _P2PSwitch_connectedPeersCleanup, null, "f");
        __classPrivateFieldSet(this, _P2PSwitch_manualPeersCheckIntervals, [], "f");
        const configBase = node.config.p2p || {};
        const config = {
            ...defaultP2PConfig,
            ...configBase,
            kv: configBase.kv ?? new kv_memory_1.default()
        };
        this.config = config;
    }
    /**
     * Get a list of known peers
     */
    async peers(options) {
        options = {
            includeSelf: false,
            includeUnverified: false,
            ...options
        };
        /**
         * The maximum time (in ms) that a representative should have
         * been confirmed
         */
        const repLastSeenLimit = Math.max(this.config.timeoutIdle, this.config.manualPeersCheckInFreq) * 10;
        const potentialKnownPeers = await this.config.kv.getAll('knownPeers');
        // Filter for only valid entries in case the format becomes invalidated in the future
        let knownPeers = Object.fromEntries(Object.entries(potentialKnownPeers).filter(([_, value]) => {
            const peer = P2PPeerFromJSO(value);
            return (peer !== null);
        }));
        const lastSeenPeers = await this.config.kv.getAll('lastSeenPeers');
        const retval = [];
        /**
         * Our local node's peer information (if any)
         */
        const ourPeer = await __classPrivateFieldGet(this, _P2PSwitch_instances, "m", _P2PSwitch_getLocalPeerInfo).call(this);
        if (options.includeUnverified) {
            const potentialPeers = await this.config.kv.getAll('potentialPeers');
            knownPeers = {
                ...potentialPeers,
                ...knownPeers
            };
        }
        /**
         * Our local node's peers public key string (if any)
         */
        let ourPeerKey = null;
        if (ourPeer !== null && 'key' in ourPeer) {
            ourPeerKey = ourPeer.key.publicKeyString.get();
        }
        /**
         * Optionally include ourself.
         * Done here as it may not be included in lastSeenPeers
         */
        if (options.includeSelf) {
            if (ourPeer?.kind === node_1.NodeKind.REPRESENTATIVE) {
                if (ourPeer !== null) {
                    retval.push(ourPeer);
                }
            }
        }
        this._log.debug('Known peers:', knownPeers);
        this._log.debug('Last seen peers:', lastSeenPeers);
        const now = Date.now();
        for (const peerID in knownPeers) {
            const peer = P2PPeerFromJSO(knownPeers[peerID]);
            if (!isP2PPeer(peer)) {
                this._log.debug('Invalid peer:', peerID, knownPeers[peerID]);
                continue;
            }
            /*
             * Determine when we last had confirmed contact with
             * this representative, and exclude representatives
             * that are too old
             */
            if (peer.kind !== node_1.NodeKind.PARTICIPANT) {
                /**
                 * Always exclude ourselves from the list
                 * of peers, if we want to add ourselves
                 * then it has already been done above.
                 */
                if (peer.key.publicKeyString.get() === ourPeerKey) {
                    this._log.debug('Excluding ourself from peers:', peerID);
                    continue;
                }
                const lastSeenPeerString = lastSeenPeers[peerID];
                if (typeof lastSeenPeerString !== 'string') {
                    this._log.debug('No last seen time for peer', peerID);
                    continue;
                }
                const lastSeenPeer = Number(lastSeenPeerString);
                /**
                 * How long ago (in relative time, in ms) was
                 * this representative confirmed to have been
                 * seen
                 */
                const lastSeenPeerAgoMS = now - lastSeenPeer;
                if (lastSeenPeerAgoMS > repLastSeenLimit) {
                    if (!options.includeStale) {
                        this._log.debug('Excluding peer', peerID, 'due to last seen limit:', lastSeenPeerAgoMS);
                        continue;
                    }
                }
            }
            retval.push(peer);
        }
        this._log.debug('Peers:', retval);
        return (retval);
    }
    /**
     * Add a manual peer to initiate peering process
     *
     * The switch will periodically reach out to this peer to build its
     * peer database
     */
    addManualPeer(peer, schedule = true) {
        const peerID = peerToID(peer);
        const peerFunc = async () => {
            const lastCheckIn = await this.config.kv.get('manualPeerCheckIn', peerID);
            const now = Date.now();
            if (typeof lastCheckIn === 'number') {
                if ((lastCheckIn + this.config.manualPeersCheckInFreq) > now) {
                    return;
                }
            }
            await this.config.kv.set('manualPeerCheckIn', peerID, now);
            /**
             * We have always seen manual peers
             */
            await __classPrivateFieldGet(this, _P2PSwitch_instances, "m", _P2PSwitch_updateLastSeenPeer).call(this, peerID, now);
            /**
             * Check to see if we are already connected to this
             * manual peer
             */
            let peerConnected = false;
            const peerConnection = await __classPrivateFieldGet(this, _P2PSwitch_instances, "m", _P2PSwitch_connectedPeerConnection).call(this, peerID);
            if (peerConnection !== null) {
                peerConnected = true;
            }
            if (peerConnected) {
                this._log.debug('Already connected to manual peer', peerID, 'Skipping CheckIn; Peer Information:', peerConnection);
                return;
            }
            this._log.debug('Checking in with manual peer', peerID);
            const added = await __classPrivateFieldGet(this, _P2PSwitch_instances, "m", _P2PSwitch_connectToPeer).call(this, peer, `manual:${peerID}`);
            this._log.debug('Checked in with manual peer', peerID, 'Added:', added);
        };
        __classPrivateFieldGet(this, _P2PSwitch_asyncSends, "f").push(peerFunc());
        if (schedule) {
            __classPrivateFieldGet(this, _P2PSwitch_manualPeersCheckIntervals, "f").push(setInterval(peerFunc, this.config.manualPeersCheckInFreq));
        }
    }
    /**
     * Stop this switch
     */
    async stop() {
        for (const interval of __classPrivateFieldGet(this, _P2PSwitch_manualPeersCheckIntervals, "f")) {
            clearInterval(interval);
        }
        const closePromises = [];
        for (const conn of __classPrivateFieldGet(this, _P2PSwitch_connectedPeersLocal, "f")) {
            closePromises.push(conn.close());
        }
        await Promise.allSettled(closePromises);
        await this.wait();
    }
    /**
     * Handle any waiting that needs to be done
     */
    async wait() {
        const promises = __classPrivateFieldGet(this, _P2PSwitch_asyncSends, "f").splice(0);
        if (promises.length === 0) {
            return;
        }
        await Promise.allSettled(promises);
    }
    async stats() {
        return ({
            incomingMessages: await __classPrivateFieldGet(this, _P2PSwitch_localNode, "f").stats.get('p2p', 'incomingMessages'),
            outgoingMessagesPeerSuccess: await __classPrivateFieldGet(this, _P2PSwitch_localNode, "f").stats.get('p2p', 'outgoingMessagesPeerSuccess'),
            outgoingMessagesPeerFailure: await __classPrivateFieldGet(this, _P2PSwitch_localNode, "f").stats.get('p2p', 'outgoingMessagesPeerFailure'),
            outgoingMessagesPeerFiltered: await __classPrivateFieldGet(this, _P2PSwitch_localNode, "f").stats.get('p2p', 'outgoingMessagesPeerFiltered'),
            outgoingMessagesPeerFailureUngreeted: await __classPrivateFieldGet(this, _P2PSwitch_localNode, "f").stats.get('p2p', 'outgoingMessagesPeerFailureUngreeted')
        });
    }
    async registerConnection(conn) {
        /**
         * For the initial connection, give the client some time to
         * introduce itself
         */
        conn.timeout = Date.now() + this.config.timeoutIdleGreeting;
        /**
         * Send our greeting
         */
        try {
            await __classPrivateFieldGet(this, _P2PSwitch_instances, "m", _P2PSwitch_emitOutgoingGreeting).call(this, conn);
        }
        catch (greetingError) {
            this._log.debug('Received greeting error: ', greetingError);
        }
        await waitForPeer(conn);
        this._log.debug(`Greeting attempt completed, connected with: ${conn.connString}`);
        /**
         * Add this peer to connected peers
         */
        __classPrivateFieldGet(this, _P2PSwitch_connectedPeersLocal, "f").push(conn);
        /**
         * If this connection can be serialized, do so
         */
        if (conn.serialize) {
            const serializedConnection = conn.serialize();
            const serializedConnectionID = conn.connString;
            await this.config.kv.set('connectedPeers', serializedConnectionID, { ...serializedConnection });
        }
        /**
         * Start a process for cleaning up idle peers if it is not
         * already going
         */
        if (__classPrivateFieldGet(this, _P2PSwitch_connectedPeersCleanup, "f") === null) {
            __classPrivateFieldSet(this, _P2PSwitch_connectedPeersCleanup, setInterval(() => {
                // We do not need to await this, as it is being ran in an interval
                void __classPrivateFieldGet(this, _P2PSwitch_instances, "m", _P2PSwitch_performPeerCleanup).call(this);
            }, this.config.timeoutIdleCheck), "f");
        }
    }
    async unregisterConnection(conn) {
        if (conn.serialize !== undefined) {
            await this.config.kv.set('connectedPeers', conn.connString, undefined);
        }
        __classPrivateFieldSet(this, _P2PSwitch_connectedPeersLocal, __classPrivateFieldGet(this, _P2PSwitch_connectedPeersLocal, "f").filter(function (checkConnection) {
            if (checkConnection === conn) {
                return (false);
            }
            return (true);
        }), "f");
        if (__classPrivateFieldGet(this, _P2PSwitch_connectedPeersLocal, "f").length === 0) {
            if (__classPrivateFieldGet(this, _P2PSwitch_connectedPeersCleanup, "f") !== null) {
                clearInterval(__classPrivateFieldGet(this, _P2PSwitch_connectedPeersCleanup, "f"));
                __classPrivateFieldSet(this, _P2PSwitch_connectedPeersCleanup, null, "f");
            }
        }
        await this.config.kv.set('messageFilters', conn.connString, undefined);
    }
    static parseJSONMessage(messageBuffer) {
        if (util_1.types.isArrayBuffer(messageBuffer)) {
            messageBuffer = Buffer.from(messageBuffer);
        }
        if (!Buffer.isBuffer(messageBuffer)) {
            throw (new Error('messageBuffer must be Buffer or ArrayBuffer'));
        }
        const messageString = messageBuffer.toString('utf-8');
        const message = JSON.parse(messageString);
        const messageTTL = message['ttl'];
        const messageID = message['id'];
        delete message['ttl'];
        delete message['id'];
        if (messageTTL !== undefined) {
            if (typeof messageTTL !== 'number') {
                return ({ valid: false, reason: 'ttl must be number' });
            }
        }
        if (typeof messageID !== 'string') {
            return ({ valid: false, reason: 'id must be string' });
        }
        const messageTypeInfo = Object.keys(message);
        if (messageTypeInfo.length !== 1) {
            return ({ valid: false, reason: 'too many or too few keys, must be exactly 1' });
        }
        const messageType = messageTypeInfo[0];
        return ({
            valid: true,
            type: messageType,
            data: message[messageType],
            ttl: messageTTL,
            id: messageID
        });
    }
    /**
     * Our own peer information
     */
    async selfPeer() {
        return (await __classPrivateFieldGet(this, _P2PSwitch_instances, "m", _P2PSwitch_getLocalPeerInfo).call(this));
    }
    async getOutgoingGreetingInfo() {
        if (__classPrivateFieldGet(this, _P2PSwitch_cachedLocalPeerSerialized, "f") === undefined) {
            const greetingInfo = await __classPrivateFieldGet(this, _P2PSwitch_instances, "m", _P2PSwitch_getLocalPeerInfo).call(this);
            if (greetingInfo === null) {
                throw (new Error('Invalid NodeKind for emitting outgoing greeting'));
            }
            __classPrivateFieldSet(this, _P2PSwitch_cachedLocalPeerSerialized, P2PPeerToJSO(greetingInfo), "f");
        }
        return (__classPrivateFieldGet(this, _P2PSwitch_cachedLocalPeerSerialized, "f"));
    }
    /**
     * Receive a message from a connection
     *
     * This message will get sent to our local node, which may then rebroadcast it
     */
    async recvMessageFromPeer(from, messageBuffer) {
        const env_1 = { stack: [], error: void 0, hasError: false };
        try {
            /*
             * Schedule a stats sync after processing the message
             */
            const cleanup = __addDisposableResource(env_1, new helper_1.AsyncDisposableStack(), true);
            cleanup.defer(async () => {
                await __classPrivateFieldGet(this, _P2PSwitch_localNode, "f").stats.sync();
            });
            __classPrivateFieldGet(this, _P2PSwitch_localNode, "f").stats.incr('p2p', 'incomingMessages');
            const message = P2PSwitch.parseJSONMessage(messageBuffer);
            if (!message.valid) {
                let reason = '';
                if ('reason' in message) {
                    reason = message.reason;
                }
                this._log.error('Invalid message from peer:', reason, '; message:', Buffer.from(messageBuffer).toString());
                return (false);
            }
            this._log.debug(`[${message.id}]`, 'Incoming message from', from.connString, { type: message.type, ttl: message.ttl });
            /**
             * If we have recently seen this message inbound do not process it again
             */
            let seenMessageID = false;
            try {
                await this.config.kv.set('seenMessageIDs', message.id, Date.now(), {
                    exclusiveCreate: true,
                    ttl: this.config.seenMessageTTL
                });
            }
            catch (seenError) {
                seenMessageID = true;
            }
            if (seenMessageID) {
                this._log.debug(`[${message.id}]`, 'Dropping already seen message');
                return (false);
            }
            /**
             * The first message from a peer must be a greeting giving us
             * peer information
             */
            let forward = true;
            let acceptable = true;
            let rebroadcastOnly = false;
            if (from.peer === null || (P2PHttpConnection.isInstance(from) && message.type === 'greeting')) {
                /**
                 * By default do not forward messages from un-greeted peers
                 */
                forward = false;
                /**
                 * Handle the greeting
                 */
                if (message.type === 'greeting') {
                    const greetingSuccess = await __classPrivateFieldGet(this, _P2PSwitch_instances, "m", _P2PSwitch_handleIncomingGreeting).call(this, from, message);
                    if (!greetingSuccess) {
                        this._log.error(`[${message.id}]`, 'Failed to process greeting');
                        acceptable = false;
                    }
                    else {
                        this._log.debug(`[${message.id}]`, 'Greeting from', from.connString, 'completed');
                    }
                }
            }
            else {
                /**
                 * Ignore greetings from identified connections
                 */
                if (message.type === 'greeting') {
                    return (false);
                }
                /**
                 * Locally handle peering information
                 */
                if (message.type === 'peer') {
                    rebroadcastOnly = false;
                    acceptable = false;
                    forward = false;
                    const learnedPeer = P2PPeerFromJSO(message.data);
                    if (learnedPeer !== null) {
                        const peerID = peerToID(learnedPeer);
                        /**
                         * Since we have received a peer from a peer, we have
                         * to validate it by attempting to connect to it at
                         * some point but we do not consider it a peer until
                         * we have successfully connected to it
                         */
                        await this.config.kv.set('potentialPeers', peerID, message.data);
                        acceptable = true;
                        this._log.debug(`[${message.id}]`, 'Peer information from', from.connString, '=>', printablePeer(learnedPeer));
                        /**
                         * If we have previously validated this peer, we can
                         * rebroadcast the information
                         */
                        if (learnedPeer.kind === node_1.NodeKind.REPRESENTATIVE) {
                            const peers = await __classPrivateFieldGet(this, _P2PSwitch_instances, "m", _P2PSwitch_peersCached).call(this);
                            const foundPeer = peers.find(function (checkPeer) {
                                if (checkPeer.kind !== node_1.NodeKind.REPRESENTATIVE) {
                                    return (false);
                                }
                                if (!checkPeer.key.comparePublicKey(learnedPeer.key)) {
                                    return (false);
                                }
                                if (checkPeer.endpoints.p2p !== learnedPeer.endpoints.p2p) {
                                    return (false);
                                }
                                if (checkPeer.endpoints.api !== learnedPeer.endpoints.api) {
                                    return (false);
                                }
                                return (true);
                            });
                            if (foundPeer !== undefined) {
                                this._log.debug(`[${message.id}]`, 'Found already validated peer, will rebroadcast learned peer:', foundPeer);
                                rebroadcastOnly = true;
                            }
                            else {
                                this._log.debug(`[${message.id}]`, 'Found unvalidated peer, will not rebroadcast learned peer:', learnedPeer);
                            }
                        }
                    }
                }
                if (message.type === 'test') {
                    this._log.debug(`[${message.id}]`, 'Got a test message, just rebroadcasting');
                    rebroadcastOnly = true;
                }
            }
            /**
             * Reject unacceptable messages
             */
            if (!acceptable) {
                this._log.debug(`[${message.id}]`, 'Rejecting unacceptable message');
                return (false);
            }
            /**
             * Update the timeout if they have sent us a unique acceptable message
             */
            __classPrivateFieldGet(this, _P2PSwitch_instances, "m", _P2PSwitch_updateConnTimeout).call(this, from);
            /**
             * Rebroadcast certain messages internally
             */
            if (rebroadcastOnly) {
                this._log.debug(`[${message.id}]`, 'Rebroadcasting only');
                __classPrivateFieldGet(this, _P2PSwitch_asyncSends, "f").push((async () => {
                    try {
                        const ttl = message.ttl;
                        if (ttl === undefined) {
                            return;
                        }
                        if (ttl < 1) {
                            return;
                        }
                        const newTTL = ttl - 1;
                        // Exclude sender from receiving message again;
                        const excluded = [from];
                        await __classPrivateFieldGet(this, _P2PSwitch_localNode, "f").sendMessage(message.id, message.type, message.data, newTTL, excluded);
                    }
                    catch (sendError) {
                        this._log.debug(`[${message.id}]`, 'Failed to rebroadcast message:', sendError);
                    }
                })());
                return (true);
            }
            /**
             * Do not forward messages which we should not forward
             */
            if (!forward) {
                this._log.debug(`[${message.id}]`, 'Not forwarding to node');
                return (false);
            }
            this._log.debug(`[${message.id}]`, 'Forwarding to node');
            /**
             * Pass the message up to the node for it to process it and
             * potentially rebroadcast it
             */
            return (await __classPrivateFieldGet(this, _P2PSwitch_localNode, "f").recvMessageFromPeer(from, message.id, message.type, message.data, message.ttl));
        }
        catch (e_1) {
            env_1.error = e_1;
            env_1.hasError = true;
        }
        finally {
            const result_1 = __disposeResources(env_1);
            if (result_1)
                await result_1;
        }
    }
    /**
     * Send a message to one or more peers
     *
     * If they are already connected that connection will be re-used,
     * otherwise a new connection will be established.
     *
     * If "to" is null then it will be sent to a sampling of peers
     *
     * @param to - Where to send the message
     * @param id - Unique message identifier
     * @param type - Message type
     * @param data - Message data, must be serializable to JSON
     * @param ttl - Maximum number of hops to pass through
     * @param exclude - List of connections to exclude (e.g., because we got the message from that connection) if "to" is null
     * @param skipConnectToPeers - Skip creating new connections to send to, only connected clients will be sent the message
     * @returns If the message could be delivered to at least one peer
     */
    async sendMessage(to, id, type, data, ttl, exclude, skipConnectToPeers = false) {
        this._log.debug(`[${id}]`, 'Sending message', type, 'to', to === null ? 'all peers' : to, 'with', data);
        __classPrivateFieldGet(this, _P2PSwitch_localNode, "f").stats.incr('p2p', 'outgoingMessages');
        /**
         * Indicate we have seen messages we emit
         */
        const seenMessageIDPromise = this.config.kv.set('seenMessageIDs', id, Date.now(), {
            ttl: this.config.seenMessageTTL
        });
        /**
         * Construct the message JSON
         */
        const messageString = JSON.stringify({
            id: id,
            [type]: data,
            ttl: ttl
        });
        /**
         * Convert the message to a buffer for sending
         */
        const messageBuffer = Buffer.from(messageString, 'utf-8');
        /**
         * If a specific destination has been defined, send to that destination
         */
        if (to !== null) {
            let target;
            if (account_1.default.isInstance(to)) {
                const connectedPeers = await __classPrivateFieldGet(this, _P2PSwitch_instances, "m", _P2PSwitch_connectedPeers).call(this);
                const peer = connectedPeers.find(function (checkConnection) {
                    const checkPeer = checkConnection.peer;
                    if (checkPeer === null) {
                        return (false);
                    }
                    if (!('key' in checkPeer)) {
                        return (false);
                    }
                    if (checkPeer.key.comparePublicKey(to)) {
                        return (false);
                    }
                    return (true);
                });
                if (peer === undefined) {
                    return (false);
                }
                target = peer;
            }
            else if (isP2PPeer(to)) {
                let connectedPeer = await __classPrivateFieldGet(this, _P2PSwitch_instances, "m", _P2PSwitch_connectedPeerConnection).call(this, to);
                if (connectedPeer === null) {
                    connectedPeer = await __classPrivateFieldGet(this, _P2PSwitch_instances, "m", _P2PSwitch_connectToPeer).call(this, to, id);
                }
                if (connectedPeer === null) {
                    return (false);
                }
                target = connectedPeer;
            }
            else {
                target = to;
            }
            const passesFilter = await __classPrivateFieldGet(this, _P2PSwitch_instances, "m", _P2PSwitch_passesFilter).call(this, target, data);
            if (!passesFilter) {
                __classPrivateFieldGet(this, _P2PSwitch_localNode, "f").stats.incr('p2p', 'outgoingMessagesPeerFiltered');
                return (false);
            }
            /**
             * Allow greetings to be sent prior to identification of a peer
             */
            if (type !== 'greeting') {
                if (target.peer === null) {
                    this._log.debug(`[${id}]`, 'Asked to send a message to a connection that contains an un-greeted peer, discarding');
                    __classPrivateFieldGet(this, _P2PSwitch_localNode, "f").stats.incr('p2p', 'outgoingMessagesPeerFailure');
                    __classPrivateFieldGet(this, _P2PSwitch_localNode, "f").stats.incr('p2p', 'outgoingMessagesPeerFailureUngreeted');
                    return (false);
                }
            }
            __classPrivateFieldGet(this, _P2PSwitch_instances, "m", _P2PSwitch_updateConnTimeout).call(this, target);
            this._log.debug(`[${id}]`, 'Sending message to connected peer', target.connString, messageBuffer.toString());
            let retval = false;
            try {
                retval = await target.send(messageBuffer);
            }
            catch (sendError) {
                this._log.debug(`[${id}]`, 'Failed to send message to connected peer', target.connString, sendError);
            }
            if (retval) {
                __classPrivateFieldGet(this, _P2PSwitch_localNode, "f").stats.incr('p2p', 'outgoingMessagesPeerSuccess');
            }
            else {
                __classPrivateFieldGet(this, _P2PSwitch_localNode, "f").stats.incr('p2p', 'outgoingMessagesPeerFailure');
            }
            return (retval);
        }
        /**
         * Otherwise broadcast to known and connected peers
         */
        /**
         * Keep track of which connections we have sent things to
         */
        const sentToTracking = {};
        /**
         * Keep track of which representatives we have sent to
         */
        const sentToReps = {};
        /**
         * Get a list of connected peers
         */
        const connectedPeers = await __classPrivateFieldGet(this, _P2PSwitch_instances, "m", _P2PSwitch_connectedPeers).call(this);
        this._log.debug(`[${id}]`, 'Sending message to all connected peers', connectedPeers.length);
        /**
         * Convert all exclusions to connection strings
         */
        let excludeConns = [];
        if (exclude !== undefined) {
            excludeConns = exclude.map(function (conn) {
                if (typeof conn === 'string') {
                    return (conn);
                }
                else {
                    return (conn.connString);
                }
            });
        }
        let resolveAny;
        const toAwaitAny = new Promise(function (resolve) {
            resolveAny = resolve;
        });
        /**
         * Send to all connected peers
         */
        this._log.debug(`[${id}]`, 'Sending message to all connected peers', connectedPeers);
        const peerConnectedPromises = connectedPeers.map(async (conn) => {
            const connString = conn.connString;
            /**
             * Verify that it's not one of the handles we are excluding
             */
            if (excludeConns.includes(connString)) {
                this._log.debug(`[${id}]`, 'Skipping', connString, 'because it is in the exclusion list');
                return (false);
            }
            /**
             * Ensure that there are no duplicate connections
             * being sent to
             */
            if (sentToTracking[connString]) {
                this._log.debug(`[${id}]`, 'Skipping', connString, 'because it has already been sent to');
                return (false);
            }
            sentToTracking[connString] = true;
            /**
             * If the peer has not been identified don't send to it
             */
            if (conn.peer === null) {
                this._log.debug(`[${id}]`, 'Skipping', connString, 'because it has not been identified');
                return (false);
            }
            /**
             * If the connection is closing, don't send to it
             */
            if (conn.abort) {
                this._log.debug(`[${id}]`, 'Skipping', connString, 'because it is closing');
                return (false);
            }
            /**
             * Don't send to the same peer multiple times even if
             * we are connected multiple times
             */
            if (conn.peer.kind === node_1.default.Kind.REPRESENTATIVE) {
                const repPubKey = conn.peer.key.publicKeyString.get();
                if (sentToReps[repPubKey]) {
                    return (false);
                }
                sentToReps[repPubKey] = true;
            }
            this._log.debug(`[${id}]`, 'Sending to connected peer:', connString);
            await seenMessageIDPromise;
            let retval = await this.sendMessage(conn, id, type, data, ttl);
            /**
             * If we are not able to send to a connected peer,
             * reconnect if it is a rep
             */
            if (retval === false) {
                if (conn.peer.kind === node_1.default.Kind.REPRESENTATIVE) {
                    const repPeer = conn.peer;
                    try {
                        await conn.close();
                    }
                    catch (ignoredError) {
                        /* Ignore the close error */
                    }
                    /*
                     * Open a new connection to the rep
                     * and send to it because we have
                     * already accounted for sending to
                     * this rep and so would otherwise not
                     * do so
                     */
                    const newConn = await __classPrivateFieldGet(this, _P2PSwitch_instances, "m", _P2PSwitch_connectToPeer).call(this, repPeer, id);
                    if (newConn === null) {
                        return (false);
                    }
                    retval = await this.sendMessage(newConn, id, type, data, ttl);
                }
            }
            if (retval) {
                resolveAny(true);
            }
            return (retval);
        });
        const connectToPeers = [];
        if (skipConnectToPeers !== true) {
            /**
             * Shuffle the peer database
             *
             * Split into multiple calls due to a bug in regenerator
             * [https://github.com/facebook/regenerator/issues/397]
             */
            const peers = await this.peers({ includeUnverified: true });
            const shuffledPeers = shuffleArray(peers);
            connectToPeers.push(...shuffledPeers);
            this._log.debug(`[${id}]`, 'Sending message to all known peers', connectToPeers.length, '(skipConnectToPeers:', skipConnectToPeers, ')');
        }
        else {
            this._log.debug(`[${id}]`, 'Not connecting to any peers');
        }
        /**
         * Connect to some outbound peers
         */
        const peerHandlePromises = connectToPeers.map(async (tryPeer) => {
            /**
             * If we have already connected to enough peers do not
             * add more
             */
            const connectedCount = Object.keys(sentToTracking).length;
            if (connectedCount > this.config.forwardingPeerCount) {
                return (false);
            }
            /**
             * Ensure we don't talk to any peers that are us
             */
            if (tryPeer.kind === node_1.default.Kind.REPRESENTATIVE) {
                if (__classPrivateFieldGet(this, _P2PSwitch_localNode, "f").config.ledgerPrivateKey !== undefined) {
                    if (tryPeer.key.comparePublicKey(__classPrivateFieldGet(this, _P2PSwitch_localNode, "f").config.ledgerPrivateKey)) {
                        return (false);
                    }
                }
            }
            /**
             * Check to see if we already have an open connection
             * to this peer, if so skip it because we will send
             * to all connected peers
             */
            const connectedHandle = connectedPeers.find(function (checkConnection) {
                if (checkConnection.peer === null) {
                    return (false);
                }
                if (checkConnection.peer.kind !== tryPeer.kind) {
                    return (false);
                }
                switch (tryPeer.kind) {
                    case node_1.NodeKind.REPRESENTATIVE:
                        return ('key' in checkConnection.peer && tryPeer.key.comparePublicKey(checkConnection.peer.key));
                    case node_1.NodeKind.PARTICIPANT:
                        return (false);
                }
                return (false);
            });
            if (connectedHandle !== undefined) {
                return (false);
            }
            /**
             * Connect to the peer
             */
            const ws = await __classPrivateFieldGet(this, _P2PSwitch_instances, "m", _P2PSwitch_connectToPeer).call(this, tryPeer, id);
            if (ws === null) {
                return (false);
            }
            await seenMessageIDPromise;
            const retval = await this.sendMessage(ws, id, type, data, ttl);
            if (retval) {
                resolveAny(true);
            }
            return (retval);
        });
        /**
         * Determine if any peers could be reached
         *
         * XXX:TODO: Add a race to limit the amount of time this can take
         * XXX:TODO: We can just wait for any "true" value before
         *           returning and add the rest to our deferred queue
         */
        const anySent = await Promise.race([toAwaitAny, Promise.all([...peerConnectedPromises, ...peerHandlePromises])]);
        if (typeof anySent === 'boolean') {
            return (anySent);
        }
        if (Array.isArray(anySent)) {
            return (anySent.includes(true));
        }
        return (false);
    }
    /**
     * TODO - make this private after refactoring websockets to handle higher load
     * https://github.com/KeetaNetwork/node/issues/785
     */
    async haveAnyFilter(data) {
        const kvFilters = await this.config.kv.getAll('messageFilters');
        for (const key in kvFilters) {
            const kvFilter = kvFilters[key];
            if (kvFilter && typeof kvFilter === 'string') {
                const filter = account_1.default.fromPublicKeyAndType(kvFilter);
                const voteStaple = new vote_1.VoteStaple(data);
                const { touched } = (0, effects_1.computeEffectOfBlocks)(voteStaple.blocks);
                return (touched.has(filter));
            }
        }
        return (false);
    }
}
exports.P2PSwitch = P2PSwitch;
_P2PSwitch_connectedPeersCleanup = new WeakMap(), _P2PSwitch_connectedPeersRemote = new WeakMap(), _P2PSwitch_connectedPeersLocal = new WeakMap(), _P2PSwitch_localNode = new WeakMap(), _P2PSwitch_manualPeersCheckIntervals = new WeakMap(), _P2PSwitch_asyncSends = new WeakMap(), _P2PSwitch_messageFilterCache = new WeakMap(), _P2PSwitch_cachedLocalPeerInfo = new WeakMap(), _P2PSwitch_cachedLocalPeerSerialized = new WeakMap(), _P2PSwitch_peersCacheSet = new WeakMap(), _P2PSwitch_instances = new WeakSet(), _P2PSwitch_connectedPeerConnection = 
/**
 * Get the connection for a given peer or PeerID
 */
async function _P2PSwitch_connectedPeerConnection(peer) {
    let peerID;
    if (typeof peer !== 'string') {
        peerID = peerToID(peer);
    }
    else {
        peerID = peer;
    }
    const connectedPeers = await __classPrivateFieldGet(this, _P2PSwitch_instances, "m", _P2PSwitch_connectedPeers).call(this);
    for (const conn of connectedPeers) {
        if (conn.abort) {
            continue;
        }
        this._log.debug('Checking to see if we are already connected to manual peer', conn, 'for', peerID, peer);
        const peerInfo = conn.validatedPeer;
        if (peerInfo === null) {
            continue;
        }
        if (peerToID(peerInfo) === peerID) {
            return (conn);
        }
    }
    return (null);
}, _P2PSwitch_connectedPeers = 
/**
 * Get a list of connected peers
 */
async function _P2PSwitch_connectedPeers() {
    if (__classPrivateFieldGet(this, _P2PSwitch_connectedPeersRemote, "f") === null) {
        __classPrivateFieldSet(this, _P2PSwitch_connectedPeersRemote, [], "f");
        const serializedConnectedPeers = await this.config.kv.getAll('connectedPeers');
        for (const connID in serializedConnectedPeers) {
            const info = serializedConnectedPeers[connID];
            if (!isSerializedConnection(info)) {
                continue;
            }
            const handler = registeredDeSerializers[info.type];
            if (!handler) {
                continue;
            }
            const newConnection = handler(__classPrivateFieldGet(this, _P2PSwitch_localNode, "f"), info.data);
            __classPrivateFieldGet(this, _P2PSwitch_connectedPeersRemote, "f").push(newConnection);
        }
    }
    /*
     * Deduplicate the connections
     */
    const seenConnections = new Set();
    const retval = [
        ...__classPrivateFieldGet(this, _P2PSwitch_connectedPeersLocal, "f"),
        ...__classPrivateFieldGet(this, _P2PSwitch_connectedPeersRemote, "f")
    ].filter(function (value, index, self) {
        if (seenConnections.has(value.connString)) {
            return (false);
        }
        seenConnections.add(value.connString);
        return (true);
    });
    return (retval);
}, _P2PSwitch_updateLastSeenPeer = 
/*
 * For non-participants, keep track of the local time of
 * the last time we got a greeting from them or were
 * able to connect outbound to them
 */
async function _P2PSwitch_updateLastSeenPeer(peer, when) {
    let peerId;
    if (typeof peer === 'string') {
        peerId = peer;
    }
    else {
        if (peer.kind === node_1.NodeKind.PARTICIPANT) {
            return;
        }
        peerId = peerToID(peer);
    }
    /**
     * The moment being recorded as the last time the representative
     * was seen (in UNIX time in ms)
     */
    let now;
    if (when === undefined) {
        now = Date.now().toString();
    }
    else if (typeof when === 'number') {
        now = when.toString();
    }
    else {
        now = when.valueOf().toString();
    }
    this._log.debug('Updating last seen time for peer', peerId, 'to', now);
    await this.config.kv.set('lastSeenPeers', peerId, now);
}, _P2PSwitch_peersCached = async function _P2PSwitch_peersCached() {
    const now = new Date();
    if (__classPrivateFieldGet(this, _P2PSwitch_peersCacheSet, "f") !== null) {
        const cachedTime = __classPrivateFieldGet(this, _P2PSwitch_peersCacheSet, "f").when;
        if ((cachedTime.valueOf() + 1000) > now.valueOf()) {
            return (__classPrivateFieldGet(this, _P2PSwitch_peersCacheSet, "f").peers);
        }
    }
    const peers = await this.peers();
    __classPrivateFieldSet(this, _P2PSwitch_peersCacheSet, {
        when: now,
        peers: peers
    }, "f");
    return (peers);
}, _P2PSwitch_relayActiveState = 
/**
 * Relay peering information to a connected node
 */
async function _P2PSwitch_relayActiveState(conn) {
    /**
     * Send a list of known peers
     */
    const knownPeers = await this.peers();
    for (const peerID in knownPeers) {
        const peerInfo = P2PPeerToJSO(knownPeers[peerID]);
        await this.sendMessage(conn, uuid.v4(), 'peer', peerInfo, 0);
    }
}, _P2PSwitch_performPeerCleanup = async function _P2PSwitch_performPeerCleanup() {
    const now = Date.now();
    for (const peerID in __classPrivateFieldGet(this, _P2PSwitch_connectedPeersLocal, "f")) {
        const peerConn = __classPrivateFieldGet(this, _P2PSwitch_connectedPeersLocal, "f")[peerID];
        if (peerConn === undefined) {
            continue;
        }
        if (peerConn.timeout < now) {
            this._log.debug('Closing connection to', peerConn.connString, 'due to idleness');
            await this.unregisterConnection(peerConn);
            await peerConn.close();
        }
    }
    /**
     * Prune list of seen messages
     */
    /** XXX:TODO */
}, _P2PSwitch_getLocalPeerInfo = async function _P2PSwitch_getLocalPeerInfo() {
    if (__classPrivateFieldGet(this, _P2PSwitch_cachedLocalPeerInfo, "f") === undefined) {
        let greetingInfo;
        switch (__classPrivateFieldGet(this, _P2PSwitch_localNode, "f").config.kind) {
            case node_1.NodeKind.PARTICIPANT:
                greetingInfo = {
                    kind: __classPrivateFieldGet(this, _P2PSwitch_localNode, "f").config.kind,
                    id: 'unused'
                };
                break;
            case node_1.NodeKind.REPRESENTATIVE:
                {
                    if (__classPrivateFieldGet(this, _P2PSwitch_localNode, "f").config.endpoints === undefined) {
                        throw (new Error('internal error: Our endpoints are not defined'));
                    }
                    if (__classPrivateFieldGet(this, _P2PSwitch_localNode, "f").config.endpoints.p2p === undefined) {
                        throw (new Error('internal error: Our endpoint (p2p) is not defined'));
                    }
                    if (__classPrivateFieldGet(this, _P2PSwitch_localNode, "f").config.endpoints.api === undefined) {
                        throw (new Error('internal error: Our endpoint (api) is not defined'));
                    }
                    if (__classPrivateFieldGet(this, _P2PSwitch_localNode, "f").config.ledgerPrivateKey === undefined) {
                        throw (new Error('internal error: Our ledger key is not defined'));
                    }
                    const greetingInfoSigned = await generateP2PPeerSigned({
                        kind: __classPrivateFieldGet(this, _P2PSwitch_localNode, "f").config.kind,
                        key: __classPrivateFieldGet(this, _P2PSwitch_localNode, "f").config.ledgerPrivateKey,
                        endpoints: {
                            p2p: __classPrivateFieldGet(this, _P2PSwitch_localNode, "f").config.endpoints.p2p,
                            api: __classPrivateFieldGet(this, _P2PSwitch_localNode, "f").config.endpoints.api
                        },
                        preferUpdates: this.config.useHTTPRepublish ? 'http' : 'websocket'
                    });
                    if (greetingInfoSigned === null) {
                        throw (new Error('internal error: Could not generate signature'));
                    }
                    greetingInfo = greetingInfoSigned;
                    break;
                }
            default:
                return (null);
        }
        __classPrivateFieldSet(this, _P2PSwitch_cachedLocalPeerInfo, greetingInfo, "f");
    }
    return (__classPrivateFieldGet(this, _P2PSwitch_cachedLocalPeerInfo, "f"));
}, _P2PSwitch_emitOutgoingGreeting = async function _P2PSwitch_emitOutgoingGreeting(to) {
    const messageID = uuid.v4();
    const greeting = await this.getOutgoingGreetingInfo();
    this._log.debug('Sending greeting to', to.connString);
    return (await this.sendMessage(to, messageID, 'greeting', greeting, 0));
}, _P2PSwitch_localNodeKeyOrNull = async function _P2PSwitch_localNodeKeyOrNull() {
    return (__classPrivateFieldGet(this, _P2PSwitch_localNode, "f").config.ledgerPrivateKey ?? null);
}, _P2PSwitch_handleIncomingGreeting = async function _P2PSwitch_handleIncomingGreeting(from, message) {
    const peerInfo = P2PPeerFromJSO(message.data);
    if (peerInfo === null) {
        return (false);
    }
    from.peer = peerInfo;
    const promises = [];
    if (peerInfo.kind !== node_1.NodeKind.PARTICIPANT) {
        const ourKey = await __classPrivateFieldGet(this, _P2PSwitch_instances, "m", _P2PSwitch_localNodeKeyOrNull).call(this);
        if (peerInfo.key.comparePublicKey(ourKey)) {
            this._log.error('Received greeting from self -- dropping');
            await from.close();
            return (false);
        }
        const peerId = peerToID(peerInfo);
        let targetArena = 'potentialPeers';
        if (from.validatedPeer !== null) {
            targetArena = 'knownPeers';
        }
        promises.push(this.config.kv.set(targetArena, peerId, P2PPeerToJSO(peerInfo)));
        /*
        * Since we successfully connected to the peer, update the
        * last seen information
        */
        promises.push(__classPrivateFieldGet(this, _P2PSwitch_instances, "m", _P2PSwitch_updateLastSeenPeer).call(this, peerInfo));
    }
    /**
     * Save message filtering for this connection if present
     */
    if (message?.data.filter) {
        const filterAccount = account_1.default.fromPublicKeyString(message.data.filter);
        const filterAccountHex = filterAccount.publicKeyAndTypeString;
        promises.push(this.config.kv.set('messageFilters', from.connString, filterAccountHex));
        __classPrivateFieldGet(this, _P2PSwitch_messageFilterCache, "f")[from.connString] = filterAccount;
    }
    /**
     * Save the connection again after it has been updated
     */
    if (from.serialize !== undefined) {
        promises.push(this.config.kv.set('connectedPeers', from.connString, from.serialize()));
    }
    /**
     * Perform peer exchange
     */
    promises.push(__classPrivateFieldGet(this, _P2PSwitch_instances, "m", _P2PSwitch_relayActiveState).call(this, from));
    await Promise.allSettled(promises);
    return (true);
}, _P2PSwitch_updateConnTimeout = function _P2PSwitch_updateConnTimeout(conn) {
    if (conn.peer) {
        if (conn.peer.kind === node_1.NodeKind.PARTICIPANT) {
            conn.timeout = Date.now() + this.config.timeoutIdleListener;
        }
        else {
            conn.timeout = Date.now() + this.config.timeoutIdle;
        }
    }
}, _P2PSwitch_connectToPeer = async function _P2PSwitch_connectToPeer(peer, logId) {
    this._log.debug(`[${logId}]`, 'Trying to connect to peer', printablePeer(peer));
    let p2pConnection = null;
    if (peer.kind === node_1.NodeKind.REPRESENTATIVE && peer.preferUpdates === 'http') {
        p2pConnection = await P2PHttpConnection.initiate(peer, this);
    }
    else {
        try {
            p2pConnection = await P2PWebSocket.initiate(peer, this);
        }
        catch (connectError) {
            /* Ignored */
        }
    }
    if (p2pConnection === null) {
        return (null);
    }
    /**
     * Since we established an outbound connection to this
     * peer we already know their information
     */
    p2pConnection.validatedPeer = peer;
    await this.registerConnection(p2pConnection);
    await waitForPeer(p2pConnection);
    /*
     * Since we successfully connected to the peer, update the
     * last seen information
     */
    await __classPrivateFieldGet(this, _P2PSwitch_instances, "m", _P2PSwitch_updateLastSeenPeer).call(this, peer);
    /*
     * Since we have successfully connected to the peer, update
     * the known peers database
     */
    const peerID = peerToID(peer);
    try {
        await this.config.kv.set('knownPeers', peerID, P2PPeerToJSO(peer));
        this._log.debug('Added knownPeer:', peerID);
    }
    catch (addPeerError) {
        this._log.error('Failed to add peer:', addPeerError);
    }
    return (p2pConnection);
}, _P2PSwitch_passesFilter = async function _P2PSwitch_passesFilter(target, data) {
    let filter = __classPrivateFieldGet(this, _P2PSwitch_messageFilterCache, "f")[target.connString];
    if (filter === undefined) {
        const kvFilter = await this.config.kv.get('messageFilters', target.connString);
        if (kvFilter && typeof kvFilter === 'string') {
            filter = account_1.default.fromPublicKeyAndType(kvFilter);
            __classPrivateFieldGet(this, _P2PSwitch_messageFilterCache, "f")[target.connString] = filter;
        }
    }
    // If there is a filter, only send effected accounts matching the filter
    if (filter) {
        const voteStaple = new vote_1.VoteStaple(data);
        const { touched } = (0, effects_1.computeEffectOfBlocks)(voteStaple.blocks);
        return (touched.has(filter));
    }
    return (true);
};
P2PSwitch.isInstance = (0, helper_1.checkableGenerator)(P2PSwitch);
exports["default"] = P2PSwitch;
/** @internal */
exports.Testing = {
    isP2PPeer,
    P2PPeerFromJSO,
    generateP2PPeerSigned,
    P2PPeerToJSO
};


/***/ }),

/***/ 5860:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var _BaseSet_instances, _a, _BaseSet_flags, _BaseSet_offsets, _BaseSet_computeOffsetArrayFromFlags, _BaseSet_updateStorageFromFlags, _BaseSet_computeFlagGroup, _BaseSet_computeOutputFlags, _ExternalSet_instances, _ExternalSet_validateWithinMaxLength, _Permissions_baseSet, _Permissions_externalSet;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Permissions = void 0;
const config_1 = __webpack_require__(1491);
const account_1 = __webpack_require__(9415);
const bitfield_1 = __importDefault(__webpack_require__(4977));
const helper_1 = __webpack_require__(3208);
const permissions_1 = __importDefault(__webpack_require__(2105));
const externalFlagPrefix = 'EXTERNAL_';
/**
 * Flags we have for non-external permissions
 */
var BaseFlag;
(function (BaseFlag) {
    BaseFlag[BaseFlag["ACCESS"] = 0] = "ACCESS";
    BaseFlag[BaseFlag["OWNER"] = 1] = "OWNER";
    BaseFlag[BaseFlag["ADMIN"] = 2] = "ADMIN";
    BaseFlag[BaseFlag["UPDATE_INFO"] = 3] = "UPDATE_INFO";
    BaseFlag[BaseFlag["SEND_ON_BEHALF"] = 4] = "SEND_ON_BEHALF";
    BaseFlag[BaseFlag["STORAGE_CAN_HOLD"] = 9] = "STORAGE_CAN_HOLD";
    BaseFlag[BaseFlag["STORAGE_DEPOSIT"] = 10] = "STORAGE_DEPOSIT";
    BaseFlag[BaseFlag["STORAGE_CREATE"] = 8] = "STORAGE_CREATE";
    BaseFlag[BaseFlag["TOKEN_ADMIN_CREATE"] = 5] = "TOKEN_ADMIN_CREATE";
    BaseFlag[BaseFlag["TOKEN_ADMIN_SUPPLY"] = 6] = "TOKEN_ADMIN_SUPPLY";
    BaseFlag[BaseFlag["TOKEN_ADMIN_MODIFY_BALANCE"] = 7] = "TOKEN_ADMIN_MODIFY_BALANCE";
    BaseFlag[BaseFlag["PERMISSION_DELEGATE_ADD"] = 11] = "PERMISSION_DELEGATE_ADD";
    BaseFlag[BaseFlag["PERMISSION_DELEGATE_REMOVE"] = 12] = "PERMISSION_DELEGATE_REMOVE";
    BaseFlag[BaseFlag["MANAGE_CERTIFICATE"] = 13] = "MANAGE_CERTIFICATE";
    BaseFlag[BaseFlag["MULTISIG_SIGNER"] = 14] = "MULTISIG_SIGNER"; /* 0x4000 */
})(BaseFlag || (BaseFlag = {}));
/**
 * Handles what flags are in what groups, groups cannot be mixed (except BASE)
 * network/token permissions must be granted on network/token identifiers
 */
var BasePermissionGroup;
(function (BasePermissionGroup) {
    BasePermissionGroup[BasePermissionGroup["NEVER"] = 0] = "NEVER";
    BasePermissionGroup[BasePermissionGroup["ANY"] = 1] = "ANY";
    BasePermissionGroup[BasePermissionGroup["NONIDENTIFIER"] = 2] = "NONIDENTIFIER";
    BasePermissionGroup[BasePermissionGroup["NETWORK"] = 3] = "NETWORK";
    BasePermissionGroup[BasePermissionGroup["TOKEN"] = 4] = "TOKEN";
    BasePermissionGroup[BasePermissionGroup["STORAGE"] = 5] = "STORAGE";
    BasePermissionGroup[BasePermissionGroup["NONIDENTIFIER_OR_MULTISIG"] = 6] = "NONIDENTIFIER_OR_MULTISIG";
    BasePermissionGroup[BasePermissionGroup["MULTISIG"] = 7] = "MULTISIG";
})(BasePermissionGroup || (BasePermissionGroup = {}));
const basePermissionRules = {
    ACCESS: {
        canBeDefault: true,
        entity: BasePermissionGroup.ANY,
        principal: BasePermissionGroup.ANY,
        target: BasePermissionGroup.ANY
    },
    OWNER: {
        canBeDefault: false,
        entity: BasePermissionGroup.ANY,
        principal: BasePermissionGroup.NONIDENTIFIER,
        target: BasePermissionGroup.NEVER
    },
    ADMIN: {
        canBeDefault: false,
        entity: BasePermissionGroup.ANY,
        principal: BasePermissionGroup.NONIDENTIFIER,
        target: BasePermissionGroup.NEVER
    },
    UPDATE_INFO: {
        canBeDefault: false,
        entity: BasePermissionGroup.ANY,
        principal: BasePermissionGroup.NONIDENTIFIER,
        target: BasePermissionGroup.NEVER
    },
    SEND_ON_BEHALF: {
        canBeDefault: false,
        entity: BasePermissionGroup.ANY,
        principal: BasePermissionGroup.NONIDENTIFIER,
        target: BasePermissionGroup.TOKEN
    },
    STORAGE_CREATE: {
        canBeDefault: true,
        entity: BasePermissionGroup.NETWORK,
        principal: BasePermissionGroup.NONIDENTIFIER,
        target: BasePermissionGroup.NEVER
    },
    STORAGE_CAN_HOLD: {
        canBeDefault: true,
        entity: BasePermissionGroup.STORAGE,
        principal: BasePermissionGroup.TOKEN,
        target: BasePermissionGroup.NEVER
    },
    STORAGE_DEPOSIT: {
        canBeDefault: true,
        entity: BasePermissionGroup.STORAGE,
        principal: BasePermissionGroup.ANY,
        target: BasePermissionGroup.TOKEN
    },
    TOKEN_ADMIN_CREATE: {
        canBeDefault: true,
        entity: BasePermissionGroup.NETWORK,
        principal: BasePermissionGroup.NONIDENTIFIER,
        target: BasePermissionGroup.NEVER
    },
    TOKEN_ADMIN_SUPPLY: {
        canBeDefault: false,
        entity: BasePermissionGroup.TOKEN,
        principal: BasePermissionGroup.NONIDENTIFIER,
        target: BasePermissionGroup.NEVER
    },
    TOKEN_ADMIN_MODIFY_BALANCE: {
        canBeDefault: false,
        entity: BasePermissionGroup.TOKEN,
        principal: BasePermissionGroup.NONIDENTIFIER,
        target: BasePermissionGroup.ANY
    },
    PERMISSION_DELEGATE_ADD: {
        canBeDefault: false,
        entity: BasePermissionGroup.ANY,
        principal: BasePermissionGroup.NONIDENTIFIER,
        target: BasePermissionGroup.ANY
    },
    PERMISSION_DELEGATE_REMOVE: {
        canBeDefault: false,
        entity: BasePermissionGroup.ANY,
        principal: BasePermissionGroup.NONIDENTIFIER,
        target: BasePermissionGroup.ANY
    },
    MANAGE_CERTIFICATE: {
        canBeDefault: true,
        entity: BasePermissionGroup.ANY,
        principal: BasePermissionGroup.ANY,
        target: BasePermissionGroup.NEVER
    },
    MULTISIG_SIGNER: {
        canBeDefault: false,
        entity: BasePermissionGroup.MULTISIG,
        principal: BasePermissionGroup.NONIDENTIFIER_OR_MULTISIG,
        target: BasePermissionGroup.NEVER
    }
};
const basePermissionSetOffsets = {};
// Generate an offset-set from the base flags
for (const flag in BaseFlag) {
    // Not everything in the enum is a number, some are the actual string flags;
    if (typeof BaseFlag[flag] !== 'string') {
        // We know this is a valid flag name, but the compiler does not
        // eslint-disable-next-line @typescript-eslint/consistent-type-assertions
        basePermissionSetOffsets[flag] = BaseFlag[flag];
    }
}
// If a string is a valid Base Flag
function IsBaseFlag(flag) {
    return (Object.keys(basePermissionRules).includes(flag));
}
// If a string follows the external flag format, just checking the prefix
function IsExternalFlag(flag) {
    return (flag.startsWith(externalFlagPrefix) && flag !== externalFlagPrefix);
}
// Checking that the offset set has all external flags as keys
function IsExternalFlagOffsetSet(set) {
    return (Object.keys(set).find(key => IsExternalFlag(key) === false) === undefined);
}
function assertBaseFlagNames(names) {
    for (const name of names) {
        if (!IsBaseFlag(name)) {
            throw (new permissions_1.default('PERMISSIONS_INVALID_FLAG_ASSERTION', `Invalid flag name: ${name}`));
        }
    }
}
function assertBaseOrExternalFlag(flag) {
    if (!IsBaseFlag(flag) && !IsExternalFlag(flag)) {
        throw (new permissions_1.default('PERMISSIONS_INVALID_FLAG_ASSERTION', `Invalid flag name: ${flag}`));
    }
    return (flag);
}
function assertBaseFlag(flag) {
    if (!IsBaseFlag(flag)) {
        throw (new permissions_1.default('PERMISSIONS_INVALID_FLAG_ASSERTION', `Invalid flag name: ${flag}`));
    }
    return (flag);
}
function isNumberArray(arr) {
    if (!Array.isArray(arr)) {
        return (false);
    }
    if (arr.some(item => typeof item !== 'number')) {
        return (false);
    }
    return (true);
}
/**
 * Abstract class to hold permissions, handles storage and some basic functions
 */
class PermissionSetHolder {
    constructor(initialValue) {
        this.storage = new bitfield_1.default(initialValue);
    }
    computeFlagsFromOffsetSet(offsets) {
        const newFlags = [];
        for (const [flagName, offset] of Object.entries(offsets)) {
            const has = this.storage.get(offset);
            if (has !== true) {
                continue;
            }
            newFlags.push(assertBaseOrExternalFlag(flagName));
        }
        return (newFlags);
    }
    // Represent permissions as a bigint
    get bigint() {
        return (this.storage.bigint);
    }
}
/**
 * Base Set permission holder
 */
class BaseSet extends PermissionSetHolder {
    constructor(presetFlags) {
        super(presetFlags);
        _BaseSet_instances.add(this);
        _BaseSet_flags.set(this, []);
        _BaseSet_offsets.set(this, basePermissionSetOffsets);
        const rawFlags = this.computeFlagsFromOffsetSet(__classPrivateFieldGet(this, _BaseSet_offsets, "f"));
        assertBaseFlagNames(rawFlags);
        __classPrivateFieldGet(this, _BaseSet_instances, "m", _BaseSet_computeFlagGroup).call(this, 'entity', rawFlags);
        __classPrivateFieldGet(this, _BaseSet_instances, "m", _BaseSet_computeFlagGroup).call(this, 'principal', rawFlags);
        __classPrivateFieldGet(this, _BaseSet_instances, "m", _BaseSet_computeFlagGroup).call(this, 'target', rawFlags);
        const newFlags = __classPrivateFieldGet(this, _BaseSet_instances, "m", _BaseSet_computeOutputFlags).call(this, rawFlags);
        __classPrivateFieldGet(this, _BaseSet_instances, "m", _BaseSet_updateStorageFromFlags).call(this, newFlags);
        __classPrivateFieldSet(this, _BaseSet_flags, newFlags, "f");
    }
    static Create(presetFlags) {
        // If you pass an array of flags, calculate offset array from that array
        if (Array.isArray(presetFlags)) {
            if (!isNumberArray(presetFlags)) {
                presetFlags = __classPrivateFieldGet(this, _a, "m", _BaseSet_computeOffsetArrayFromFlags).call(this, presetFlags);
            }
        }
        return (new _a(presetFlags));
    }
    // Check if the set has flags
    hasFlags(flags) {
        if (typeof flags === 'string') {
            flags = [flags];
        }
        for (const flag of flags) {
            if (this.flags.includes(flag) === false) {
                return (false);
            }
        }
        return (true);
    }
    checkAccountMatchesGroup(type, account) {
        const flagGroup = __classPrivateFieldGet(this, _BaseSet_instances, "m", _BaseSet_computeFlagGroup).call(this, type, this.flags);
        if (account === undefined) {
            if (type === 'target') {
                return (true);
            }
            if (flagGroup === BasePermissionGroup.NEVER) {
                return (true);
            }
            return (false);
        }
        const { keyType } = account;
        switch (flagGroup) {
            case _a.BasePermissionGroup.NONIDENTIFIER:
                // Multisig addresses can sign anywhere a keyed account can.
                return (account.isAccount() || account.isMultisig());
            case _a.BasePermissionGroup.NETWORK:
                return (keyType === account_1.AccountKeyAlgorithm.NETWORK);
            case _a.BasePermissionGroup.TOKEN:
                return (keyType === account_1.AccountKeyAlgorithm.TOKEN);
            case _a.BasePermissionGroup.STORAGE:
                return (keyType === account_1.AccountKeyAlgorithm.STORAGE);
            case _a.BasePermissionGroup.ANY:
                return (true);
            case _a.BasePermissionGroup.NEVER:
                return (false);
            case _a.BasePermissionGroup.NONIDENTIFIER_OR_MULTISIG:
                return (account.isAccount() || account.isMultisig());
            case _a.BasePermissionGroup.MULTISIG:
                return (account.isMultisig());
        }
        return (false);
    }
    get flags() {
        return (__classPrivateFieldGet(this, _BaseSet_flags, "f"));
    }
    get isValidForDefault() {
        const foundInvalid = __classPrivateFieldGet(this, _BaseSet_flags, "f").find(flag => basePermissionRules[flag].canBeDefault !== true);
        return (foundInvalid === undefined);
    }
}
_a = BaseSet, _BaseSet_flags = new WeakMap(), _BaseSet_offsets = new WeakMap(), _BaseSet_instances = new WeakSet(), _BaseSet_computeOffsetArrayFromFlags = function _BaseSet_computeOffsetArrayFromFlags(flags) {
    const ret = [];
    for (const flag of flags) {
        if (IsBaseFlag(flag) !== true) {
            throw (new permissions_1.default('PERMISSIONS_INVALID_FLAG', `Invalid flag passed in: ${flag}`));
        }
        ret.push(BaseFlag[flag]);
    }
    return (ret);
}, _BaseSet_updateStorageFromFlags = function _BaseSet_updateStorageFromFlags(updatedFlags) {
    assertBaseFlagNames(updatedFlags);
    for (const [flagName, offset] of Object.entries(__classPrivateFieldGet(this, _BaseSet_offsets, "f"))) {
        this.storage.set(offset, updatedFlags.includes(assertBaseFlag(flagName)));
    }
}, _BaseSet_computeFlagGroup = function _BaseSet_computeFlagGroup(type, flags) {
    let finalGroup = BasePermissionGroup.ANY;
    for (const flag of flags) {
        const foundGroup = basePermissionRules[flag];
        const foundType = foundGroup[type];
        if (foundType === BasePermissionGroup.ANY) {
            continue;
        }
        // No need to update anything if the found group is the same as what is currently going to be returned
        if (finalGroup === foundType) {
            continue;
        }
        // If the found type is never, that will invalidate all other types
        if (foundType === BasePermissionGroup.NEVER) {
            return (foundType);
        }
        if (finalGroup === BasePermissionGroup.ANY) {
            finalGroup = foundType;
        }
        if (foundType !== finalGroup) {
            throw (new permissions_1.default('PERMISSIONS_CANNOT_MIX_FLAGS_AND_TYPES', `Cannot mix base flags with different ${type} [${finalGroup}/${foundType}] Flags: [${flags.join(',')}]`));
        }
    }
    return (finalGroup);
}, _BaseSet_computeOutputFlags = function _BaseSet_computeOutputFlags(newFlags) {
    // OWNER and ADMIN override any other flags (besides access);
    if (newFlags.includes('OWNER')) {
        newFlags = ['OWNER'];
    }
    if (newFlags.includes('ADMIN')) {
        newFlags = ['ADMIN'];
    }
    // If permissions are not empty, add ACCESS flag
    if (newFlags.length > 0) {
        if (newFlags.includes('ACCESS') === false) {
            newFlags = [...newFlags, 'ACCESS'];
        }
    }
    return (newFlags);
};
BaseSet.isInstance = (0, helper_1.checkableGenerator)(_a);
BaseSet.BasePermissionGroup = BasePermissionGroup;
/**
 * External permission set holder
 */
class ExternalSet extends PermissionSetHolder {
    constructor(presetOffsets = []) {
        super(presetOffsets);
        _ExternalSet_instances.add(this);
    }
    static Create(presetFlags) {
        return (new ExternalSet(presetFlags));
    }
    validate(network) {
        const validation = (0, config_1.getValidation)(network);
        __classPrivateFieldGet(this, _ExternalSet_instances, "m", _ExternalSet_validateWithinMaxLength).call(this, validation);
        return (true);
    }
    /**
     * Takes an offset set
     * Returns an array of external flags that are true in relation to current storage
     */
    computeFlagNames(offsets) {
        const validOffsetSet = IsExternalFlagOffsetSet(offsets);
        if (!validOffsetSet) {
            throw (new permissions_1.default('PERMISSIONS_INVALID_EXTERNAL_FLAG', 'Invalid external flag set provided'));
        }
        return (this.computeFlagsFromOffsetSet(offsets));
    }
    // If the set has a specific offset set as true
    hasOffset(offset) {
        return (this.storage.get(offset));
    }
    // Set a specific offset to true/false
    setOffset(offset, value) {
        this.storage.set(offset, value);
    }
    // Take an array of offsets, and set all of those to true
    setFromTrueOffsets(trueOffset) {
        for (const offset of trueOffset) {
            this.setOffset(offset, true);
        }
    }
    // Get all true offsets as an array of numbers
    get trueOffsets() {
        const has = [];
        for (let i = 0; i < this.storage.size; i++) {
            if (this.hasOffset(i)) {
                has.push(i);
            }
        }
        return (has);
    }
}
_ExternalSet_instances = new WeakSet(), _ExternalSet_validateWithinMaxLength = function _ExternalSet_validateWithinMaxLength(validation) {
    const { maxExternalOffset } = validation.permissions;
    if (this.storage.size >= maxExternalOffset) {
        throw (new permissions_1.default('PERMISSIONS_EXTERNAL_OFFSET_TOO_LARGE', `External permissions can only have up to ${maxExternalOffset} flags set and tried to set ${this.storage.size}`));
    }
};
ExternalSet.isInstance = (0, helper_1.checkableGenerator)(ExternalSet);
/**
 * Class to hold a Base and External permission set
 */
class Permissions {
    static FromAcceptedTypes(perms) {
        if (Permissions.isInstance(perms)) {
            return (new Permissions(perms.base, perms.external));
        }
        if (perms === false) {
            return (new Permissions());
        }
        let base;
        let external;
        if (Array.isArray(perms[0])) {
            base = Permissions.BaseSet.Create(perms[0]);
        }
        if (isNumberArray(perms[1])) {
            external = Permissions.ExternalSet.Create(perms[1]).bigint;
        }
        if (typeof perms[0] === 'string') {
            base = BigInt(perms[0]);
        }
        if (typeof perms[1] === 'string') {
            external = BigInt(perms[1]);
        }
        return (new Permissions(base, external));
    }
    constructor(baseFlags = [], externalOffsets = []) {
        _Permissions_baseSet.set(this, void 0);
        _Permissions_externalSet.set(this, void 0);
        if (BaseSet.isInstance(baseFlags)) {
            baseFlags = baseFlags.flags;
        }
        __classPrivateFieldSet(this, _Permissions_baseSet, BaseSet.Create(baseFlags), "f");
        if (ExternalSet.isInstance(externalOffsets)) {
            externalOffsets = externalOffsets.trueOffsets;
        }
        __classPrivateFieldSet(this, _Permissions_externalSet, ExternalSet.Create(externalOffsets), "f");
    }
    validate(network) {
        __classPrivateFieldGet(this, _Permissions_externalSet, "f").validate(network);
        return (true);
    }
    has(flags = [], offsets = []) {
        if (Permissions.isInstance(flags)) {
            return (this.has(flags.base.flags, flags.external.trueOffsets));
        }
        if ((flags.length + offsets.length) === 0) {
            return (true);
        }
        if (__classPrivateFieldGet(this, _Permissions_baseSet, "f").hasFlags('ACCESS') === false) {
            return (false);
        }
        if (__classPrivateFieldGet(this, _Permissions_baseSet, "f").hasFlags('OWNER')) {
            return (true);
        }
        if (flags.includes('OWNER') === false && __classPrivateFieldGet(this, _Permissions_baseSet, "f").hasFlags('ADMIN')) {
            return (true);
        }
        for (const flag of flags) {
            const hasSingleFlag = __classPrivateFieldGet(this, _Permissions_baseSet, "f").hasFlags(flag);
            if (hasSingleFlag === false) {
                return (false);
            }
        }
        for (const offset of offsets) {
            const hasSingleOffset = __classPrivateFieldGet(this, _Permissions_externalSet, "f").hasOffset(offset);
            if (hasSingleOffset === false) {
                return (false);
            }
        }
        return (true);
    }
    static combine(combineFrom, toCombine) {
        const newBaseSet = BaseSet.Create([
            ...__classPrivateFieldGet(combineFrom, _Permissions_baseSet, "f").flags,
            ...__classPrivateFieldGet(toCombine, _Permissions_baseSet, "f").flags
        ]);
        const newExternalSet = ExternalSet.Create([
            ...__classPrivateFieldGet(combineFrom, _Permissions_externalSet, "f").trueOffsets,
            ...__classPrivateFieldGet(toCombine, _Permissions_externalSet, "f").trueOffsets
        ]);
        return (new Permissions(newBaseSet, newExternalSet));
    }
    combine(toCombine) {
        return (Permissions.combine(this, toCombine));
    }
    static remove(removeFrom, toRemove) {
        const newFlags = __classPrivateFieldGet(removeFrom, _Permissions_baseSet, "f").flags.filter(function (flag) {
            return (!toRemove.base.flags.includes(flag));
        });
        const newOffsets = __classPrivateFieldGet(removeFrom, _Permissions_externalSet, "f").trueOffsets.filter(function (offset) {
            return (!toRemove.external.trueOffsets.includes(offset));
        });
        return (new Permissions(BaseSet.Create(newFlags), ExternalSet.Create(newOffsets)));
    }
    remove(toRemove) {
        return (Permissions.remove(this, toRemove));
    }
    // NOTE: This wont compare what external set it is from, only that the value is equal
    compare(toCompare) {
        if (toCompare === undefined) {
            return (false);
        }
        return (__classPrivateFieldGet(this, _Permissions_baseSet, "f").bigint === toCompare.base.bigint && __classPrivateFieldGet(this, _Permissions_externalSet, "f").bigint === toCompare.external.bigint);
    }
    get toUpdateRequires() {
        let requiredFlag = 'ADMIN';
        if (this.has(['OWNER'])) {
            requiredFlag = 'OWNER';
        }
        return (new Permissions([requiredFlag]));
    }
    get canUseDelegation() {
        const delegationFlags = [
            'ADMIN',
            'PERMISSION_DELEGATE_ADD',
            'PERMISSION_DELEGATE_REMOVE'
        ];
        for (const flag of delegationFlags) {
            if (this.has([flag])) {
                return (false);
            }
        }
        return (true);
    }
    get base() {
        return (__classPrivateFieldGet(this, _Permissions_baseSet, "f"));
    }
    get external() {
        return (__classPrivateFieldGet(this, _Permissions_externalSet, "f"));
    }
    toJSON() {
        return ([this.base.bigint, this.external.bigint]);
    }
}
exports.Permissions = Permissions;
_Permissions_baseSet = new WeakMap(), _Permissions_externalSet = new WeakMap();
Permissions.isInstance = (0, helper_1.checkableGenerator)(Permissions);
Permissions.BaseSet = BaseSet;
Permissions.ExternalSet = ExternalSet;


/***/ }),

/***/ 2127:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var _a, _Stats_syncPromise, _Stats_kv, _Stats_assertDurationBreakdowns, _Stats_getDurationRange;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Stats = exports.StatsPending = void 0;
const kv_memory_1 = __importDefault(__webpack_require__(1557));
const buffer_1 = __webpack_require__(3310);
const hash_1 = __webpack_require__(7908);
/**
 * Size of the XOR buffer objects -- we use them for block hashes so they
 * should be the same size as a block hash
 */
const XOR_BUFFER_SIZE = hash_1.HashFunctionLength;
const durationRanges = {
    '-1ms': [-1, -1],
    '0ms': [0, 0],
    '10ms': [1, 10],
    '100ms': [11, 100],
    '200ms': [101, 200],
    '300ms': [201, 300],
    '400ms': [301, 400],
    '500ms': [401, 500],
    '600ms': [501, 600],
    '700ms': [601, 700],
    '800ms': [701, 800],
    '900ms': [801, 900],
    '1000ms': [901, 1000],
    '1500ms': [1001, 1500],
    '2000ms': [1501, 2000],
    '5000ms': [2001, 5000],
    '10000ms': [5001, 10000],
    '100000ms': [10001, 100000],
    'ExtraLong': [100000, Number.MAX_SAFE_INTEGER]
};
class StatsPending {
    constructor() {
        this.localDBIncr = {};
        this.localDBXOR = {};
    }
    consume() {
        const incrChanges = this.localDBIncr;
        this.localDBIncr = {};
        const xorChanges = this.localDBXOR;
        this.localDBXOR = {};
        return ({ incrChanges, xorChanges });
    }
    compoundKey(arena, key) {
        const compoundKey = [arena, key].join('|');
        return (compoundKey);
    }
    incrCompoundKey(compoundKey, change) {
        if (this.localDBIncr[compoundKey] === undefined) {
            this.localDBIncr[compoundKey] = 0;
        }
        this.localDBIncr[compoundKey] += change;
    }
    incr(arena, key, change = 1) {
        const compoundKey = this.compoundKey(arena, key);
        this.incrCompoundKey(compoundKey, change);
    }
    xor(key, change) {
        const changeValue = typeof change === 'bigint' ? change : change.toBigInt();
        const existingValue = this.localDBXOR[key];
        if (existingValue === undefined) {
            this.localDBXOR[key] = changeValue;
            return;
        }
        this.localDBXOR[key] ^= changeValue;
    }
    merge(pending) {
        const { incrChanges, xorChanges } = pending.consume();
        // Merge incr changes
        for (const [key, value] of Object.entries(incrChanges)) {
            this.incrCompoundKey(key, value);
        }
        // Merge xor changes
        for (const [key, value] of Object.entries(xorChanges)) {
            this.xor(key, value);
        }
    }
}
exports.StatsPending = StatsPending;
class Stats extends StatsPending {
    constructor(config) {
        super();
        _Stats_syncPromise.set(this, void 0);
        _Stats_kv.set(this, void 0);
        let kv = config.kv;
        if (kv === null) {
            kv = new kv_memory_1.default();
        }
        __classPrivateFieldSet(this, _Stats_kv, kv, "f");
    }
    // Return all keys from durationRanges
    static durationBreakdownList() {
        // We know the keys are all valid to the type, but typescript does not know this
        // eslint-disable-next-line @typescript-eslint/consistent-type-assertions
        return Object.keys(durationRanges);
    }
    static assertDurationBreakdown(duration) {
        if (!(duration in durationRanges)) {
            throw (new Error(`Invalid duration: ${duration}`));
        }
    }
    // Get duration key for specific number
    static durationBreakdown(duration) {
        // Loop through ranges and select key with range that fits around duration
        if (duration < 0) {
            duration = 0;
        }
        for (const name of this.durationBreakdownList()) {
            const [min, max] = durationRanges[name];
            if (duration >= min && (max === undefined || duration <= max)) {
                return (name);
            }
        }
        throw (new Error(`Time frame not found for duration: ${duration}`));
    }
    static placeholderTimingData() {
        const ret = {};
        for (const key of this.durationBreakdownList()) {
            ret[key] = { count: -1, range: __classPrivateFieldGet(this, _a, "m", _Stats_getDurationRange).call(this, key) };
        }
        // We know this fits TimeStats because we just created it with all of the keys
        // eslint-disable-next-line @typescript-eslint/consistent-type-assertions
        return ret;
    }
    async getXor(key) {
        await __classPrivateFieldGet(this, _Stats_syncPromise, "f");
        const bufferKey = `@buffer:${key}`;
        const baseString = await __classPrivateFieldGet(this, _Stats_kv, "f").get(null, bufferKey);
        let base = 0n;
        if (baseString !== undefined) {
            base = BigInt(`0x${baseString}`);
        }
        let local = 0n;
        if (this.localDBXOR[key] !== undefined) {
            local = this.localDBXOR[key];
        }
        const computed = base ^ local;
        const retval = new buffer_1.BufferStorage(computed, XOR_BUFFER_SIZE);
        return (retval);
    }
    // Calculate key and increment for specific duration/category
    addTimingPoint(arena, category, duration, returnOnly = false) {
        const breakdown = _a.durationBreakdown(duration);
        const params = [arena, `${category}@${breakdown}`, 1];
        if (returnOnly !== true) {
            this.incr(...params);
        }
        return (params);
    }
    addRequestTiming(arena, timing, returnOnly = false) {
        const retval = [];
        for (const sectionInfo of Object.values(timing.getAllTiming())) {
            const duration = sectionInfo.duration;
            const name = sectionInfo.name;
            retval.push(this.addTimingPoint(arena, name, duration, returnOnly));
        }
        return (retval);
    }
    async get(arena, key) {
        await __classPrivateFieldGet(this, _Stats_syncPromise, "f");
        const compoundKey = this.compoundKey(arena, key);
        let base = await __classPrivateFieldGet(this, _Stats_kv, "f").get('stats', compoundKey);
        if (base === undefined) {
            base = 0;
        }
        if (typeof base === 'string') {
            base = Number(base);
        }
        if (typeof base !== 'number' || isNaN(base)) {
            throw (new Error('internal error: corrupt data in stats table'));
        }
        let local = 0;
        if (this.localDBIncr[compoundKey] !== undefined) {
            local = this.localDBIncr[compoundKey];
        }
        return (base + local);
    }
    // Get all timing data from specific arena/category
    async getTimingData(arena, category) {
        const retval = _a.placeholderTimingData();
        const keys = Object.keys(retval);
        __classPrivateFieldGet(_a, _a, "m", _Stats_assertDurationBreakdowns).call(_a, keys);
        await Promise.all(keys.map(async (breakdown) => {
            const key = `${category}@${breakdown}`;
            const range = __classPrivateFieldGet(_a, _a, "m", _Stats_getDurationRange).call(_a, breakdown);
            let count = -1;
            try {
                count = await this.get(arena, key);
            }
            catch (_ignored_error) {
                /* Errors fetching single stat are ignored */
            }
            finally {
                retval[breakdown] = {
                    count, range
                };
            }
        }));
        return (retval);
    }
    async sync() {
        const { incrChanges, xorChanges } = this.consume();
        await __classPrivateFieldGet(this, _Stats_syncPromise, "f");
        __classPrivateFieldSet(this, _Stats_syncPromise, (async () => {
            const updatePromises = [];
            for (const [key, value] of Object.entries(incrChanges)) {
                if (value === undefined) {
                    continue;
                }
                updatePromises.push(__classPrivateFieldGet(this, _Stats_kv, "f").incr('stats', key, value));
            }
            for (const [key, value] of Object.entries(xorChanges)) {
                if (value === undefined) {
                    continue;
                }
                const valueBuffer = new buffer_1.BufferStorage(value, XOR_BUFFER_SIZE);
                const bufferKey = `@buffer:${key}`;
                updatePromises.push(__classPrivateFieldGet(this, _Stats_kv, "f").xor(null, bufferKey, valueBuffer));
            }
            await Promise.all(updatePromises);
        })(), "f");
        await __classPrivateFieldGet(this, _Stats_syncPromise, "f");
        __classPrivateFieldSet(this, _Stats_syncPromise, undefined, "f");
    }
}
exports.Stats = Stats;
_a = Stats, _Stats_syncPromise = new WeakMap(), _Stats_kv = new WeakMap(), _Stats_assertDurationBreakdowns = function _Stats_assertDurationBreakdowns(durations) {
    for (const duration of durations) {
        this.assertDurationBreakdown(duration);
    }
}, _Stats_getDurationRange = function _Stats_getDurationRange(duration) {
    this.assertDurationBreakdown(duration);
    const range = durationRanges[duration];
    if (!range) {
        throw (new Error(`Could not get range for invalid duration: ${duration}, got range ${range}`));
    }
    // eslint-disable-next-line @typescript-eslint/consistent-type-assertions
    return range;
};
exports["default"] = Stats;


/***/ }),

/***/ 6045:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var _ValidateASN1_schema, _BufferStorageASN1_data;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports._Testing = exports.ASN1BigIntToBuffer = exports.ASN1IntegerToBigInt = exports.JStoASN1 = exports.ASN1toJS = exports.BufferStorageASN1 = exports.ValidateASN1 = exports.ASN1CheckUtilities = exports.asn1 = void 0;
exports.isASN1Object = isASN1Object;
exports.isValidSequenceSchema = isValidSequenceSchema;
const asn1js = __importStar(__webpack_require__(7813));
const helper_1 = __webpack_require__(3208);
const util_1 = __webpack_require__(9023);
exports.asn1 = asn1js;
const never_1 = __webpack_require__(8692);
const util_2 = __importDefault(__webpack_require__(9023));
/**
 * Enable this flag to validate the output of the native bindings against the
 * JavaScript implementation. This is useful for debugging and testing the
 * native bindings.
 */
const ASN1_ENCODE_DECODE_PARANOID = process.env['KEETANET_NODE_ASN1_ENCODE_DECODE_PARANOID'] === '1';
function jsBigIntToBuffer(value) {
    /**
     * Convert value to Hex
     */
    let valueStr = value.toString(16);
    /**
     * Determine if the value is negative
     */
    let isNegative = false;
    if (valueStr.startsWith('-')) {
        isNegative = true;
        valueStr = valueStr.slice(1);
    }
    /*
     * Ensure there are an even number of hex digits
     */
    if (valueStr.length % 2 !== 0) {
        valueStr = '0' + valueStr;
    }
    /*
     * Pad with a leading 0 byte if the MSB is 1 to avoid writing a
     * negative number
     */
    const leader = valueStr.slice(0, 2);
    const leaderValue = Number(`0x${leader}`);
    if (!isNegative) {
        if (leaderValue > 127) {
            valueStr = '00' + valueStr;
        }
    }
    else {
        if (leaderValue <= 127) {
            valueStr = 'FF' + valueStr;
        }
    }
    /*
     * Convert to a buffer
     */
    const valueBuffer = Buffer.from(valueStr, 'hex');
    return (valueBuffer);
}
/* XXX:TODO: This does not correctly deal with negative values */
function jsIntegerToBigInt(value) {
    let valueStr;
    if (value instanceof asn1js.Integer) {
        valueStr = value.toString().split(':')[1].trim();
    }
    else {
        valueStr = value;
    }
    return (BigInt(valueStr));
}
function isASN1Object(input) {
    if (input === null || input === undefined || typeof input !== 'object') {
        return (false);
    }
    if (!('type' in input) || typeof input.type !== 'string') {
        return (false);
    }
    return (true);
}
function isASN1OID(input) {
    if (!isASN1Object(input)) {
        return (false);
    }
    if (input.type !== 'oid') {
        return (false);
    }
    if (!('oid' in input) || typeof input.oid !== 'string') {
        return (false);
    }
    return (true);
}
function isASN1String(input) {
    if (!isASN1Object(input)) {
        return (false);
    }
    if (!('type' in input) || input.type !== 'string') {
        return (false);
    }
    if (!('kind' in input) || typeof input.kind !== 'string') {
        return (false);
    }
    switch (input.kind) {
        case 'printable':
        case 'ia5':
        case 'utf8':
            break;
        default:
            return (false);
    }
    if (!('value' in input) || typeof input.value !== 'string') {
        return (false);
    }
    return (true);
}
function isASN1Set(input) {
    if (!isASN1Object(input)) {
        return (false);
    }
    if (input.type !== 'set') {
        return (false);
    }
    if (!('name' in input) || !isASN1OID(input.name)) {
        return (false);
    }
    if (!('value' in input)) {
        return (false);
    }
    if (typeof input.value !== 'string') {
        if (!isASN1String(input.value)) {
            return (false);
        }
    }
    return (true);
}
function isASN1ContextTagKind(input) {
    if (typeof input !== 'string') {
        return (false);
    }
    if (!(['explicit', 'implicit'].includes(input))) {
        return (false);
    }
    return (true);
}
function isASN1ContextTag(input, tagKind) {
    if (!isASN1Object(input)) {
        return (false);
    }
    if (!('type' in input) || input.type !== 'context') {
        return (false);
    }
    if (!('value' in input) || typeof input.value !== 'number') {
        return (false);
    }
    if (!('contains' in input) || input.contains === undefined) {
        return (false);
    }
    if (!('kind' in input) || !isASN1ContextTagKind(input.kind)) {
        return (false);
    }
    if (tagKind !== undefined && input.kind !== tagKind) {
        return (false);
    }
    return (true);
}
function isASN1BitString(input) {
    if (!isASN1Object(input)) {
        return (false);
    }
    if (input.type !== 'bitstring') {
        return (false);
    }
    if (!('value' in input) || !(0, helper_1.isBuffer)(input.value)) {
        return (false);
    }
    return (true);
}
function isASN1Date(input) {
    if (!isASN1Object(input)) {
        return (false);
    }
    if (!('type' in input) || input.type !== 'date') {
        return (false);
    }
    if ('kind' in input) {
        if (input.kind !== 'utc' && input.kind !== 'general' && input.kind !== 'default') {
            return (false);
        }
    }
    if (!('date' in input) || !util_1.types.isDate(input.date)) {
        return (false);
    }
    return (true);
}
function isStringValidForKind(input, kind) {
    if (input === '') {
        return (true);
    }
    switch (kind) {
        case 'printable':
            /* PrintableString can contain a specific set of characters */
            if (input.match(/^[a-zA-Z0-9 '()+,./:=?-]*$/)) {
                return (true);
            }
            break;
        case 'ia5':
            /* IA5String can contain any character below ASCII 128 */
            if (input.match(/^[ -~]*$/)) {
                return (true);
            }
            break;
        case 'utf8':
            /* UTF-8 can handle any character */
            return (true);
        default:
            (0, never_1.assertNever)(kind);
    }
    return (false);
}
exports.ASN1CheckUtilities = {
    isASN1Object,
    isASN1OID,
    isASN1String,
    isASN1Set,
    isASN1ContextTag,
    isASN1BitString,
    isASN1Date
};
/**
 * Checks if an ASN.1 sequence is valid based on a provided validation schema.
 */
function isValidSequenceSchema(input, schema) {
    if (input.length !== schema.length) {
        return (false);
    }
    for (const [i, val] of input.entries()) {
        if (schema[i] === undefined || !schema[i](val)) {
            return (false);
        }
    }
    return (true);
}
const oidMapDB = {
    'sha256': '2.16.840.1.101.3.4.2.1',
    'sha3-256': '2.16.840.1.101.3.4.2.8',
    'sha3-256WithEcDSA': '2.16.840.1.101.3.4.3.10',
    'sha256WithEcDSA': '1.2.840.10045.4.3.2',
    'ecdsa': '1.2.840.10045.2.1',
    'ed25519': '1.3.101.112',
    'secp256k1': '1.3.132.0.10',
    'secp256r1': '1.2.840.10045.3.1.7',
    'account': '2.23.42.2.7.11',
    'serialNumber': '2.5.4.5',
    'member': '2.5.4.31',
    'commonName': '2.5.4.3',
    'hash': '1.3.6.1.4.1.8301.3.2.2.1.1',
    'hashData': '2.16.840.1.101.3.3.1.3'
};
/**
 * Convert a symbolic name into an Object Identifier (OID)
 */
function nameToOID(name) {
    const oid = oidMapDB[name];
    if (oid === undefined) {
        /**
         * If the name looks like an OID, just return it
         */
        if (name.includes('.')) {
            return (name);
        }
        throw (new Error(`Unable to lookup OID for ${name}`));
    }
    return (oid);
}
/**
 * Convert an Object Identifier into the canonical symbolic name
 */
function oidToName(oid) {
    if (oid instanceof asn1js.ObjectIdentifier) {
        oid = oid.valueBlock.toString();
    }
    for (const checkName in oidMapDB) {
        const checkOID = oidMapDB[checkName];
        if (checkOID === oid) {
            return (checkName);
        }
    }
    return (oid);
}
function jsJStoASN1(input, allowUndefined) {
    if (Array.isArray(input)) {
        const container = new asn1js.Sequence();
        container.valueBlock.value = input.map(function (item) {
            return (jsJStoASN1(item, true));
        }).filter(function (item) {
            return (item !== undefined);
        });
        return (container);
    }
    else if (typeof input === 'bigint') {
        const valueHex = jsBigIntToBuffer(input);
        // @ts-ignore
        return (new asn1js.Integer({ isHexOnly: true, valueHex }));
    }
    else if (typeof input === 'number') {
        return (new asn1js.Integer({ value: input }));
    }
    else if (util_1.types.isDate(input)) {
        /* By default, handle dates as described by RFC 5280 */
        if (input.getUTCFullYear() < 2050) {
            return (new asn1js.UTCTime({ valueDate: input }));
        }
        else {
            return (new asn1js.GeneralizedTime({ valueDate: input }));
        }
    }
    else if (isASN1Date(input)) {
        /* Allow the user to specify the date format */
        if (input.kind === 'utc') {
            return (new asn1js.UTCTime({ valueDate: input.date }));
        }
        else if (input.kind === 'general') {
            return (new asn1js.GeneralizedTime({ valueDate: input.date }));
        }
        else {
            return (jsJStoASN1(input.date));
        }
    }
    else if (input === null) {
        return (new asn1js.Null());
    }
    else if ((0, helper_1.isBuffer)(input)) {
        return (new asn1js.OctetString({ isHexOnly: true, valueHex: input }));
    }
    else if (isASN1BitString(input)) {
        const retval = new asn1js.BitString();
        if (input.value.length === 0) {
            throw (new Error('internal error: BitString must have a length greater than 0'));
        }
        else {
            retval.valueBlock.unusedBits = input.unusedBits ?? 0;
            retval.valueBlock.valueHex = (0, helper_1.bufferToArrayBuffer)(input.value);
        }
        retval.valueBlock.isHexOnly = true;
        return (retval);
    }
    else if (isASN1OID(input)) {
        const oid = nameToOID(input.oid);
        return (new asn1js.ObjectIdentifier({ value: oid }));
    }
    else if (isASN1Set(input)) {
        const setContainer = new asn1js.Set();
        const sequenceContainer = new asn1js.Sequence();
        sequenceContainer.valueBlock.value.push(jsJStoASN1(input.name));
        sequenceContainer.valueBlock.value.push(jsJStoASN1(input.value));
        setContainer.valueBlock.value.push(sequenceContainer);
        return (setContainer);
    }
    else if (isASN1ContextTag(input)) {
        if (input.kind === 'implicit') {
            let valueHex;
            if (util_1.types.isArrayBuffer(input.contains)) {
                valueHex = input.contains;
            }
            else if (input.contains === null) {
                /*
                 * If the value is null, then we don't have to do anything
                 */
                valueHex = new ArrayBuffer(0);
            }
            else {
                /*
                 * Strip off the tag and length from the
                 * object and store just the encoded data
                 */
                const asn1Objects = jsJStoASN1(input.contains);
                const asn1Buffer = asn1Objects.toBER(false);
                const untaggedBuffer = asn1Buffer.slice(-1 * asn1Objects.lenBlock.length);
                valueHex = untaggedBuffer;
            }
            const primitiveObject = new asn1js.Primitive();
            primitiveObject.idBlock.tagClass = 3; /* Context Specific */
            primitiveObject.idBlock.tagNumber = input.value;
            primitiveObject.valueBlock.valueHex = valueHex;
            primitiveObject.valueBlock.isHexOnly = true;
            return (primitiveObject);
        }
        else {
            const constructedObject = new asn1js.Constructed();
            constructedObject.idBlock.tagClass = 3; /* Context Specific */
            constructedObject.idBlock.tagNumber = input.value;
            constructedObject.valueBlock.value.push(jsJStoASN1(input.contains));
            return (constructedObject);
        }
    }
    else if (typeof input === 'string') {
        if (isStringValidForKind(input, 'printable')) {
            return (new asn1js.PrintableString({ value: input }));
        }
        else if (isStringValidForKind(input, 'ia5')) {
            return (new asn1js.IA5String({ value: input }));
        }
        else if (isStringValidForKind(input, 'utf8')) {
            return (new asn1js.Utf8String({ value: input }));
        }
        else {
            throw (new Error('internal error: Invalid string'));
        }
    }
    else if (isASN1String(input)) {
        if (!isStringValidForKind(input.value, input.kind)) {
            throw (new Error(`internal error: Invalid string, not compatible with ${input.kind}`));
        }
        switch (input.kind) {
            case 'printable':
                return (new asn1js.PrintableString({ value: input.value }));
            case 'ia5':
                return (new asn1js.IA5String({ value: input.value }));
            case 'utf8':
                return (new asn1js.Utf8String({ value: input.value }));
            default:
                (0, never_1.assertNever)(input.kind);
        }
    }
    else if (typeof input === 'boolean') {
        /** @ts-ignore */
        const retval = new asn1js.Boolean({ value: input });
        return (retval);
    }
    else if (input === undefined) {
        if (allowUndefined) {
            return (undefined);
        }
        throw (new Error('internal error: Undefined value when not allowed'));
    }
    throw (new Error(`Unsupported JavaScript type ${typeof input} ${JSON.stringify(input)}`));
}
function jsASN1toJS(input) {
    /**
     * Parse BER encoded data into objects
     */
    const data = asn1js.fromBER(input).result;
    if (data.error) {
        throw (new Error(data.error));
    }
    if (data instanceof asn1js.Sequence) {
        const retval = [];
        for (const part of data.valueBlock.value) {
            retval.push(jsASN1toJS(part.valueBeforeDecode));
        }
        return (retval);
    }
    else if (data instanceof asn1js.Set) {
        const sequences = data.valueBlock.value;
        if (sequences.length !== 1) {
            throw (new Error('internal error: We only know how to handle sets with 1 sequence'));
        }
        const sequence = sequences[0];
        if (!(sequence instanceof asn1js.Sequence)) {
            throw (new Error('internal error: Set must contain 1 sequence'));
        }
        const sequenceData = sequence.valueBlock.value;
        if (sequenceData.length !== 2) {
            throw (new Error('internal error: Set->Sequence must contain 2 values'));
        }
        const name = jsASN1toJS(sequenceData[0].valueBeforeDecode);
        const value = jsASN1toJS(sequenceData[1].valueBeforeDecode);
        if (!isASN1OID(name)) {
            throw (new Error(`internal error: Set->Sequence->Name must be an OID, got ${name}`));
        }
        if (typeof value !== 'string' && !isASN1String(value)) {
            throw (new Error(`internal error: Set->Sequence->Value must be a string, got ${value}`));
        }
        const retval = {
            type: 'set',
            name: name,
            value: value
        };
        return (retval);
    }
    else if (data instanceof asn1js.Integer) {
        return (jsIntegerToBigInt(data));
    }
    else if (data instanceof asn1js.GeneralizedTime || data instanceof asn1js.UTCTime) {
        const date = data.toDate();
        let kind;
        if (data instanceof asn1js.GeneralizedTime) {
            kind = 'general';
        }
        else {
            kind = 'utc';
        }
        if (date.getUTCFullYear() < 2050) {
            if (kind === 'utc') {
                kind = 'default';
            }
        }
        else {
            if (kind === 'general') {
                kind = 'default';
            }
        }
        if (kind === 'default') {
            return (date);
        }
        return ({
            type: 'date',
            kind: kind,
            date: date
        });
    }
    else if (data instanceof asn1js.Null) {
        return (null);
    }
    else if (data instanceof asn1js.OctetString) {
        return (Buffer.from(data.valueBlock.valueHex));
    }
    else if (data instanceof asn1js.BitString) {
        const retval = {
            type: 'bitstring',
            value: Buffer.from(data.valueBlock.valueHex),
            unusedBits: data.valueBlock.unusedBits
        };
        return (retval);
    }
    else if (data instanceof asn1js.ObjectIdentifier) {
        const retval = {
            type: 'oid',
            oid: oidToName(data)
        };
        return (retval);
    }
    else if (data instanceof asn1js.Boolean) {
        return (data.valueBlock.value);
    }
    else if (data instanceof asn1js.PrintableString || data instanceof asn1js.BmpString || data instanceof asn1js.CharacterString || data instanceof asn1js.IA5String || data instanceof asn1js.GeneralString || data instanceof asn1js.GraphicString || data instanceof asn1js.UniversalString || data instanceof asn1js.Utf8String) {
        let stringValue;
        if (data instanceof asn1js.Utf8String) {
            stringValue = Buffer.from(data.valueBlock.valueHex).toString('utf8');
        }
        else {
            stringValue = data.valueBlock.value;
        }
        /*
         * If the type is something different than how we would have
         * encoded it return the ASN1String version so that it can be
         * converted back into the correct type
         */
        let expectedKind;
        if (isStringValidForKind(stringValue, 'printable')) {
            expectedKind = 'printable';
        }
        else if (isStringValidForKind(stringValue, 'ia5')) {
            expectedKind = 'ia5';
        }
        else if (isStringValidForKind(stringValue, 'utf8')) {
            expectedKind = 'utf8';
        }
        else {
            expectedKind = null;
        }
        let foundKind;
        if (data instanceof asn1js.PrintableString) {
            foundKind = 'printable';
        }
        else if (data instanceof asn1js.IA5String) {
            foundKind = 'ia5';
        }
        else if (data instanceof asn1js.Utf8String) {
            foundKind = 'utf8';
        }
        else {
            foundKind = null;
        }
        if (foundKind === null || expectedKind === null) {
            throw (new Error('internal error: Invalid string type'));
        }
        if (expectedKind !== foundKind) {
            return ({ type: 'string', kind: foundKind, value: stringValue });
        }
        return (stringValue);
    }
    else if (data instanceof asn1js.Constructed) {
        if (data.idBlock.tagClass === 3 /* Context-Specific */) {
            if (data.valueBlock.value.length !== 1) {
                throw (new Error('internal error: Constructed values may only contain 1 value'));
            }
            const retval = {
                type: 'context',
                kind: 'explicit',
                value: data.idBlock.tagNumber,
                contains: jsASN1toJS(data.valueBlock.value[0].valueBeforeDecode)
            };
            return (retval);
        }
    }
    else if (data instanceof asn1js.Primitive) {
        if (data.idBlock.tagClass === 3 /* Context-Specific */) {
            const retval = {
                type: 'context',
                kind: 'implicit',
                value: data.idBlock.tagNumber,
                contains: data.valueBlock.valueHex
            };
            return (retval);
        }
    }
    let typeName = '<unknown>';
    if (data.constructor?.name) {
        typeName = data.constructor.name;
    }
    let stringRep;
    try {
        stringRep = data.toJSON();
    }
    catch {
        /* Ignored error */
    }
    throw (new Error(`Unsupported ASN.1 type ${typeof data} ${typeName} ${stringRep}`));
}
const asn1lib = {
    ASN1toJS: jsASN1toJS,
    JStoASN1: jsJStoASN1,
    ASN1BigIntToBuffer: jsBigIntToBuffer,
    ASN1IntegerToBigInt: jsIntegerToBigInt
};
// Load the native binding and fallback if it cannot be loaded.
// eslint-disable-next-line @typescript-eslint/consistent-type-imports
let asn1_napi_rs;
try {
    // eslint-disable-next-line @typescript-eslint/no-var-requires, @typescript-eslint/consistent-type-assertions, @typescript-eslint/consistent-type-imports
    asn1_napi_rs = __webpack_require__(9529);
}
catch {
    // Native bindings not loaded.
}
if (asn1_napi_rs !== undefined) {
    if (asn1_napi_rs.ASN1toJS !== undefined) {
        if (ASN1_ENCODE_DECODE_PARANOID) {
            asn1lib.ASN1toJS = function (...args) {
                const check_native = asn1_napi_rs.ASN1toJS(...args);
                const check_js = jsASN1toJS(...args);
                if (util_2.default.inspect(check_native, { depth: null }) !== util_2.default.inspect(check_js, { depth: null })) {
                    console.error('ASN1toJS failed with the input:', util_2.default.inspect(args[0], { colors: true, depth: Infinity }));
                    console.error('Native:', util_2.default.inspect(check_native, { depth: null }));
                    console.error('JS    :', util_2.default.inspect(check_js, { depth: null }));
                    throw (new Error('ASN1toJS failed to be validated with the input'));
                }
                return (check_native);
            };
            asn1lib.JStoASN1 = function (...args) {
                // @ts-ignore
                const check_native = asn1_napi_rs.JStoASN1(...args);
                // @ts-ignore
                const check_js = jsJStoASN1(...args);
                if (check_native === undefined && check_js === undefined) {
                    return (undefined);
                }
                const check_native_ber = Buffer.from(check_native.toBER()).toString('hex');
                const check_js_ber = Buffer.from(check_js.toBER()).toString('hex');
                if (check_native_ber !== check_js_ber) {
                    console.error('JStoASN1 failed with the input:', util_2.default.inspect(args[0], { colors: true, depth: Infinity }));
                    console.error('Native:', check_native_ber);
                    console.error('JS     :', check_js_ber);
                    throw (new Error('JStoASN1 failed to be validated with the input'));
                }
                return (check_native);
            };
        }
        else {
            asn1lib.ASN1toJS = asn1_napi_rs.ASN1toJS;
            asn1lib.JStoASN1 = asn1_napi_rs.JStoASN1;
        }
        asn1lib.ASN1BigIntToBuffer = asn1_napi_rs.ASN1BigIntToBuffer;
        asn1lib.ASN1IntegerToBigInt = asn1_napi_rs.ASN1IntegerToBigInt;
    }
}
const { ASN1toJS, JStoASN1, ASN1IntegerToBigInt, ASN1BigIntToBuffer } = asn1lib;
exports.ASN1toJS = ASN1toJS;
exports.JStoASN1 = JStoASN1;
exports.ASN1IntegerToBigInt = ASN1IntegerToBigInt;
exports.ASN1BigIntToBuffer = ASN1BigIntToBuffer;
class ValidateASN1 {
    /**
     * Interpret an untagged type as a specific universal tag
     */
    static interpretASN1Tag(input, tag) {
        let interpretTag;
        switch (tag) {
            case ValidateASN1.IsBoolean:
                interpretTag = 1;
                break;
            case ValidateASN1.IsInteger:
                interpretTag = 2;
                break;
            case ValidateASN1.IsBitString:
                interpretTag = 3;
                break;
            case ValidateASN1.IsOctetString:
                interpretTag = 4;
                break;
            case ValidateASN1.IsNull:
                interpretTag = 5;
                break;
            case ValidateASN1.IsOID:
                interpretTag = 6;
                break;
            case ValidateASN1.IsDate:
            case ValidateASN1.IsAnyDate:
                /*
                 * We can determine by the length of the buffer if it is a
                 * GeneralizedTime or UTCTime
                 */
                if (input.byteLength > 13) {
                    interpretTag = 24;
                }
                else {
                    interpretTag = 23;
                }
                break;
            case ValidateASN1.IsString:
            case ValidateASN1.IsAnyString:
            case ValidateASN1.IsAny:
            case ValidateASN1.IsUnknown:
                throw (new Error(`internal error: Cannot interpret untagged type as ${String(tag)}`));
            case ValidateASN1.IsSet:
                throw (new Error('not implemented: Cannot interpret untagged type as Set'));
            default:
                if (typeof tag !== 'object' || tag === null) {
                    throw (new Error(`internal error: Unsupported schema type ${JSON.stringify(tag)}`));
                }
                if (Array.isArray(tag)) {
                    interpretTag = 16;
                }
                else if ('type' in tag) {
                    switch (tag.type) {
                        case 'string':
                            switch (tag.kind) {
                                case 'printable':
                                    interpretTag = 19;
                                    break;
                                case 'ia5':
                                    interpretTag = 22;
                                    break;
                                case 'utf8':
                                    interpretTag = 12;
                                    break;
                                default:
                                    (0, never_1.assertNever)(tag);
                            }
                            break;
                        case 'oid':
                            interpretTag = 6;
                            break;
                        case 'date':
                            switch (tag.kind) {
                                case 'utc':
                                    interpretTag = 23;
                                    break;
                                case 'general':
                                    interpretTag = 24;
                                    break;
                                default:
                                    (0, never_1.assertNever)(tag);
                            }
                            break;
                        case 'context':
                            throw (new Error('not implemented: Cannot interpret untagged type as Context Tag yet'));
                        default:
                            (0, never_1.assertNever)(tag);
                    }
                }
                else if ('sequenceOf' in tag) {
                    interpretTag = 16;
                }
                else if ('optional' in tag || 'choice' in tag) {
                    /* It doesn't make a lot of sense to support Choice or Optional here */
                    throw (new Error(`internal error: Unsupported schema type ${JSON.stringify(tag)}`));
                }
                else {
                    /* We want to assertNever() here but we can't because the tuple type hasn't been elided successfully */
                    throw (new Error(`internal error: Unknown schema type ${JSON.stringify(tag)}`));
                }
                break;
        }
        const newObject = new asn1js.Primitive();
        newObject.idBlock.tagClass = 1; /* Universal */
        newObject.idBlock.tagNumber = interpretTag;
        newObject.valueBlock.valueHex = input;
        newObject.valueBlock.isHexOnly = true;
        return (jsASN1toJS(newObject.toBER(false)));
    }
    /**
     * Given a schema, validate the ASN.1 object against it and return the
     * object as the validated type
     */
    static againstSchema(input, schemaIn) {
        let schema = schemaIn;
        if (typeof schema === 'function') {
            schema = schema();
        }
        let needsMoreAnalysis = false;
        if (util_1.types.isDate(input) && schema === ValidateASN1.IsDate) {
            /* XXX:TODO */
            // eslint-disable-next-line @typescript-eslint/consistent-type-assertions
            return input;
        }
        if (typeof schema === 'bigint') {
            if (input !== schema) {
                throw (new Error(`Expected ${schema} got ${input}`));
            }
            // eslint-disable-next-line @typescript-eslint/consistent-type-assertions
            return input;
        }
        switch (schema) {
            case ValidateASN1.IsAny:
                break;
            case ValidateASN1.IsDate:
                if (!util_1.types.isDate(input)) {
                    throw (new Error(`Expected Date, got ${typeof input}`));
                }
                break;
            case ValidateASN1.IsAnyDate:
                if (util_1.types.isDate(input)) {
                    if (input.getUTCFullYear() < 2050) {
                        input = { type: 'date', kind: 'utc', date: input };
                    }
                    else {
                        input = { type: 'date', kind: 'general', date: input };
                    }
                }
                else {
                    if (!isASN1Date(input)) {
                        throw (new Error(`Expected ASN1Date, got ${util_1.types.isDate(input) ? 'Date Object' : typeof input}`));
                    }
                }
                break;
            case ValidateASN1.IsString:
                if (typeof input !== 'string') {
                    throw (new Error(`Expected String, got ${typeof input}`));
                }
                break;
            case ValidateASN1.IsAnyString:
                if (typeof input === 'string') {
                    if (isStringValidForKind(input, 'printable')) {
                        input = { type: 'string', kind: 'printable', value: input };
                    }
                    else if (isStringValidForKind(input, 'ia5')) {
                        input = { type: 'string', kind: 'ia5', value: input };
                    }
                    else {
                        input = { type: 'string', kind: 'utf8', value: input };
                    }
                }
                else {
                    if (!isASN1String(input)) {
                        throw (new Error(`Expected String, got ${typeof input}`));
                    }
                }
                break;
            case ValidateASN1.IsOctetString:
                if (!Buffer.isBuffer(input)) {
                    throw (new Error(`Expected Buffer, got ${typeof input}`));
                }
                break;
            case ValidateASN1.IsBitString:
                if (!isASN1BitString(input)) {
                    throw (new Error(`Expected BitString, got ${typeof input}`));
                }
                break;
            case ValidateASN1.IsInteger:
                if (typeof input === 'number') {
                    input = BigInt(input);
                }
                if (typeof input !== 'bigint') {
                    throw (new Error(`Expected BigInt, got ${typeof input}`));
                }
                break;
            case ValidateASN1.IsBoolean:
                if (typeof input !== 'boolean') {
                    throw (new Error(`Expected Boolean, got ${typeof input}`));
                }
                break;
            case ValidateASN1.IsOID:
                if (!isASN1OID(input)) {
                    throw (new Error(`Expected OID, got ${typeof input}`));
                }
                break;
            case ValidateASN1.IsSet:
                if (!isASN1Set(input)) {
                    throw (new Error(`Expected Set, got ${typeof input} --> ${JSON.stringify(input)}`));
                }
                break;
            case ValidateASN1.IsNull:
                if (input !== null) {
                    throw (new Error(`Expected Null, got ${typeof input}`));
                }
                break;
            default:
                needsMoreAnalysis = true;
                break;
        }
        if (needsMoreAnalysis) {
            if (typeof schema !== 'object' || schema === null) {
                throw (new Error(`Internal error: Unsupported schema type ${JSON.stringify(schema)}`));
            }
            if ('type' in schema) {
                switch (schema.type) {
                    case 'context': {
                        if (!isASN1ContextTag(input)) {
                            throw (new Error(`Expected Context Tag, got ${typeof input}`));
                        }
                        if (schema.value !== input.value) {
                            throw (new Error(`Expected Context Tag value ${schema.value}, got ${input.value}`));
                        }
                        if (schema.kind !== undefined && schema.kind !== input.kind) {
                            throw (new Error(`Expected Context Tag kind ${schema.kind}, got ${input.kind}`));
                        }
                        let contains = input.contains;
                        if (input.kind === 'implicit' && util_1.types.isArrayBuffer(contains)) {
                            /*
                             * Given an implicit context tag, the value is
                             * an ArrayBuffer, so we need to convert it to
                             * the right tag based on the schema
                             */
                            contains = ValidateASN1.interpretASN1Tag(contains, schema.contains);
                        }
                        if (util_1.types.isArrayBuffer(contains)) {
                            throw (new Error('internal error: Context Tag contains must be converted'));
                        }
                        // @ts-ignore
                        return ({ type: 'context', value: schema.value, kind: input.kind, contains: ValidateASN1.againstSchema(contains, schema.contains) });
                    }
                    case 'oid':
                        if (!isASN1OID(input)) {
                            throw (new Error(`Expected OID, got ${typeof input}`));
                        }
                        if (schema.oid !== input.oid) {
                            throw (new Error(`Expected OID ${schema.oid}, got ${input.oid}`));
                        }
                        needsMoreAnalysis = false;
                        break;
                    case 'string':
                        if (typeof input === 'string') {
                            if (!isStringValidForKind(input, schema.kind)) {
                                throw (new Error(`Invalid string for kind ${schema.kind}`));
                            }
                            input = { type: 'string', kind: schema.kind, value: input };
                        }
                        else {
                            if (!isASN1String(input)) {
                                throw (new Error(`Expected String, got ${typeof input}`));
                            }
                            if (schema.kind !== input.kind) {
                                throw (new Error(`Expected String kind ${schema.kind}, got ${input.kind}`));
                            }
                            if (!isStringValidForKind(input.value, schema.kind)) {
                                throw (new Error(`Invalid string for kind ${schema.kind}`));
                            }
                        }
                        needsMoreAnalysis = false;
                        break;
                    case 'date':
                        if (util_1.types.isDate(input)) {
                            if (input.getUTCFullYear() < 2050) {
                                if (schema.kind === 'general') {
                                    throw (new Error('Expected GeneralizedTime, got UTCTime'));
                                }
                                input = { type: 'date', kind: 'utc', date: input };
                            }
                            else {
                                if (schema.kind === 'utc') {
                                    throw (new Error('Expected UTCTime, got GeneralizedTime'));
                                }
                                input = { type: 'date', kind: 'general', date: input };
                            }
                        }
                        else {
                            if (!isASN1Date(input)) {
                                throw (new Error(`Expected ASN1Date, got ${util_1.types.isDate(input) ? 'Date Object' : typeof input}`));
                            }
                            if (schema.kind !== input.kind) {
                                throw (new Error(`Expected ASN1Date kind ${schema.kind}, got ${input.kind}`));
                            }
                        }
                        needsMoreAnalysis = false;
                        break;
                    default:
                        (0, never_1.assertNever)(schema);
                }
            }
            else if ('choice' in schema) {
                if (isASN1ContextTag(input)) {
                    const inputAsChoice = input;
                    const matchingSchema = schema.choice.find(function (choice) {
                        if (!isASN1ContextTag(choice)) {
                            return (false);
                        }
                        if (choice.value !== inputAsChoice.value) {
                            return (false);
                        }
                        if (choice.kind !== inputAsChoice.kind) {
                            return (false);
                        }
                        return (true);
                    });
                    if (matchingSchema === undefined) {
                        throw (new Error('No valid choice found'));
                    }
                    return (ValidateASN1.againstSchema(input, matchingSchema));
                }
                for (const choice of schema.choice) {
                    try {
                        // @ts-ignore
                        return (ValidateASN1.againstSchema(input, choice));
                    }
                    catch (_ignored_checkError) {
                        /* Ignored error */
                    }
                }
                throw (new Error('No valid choice found'));
            }
            else if ('sequenceOf' in schema) {
                if (!Array.isArray(input)) {
                    throw (new Error(`Expected Array (SequenceOf), got ${typeof input} --> ${JSON.stringify(input)}`));
                }
                // eslint-disable-next-line @typescript-eslint/consistent-type-assertions
                return input.map(function (item) {
                    // eslint-disable-next-line @typescript-eslint/consistent-type-assertions
                    return (ValidateASN1.againstSchema(item, schema.sequenceOf));
                });
            }
            else if ('optional' in schema) {
                if (input === undefined) {
                    // eslint-disable-next-line @typescript-eslint/consistent-type-assertions
                    return undefined;
                }
                // eslint-disable-next-line @typescript-eslint/consistent-type-assertions
                return ValidateASN1.againstSchema(input, schema.optional);
            }
            else if (Array.isArray(schema)) {
                if (!Array.isArray(input)) {
                    throw (new Error(`Expected Array (Sequence), got ${typeof input} --> ${JSON.stringify(input)}`));
                }
                const maxLength = schema.length;
                const minLength = schema.filter(function (item) {
                    if (typeof item !== 'object' || item === null) {
                        return (true);
                    }
                    return (!('optional' in item));
                }).length;
                if (input.length < minLength || input.length > maxLength) {
                    throw (new Error(`Expected Array length between [${minLength}, ${maxLength}], got ${input.length}`));
                }
                const output = [];
                for (let i = 0; i < schema.length; i++) {
                    // If the schema is optional, we check two paths, if the value is present or not.
                    // This will break the loop and leave the rest of the validation to the recursive call.
                    if (typeof schema[i] === 'object' && 'optional' in schema[i]) {
                        // We only need to take two paths for optional values when we are before the last value, and the value is not undefined
                        if (i < schema.length - 1 && input[i] !== undefined) {
                            const remainingSchema = schema.slice(i + 1);
                            try {
                                // Try to validate against schema assuming optional is present
                                // @ts-ignore
                                output.push(...ValidateASN1.againstSchema(input.slice(i), [schema[i].optional, ...remainingSchema]));
                            }
                            catch {
                                /* ignore error because we are going to try without the optional value */
                                // @ts-ignore
                                output.push(undefined, ...ValidateASN1.againstSchema(input.slice(i), remainingSchema));
                            }
                            break;
                        }
                    }
                    // @ts-ignore
                    output.push(ValidateASN1.againstSchema(input[i], schema[i]));
                }
                // If the end of the output is only optional values, exclude undefined values.
                while (output.length > 0 && output.at(-1) === undefined) {
                    output.pop();
                }
                // eslint-disable-next-line @typescript-eslint/consistent-type-assertions
                return output;
            }
            else {
                throw (new Error(`Internal error: Unsupported schema type ${JSON.stringify(schema)}`));
            }
        }
        if (needsMoreAnalysis) {
            throw (new Error(`Internal error: Unsupported schema type ${JSON.stringify(schema)}`));
        }
        // eslint-disable-next-line @typescript-eslint/consistent-type-assertions
        return input;
    }
    constructor(schema) {
        _ValidateASN1_schema.set(this, void 0);
        __classPrivateFieldSet(this, _ValidateASN1_schema, schema, "f");
    }
    validate(input) {
        return (ValidateASN1.againstSchema(input, __classPrivateFieldGet(this, _ValidateASN1_schema, "f")));
    }
}
exports.ValidateASN1 = ValidateASN1;
_ValidateASN1_schema = new WeakMap();
ValidateASN1.IsAny = Symbol('IsAny');
ValidateASN1.IsUnknown = Symbol('IsUnknown');
ValidateASN1.IsDate = Symbol('IsDate');
ValidateASN1.IsAnyDate = Symbol('IsAnyDate');
ValidateASN1.IsString = Symbol('IsString');
ValidateASN1.IsAnyString = Symbol('IsAnyString');
ValidateASN1.IsOctetString = Symbol('IsOctetString');
ValidateASN1.IsBitString = Symbol('IsBitString');
ValidateASN1.IsInteger = Symbol('IsInteger');
ValidateASN1.IsBoolean = Symbol('IsBoolean');
ValidateASN1.IsOID = Symbol('IsOID');
ValidateASN1.IsSet = Symbol('IsSet');
ValidateASN1.IsNull = Symbol('IsNull');
/**
 * An ASN.1 object which contains the DER encoded value as well as the
 * unencoded value
 */
class BufferStorageASN1 {
    constructor(input, schema) {
        _BufferStorageASN1_data.set(this, void 0);
        if (input instanceof ArrayBuffer) {
            /* XXX:TODO: If the input is an ArrayBuffer, T *MUST* be a ASN1AnyJS -- we need to figure out how to enforce that */
            // eslint-disable-next-line @typescript-eslint/consistent-type-assertions
            input = ASN1toJS(input);
        }
        /*
         * Because we have already verified the type, or it is the
         * type of the input we are sure this is the correct type
         * we need to cast to "any" to avoid typing errors or repeating
         * the type
         */
        if (schema !== undefined) {
            // eslint-disable-next-line @typescript-eslint/consistent-type-assertions
            __classPrivateFieldSet(this, _BufferStorageASN1_data, ValidateASN1.againstSchema(input, schema), "f");
        }
        else {
            // eslint-disable-next-line @typescript-eslint/consistent-type-assertions
            __classPrivateFieldSet(this, _BufferStorageASN1_data, input, "f");
        }
    }
    getDER() {
        /*
         * The input is either a ASN1AnyJS or the type of the input
         * we are sure this is the correct type we need to cast to
         * the base "ASN1AnyJS" to errors with TypeScript's verification
         * being excessively deep (may be fixed in TypeScript 5.7+)
         */
        // eslint-disable-next-line @typescript-eslint/consistent-type-assertions
        const data = JStoASN1(this.getASN1());
        if (data === undefined) {
            return (new ArrayBuffer(0));
        }
        const retval = data.toBER(false);
        return (retval);
    }
    getDERBuffer() {
        return (Buffer.from(this.getDER()));
    }
    getASN1() {
        /*
         * Because we have already verified the type, or it is the
         * type of the input we are sure this is the correct type
         * we need to cast to "any" to avoid typing errors or repeating
         * the type
         */
        // eslint-disable-next-line @typescript-eslint/consistent-type-assertions
        return __classPrivateFieldGet(this, _BufferStorageASN1_data, "f");
    }
}
exports.BufferStorageASN1 = BufferStorageASN1;
_BufferStorageASN1_data = new WeakMap();
BufferStorageASN1.Validate = ValidateASN1;
BufferStorageASN1.isInstance = (0, helper_1.checkableGenerator)(BufferStorageASN1);
/** @internal */
exports._Testing = {
    // eslint-disable-next-line @typescript-eslint/consistent-type-assertions
    native: asn1_napi_rs ? {
        ASN1toJS: asn1_napi_rs.ASN1toJS,
        JStoASN1: asn1_napi_rs.JStoASN1,
        ASN1BigIntToBuffer: asn1_napi_rs.ASN1BigIntToBuffer,
        ASN1IntegerToBigInt: asn1_napi_rs.ASN1IntegerToBigInt
    } : undefined,
    js: {
        ASN1toJS: jsASN1toJS,
        JStoASN1: jsJStoASN1,
        ASN1BigIntToBuffer: jsBigIntToBuffer,
        ASN1IntegerToBigInt: jsIntegerToBigInt
    }
};


/***/ }),

/***/ 4977:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _BitField_instances, _BitField_storage, _BitField_fromOffsetArray;
Object.defineProperty(exports, "__esModule", ({ value: true }));
const helper_1 = __webpack_require__(3208);
/**
 * Class to store a BitField
 * Simple array of 0/1 values
 */
class BitField {
    // You can construct this with a specific set size, an existing Array, an array of offsets, or a BigInt
    constructor(data) {
        _BitField_instances.add(this);
        _BitField_storage.set(this, 0n);
        if (BitField.isInstance(data)) {
            __classPrivateFieldSet(this, _BitField_storage, data.bigint, "f");
        }
        else if (Array.isArray(data)) {
            __classPrivateFieldSet(this, _BitField_storage, __classPrivateFieldGet(this, _BitField_instances, "m", _BitField_fromOffsetArray).call(this, data), "f");
        }
        else if (typeof data === 'bigint') {
            __classPrivateFieldSet(this, _BitField_storage, data, "f");
        }
    }
    // Set a specific value in the bitfield, It will also expand the storage if necessary
    set(offset, value) {
        // Convert value to number if boolean, otherwise leave it
        // +0 -----> 0 -- +1 ----> 1
        // +false -> 0 -- +true -> 1
        const numValue = +value;
        switch (numValue) {
            case 0:
                if (this.get(offset)) {
                    __classPrivateFieldSet(this, _BitField_storage, __classPrivateFieldGet(this, _BitField_storage, "f") ^ 1n << BigInt(offset), "f");
                }
                break;
            case 1:
                __classPrivateFieldSet(this, _BitField_storage, __classPrivateFieldGet(this, _BitField_storage, "f") | 1n << BigInt(offset), "f");
                break;
            default:
                throw (new Error('Bitfield value must be a boolean or 0, 1'));
        }
    }
    get size() {
        return (__classPrivateFieldGet(this, _BitField_storage, "f").toString(2).length);
    }
    // Get a specific value in the BitField
    get(offset) {
        return ((__classPrivateFieldGet(this, _BitField_storage, "f") & 1n << BigInt(offset)) !== 0n);
    }
    // Git a bigint representing the storage
    get bigint() {
        return (__classPrivateFieldGet(this, _BitField_storage, "f"));
    }
}
_BitField_storage = new WeakMap(), _BitField_instances = new WeakSet(), _BitField_fromOffsetArray = function _BitField_fromOffsetArray(setOffsets) {
    let val = 0n;
    for (const toSet of setOffsets) {
        val |= 1n << BigInt(toSet);
    }
    return (val);
};
BitField.isInstance = (0, helper_1.checkableGenerator)(BitField);
exports["default"] = BitField;


/***/ }),

/***/ 7313:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BloomFilter = void 0;
exports.serializeBloomFilter = serializeBloomFilter;
exports.deserializeBloomFilter = deserializeBloomFilter;
const bloom_filters_1 = __webpack_require__(5652);
Object.defineProperty(exports, "BloomFilter", ({ enumerable: true, get: function () { return bloom_filters_1.BloomFilter; } }));
const zlib_1 = __importDefault(__webpack_require__(3106));
function assertBloomFilterTransport(data) {
    let valid = typeof data === 'object' && typeof data.contents === 'string';
    for (const numKeys of ['hashes', 'size', 'seed']) {
        if (!valid || typeof data[numKeys] !== 'number') {
            valid = false;
            break;
        }
    }
    if (typeof data.contents !== 'string') {
        valid = false;
    }
    if (valid) {
        return (data);
    }
    throw (new Error(`Invalid BloomFilterTransport, got ${JSON.stringify(data)}`));
}
function serializeBloomFilter(filter) {
    if (filter === undefined) {
        return (undefined);
    }
    const filterJSON = filter.saveAsJSON();
    const result = {
        hashes: filterJSON._nbHashes,
        size: filterJSON._size,
        seed: filterJSON._seed,
        contents: filterJSON._filter.content
    };
    const resultString = JSON.stringify(result);
    const resultCompressed = zlib_1.default.deflateSync(resultString, {
        level: 9
    });
    return (resultCompressed.toString('base64'));
}
function deserializeBloomFilter(input) {
    const compressed = Buffer.from(input, 'base64');
    const decompressed = zlib_1.default.inflateSync(compressed).toString();
    const filterPlain = assertBloomFilterTransport(JSON.parse(decompressed));
    const filterJSON = {
        type: 'BloomFilter',
        _nbHashes: filterPlain.hashes,
        _size: filterPlain.size,
        _seed: filterPlain.seed,
        _filter: {
            size: filterPlain.size,
            content: filterPlain.contents
        }
    };
    /**
     * The type information is incorrect for this !
     */
    // @ts-ignore
    const filter = bloom_filters_1.BloomFilter.fromJSON(filterJSON);
    return (filter);
}


/***/ }),

/***/ 3310:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var _BufferStorage_key;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Buffer = exports.BufferStorage = void 0;
exports.DecodeBase32 = DecodeBase32;
exports.EncodeBase32 = EncodeBase32;
exports.DecodeBase64 = DecodeBase64;
exports.EncodeBase64 = EncodeBase64;
exports.ZlibInflate = ZlibInflate;
exports.ZlibDeflate = ZlibDeflate;
exports.ZlibInflateAsync = ZlibInflateAsync;
exports.ZlibDeflateAsync = ZlibDeflateAsync;
const helper_1 = __webpack_require__(3208);
const rfc4648_1 = __webpack_require__(9211);
const buffer_1 = __webpack_require__(181);
Object.defineProperty(exports, "Buffer", ({ enumerable: true, get: function () { return buffer_1.Buffer; } }));
const util_1 = __webpack_require__(9023);
const zlib_1 = __importDefault(__webpack_require__(3106));
const inflateAsync = (0, util_1.promisify)(zlib_1.default.inflate);
const deflateAsync = (0, util_1.promisify)(zlib_1.default.deflate);
/**
 * RFC 4648 Base32 Decoder
 */
function DecodeBase32(data, length) {
    const retval = rfc4648_1.base32.parse(data, {
        loose: true
    });
    if (retval.length !== length) {
        throw (new Error(`Expected ${length} bytes, got ${retval.length}`));
    }
    return (retval);
}
/**
 * RFC 4648 Base32 Encoder
 */
function EncodeBase32(data) {
    const values = new Uint8Array(data);
    return (rfc4648_1.base32.stringify(values, {
        pad: false
    }).toLowerCase());
}
function DecodeBase64(data) {
    return ((0, helper_1.bufferToArrayBuffer)(buffer_1.Buffer.from(data, 'base64')));
}
function EncodeBase64(data) {
    return (buffer_1.Buffer.from(data).toString('base64'));
}
function ZlibInflate(data, options) {
    return ((0, helper_1.bufferToArrayBuffer)(zlib_1.default.inflateSync(buffer_1.Buffer.from(data), options)));
}
function ZlibDeflate(data, options) {
    return ((0, helper_1.bufferToArrayBuffer)(zlib_1.default.deflateSync(buffer_1.Buffer.from(data), options)));
}
async function ZlibInflateAsync(data, options = {}) {
    const buffer = await inflateAsync(buffer_1.Buffer.from(data), options);
    return ((0, helper_1.bufferToArrayBuffer)(buffer));
}
async function ZlibDeflateAsync(data, options = {}) {
    const buffer = await deflateAsync(buffer_1.Buffer.from(data), options);
    return ((0, helper_1.bufferToArrayBuffer)(buffer));
}
class BufferStorage {
    constructor(key, length) {
        _BufferStorage_key.set(this, void 0);
        this.storageKind = 'GenericBuffer';
        if (typeof (key) === 'string') {
            /*
             * Convert from a hex-encoded string into a buffer
             */
            const buffer_key = buffer_1.Buffer.from(key, 'hex');
            if (buffer_key.length !== length) {
                throw (new Error(`When decoding buffer we got different number of bytes than expected (${buffer_key.length} expected ${length})`));
            }
            __classPrivateFieldSet(this, _BufferStorage_key, buffer_key, "f");
        }
        else if (typeof key === 'bigint') {
            let value = key.toString(16);
            if (value.length > (length * 2)) {
                throw (new Error(`When decoding BigInt we got different number of bytes than expected (${value.length} expected ${length * 2})`));
            }
            value = '0'.repeat(length * 2) + value;
            value = value.slice(length * 2 * -1);
            __classPrivateFieldSet(this, _BufferStorage_key, buffer_1.Buffer.from(value, 'hex'), "f");
        }
        else {
            if (buffer_1.Buffer.from(key).length !== length) {
                throw (new Error(`When storing buffer we got different number of bytes than expected (${buffer_1.Buffer.from(key).length} expected ${length})`));
            }
            __classPrivateFieldSet(this, _BufferStorage_key, key, "f");
        }
    }
    get() {
        return (__classPrivateFieldGet(this, _BufferStorage_key, "f"));
    }
    get length() {
        return (__classPrivateFieldGet(this, _BufferStorage_key, "f").byteLength);
    }
    getBuffer() {
        return (buffer_1.Buffer.from(__classPrivateFieldGet(this, _BufferStorage_key, "f")));
    }
    toString(encoding = 'hex') {
        switch (encoding) {
            case 'hex':
                return (buffer_1.Buffer.from(__classPrivateFieldGet(this, _BufferStorage_key, "f")).toString(encoding).toUpperCase());
            case 'base64':
                return (buffer_1.Buffer.from(__classPrivateFieldGet(this, _BufferStorage_key, "f")).toString(encoding));
            case 'base32':
                return (EncodeBase32(__classPrivateFieldGet(this, _BufferStorage_key, "f")));
            default:
                throw (new Error(`Unsupported conversion: ${encoding}`));
        }
    }
    toBigInt() {
        const hex_value = `0x${this.toString('hex')}`;
        const value = BigInt(hex_value);
        return (value);
    }
    compare(compareWith) {
        if (compareWith === undefined || compareWith === null) {
            return (false);
        }
        const thisValue = this.toString('hex');
        const compareWithValue = compareWith.toString('hex');
        return (thisValue === compareWithValue);
    }
    compareHexString(compareWith) {
        if (compareWith === undefined || compareWith === null) {
            return (false);
        }
        if (typeof compareWith === 'string') {
            const asBuf = buffer_1.Buffer.from(compareWith, 'hex');
            if (asBuf.length !== this.length) {
                return (false);
            }
            compareWith = new BufferStorage(buffer_1.Buffer.from(compareWith, 'hex'), this.length);
        }
        return (this.toString('hex') === compareWith.toString('hex'));
    }
}
exports.BufferStorage = BufferStorage;
_BufferStorage_key = new WeakMap();
BufferStorage.isInstance = (0, helper_1.checkableGenerator)(BufferStorage);


/***/ }),

/***/ 5661:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var _CertificateBuilder_params, _CertificateBundle_raw, _CertificateBundle_contents, _Certificate_instances, _Certificate_raw, _Certificate_hash, _Certificate_extensionsRaw, _Certificate_extensionsProcessed, _Certificate_finalizeConstructionCalled, _Certificate_processExtensionsInternal, _Certificate_processBaseExtensions, _Certificate_processBaseExtension, _Certificate_assertAllCriticalExtensionsProcessed, _Certificate_checkValid, _Certificate_checkIssued;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Certificate = exports.CertificateBundle = exports.CertificateHash = exports.CertificateBuilder = void 0;
const ASN1 = __importStar(__webpack_require__(6045));
const account_1 = __importStar(__webpack_require__(9415));
const never_1 = __webpack_require__(8692);
const helper_1 = __webpack_require__(3208);
const HashLib = __importStar(__webpack_require__(7908));
const crypto_1 = __importDefault(__webpack_require__(6982));
const buffer_1 = __webpack_require__(3310);
const certificate_1 = __importDefault(__webpack_require__(9890));
/** @internal */
const CertificateSchemaInternal = [
    /* TBS Certificate */
    [
        /* Version */
        { type: 'context', value: 0, kind: 'explicit', contains: ASN1.ValidateASN1.IsInteger },
        /* Serial Number */
        ASN1.ValidateASN1.IsInteger,
        /* Signature Algorithm */
        { sequenceOf: ASN1.ValidateASN1.IsOID },
        /* Issuer */
        { sequenceOf: ASN1.ValidateASN1.IsSet },
        /* Validity Period */
        [
            /* Not Before */
            ASN1.ValidateASN1.IsAnyDate,
            /* Not After */
            ASN1.ValidateASN1.IsAnyDate
        ],
        /* Subject */
        { sequenceOf: ASN1.ValidateASN1.IsSet },
        /* Subject Public Key */
        [
            /* Algorithm */
            { sequenceOf: ASN1.ValidateASN1.IsOID },
            /* Public Key */
            ASN1.ValidateASN1.IsBitString
        ],
        /* Extensions */
        {
            optional: {
                type: 'context',
                value: 3,
                kind: 'explicit',
                contains: {
                    sequenceOf: {
                        choice: [
                            [
                                /* Extension */
                                ASN1.ValidateASN1.IsOID,
                                /* Critical */
                                ASN1.ValidateASN1.IsBoolean,
                                /* Value */
                                ASN1.ValidateASN1.IsOctetString
                            ], [
                                /* Extension */
                                ASN1.ValidateASN1.IsOID,
                                /* Value */
                                ASN1.ValidateASN1.IsOctetString
                            ]
                        ]
                    }
                }
            }
        }
    ],
    /* Signature Algorithm */
    { sequenceOf: ASN1.ValidateASN1.IsOID },
    /* Signature */
    ASN1.ValidateASN1.IsBitString
];
/**
 * This function statically enforces that the public API (see {@link CertificateSchema}) is
 * compatible with the internal schema (see {@link CertificateSchemaInternal}), which
 * would otherwise require validation using a very complex type that sometimes breaks
 * TypeScript's type checker
 *
 * @internal
 */
// eslint-disable-next-line @typescript-eslint/no-unused-vars
function _ignore_static_check_certificate_schema_type() {
    // eslint-disable-next-line @typescript-eslint/no-unused-vars,@typescript-eslint/consistent-type-assertions
    const _ignore_check_type_forward_in = {};
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    const _ignore_check_type_forward_out = _ignore_check_type_forward_in;
    // eslint-disable-next-line @typescript-eslint/no-unused-vars,@typescript-eslint/consistent-type-assertions
    const _ignore_check_type_reverse_in = {};
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    const _ignore_check_type_reverse_out = _ignore_check_type_reverse_in;
}
/**
 * Convert a name-value pair to a DN sequence
 */
function toDNSequence(dn) {
    const retval = dn.map(function (part) {
        return ({
            type: 'set',
            name: {
                type: 'oid',
                oid: part.name
            },
            value: part.value
        });
    });
    return (retval);
}
/**
 * Convert a DN sequence to an array of name-value pairs
 */
function fromDNSequence(dn) {
    const retval = dn.map(function (part) {
        const nameOID = part.name;
        const name = nameOID.oid;
        let value = part.value;
        if (typeof value !== 'string') {
            value = value.value;
        }
        return ({ name, value });
    });
    return (retval);
}
/**
 * Convert a DN sequence to a string -- for information purposes only, it is
 * non-distinguished (e.g., different kinds of strings are all converted to
 * a string type)
 */
function fromDNSequenceToString(dn) {
    const parts = fromDNSequence(dn).map(function (part) {
        return (`${part.name}=${part.value}`);
    });
    const retval = parts.join(', ');
    return (retval);
}
const defaultHashName = HashLib.HashFunctionName;
class CertificateBuilder {
    constructor(params) {
        _CertificateBuilder_params.set(this, void 0);
        __classPrivateFieldSet(this, _CertificateBuilder_params, {
            ...params
        }, "f");
    }
    static hashName(params, purpose) {
        const hashLib = params.hashLib;
        if (hashLib !== undefined) {
            switch (hashLib.name) {
                case 'sha256':
                case 'sha3-256':
                    return (hashLib.name);
                default:
                    throw (new Error(`internal error: Unsupported hash algorithm "${hashLib.name}"`));
            }
        }
        const hashName = params.hashParams?.defaults?.[purpose] ?? defaultHashName;
        return (hashName);
    }
    static hash(params, purpose, ...data) {
        /*
         * If the deprecated hashLib parameter is set, then use it
         * regardless of the algo parameter for backwards compatibility
         * even though it is not recommended to use it anymore
         */
        const hashLib = params.hashLib;
        if (hashLib !== undefined) {
            return (hashLib.hash(...data));
        }
        const hashName = this.hashName(params, purpose);
        const hashFunction = params.hashParams.functions?.[hashName];
        if (hashFunction === undefined) {
            throw (new Error(`internal error: Hash function "${hashName}" not found for purpose "${purpose}"`));
        }
        return (hashFunction(...data));
    }
    /**
     * Construct an extension
     */
    static extension(oid, value, critical) {
        let criticalValue = [];
        if (critical !== undefined) {
            criticalValue = [critical];
        }
        const retval = [
            { type: 'oid', oid: oid },
            ...criticalValue,
            Buffer.from(ASN1.JStoASN1(value).toBER())
        ];
        return (retval);
    }
    /**
     * Convert a KeetaNet Account to a Key ID (for Subject Key Identifier)
     */
    accountToKeyId(params, account, purpose) {
        return (Buffer.from(CertificateBuilder.hash(params, purpose, Buffer.concat([
            Buffer.from('KeetaKey', 'utf-8'),
            account.publicKeyAndType
        ]), 20)));
    }
    /**
     * Produce the extensions to include in this certificate
     */
    async addExtensions(params) {
        const extensions = [];
        if (params.includeCommonExts === false) {
            return (extensions);
        }
        /**
         * Determine if the certificate is a Certificate Authority,
         * and add the appropriate extensions
         */
        let isCertificateAuthority = false;
        if (params.isCA === undefined) {
            if (params.issuer.comparePublicKey(params.subjectPublicKey)) {
                isCertificateAuthority = true;
            }
        }
        else {
            isCertificateAuthority = params.isCA;
        }
        if (isCertificateAuthority) {
            extensions.push(
            /** Extension: Basic Constraints (CA) */
            CertificateBuilder.extension('2.5.29.19', [true], true), 
            /** Extension: Key Usage */
            CertificateBuilder.extension('2.5.29.15', {
                type: 'bitstring',
                value: Buffer.from([0
                        | (1 << 1) /* CRL Sign */
                        | (1 << 2) /* Cert Sign */
                        | (0 << 3) /* Key Agreement */
                        | (0 << 4) /* Data Encipherment */
                        | (0 << 5) /* Key Encipherment */
                        | (1 << 6) /* Non Repudiation */
                        | (1 << 7) /* Digital Signature */
                ])
            }, true));
        }
        else {
            extensions.push(
            /** Extension: Key Usage */
            CertificateBuilder.extension('2.5.29.15', {
                type: 'bitstring',
                value: Buffer.from([0
                        | (0 << 1) /* CRL Sign */
                        | (0 << 2) /* Cert Sign */
                        | (0 << 3) /* Key Agreement */
                        | (0 << 4) /* Data Encipherment */
                        | (0 << 5) /* Key Encipherment */
                        | (1 << 6) /* Non Repudiation */
                        | (1 << 7) /* Digital Signature */
                ])
            }, true));
        }
        /* Common Extensions */
        extensions.push(
        /** Extension: Authority Key Identifier */
        CertificateBuilder.extension('2.5.29.35', [
            /** XXX:TODO: Copy the key ID from the issuer certificate's Subject Key Identifier if known */
            { type: 'context', value: 0, kind: 'implicit', contains: this.accountToKeyId(params, params.issuer, 'aki') }
        ]), 
        /** Extension: Subject Key Identifier */
        CertificateBuilder.extension('2.5.29.14', this.accountToKeyId(params, params.subjectPublicKey, 'ski')));
        return (extensions);
    }
    /**
     * Compute the final params as required
     */
    getFinalParams(params) {
        const finalParams = {
            ...__classPrivateFieldGet(this, _CertificateBuilder_params, "f"),
            ...params,
            hashParams: {
                ...__classPrivateFieldGet(this, _CertificateBuilder_params, "f")?.hashParams,
                ...params?.hashParams,
                functions: {
                    'sha256': function (data, len) {
                        throw (new Error('not implemented, please provide an implementation'));
                    },
                    [defaultHashName]: HashLib.Hash,
                    ...__classPrivateFieldGet(this, _CertificateBuilder_params, "f")?.hashParams?.functions,
                    ...params?.hashParams?.functions
                },
                defaults: {
                    signature: defaultHashName,
                    ski: defaultHashName,
                    aki: defaultHashName,
                    ...__classPrivateFieldGet(this, _CertificateBuilder_params, "f")?.hashParams?.defaults,
                    ...params?.hashParams?.defaults
                }
            }
        };
        /* Validate that required parameters are set */
        const issuer = finalParams.issuer;
        if (issuer === undefined) {
            throw (new certificate_1.default('CERTIFICATE_MISSING_FIELD', '"issuer" not set'));
        }
        const subjectPublicKey = finalParams.subjectPublicKey;
        if (subjectPublicKey === undefined) {
            throw (new certificate_1.default('CERTIFICATE_MISSING_FIELD', '"subject" not set'));
        }
        const validFrom = finalParams.validFrom;
        if (validFrom === undefined) {
            throw (new certificate_1.default('CERTIFICATE_MISSING_FIELD', '"validFrom" not set'));
        }
        const validTo = finalParams.validTo;
        if (validTo === undefined) {
            throw (new certificate_1.default('CERTIFICATE_MISSING_FIELD', '"validTo" not set'));
        }
        const serial = finalParams.serial;
        if (serial === undefined) {
            throw (new certificate_1.default('CERTIFICATE_MISSING_FIELD', '"serialNumber" not set'));
        }
        const hashLib = finalParams.hashLib;
        const hashParams = finalParams.hashParams;
        if (hashParams === undefined) {
            throw (new certificate_1.default('CERTIFICATE_MISSING_FIELD', '"hashParams" not set'));
        }
        return ({
            ...finalParams,
            issuer,
            subjectPublicKey,
            validFrom,
            validTo,
            serial,
            hashLib,
            hashParams
        });
    }
    /**
     * Create a certificate
     */
    async buildDER(params) {
        const finalParams = this.getFinalParams(params);
        const { oid: signatureAlgorithmOID, hashData: hashData } = (function () {
            const hashName = CertificateBuilder.hashName(finalParams, 'signature');
            switch (finalParams.issuer.keyType) {
                case account_1.AccountKeyAlgorithm.ECDSA_SECP256K1:
                case account_1.AccountKeyAlgorithm.ECDSA_SECP256R1:
                    return ({
                        oid: `${hashName}WithEcDSA`,
                        hashData: true
                    });
                case account_1.AccountKeyAlgorithm.ED25519:
                    return ({
                        oid: 'ed25519',
                        hashData: false
                    });
                default:
                    (0, never_1.assertNever)(finalParams.issuer.keyType);
            }
        })();
        /*
         * Compute the Subject and Issuer DNs
         */
        if (finalParams.subjectDN === undefined) {
            finalParams.subjectDN = [{ name: 'commonName', value: finalParams.subjectPublicKey.publicKeyString.get() }];
        }
        const subjectDN = toDNSequence(finalParams.subjectDN);
        if (finalParams.issuerDN === undefined) {
            finalParams.issuerDN = [{ name: 'commonName', value: finalParams.issuer.publicKeyString.get() }];
        }
        const issuerDN = toDNSequence(finalParams.issuerDN);
        /**
         * Extensions to add to the certificate
         */
        const extensions = await this.addExtensions(finalParams);
        /**
         * Generate the data to be signed within the certificate
         */
        const tbsCertificateData = [
            /* Version (v3) */
            { type: 'context', value: 0, kind: 'explicit', contains: 2n },
            /* Serial Number */
            BigInt(finalParams.serial),
            /* Signature Algorithm */
            [
                /* Algorithm */
                { type: 'oid', oid: signatureAlgorithmOID }
            ],
            /* Issuer */
            issuerDN,
            /* Validity Period */
            [
                /* Not Before */
                { type: 'date', kind: 'default', date: finalParams.validFrom },
                /* Not After */
                { type: 'date', kind: 'default', date: finalParams.validTo }
            ],
            /* Subject */
            subjectDN,
            /* Subject Public Key */
            finalParams.subjectPublicKey.publicKey.ASN1.getASN1(),
            /* Extensions */
            {
                type: 'context',
                kind: 'explicit',
                value: 3,
                contains: extensions
            }
        ];
        const tbsCertificate = ASN1.JStoASN1(tbsCertificateData).toBER();
        const tbsCertificateBuffer = Buffer.from(tbsCertificate);
        /**
         * Sign the certificate
         */
        let toSign;
        if (hashData) {
            toSign = Buffer.from(CertificateBuilder.hash(finalParams, 'signature', tbsCertificateBuffer));
        }
        else {
            toSign = tbsCertificateBuffer;
        }
        const signature = await finalParams.issuer.sign(toSign, {
            raw: true,
            forCert: true
        });
        /**
         * Emit the final certificate
         */
        const certificateObject = [
            /* TBS Certificate */
            tbsCertificateData,
            /* Signature Algorithm */
            [
                /* Algorithm */
                { type: 'oid', oid: signatureAlgorithmOID }
            ],
            /* Signature */
            { type: 'bitstring', value: signature.getBuffer() }
        ];
        const certificate = ASN1.JStoASN1(certificateObject).toBER();
        return (certificate);
    }
    async build(params, options) {
        const certificate = await this.buildDER(params);
        // eslint-disable-next-line @typescript-eslint/no-use-before-define
        return (new Certificate(certificate, {
            moment: null,
            ...options
        }));
    }
}
exports.CertificateBuilder = CertificateBuilder;
_CertificateBuilder_params = new WeakMap();
/**
 * Certificate hash
 */
class CertificateHash extends buffer_1.BufferStorage {
    get hashFunctionName() {
        return (HashLib.Hash.functionName);
    }
    constructor(certificateHash) {
        super(certificateHash, 32);
    }
    static fromData(data) {
        return (new this(HashLib.Hash(data)));
    }
    toJSON() {
        return (this.toString());
    }
    toString() {
        // eslint-disable-next-line @typescript-eslint/consistent-type-assertions
        return super.toString('hex');
    }
}
exports.CertificateHash = CertificateHash;
CertificateHash.isInstance = (0, helper_1.checkableGenerator)(CertificateHash);
CertificateHash.Set = (0, helper_1.setGenerator)(CertificateHash, function (value) {
    return (value.toString());
}, function (value) {
    return (new CertificateHash(Buffer.from(value, 'hex')));
});
const CertificateBundleSchemaInternal = {
    sequenceOf: CertificateSchemaInternal
};
class CertificateBundle {
    constructor(input) {
        _CertificateBundle_raw.set(this, void 0);
        _CertificateBundle_contents.set(this, void 0);
        if (CertificateBundle.isInstance(input)) {
            __classPrivateFieldSet(this, _CertificateBundle_raw, input.getDER(), "f");
        }
        else if (Array.isArray(input) || input instanceof Set) {
            if (input instanceof Set) {
                input = Array.from(input);
            }
            const decodedInput = input.map(function (certificate) {
                let decoded;
                // eslint-disable-next-line @typescript-eslint/no-use-before-define
                if (Certificate.isCertificate(certificate)) {
                    decoded = new ASN1.BufferStorageASN1(certificate.toDER());
                }
                else {
                    // eslint-disable-next-line @typescript-eslint/no-use-before-define
                    decoded = new ASN1.BufferStorageASN1(new Certificate(certificate).toDER());
                }
                // For some reason the typescript compiler cannot understand this, but we do not care about it being typed because we are validating it right after.
                // @ts-ignore
                const output = decoded.getASN1();
                return (output);
            });
            __classPrivateFieldSet(this, _CertificateBundle_raw, new ASN1.BufferStorageASN1(decodedInput, CertificateBundleSchemaInternal).getDER(), "f");
        }
        else {
            if (typeof input === 'string') {
                input = Buffer.from(input, 'base64');
            }
            if (Buffer.isBuffer(input)) {
                input = (0, helper_1.bufferToArrayBuffer)(input);
            }
            __classPrivateFieldSet(this, _CertificateBundle_raw, input, "f");
        }
        const decoded = new ASN1.BufferStorageASN1(__classPrivateFieldGet(this, _CertificateBundle_raw, "f"), CertificateBundleSchemaInternal);
        __classPrivateFieldSet(this, _CertificateBundle_contents, [], "f");
        const seenHashes = new CertificateHash.Set();
        for (const item of decoded.getASN1()) {
            const certificateValue = new ASN1.BufferStorageASN1(item, CertificateSchemaInternal);
            // eslint-disable-next-line @typescript-eslint/no-use-before-define
            const certificate = new Certificate(certificateValue.getDER());
            const hash = certificate.hash();
            if (seenHashes.has(hash)) {
                throw (new certificate_1.default('CERTIFICATE_DUPLICATE_INCLUDED', `Duplicate certificate ${hash} within certificate bundle`));
            }
            seenHashes.add(hash);
            __classPrivateFieldGet(this, _CertificateBundle_contents, "f").push(certificate);
        }
    }
    get bundleSize() {
        return (__classPrivateFieldGet(this, _CertificateBundle_contents, "f").length);
    }
    getDER() {
        return (__classPrivateFieldGet(this, _CertificateBundle_raw, "f"));
    }
    getDERBuffer() {
        return (Buffer.from(this.getDER()));
    }
    getCertificates() {
        return (__classPrivateFieldGet(this, _CertificateBundle_contents, "f"));
    }
    toJSON() {
        return ({
            certificates: this.getCertificates().map(function (certificate) {
                return (certificate.toPEM());
            })
        });
    }
}
exports.CertificateBundle = CertificateBundle;
_CertificateBundle_raw = new WeakMap(), _CertificateBundle_contents = new WeakMap();
CertificateBundle.isInstance = (0, helper_1.checkableGenerator)(CertificateBundle);
class Certificate {
    /**
     * Is a certificate object?
     */
    static isCertificate(value) {
        if (typeof value !== 'object' || value === null) {
            return (false);
        }
        if (!('certificateObjectTypeID' in value)) {
            return (false);
        }
        if (value['certificateObjectTypeID'] !== Certificate.certificateObjectTypeID) {
            return (false);
        }
        return (true);
    }
    constructor(input, options) {
        _Certificate_instances.add(this);
        /**
         * The raw certificate (DER encoded)
         */
        _Certificate_raw.set(this, void 0);
        _Certificate_hash.set(this, void 0);
        /**
         * Raw extensions, which can be processed by subclasses
         */
        _Certificate_extensionsRaw.set(this, void 0);
        /**
         * Extensions that have been processed (by OID)
         */
        _Certificate_extensionsProcessed.set(this, void 0);
        /**
         * Has finalizeConstruction been called?
         */
        _Certificate_finalizeConstructionCalled.set(this, false);
        /*
         * If a certificate is provided, then extract the raw
         * certificate and process it -- do not merge any of
         * its trust options
         */
        if (Certificate.isCertificate(input)) {
            // For use in browser, have to use toDER instead of accessing #raw directly
            input = input.toDER();
        }
        /*
         * Define an object type ID as an un-enumerable property to
         * ensure that we can identify this object as an instance of
         * Certificate, but we do not need to serialize it.
         */
        Object.defineProperty(this, 'certificateObjectTypeID', {
            value: Certificate.certificateObjectTypeID,
            enumerable: false
        });
        if (typeof input === 'string') {
            let lines = input.split('\n');
            const beginIndex = lines.findIndex(function (line) {
                return (line === '-----BEGIN CERTIFICATE-----');
            });
            if (beginIndex !== -1) {
                lines = lines.slice(beginIndex + 1);
                const endIndex = lines.findIndex(function (line) {
                    return (line === '-----END CERTIFICATE-----');
                });
                if (endIndex !== -1) {
                    lines = lines.slice(0, endIndex);
                    input = lines.join('');
                }
            }
            input = Buffer.from(input, 'base64');
        }
        if (Buffer.isBuffer(input)) {
            input = (0, helper_1.bufferToArrayBuffer)(input);
        }
        const data = new ASN1.BufferStorageASN1(input, CertificateSchemaInternal);
        __classPrivateFieldSet(this, _Certificate_raw, data.getDER(), "f");
        const parts = data.getASN1();
        const tbsCertificate = parts[0];
        const [version, serialNumber, signatureAlgorithmSigned, issuer, [notBefore, notAfter], subject, subjectPublicKey, extensions] = tbsCertificate;
        if (version.contains !== 2n) {
            throw (new certificate_1.default('CERTIFICATE_INVALID_VERSION', 'Only X509v3 certificates are supported'));
        }
        const signatureAlgorithm = parts[1];
        /**
         * Get the KeetaNet Account that corresponds with the subject
         */
        const subjectAccount = account_1.default.fromASN1(subjectPublicKey);
        /*
         * Verify the validity period relative to the specified moment
         */
        let moment = options?.moment;
        if (moment === undefined) {
            moment = new Date();
        }
        this.moment = moment;
        this.assertValid(this.moment);
        /*
         * Allow specifying a null moment to indicate that the moment
         * of validation is unknown
         */
        /*
         * Assign attributes we have processed
         */
        this.serial = serialNumber;
        this.subjectPublicKey = subjectAccount;
        this.notBefore = notBefore.date;
        this.notAfter = notAfter.date;
        this.subject = fromDNSequenceToString(subject);
        this.issuer = fromDNSequenceToString(issuer);
        this.subjectDN = fromDNSequence(subject);
        this.issuerDN = fromDNSequence(issuer);
        this.subjectDNSet = subject;
        this.issuerDNSet = issuer;
        /*
         * Compare the signature algorithm in the certificate with
         * the signature algorithm in the signature
         */
        const signatureAlgorithmSignedBuffer = new ASN1.BufferStorageASN1(signatureAlgorithmSigned).getDERBuffer();
        const signatureAlgorithmBuffer = new ASN1.BufferStorageASN1(signatureAlgorithm).getDERBuffer();
        if (!signatureAlgorithmSignedBuffer.equals(signatureAlgorithmBuffer)) {
            throw (new certificate_1.default('CERTIFICATE_SIGNATURE_ALGORITHM_MISMATCH', 'Signature algorithm mismatch between signature and certificate'));
        }
        /*
         * Process the extensions base extensions, which can be critical for
         * validation
         */
        __classPrivateFieldSet(this, _Certificate_extensionsRaw, extensions?.contains, "f");
        __classPrivateFieldSet(this, _Certificate_extensionsProcessed, new Set(), "f");
        __classPrivateFieldGet(this, _Certificate_instances, "m", _Certificate_processBaseExtensions).call(this, extensions);
        /*
         * If the certificate is self-signed, then we can verify the
         * signature using the public key in the certificate
         */
        if (this.isSelfSigned()) {
            /*
             * Verify that this is a Root CA in the store if provided
             */
            if (options?.store !== undefined) {
                if (options.store.root !== undefined) {
                    let found = false;
                    options.store.root.forEach((checkCertificate) => {
                        if (found) {
                            return;
                        }
                        if (checkCertificate.equals(this)) {
                            found = true;
                            return;
                        }
                    });
                    if (!found) {
                        throw (new certificate_1.default('CERTIFICATE_SELF_SIGNED_VALIDATION_FAILED', 'Self-signed certificate is not a root CA in the Root CA store'));
                    }
                    this.chain = [this];
                }
            }
            if (options?.isTrustedRoot) {
                this.chain = [this];
            }
            if (!this.verify(this)) {
                throw (new certificate_1.default('CERTIFICATE_SELF_SIGNED_VALIDATION_FAILED', 'Self-signed certificate signature verification failed'));
            }
        }
        else {
            /*
             * If a store is provided, then verify the certificate chain
             */
            if (options?.store !== undefined) {
                const chain = this.verifyChain(options.store);
                if (chain === null || chain.length === 0) {
                    throw (new certificate_1.default('CERTIFICATE_CHAIN_VERIFICATION_FAILED', 'Certificate chain verification failed'));
                }
                this.chain = chain;
            }
        }
        this.finalizeConstruction();
    }
    /**
     * Finalize construction of the certificate -- if this method is
     * replaced in a subclass, remember to call it at the end of the
     * subclass constructor or the certificate will not be fully
     * constructed
     */
    finalizeConstruction() {
        this.processExtensions();
        __classPrivateFieldGet(this, _Certificate_instances, "m", _Certificate_assertAllCriticalExtensionsProcessed).call(this);
        __classPrivateFieldSet(this, _Certificate_finalizeConstructionCalled, true, "f");
    }
    /**
     * Process remaining extensions
     */
    processExtensions() {
        __classPrivateFieldGet(this, _Certificate_instances, "m", _Certificate_processExtensionsInternal).call(this, __classPrivateFieldGet(this, _Certificate_extensionsRaw, "f"), __classPrivateFieldGet(this, _Certificate_extensionsProcessed, "f"), this.processExtension.bind(this));
    }
    /**
     * Process an extension -- returns true if the extension was processed
     *
     * This is intended to be overridden by subclasses for processing
     * custom extensions
     */
    /*
     * These variables are not used, but are defined here so that
     * the subclass can access them
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    processExtension(id, value) {
        return (false);
    }
    /**
     * Verifies that a certificate is self-signed
     */
    isSelfSigned() {
        return (this.checkIssued(this));
    }
    /**
     * Verifies that the certificate is was signed by the given account or certificate
     */
    verify(account) {
        if (Certificate.isCertificate(account)) {
            account = account.subjectPublicKey;
        }
        const data = new ASN1.BufferStorageASN1(__classPrivateFieldGet(this, _Certificate_raw, "f"), CertificateSchemaInternal);
        const [tbsCertificate, signatureAlgorithmObject, signatureObject] = data.getASN1();
        const signatureAlgorithm = signatureAlgorithmObject[0].oid;
        const tbsCertificateToVerify = new ASN1.BufferStorageASN1(tbsCertificate).getDER();
        let compatibleKeyTypes;
        switch (signatureAlgorithm) {
            case 'sha3-256WithEcDSA':
            case 'sha256WithEcDSA':
                compatibleKeyTypes = [account_1.default.AccountKeyAlgorithm.ECDSA_SECP256K1, account_1.default.AccountKeyAlgorithm.ECDSA_SECP256R1];
                break;
            case 'ed25519':
                compatibleKeyTypes = [account_1.default.AccountKeyAlgorithm.ED25519];
                break;
            default:
                throw (new certificate_1.default('CERTIFICATE_INVALID_SIGNATURE_ALGORITHM', `Unsupported signature algorithm ${signatureAlgorithm}`));
        }
        let hashAlgorithm;
        switch (signatureAlgorithm) {
            case 'sha3-256WithEcDSA':
                hashAlgorithm = 'SHA3-256';
                break;
            case 'sha256WithEcDSA':
                hashAlgorithm = 'SHA2-256';
                break;
            case 'ed25519':
                hashAlgorithm = null;
                break;
            default:
                throw (new certificate_1.default('CERTIFICATE_INVALID_SIGNATURE_ALGORITHM', `Unsupported signature algorithm ${signatureAlgorithm}`));
        }
        let accountIsCompatible = false;
        for (const checkCompatibleKeyType of compatibleKeyTypes) {
            if (account.isKeyType(checkCompatibleKeyType)) {
                accountIsCompatible = true;
                break;
            }
        }
        if (!accountIsCompatible) {
            throw (new certificate_1.default('CERTIFICATE_INVALID_SIGNATURE_ALGORITHM', `Account does not have a compatible key type for signature algorithm ${signatureAlgorithm}`));
        }
        let dataToVerify;
        if (hashAlgorithm !== null) {
            const hashFunction = crypto_1.default.createHash(hashAlgorithm);
            hashFunction.update(Buffer.from(tbsCertificateToVerify));
            dataToVerify = (0, helper_1.bufferToArrayBuffer)(hashFunction.digest());
        }
        else {
            dataToVerify = tbsCertificateToVerify;
        }
        const signature = signatureObject.value;
        const verified = account.verify(dataToVerify, (0, helper_1.bufferToArrayBuffer)(signature), {
            forCert: true,
            raw: true
        });
        return (verified);
    }
    /**
     * Asserts provided certificates can construct a valid graph with no loops or orphans, and that all provided certificates can reach the root, or current certificate
     * @param certificates Additional intermediate certificates to verify
     */
    assertCanConstructValidGraph(certificates) {
        if (certificates.size === 0) {
            return (true);
        }
        if (certificates.size > 10) {
            throw (new certificate_1.default('CERTIFICATE_INVALID_GRAPH_COUNT', 'Cannot currently handle more than 10 certificates in a graph'));
        }
        const issuersFrom = [];
        const issuersTo = [];
        const allCertificates = [];
        const seenHashes = new CertificateHash.Set();
        for (const certificate of [this, ...certificates.values()]) {
            const hash = certificate.hash();
            if (seenHashes.has(hash)) {
                throw (new certificate_1.default('CERTIFICATE_DUPLICATE_INCLUDED', `Duplicate certificate found ${hash.toString()}`));
            }
            seenHashes.add(hash);
            allCertificates.push(certificate);
            issuersFrom.push([]);
            issuersTo.push([]);
        }
        for (let i = 0; i < allCertificates.length; i++) {
            const certificate = allCertificates[i];
            for (let y = 0; y < allCertificates.length; y++) {
                if (i === y) {
                    continue;
                }
                const innerCertificate = allCertificates[y];
                const issued = certificate.checkIssued(innerCertificate);
                if (issued) {
                    issuersFrom[i].push(y);
                    issuersTo[y].push(i);
                }
            }
        }
        for (let i = 0; i < allCertificates.length; i++) {
            if (issuersFrom[i].length + issuersTo[i].length === 0) {
                throw (new certificate_1.default('CERTIFICATE_ORPHAN_FOUND', `Found orphan certificate ${allCertificates[i].hash()}`));
            }
            const seenIndexes = new Set();
            const toVisit = [i];
            while (toVisit.length > 0) {
                // We can assert that this is not null because this will only run if there is an item in the array
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                const next = toVisit.shift();
                if (seenIndexes.has(next)) {
                    throw (new certificate_1.default('CERTIFICATE_CYCLE_FOUND', 'Cyclic certificate chain'));
                }
                seenIndexes.add(next);
                toVisit.push(...issuersTo[next]);
            }
            if (!seenIndexes.has(0)) {
                throw (new certificate_1.default('CERTIFICATE_SECONDARY_GRAPH', `Certificate ${allCertificates[i].hash()} does not reach target`));
            }
        }
    }
    /**
     * Verify against a given certificate store
     */
    verifyChain(store, _ignore_seenCerts /* XXX:TODO */) {
        /*
         * Check to see if the certificate is signed by any of the Root CAs
         */
        if (store.root === undefined) {
            return (null);
        }
        let retval = null;
        store.root.forEach((rootCertificate) => {
            if (retval !== null) {
                return;
            }
            const checkIssued = this.checkIssued(rootCertificate, true);
            if (checkIssued.issued) {
                if (rootCertificate.checkValid(this.moment)) {
                    retval = [rootCertificate];
                }
            }
        });
        if (retval !== null) {
            return (retval);
        }
        /*
         * Check to see if the certificate is signed by any of the specified intermediates
         */
        if (store.intermediate !== undefined) {
            store.intermediate.forEach((intermediateCertificate) => {
                if (retval !== null) {
                    return;
                }
                if (this.checkIssued(intermediateCertificate)) {
                    if (intermediateCertificate.checkValid(this.moment)) {
                        const moreChain = intermediateCertificate.verifyChain(store /* , seenCerts XXX:TODO */);
                        if (moreChain !== null) {
                            retval = [...moreChain, intermediateCertificate];
                            return;
                        }
                    }
                }
            });
            if (retval !== null) {
                return (retval);
            }
        }
        return (null);
    }
    checkValid(moment, reason) {
        const retval = __classPrivateFieldGet(this, _Certificate_instances, "m", _Certificate_checkValid).call(this, moment);
        if (reason) {
            return (retval);
        }
        return (retval.valid);
    }
    /**
     * Assert that the certificate is valid at a given moment
     */
    assertValid(moment) {
        const valid = this.checkValid(moment, true);
        if (!valid.valid) {
            throw (new certificate_1.default('CERTIFICATE_MOMENT_INVALID', `Certificate is not valid: ${valid.reason}`));
        }
    }
    checkIssued(issuer, reason) {
        const retval = __classPrivateFieldGet(this, _Certificate_instances, "m", _Certificate_checkIssued).call(this, issuer);
        if (reason !== true) {
            return (retval.issued);
        }
        return (retval);
    }
    /**
     * Get the issuer certificate (if known)
     */
    getIssuerCertificate() {
        if (this.isSelfSigned()) {
            return (this);
        }
        if (this.chain === undefined) {
            return (null);
        }
        if (this.chain.length === 0) {
            return (null);
        }
        const chain = this.chain;
        const issuer = chain[chain.length - 1];
        return (issuer);
    }
    /**
     * Get the root certificate (if known)
     */
    getRootCertificate() {
        if (this.chain === undefined) {
            return (null);
        }
        if (this.chain.length === 0) {
            return (null);
        }
        const chain = this.chain;
        const root = chain[0];
        return (root);
    }
    /**
     * Get the issuer account
     */
    getIssuerAccount() {
        const issuerCert = this.getIssuerCertificate();
        if (issuerCert === null) {
            return (null);
        }
        return (issuerCert.subjectPublicKey);
    }
    /**
     * Get the extensions present in the certificate -- this is the raw
     * extensions as they were parsed from the certificate, and may
     * contain extensions that are not processed by this class.
     */
    getExtensions() {
        this.assertConstructed();
        if (__classPrivateFieldGet(this, _Certificate_extensionsRaw, "f") === undefined) {
            return (undefined);
        }
        return (__classPrivateFieldGet(this, _Certificate_extensionsRaw, "f"));
    }
    assertConstructed() {
        if (!__classPrivateFieldGet(this, _Certificate_finalizeConstructionCalled, "f")) {
            throw (new Error('internal error: finalizeConstruction not called'));
        }
    }
    /**
     * Compare the certificate with another certificate and return true if they
     * are the same
     */
    equals(other) {
        this.assertConstructed();
        if (__classPrivateFieldGet(this, _Certificate_raw, "f").byteLength !== __classPrivateFieldGet(other, _Certificate_raw, "f").byteLength) {
            return (false);
        }
        const thisBuffer = Buffer.from(__classPrivateFieldGet(this, _Certificate_raw, "f"));
        const otherBuffer = Buffer.from(__classPrivateFieldGet(other, _Certificate_raw, "f"));
        return (thisBuffer.equals(otherBuffer));
    }
    /**
     * If this certificate can be trusted to have been validated to a trusted Root CA
     */
    get trusted() {
        this.assertConstructed();
        return (this.getRootCertificate() !== null);
    }
    /**
     * Get the certificate as a DER encoded ArrayBuffer
     */
    toDER() {
        this.assertConstructed();
        return (__classPrivateFieldGet(this, _Certificate_raw, "f"));
    }
    /**
     * Get the certificate as a PEM encoded string
     */
    toPEM() {
        this.assertConstructed();
        const certificatePEMLines = Buffer.from(__classPrivateFieldGet(this, _Certificate_raw, "f")).toString('base64').split(/(.{64})/g).filter(function (line) {
            return (line.length > 0);
        });
        const certificatePEM = [
            '-----BEGIN CERTIFICATE-----',
            ...certificatePEMLines,
            '-----END CERTIFICATE-----'
        ].join('\n') + '\n';
        return (certificatePEM);
    }
    /**
     * The string representation of the certificate
     * is a PEM encoded certificate -- this misses
     * some of the internal details like chain
     * and verified, but is usually what someone
     * wants to see when they call toString()
     */
    toString() {
        return (this.toPEM());
    }
    /**
     * Compute a hash of the certificate
     */
    hash() {
        this.assertConstructed();
        if (!__classPrivateFieldGet(this, _Certificate_hash, "f")) {
            __classPrivateFieldSet(this, _Certificate_hash, CertificateHash.fromData(Buffer.from(__classPrivateFieldGet(this, _Certificate_raw, "f"))), "f");
        }
        return (__classPrivateFieldGet(this, _Certificate_hash, "f"));
    }
    /**
     * Get a JSON representation of the certificate
     */
    toJSON(options, includeChain = false) {
        this.assertConstructed();
        // XXX:TODO Fix this type
        const additionalFields = {};
        if (options?.addBinary) {
            additionalFields['$binary'] = this.toPEM();
        }
        if (includeChain && this.chain !== undefined) {
            additionalFields['$chain'] = this.chain.map(function (chainCert) {
                return (chainCert.toJSON({ ...options, addBinary: false }, false));
            });
        }
        return ({
            serial: this.serial,
            notBefore: this.notBefore,
            notAfter: this.notAfter,
            subject: this.subject,
            issuer: this.issuer,
            subjectPublicKey: this.subjectPublicKey,
            baseExtensions: this.baseExtensions,
            subjectDN: fromDNSequence(this.subjectDNSet),
            issuerDN: fromDNSequence(this.issuerDNSet),
            $hash: this.hash(),
            ...additionalFields
        });
    }
}
exports.Certificate = Certificate;
_Certificate_raw = new WeakMap(), _Certificate_hash = new WeakMap(), _Certificate_extensionsRaw = new WeakMap(), _Certificate_extensionsProcessed = new WeakMap(), _Certificate_finalizeConstructionCalled = new WeakMap(), _Certificate_instances = new WeakSet(), _Certificate_processExtensionsInternal = function _Certificate_processExtensionsInternal(extensions, processedSet, handleExtension) {
    if (extensions === undefined) {
        return;
    }
    for (const extension of extensions) {
        let id;
        let value;
        if (extension.length === 3) {
            [id, , value] = extension;
        }
        else {
            [id, value] = extension;
        }
        if (processedSet.has(id.oid)) {
            continue;
        }
        const processed = handleExtension(id.oid, (0, helper_1.bufferToArrayBuffer)(value));
        if (processed) {
            processedSet.add(id.oid);
        }
    }
}, _Certificate_processBaseExtensions = function _Certificate_processBaseExtensions(extensionsObject) {
    // @ts-ignore
    this.baseExtensions = {};
    if (extensionsObject === undefined) {
        return;
    }
    const extensions = extensionsObject.contains;
    /**
     * Ensure that there are no duplicate extensions
     */
    const seenExtensions = new Set();
    for (const extension of extensions) {
        const id = extension[0].oid;
        if (seenExtensions.has(id)) {
            throw (new certificate_1.default('CERTIFICATE_DUPLICATE_EXTENSION', `Duplicate extension ${id}`));
        }
        seenExtensions.add(id);
    }
    __classPrivateFieldGet(this, _Certificate_instances, "m", _Certificate_processExtensionsInternal).call(this, extensions, __classPrivateFieldGet(this, _Certificate_extensionsProcessed, "f"), __classPrivateFieldGet(this, _Certificate_instances, "m", _Certificate_processBaseExtension).bind(this));
}, _Certificate_processBaseExtension = function _Certificate_processBaseExtension(id, value) {
    if (this.baseExtensions === undefined) {
        throw (new Error('internal error: baseExtensions not defined'));
    }
    switch (id) {
        /** Extension: Basic Constraints (CA) */
        case '2.5.29.19': {
            const basicConstraints = new ASN1.BufferStorageASN1(value, [
                { optional: ASN1.ValidateASN1.IsBoolean },
                { optional: ASN1.ValidateASN1.IsInteger }
            ]).getASN1();
            if (basicConstraints[0] === undefined) {
                basicConstraints[0] = false;
            }
            this.baseExtensions.basicConstraints = [basicConstraints[0], basicConstraints[1]];
            return (true);
        }
        /** Extension: Key Usage */
        case '2.5.29.15':
            /* XXX:TODO */
            return (true);
        /** Extension: Authority Key Identifier */
        case '2.5.29.35':
            this.baseExtensions.authorityKeyIdentifier = new ASN1.BufferStorageASN1(value, [{ choice: [
                        { type: 'context', value: 0, kind: 'implicit', contains: ASN1.ValidateASN1.IsOctetString },
                        /* For backward compatibility */
                        { type: 'context', value: 0, kind: 'explicit', contains: ASN1.ValidateASN1.IsOctetString }
                        /* XXX:TODO: Handle other types */
                    ] }]).getASN1()[0];
            return (true);
        /** Extension: Subject Key Identifier */
        case '2.5.29.14':
            this.baseExtensions.subjectKeyIdentifier = new ASN1.BufferStorageASN1(value, ASN1.ValidateASN1.IsOctetString).getASN1();
            return (true);
    }
    return (false);
}, _Certificate_assertAllCriticalExtensionsProcessed = function _Certificate_assertAllCriticalExtensionsProcessed() {
    if (__classPrivateFieldGet(this, _Certificate_extensionsRaw, "f") === undefined) {
        return;
    }
    for (const extension of __classPrivateFieldGet(this, _Certificate_extensionsRaw, "f")) {
        let id;
        let critical = false;
        if (extension.length === 3) {
            [id, critical] = extension;
        }
        else {
            [id] = extension;
        }
        if (critical && !__classPrivateFieldGet(this, _Certificate_extensionsProcessed, "f").has(id.oid)) {
            throw (new certificate_1.default('CERTIFICATE_EXTENSION_NOT_PROCESSED', `Critical extension ${id.oid} not processed`));
        }
    }
}, _Certificate_checkValid = function _Certificate_checkValid(moment) {
    if (moment === undefined) {
        moment = new Date();
    }
    let valid = true;
    let reasonString = '<unknown>';
    if (moment !== null) {
        if (this.notBefore > moment) {
            valid = false;
            reasonString = 'Certificate is not yet valid';
        }
        if (this.notAfter < moment) {
            valid = false;
            reasonString = 'Certificate has expired';
        }
    }
    if (valid) {
        return ({ valid: true });
    }
    else {
        return ({ valid: false, reason: reasonString });
    }
}, _Certificate_checkIssued = function _Certificate_checkIssued(issuer) {
    /**
     * Compare the issuerDN and the subjectDN byte-for-byte
     */
    const issuerDN = new ASN1.BufferStorageASN1(issuer.subjectDNSet);
    const subjectIssuerDN = new ASN1.BufferStorageASN1(this.issuerDNSet);
    const issuerDER = issuerDN.getDERBuffer();
    const subjectIssuerDER = subjectIssuerDN.getDERBuffer();
    if (!issuerDER.equals(subjectIssuerDER)) {
        return ({ issued: false, reason: 'Certificate Issuer DN does not match issuer\'s Subject DN' });
    }
    /**
     * If the authority key identifier is present, then compare
     * it with the respective attribute
     */
    if (this.baseExtensions?.authorityKeyIdentifier !== undefined) {
        const authorityKeyIdentifier = this.baseExtensions.authorityKeyIdentifier;
        switch (authorityKeyIdentifier.value) {
            case 0: {
                /* Key Identifier */
                if (issuer.baseExtensions?.subjectKeyIdentifier === undefined) {
                    return ({ issued: false, reason: 'Authority Key Identifier present but no Subject Key Identifier' });
                }
                const subjectKeyIdentifier = issuer.baseExtensions.subjectKeyIdentifier;
                if (subjectKeyIdentifier.equals(authorityKeyIdentifier.contains)) {
                    break;
                }
                return ({ issued: false, reason: 'Authority Key Identifier does not match Subject Key Identifier' });
            }
            default:
                (0, never_1.assertNever)(authorityKeyIdentifier.value);
        }
    }
    /**
     * Verify that the issuer has the authority to issue the
     * certificate (basic constraints)
     */
    /* XXX:TODO */
    /**
     * If the key usage extension is present, then check that the
     * issuer key usage is consistent with the certificate being
     * a CA
     */
    /* XXX:TODO */
    /**
     * Verify the signature
     */
    if (!this.verify(issuer)) {
        return ({ issued: false, reason: 'Signature verification failed' });
    }
    return ({ issued: true });
};
/**
 * The Certificate Builder
 */
Certificate.Builder = CertificateBuilder;
/**
 * The certificate bundle
 */
Certificate.Bundle = CertificateBundle;
/**
 * The certificate hash information
 */
Certificate.Hash = CertificateHash;
/**
 * Object type ID for {@link Certificate.isCertificate}
 */
Certificate.certificateObjectTypeID = '8d05dca5-5f42-4dc9-8bf9-f534c6570994:CERTIFICATE';


/***/ }),

/***/ 2360:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.toJSONSerializable = toJSONSerializable;
exports.objectToBuffer = objectToBuffer;
exports.parseHexBigIntString = parseHexBigIntString;
const util_1 = __webpack_require__(9023);
;
function convertSingleValue(value, opts = {}) {
    const checkPrefix = function (out, prefix, parseOpts) {
        if (parseOpts.debugUnsafe && prefix) {
            out = `[${prefix} ${out}]`;
        }
        return (out);
    };
    let out = value;
    let prefix;
    if (typeof value === 'bigint') {
        if (opts.debugUnsafe) {
            out = String(value);
        }
        else {
            let positiveValue = value;
            let sign = '';
            if (value < 0n) {
                positiveValue = value * -1n;
                sign = '-';
            }
            const numberAsString = positiveValue.toString(16).toUpperCase();
            out = `${sign}0x${numberAsString}`;
        }
    }
    else if (util_1.types.isDate(value)) {
        prefix = 'DATE';
        out = value.toISOString();
    }
    else if (util_1.types.isArrayBuffer(value)) {
        out = Buffer.from(value).toString('hex').toUpperCase();
    }
    else if (value instanceof Buffer) {
        out = value.toString('hex').toUpperCase();
    }
    else if (Array.isArray(value)) {
        out = value.map(val => convertSingleValue(val, opts));
    }
    else if (value instanceof Object) {
        let hasValue = false;
        if (value.toJSON !== undefined && typeof value.toJSON === 'function') {
            hasValue = true;
            out = convertSingleValue(value.toJSON(opts), opts);
        }
        else if (opts.debugUnsafe && value.toString !== undefined && typeof value.toString === 'function') {
            const toStringResult = value.toString();
            if (toStringResult !== '[object Object]') {
                out = convertSingleValue(value.toJSON(), opts);
                prefix = 'OBJECT';
                if (typeof value.constructor && value.constructor.name) {
                    prefix = value.constructor.name;
                }
                hasValue = true;
                out = value.toString();
            }
        }
        if (hasValue === false) {
            const retval = { ...value };
            for (const key in retval) {
                retval[key] = convertSingleValue(retval[key], opts);
            }
            out = retval;
        }
    }
    return (checkPrefix(out, prefix, opts));
}
function toJSONSerializable(data, opts) {
    return (JSON.parse(JSON.stringify(convertSingleValue(data, opts))));
}
function objectToBuffer(data, opts = {}) {
    return (Buffer.from(JSON.stringify(convertSingleValue(data, opts))));
}
function parseHexBigIntString(input) {
    if (input.startsWith('-')) {
        return (BigInt(input.substring(1)) * -1n);
    }
    else {
        return (BigInt(input));
    }
}


/***/ }),

/***/ 9240:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// https://raw.githubusercontent.com/jjavery/ed25519-to-x25519/main/src/ed2curve.js
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.convertPublicKey = convertPublicKey;
exports.convertSecretKey = convertSecretKey;
// @ts-nocheck
const crypto_1 = __importDefault(__webpack_require__(6982));
// If an 'initialValues' argument is provided, the values of the 'initialValues' array will be assigned to the new 'result' array
const gf = function (initialValues) {
    // Declare variables 'index' and 'result'
    const result = new Float64Array(16);
    // If an 'initialValues' argument is provided
    if (initialValues) {
        // Loop through the 'initialValues' array
        for (let index = 0; index < initialValues.length; index++) {
            // Assign the value of the 'initialValues' array at the current index to the corresponding index in the 'result' array
            result[index] = initialValues[index];
        }
    }
    // Return the new 'result' array
    return (result);
};
const gf0 = gf();
const gf1 = gf([1]);
const D = gf([
    0x78a3,
    0x1359,
    0x4dca,
    0x75eb,
    0xd8ab,
    0x4141,
    0x0a4d,
    0x0070,
    0xe898,
    0x7779,
    0x4079,
    0x8cc7,
    0xfe73,
    0x2b6f,
    0x6cee,
    0x5203
]);
const I = gf([
    0xa0b0,
    0x4a0e,
    0x1b27,
    0xc4ee,
    0xe478,
    0xad2f,
    0x1806,
    0x2f43,
    0xd7a7,
    0x3dfb,
    0x0099,
    0x2b4d,
    0xdf0b,
    0x4fc1,
    0x2480,
    0x2b83
]);
// This function is used to perform some operations on an array 'o' of 16 elements
// It adds 65536 to each element,  perform a floor division by 65536,
// and based on the result of floor division it will make some additional calculations
function car25519(inputArray) {
    let carryOverValue;
    // Loop through each element of the array
    for (let index = 0; index < 16; index++) {
        // Add 65536 to the current element
        inputArray[index] += 65536;
        // Perform a floor division by 65536 and assign the result to 'carryOverValue'
        carryOverValue = Math.floor(inputArray[index] / 65536);
        // If current index is not the last element of the array
        if (index < 15) {
            inputArray[index + 1] += carryOverValue - 1;
        }
        else {
            inputArray[0] += carryOverValue - 1 + 37 * (carryOverValue - 1);
        }
        // Subtract the product of 'carryOverValue' and 65536 from the current element
        inputArray[index] -= (carryOverValue * 65536);
    }
}
// This function takes three arguments: two arrays 'p' and 'q' of length 16 and a variable 'b'
// It performs a selection operation on the elements of the 'p' and 'q' based on the value of 'b'
function sel25519(array1, array2, b) {
    const comparison = ~(b - 1);
    let temp;
    // Loop through each element of the array
    for (let index = 0; index < 16; index++) {
        temp = comparison & (array1[index] ^ array2[index]);
        array1[index] ^= temp;
        array2[index] ^= temp;
    }
}
/**
 * This function unpacks bytes into 16-bit integers in order to perform operations on them with maximum precision.
 * Since JavaScript numbers are 64-bit floating-point numbers and they can't accurately represent integers larger than 2^53,
 * unpacking bytes into 16-bit integers provides a way to work with larger integers without losing precision.
 *
 * @param output the array of integers to store the unpacked values
 * @param inputBytes the input bytes array to unpack
 */
function unpack25519(output, inputBytes) {
    // iterate over the first 16 element of inputBytes
    for (let i = 0; i < 16; i++) {
        // output at i is inputBytes at 2i plus inputBytes at 2i+1 shifted 8 bit to the left ( this is equivalent of combining 2 bytes)
        output[i] = inputBytes[2 * i] + (inputBytes[2 * i + 1] << 8);
    }
    // Zeroing the most significant bit of last element
    output[15] &= 0x7fff;
}
/**
 * This function performs the addition of two arrays and stores the result in the output array
 *
 * @param output the array to store the result
 * @param a first array to add
 * @param b second array to add
 */
function A(output, a, b) {
    for (let i = 0; i < 16; i++) {
        output[i] = a[i] + b[i] | 0;
    }
}
/**
* This function performs the subtraction of two arrays and stores the result in the output array
*
* @param output the array to store the result
* @param a first array
* @param b second array to subtract from the first
*/
function Z(output, a, b) {
    for (let i = 0; i < 16; i++) {
        output[i] = a[i] - b[i] | 0;
    }
}
/**
 * This function performs the multiplication of two arrays and stores the result in the output array.
 *
 * @param output the array to store the result
 * @param a first array
 * @param b second array
 */
function M(output, a, b) {
    const temp = new Float64Array(31);
    // initialize temp array to zero
    for (let i = 0; i < 31; i++) {
        temp[i] = 0;
    }
    // perform the multiplication of a and b
    for (let i = 0; i < 16; i++) {
        for (let j = 0; j < 16; j++) {
            temp[i + j] += a[i] * b[j];
        }
    }
    // add 38 times the higher order coefficients to the lower order ones
    for (let i = 0; i < 15; i++) {
        temp[i] += 38 * temp[i + 16];
    }
    // copy the temp array to output array
    for (let i = 0; i < 16; i++) {
        output[i] = temp[i];
    }
    // perform two car25519 operation on output array
    car25519(output);
    car25519(output);
}
// squaring
function S(o, a) {
    M(o, a, a);
}
/**
 * This function calculates the modular inverse of the input array and stores it in the output array.
 *
 * @param output the array to store the result
 * @param inputArray the input array
 */
function inv25519(output, inputArray) {
    const c = gf();
    let a;
    // copy the input array to c
    for (a = 0; a < 16; a++) {
        c[a] = inputArray[a];
    }
    // perform the modular inverse calculation
    for (a = 253; a >= 0; a--) {
        S(c, c);
        if (a !== 2 && a !== 4) {
            M(c, c, inputArray);
        }
    }
    // copy the result to output
    for (a = 0; a < 16; a++) {
        output[a] = c[a];
    }
}
/**
 * This function packs a 16-bit integers array into bytes array
 *
 * @param outputBytes the array of bytes to store the packed values
 * @param inputIntegers the input integers array to pack
 */
function pack25519(outputBytes, inputIntegers) {
    let i, j, carryBit;
    const tempArray = gf();
    const resultArray = gf();
    // copy input array to resultArray
    for (i = 0; i < 16; i++) {
        resultArray[i] = inputIntegers[i];
    }
    // perform car25519 operation on resultArray
    car25519(resultArray);
    car25519(resultArray);
    car25519(resultArray);
    for (j = 0; j < 2; j++) {
        tempArray[0] = resultArray[0] - 0xffed;
        for (i = 1; i < 15; i++) {
            tempArray[i] = resultArray[i] - 0xffff - ((tempArray[i - 1] >> 16) & 1);
            tempArray[i - 1] &= 0xffff;
        }
        tempArray[15] = resultArray[15] - 0x7fff - ((tempArray[14] >> 16) & 1);
        carryBit = (tempArray[15] >> 16) & 1;
        tempArray[14] &= 0xffff;
        // perform sel25519 operation on resultArray
        sel25519(resultArray, tempArray, 1 - carryBit);
    }
    // pack the resultArray into outputBytes
    for (i = 0; i < 16; i++) {
        outputBytes[2 * i] = resultArray[i] & 0xff;
        outputBytes[2 * i + 1] = resultArray[i] >> 8;
    }
}
/**
 * This function checks if the least significant bit of the packed bytes representation of a number is set.
 *
 * @param inputInteger the number to check
 * @returns 1 if the least significant bit is set, 0 otherwise
 */
function par25519(inputInteger) {
    const packedBytes = new Uint8Array(32);
    pack25519(packedBytes, [inputInteger]);
    return (packedBytes[0] & 1);
}
/**
 * This function compares two arrays for equality.
 *
 * @param x the first array to compare
 * @param xi the starting index of the first array
 * @param y the second array to compare
 * @param yi the starting index of the second array
 * @param n the number of elements to compare
 * @returns 0 if the arrays are equal, -1 otherwise
 */
function vn(x, xi, y, yi, n) {
    for (let i = 0; i < n; i++) {
        if (x[xi + i] !== y[yi + i]) {
            return (-1);
        }
    }
    return (0);
}
/**
* This function compares two arrays of 16-bit integers for equality, after they have been packed into bytes.
*
* @param a the first array to compare
* @param b the second array to compare
* @returns 0 if the arrays are equal, -1 otherwise
*/
function neq25519(a, b) {
    const packedA = new Uint8Array(32), packedB = new Uint8Array(32);
    pack25519(packedA, a);
    pack25519(packedB, b);
    return (vn(packedA, 0, packedB, 0, 32));
}
function pow2523(o, i) {
    const c = gf();
    let a;
    for (a = 0; a < 16; a++) {
        c[a] = i[a];
    }
    for (a = 250; a >= 0; a--) {
        S(c, c);
        if (a !== 1) {
            M(c, c, i);
        }
    }
    for (a = 0; a < 16; a++) {
        o[a] = c[a];
    }
}
function set25519(r, a) {
    for (let i = 0; i < 16; i++) {
        r[i] = a[i] | 0;
    }
}
/**
 * Ensure a key is valid
 */
function unpackNeg(r, p) {
    // Initialize local variables
    const t = gf();
    const chk = gf();
    const num = gf();
    const den = gf();
    const den2 = gf();
    const den4 = gf();
    const den6 = gf();
    // Set the value of the third element in the 'r' array to 'gf1'
    set25519(r[2], gf1);
    // Unpack the values of the 'p' array and assign them to the second element of the 'r' array
    unpack25519(r[1], p);
    // Squaring the value of the second element of the 'r' array and assigns the result to 'num'
    S(num, r[1]);
    // Multiply the value of 'num' by the constant 'D' and assigns the result to 'den'
    M(den, num, D);
    // Add the values of 'num' and the third element of the 'r' array and assigns the result to 'num'
    Z(num, num, r[2]);
    // Add the values of 'den' and the third element of the 'r' array and assigns the result to 'den'
    A(den, r[2], den);
    // Squaring the value of 'den' and assigns the result to 'den2'
    S(den2, den);
    // Squaring the value of 'den2' and assigns the result to 'den4'
    S(den4, den2);
    // Multiply the values of 'den4' and 'den2' and assigns the result to 'den6'
    M(den6, den4, den2);
    // Multiply the values of 't', 'den6', 'num' and 'den'
    M(t, den6, num);
    M(t, t, den);
    // Raise the value of 't' to the power of 2523
    pow2523(t, t);
    // Multiply the values of 't', 'num' and 'den'
    M(t, t, num);
    M(t, t, den);
    M(t, t, den);
    // Assign the value of 't' to the first element of the 'r' array
    M(r[0], t, den);
    // Squaring the value of the first element of the 'r' array and assigns the result to 'chk'
    S(chk, r[0]);
    M(chk, chk, den);
    // Check if the value of 'chk' is equal to the value of 'num'
    if (neq25519(chk, num)) {
        // If not, multiply the first element of the 'r' array by the constant 'I'
        M(r[0], r[0], I);
    }
    // Squaring the value of the first element of the 'r' array and assigns the result to 'chk'
    S(chk, r[0]);
    M(chk, chk, den);
    // Check if the value of 'chk' is equal to the value of 'num'
    if (neq25519(chk, num)) {
        return (-1);
    }
    // Check if the parity of the first element of the 'r' array is equal to the most significant bit of the 32nd element of the 'p' array
    if (par25519(r[0]) === (p[31] >> 7)) {
        // If so, subtract the first element of the 'r' array from 'gf0' and assigns the result to the first element of the 'r' array
        Z(r[0], gf0, r[0]);
    }
    // Multiply the first and second element of the 'r' array and assign the result to the fourth element of the 'r' array
    M(r[3], r[0], r[1]);
    return (0);
}
// ----
// Converts Ed25519 public key to Curve25519 public key.
// montgomeryX = (edwardsY + 1)*inverse(1 - edwardsY) mod p
function convertPublicKey(pk) {
    const z = new Uint8Array(32);
    const q = [gf(), gf(), gf(), gf()];
    const a = gf(), b = gf();
    // reject invalid key
    if (unpackNeg(q, pk)) {
        return (null);
    }
    A(a, gf1, q[1]);
    Z(b, gf1, q[1]);
    inv25519(b, b);
    M(a, a, b);
    pack25519(z, a);
    return (z);
}
// Converts Ed25519 secret key to Curve25519 secret key.
function convertSecretKey(sk) {
    const o = new Uint8Array(32);
    const hash = crypto_1.default.createHash('sha512');
    hash.update(sk);
    const digest = hash.digest();
    digest[0] &= 248;
    digest[31] &= 127;
    digest[31] |= 64;
    for (let i = 0; i < 32; i++) {
        o[i] = digest[i];
    }
    return (o);
}
exports["default"] = { convertSecretKey, convertPublicKey };


/***/ }),

/***/ 7908:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.HashFunctionLength = exports.HashFunctionName = void 0;
exports.Hash = Hash;
const crypto_1 = __importDefault(__webpack_require__(6982));
/**
 * Hashing function name to use with key derivation and public key checksums
 */
exports.HashFunctionName = 'sha3-256';
/**
 * Length of the hash function
 */
exports.HashFunctionLength = 32;
/**
 * Hash some data
 */
function Hash(data, len = -1) {
    const hashFunction = crypto_1.default.createHash(exports.HashFunctionName);
    hashFunction.update(data);
    const digest = hashFunction.digest();
    if (len < 0) {
        return (digest);
    }
    return (digest.slice(0, len));
}
Hash.functionName = exports.HashFunctionName;
Hash.functionLength = exports.HashFunctionLength;


/***/ }),

/***/ 3208:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var _AsyncDisposableStackPolyfill_instances, _AsyncDisposableStackPolyfill_toDispose, _AsyncDisposableStackPolyfill_validateNotDisposed, _a;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.crypto = exports.AsyncDisposableStack = void 0;
exports.bufferToArrayBuffer = bufferToArrayBuffer;
exports.bufferToBigInt = bufferToBigInt;
exports.isIntegerOrBigInt = isIntegerOrBigInt;
exports.isBuffer = isBuffer;
exports.arrayRepeat = arrayRepeat;
exports.waitTicks = waitTicks;
exports.env = env;
exports.booleanEnv = booleanEnv;
exports.randomString = randomString;
exports.randomInt = randomInt;
exports.asleep = asleep;
exports.promiseGenerator = promiseGenerator;
exports.internalLogger = internalLogger;
exports.objectToBuffer = objectToBuffer;
exports.debugPrintableObject = debugPrintableObject;
exports.checkableGenerator = checkableGenerator;
exports.nonNullable = nonNullable;
exports.setGenerator = setGenerator;
const crypto_1 = __importDefault(__webpack_require__(6982));
const util_1 = __webpack_require__(9023);
const hash_1 = __webpack_require__(7908);
const uuid = __importStar(__webpack_require__(5827));
const loggingLevels = ['debug', 'error'];
const configuredLoggingLevel = process.env['KEETANET_DEBUG']?.toLowerCase();
const configuredLoggingFilter = new RegExp(process.env['KEETANET_DEBUG_FILTER'] ?? '', 'i');
const randomBytes = crypto_1.default.randomBytes.bind(crypto_1.default);
const randomUUID = crypto_1.default.randomUUID ? crypto_1.default.randomUUID.bind(crypto_1.default) : function () {
    return (uuid.v4());
};
function bufferToArrayBuffer(input) {
    const out = new ArrayBuffer(input.length);
    const view = new Uint8Array(out);
    for (let index = input.length - 1; index >= 0; index--) {
        view[index] = input[index];
    }
    return (out);
}
function bufferToBigInt(buffer) {
    let result = 0n;
    for (const byte of buffer) {
        result = (result << 8n) + BigInt(byte);
    }
    return (result);
}
/**
 * Check if a value is an integer or a bigint.
 */
function isIntegerOrBigInt(value) {
    return (Number.isInteger(value) || typeof value === 'bigint');
}
/**
 * Check if a value is a Buffer. This exists due to an inconsistency with the
 * way `Buffer.isBuffer` is defined in `@types/node` and differs from similar
 * functionality such as `Array.isArray`. This leads `Buffer.isBuffer` to
 * result in an unbound method reference error despite being a static call.
 * Eslint Rule: eslint@typescript-eslint/unbound-method
 */
function isBuffer(value) {
    return (Buffer.isBuffer(value));
}
function arrayRepeat(value, length) {
    return (Array.from({ length }, () => value));
}
function oneTick() {
    return (new Promise(function (resolve) {
        process.nextTick(resolve);
    }));
}
/**
 * Waits a specific number of ticks and then resolves
 */
async function waitTicks(ticks) {
    if (ticks < 1) {
        throw (new Error('Ticks to wait cannot be below 1'));
    }
    if (ticks > 1) {
        await waitTicks(ticks - 1);
    }
    await oneTick();
}
/**
 * Returns env variable, or default
 * Throws if neither are defined
 */
function env(name, defaultValue) {
    const retval = process.env[name];
    if (retval === undefined) {
        if (defaultValue !== undefined) {
            return (defaultValue);
        }
        throw (new Error(`${name} must be defined`));
    }
    return (retval);
}
function booleanEnv(name, defaultValue) {
    const value = env(name, defaultValue?.toString());
    if (value.toLowerCase() === 'true') {
        return (true);
    }
    else {
        return (false);
    }
}
/**
 * Generate a random string from length provided (default 32)
 */
function randomString(requestedLength = 32) {
    if (requestedLength === 0) {
        return ('');
    }
    // One byte === 2 chars
    let bytesToGen = Math.ceil(requestedLength / 2);
    // If you try to generate less than one byte, set to one byte
    if (bytesToGen < 1) {
        bytesToGen = 1;
    }
    // Generate bytes and convert to hex string
    let generated = randomBytes(bytesToGen).toString('hex');
    // If you requested an odd length, remove last character
    // This is one byte is 2 characters, so we cannot directly generate odd lengths
    if (requestedLength % 2 === 1) {
        generated = generated.slice(0, -1);
    }
    return (generated);
}
// Generate a random int from a range
// NOTE: SHOULD NOT BE USED WHERE TRUE RANDOMNESS IS REQUIRED
function randomInt(min, max) {
    return (Math.floor(Math.random() * (max - min + 1)) + min);
}
async function asleep(time_ms) {
    const promise = new Promise(function (resolve) {
        setTimeout(function () {
            resolve(null);
        }, time_ms);
    });
    await promise;
}
function promiseGenerator() {
    let resolve, reject;
    const promise = new Promise(function (_resolve, _reject) {
        resolve = _resolve;
        reject = _reject;
    });
    if (resolve === undefined || reject === undefined) {
        throw (new Error('internal error: promise setup failed'));
    }
    return ({ promise, resolve, reject });
}
function convertToJSON(_ignore_key, item) {
    switch (typeof item) {
        case 'string':
        case 'boolean':
            return (item);
        case 'undefined':
            return (String(item));
        case 'bigint':
            if (item < BigInt(Number.MAX_SAFE_INTEGER) && item > BigInt(Number.MIN_SAFE_INTEGER)) {
                return (Number(item.toString()));
            }
            else {
                return (`0x${item.toString(16)}[=>${item.toString(10)}]`);
            }
        case 'number':
            if (item === Infinity) {
                return ('‚àû');
            }
            if (isNaN(item)) {
                return ('#NaN');
            }
            return (item);
        default:
            /* We handle other cases outside of this switch */
            break;
    }
    if (Array.isArray(item)) {
        return (item);
    }
    if (item === null) {
        return (item);
    }
    if (util_1.types.isDate(item)) {
        return (`[Date ${item.toISOString()}]`);
    }
    if (Buffer.isBuffer(item)) {
        return (item.toString('base64'));
    }
    if (util_1.types.isArrayBuffer(item)) {
        return (Buffer.from(item).toString('base64'));
    }
    if (item instanceof Object) {
        if (item.toJSON !== undefined) {
            if (typeof item.toJSON === 'function') {
                return (item.toJSON());
            }
        }
        if (item.publicKeyString !== undefined) {
            if (item.publicKeyString.get !== undefined) {
                if (typeof item.publicKeyString.get === 'function') {
                    const hasPrivateKey = item.hasPrivateKey;
                    let addToString = 'PUBLIC';
                    if (hasPrivateKey) {
                        addToString = 'PRIVATE';
                    }
                    return (`[Account ${item.publicKeyString.get()} ${addToString}]`);
                }
            }
        }
    }
    if (item instanceof Object) {
        if (item.toString !== undefined) {
            if (typeof item.toString === 'function') {
                const checkString = item.toString();
                if (checkString !== '[object Object]' && checkString !== '[Object]') {
                    let typeID = 'object';
                    if (typeof item.constructor && item.constructor.name) {
                        typeID = item.constructor.name;
                    }
                    return (`[${typeID} ${checkString}]`);
                }
            }
        }
    }
    if (item instanceof Object) {
        const retval = { ...item };
        for (const key in retval) {
            const value = retval[key];
            if (util_1.types.isDate(value)) {
                retval[key] = convertToJSON(key, value);
            }
        }
        return (retval);
    }
    return (item);
}
function internalLogger(nodeAlias, level, from, ...message) {
    /**
     * Disable logging unless specified
     */
    if (configuredLoggingLevel === undefined) {
        return;
    }
    /**
     * Only log matching sources
     */
    if (!configuredLoggingFilter.test(from)) {
        return;
    }
    const configuredLoggingLevelValue = loggingLevels.indexOf(configuredLoggingLevel);
    const levelValue = loggingLevels.indexOf(level);
    /**
     * Do not log anything if desired log level is higher than logged message
     */
    if (configuredLoggingLevelValue > levelValue) {
        return;
    }
    if (nodeAlias === undefined) {
        nodeAlias = '<unnamed node>';
    }
    let logger;
    switch (level) {
        case 'debug':
            logger = console.debug;
            break;
        case 'error':
            logger = console.error;
            break;
    }
    if (logger === undefined) {
        return;
    }
    logger(`[${nodeAlias}/${from.toUpperCase()}]`, ...message);
}
function objectToBuffer(input) {
    const stringified = JSON.stringify(input, convertToJSON);
    return (Buffer.from(stringified));
}
function debugPrintableObject(input) {
    return (JSON.parse(JSON.stringify(input, convertToJSON)));
}
// Helpers for isInstance
function isSubset(subset, fullset) {
    return (fullset.length >= subset.length &&
        subset.every(p => fullset.includes(p)));
}
function getAllPropertyNames(obj) {
    const propertiesArray = [];
    while (obj) {
        propertiesArray.push(...Object.getOwnPropertyNames(obj));
        obj = Object.getPrototypeOf(obj);
    }
    const asSet = new Set(propertiesArray);
    return (Array.from(asSet));
}
const classIdKey = '__classId__';
function checkableGenerator(parent, defaultStrict = true) {
    const staticSignature = getAllPropertyNames(parent);
    const instanceSignature = getAllPropertyNames(parent.prototype);
    if (!instanceSignature.includes(classIdKey)) {
        instanceSignature.push(classIdKey);
    }
    const allProperties = [
        parent.name,
        ...staticSignature.sort(),
        ...instanceSignature.sort()
    ].join('%');
    const classId = Buffer.from((0, hash_1.Hash)(Buffer.from(allProperties))).toString('hex');
    parent.prototype[classIdKey] = classId;
    return (function (child, strict = defaultStrict) {
        if (!child) {
            return (false);
        }
        if (strict) {
            // We know that any class with this function already has the classID, so we can have this assertion
            // eslint-disable-next-line @typescript-eslint/consistent-type-assertions
            return (child[classIdKey] === classId);
        }
        const childBase = getAllPropertyNames(child.constructor);
        if (!isSubset(staticSignature, childBase)) {
            return (false);
        }
        const childProto = getAllPropertyNames(child);
        if (!isSubset(instanceSignature, childProto)) {
            return (false);
        }
        return (true);
    });
}
function nonNullable(value) {
    if (value === null || value === undefined) {
        throw (new Error('Value cannot be null or undefined'));
    }
    return (value);
}
/**
 * Polyfill for AsyncDisposableStack if not available in the global scope.
 * This is a basic implementation that only permits defer
 */
class AsyncDisposableStackPolyfill {
    constructor() {
        _AsyncDisposableStackPolyfill_instances.add(this);
        _AsyncDisposableStackPolyfill_toDispose.set(this, []);
        this.disposed = false;
        this[_a] = 'AsyncDisposablePolyfill';
    }
    async [(_AsyncDisposableStackPolyfill_toDispose = new WeakMap(), _AsyncDisposableStackPolyfill_instances = new WeakSet(), _a = Symbol.toStringTag, _AsyncDisposableStackPolyfill_validateNotDisposed = function _AsyncDisposableStackPolyfill_validateNotDisposed() {
        if (this.disposed) {
            throw (new Error('Attempted to use AsyncDisposablePolyfill after it was disposed'));
        }
    }, Symbol.asyncDispose)]() {
        __classPrivateFieldGet(this, _AsyncDisposableStackPolyfill_instances, "m", _AsyncDisposableStackPolyfill_validateNotDisposed).call(this);
        this.disposed = true;
        const toDispose = __classPrivateFieldGet(this, _AsyncDisposableStackPolyfill_toDispose, "f").splice(0);
        for (const callback of toDispose) {
            await callback();
        }
    }
    defer(callback) {
        __classPrivateFieldGet(this, _AsyncDisposableStackPolyfill_instances, "m", _AsyncDisposableStackPolyfill_validateNotDisposed).call(this);
        __classPrivateFieldGet(this, _AsyncDisposableStackPolyfill_toDispose, "f").push(callback);
    }
    async disposeAsync() {
        return (await this[Symbol.asyncDispose]());
    }
    use(_value) {
        __classPrivateFieldGet(this, _AsyncDisposableStackPolyfill_instances, "m", _AsyncDisposableStackPolyfill_validateNotDisposed).call(this);
        throw (new Error('not implemented'));
    }
    adopt(_value, _onDisposeAsync) {
        __classPrivateFieldGet(this, _AsyncDisposableStackPolyfill_instances, "m", _AsyncDisposableStackPolyfill_validateNotDisposed).call(this);
        throw (new Error('not implemented'));
    }
    move() {
        __classPrivateFieldGet(this, _AsyncDisposableStackPolyfill_instances, "m", _AsyncDisposableStackPolyfill_validateNotDisposed).call(this);
        throw (new Error('not implemented'));
    }
}
/**
 * AsyncDisposableStack https://github.com/tc39/proposal-explicit-resource-management
 */
exports.AsyncDisposableStack = global.AsyncDisposableStack ?? globalThis.AsyncDisposableStack ?? AsyncDisposableStackPolyfill;
function setGenerator(parent, rawEncode, rawDecode) {
    var _set, _map, _b;
    const encode = function (data, map) {
        const encoded = rawEncode(data);
        map.set(encoded, data);
        return (encoded);
    };
    const decode = function (data, map) {
        const decoded = rawDecode(data);
        if (map.has(data)) {
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            return (map.get(data));
        }
        map.set(data, decoded);
        return (decoded);
    };
    return (class {
        constructor(data = []) {
            _set.set(this, void 0);
            _map.set(this, void 0);
            this[_b] = `${parent.name}Set`;
            __classPrivateFieldSet(this, _map, new Map(), "f");
            __classPrivateFieldSet(this, _set, new Set, "f");
            // Use a loop since data could be an Iterable not always an array
            for (const item of data) {
                __classPrivateFieldGet(this, _set, "f").add(encode(item, __classPrivateFieldGet(this, _map, "f")));
            }
        }
        // Fit with new JS spec
        // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set/isSubsetOf
        isSubsetOf(compareTo) {
            if (compareTo.size < this.size) {
                return (false);
            }
            for (const val of this.valuesInternal()) {
                if (!compareTo.hasInternal(val)) {
                    return (false);
                }
            }
            return (true);
        }
        isEqualTo(compareTo) {
            if (this.size !== compareTo.size) {
                return (false);
            }
            return (this.isSubsetOf(compareTo));
        }
        add(data) {
            if (!Array.isArray(data)) {
                const encodedData = encode(data, __classPrivateFieldGet(this, _map, "f"));
                __classPrivateFieldGet(this, _set, "f").add(encodedData);
            }
            else {
                for (const toAdd of data) {
                    const encodedData = encode(toAdd, __classPrivateFieldGet(this, _map, "f"));
                    __classPrivateFieldGet(this, _set, "f").add(encodedData);
                }
            }
            return (this);
        }
        addInternal(data) {
            __classPrivateFieldGet(this, _set, "f").add(data);
            return (this);
        }
        delete(data) {
            const encoded = encode(data, __classPrivateFieldGet(this, _map, "f"));
            const retval = __classPrivateFieldGet(this, _set, "f").delete(encoded);
            if (retval) {
                __classPrivateFieldGet(this, _map, "f").delete(encoded);
            }
            return (retval);
        }
        deleteInternal(data) {
            const retval = __classPrivateFieldGet(this, _set, "f").delete(data);
            if (retval) {
                __classPrivateFieldGet(this, _map, "f").delete(data);
            }
            return (retval);
        }
        has(data) {
            return (__classPrivateFieldGet(this, _set, "f").has(encode(data, __classPrivateFieldGet(this, _map, "f"))));
        }
        hasInternal(data) {
            return (__classPrivateFieldGet(this, _set, "f").has(data));
        }
        toArray() {
            return (this.toArrayInternal().map(data => decode(data, __classPrivateFieldGet(this, _map, "f"))));
        }
        toArrayInternal() {
            return (Array.from(__classPrivateFieldGet(this, _set, "f")));
        }
        get size() {
            return (__classPrivateFieldGet(this, _set, "f").size);
        }
        *[(_set = new WeakMap(), _map = new WeakMap(), _b = Symbol.toStringTag, Symbol.iterator)]() {
            for (const encoded of __classPrivateFieldGet(this, _set, "f")) {
                yield decode(encoded, __classPrivateFieldGet(this, _map, "f"));
            }
        }
        *entries() {
            for (const encoded of __classPrivateFieldGet(this, _set, "f")) {
                const decoded = decode(encoded, __classPrivateFieldGet(this, _map, "f"));
                yield ([decoded, decoded]);
            }
        }
        *keys() {
            for (const encoded of __classPrivateFieldGet(this, _set, "f")) {
                yield decode(encoded, __classPrivateFieldGet(this, _map, "f"));
            }
        }
        *values() {
            for (const encoded of __classPrivateFieldGet(this, _set, "f")) {
                yield decode(encoded, __classPrivateFieldGet(this, _map, "f"));
            }
        }
        valuesInternal() {
            return (__classPrivateFieldGet(this, _set, "f").values());
        }
        clear() {
            __classPrivateFieldGet(this, _set, "f").clear();
            __classPrivateFieldGet(this, _map, "f").clear();
        }
        [Symbol.dispose]() {
            this.clear();
        }
        forEach(callbackfn, thisArg) {
            __classPrivateFieldGet(this, _set, "f").forEach((encodedValue) => {
                const decodedValue = decode(encodedValue, __classPrivateFieldGet(this, _map, "f"));
                callbackfn.call(thisArg, decodedValue, decodedValue, this);
            });
        }
    });
}
exports.crypto = {
    randomUUID: randomUUID,
    randomBytes: randomBytes,
    createCipheriv: crypto_1.default.createCipheriv.bind(crypto_1.default),
    createDecipheriv: crypto_1.default.createDecipheriv.bind(crypto_1.default)
};


/***/ }),

/***/ 3750:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.generateInitialVoteStaple = generateInitialVoteStaple;
const account_1 = __importDefault(__webpack_require__(9415));
const block_1 = __importDefault(__webpack_require__(6158));
const permissions_1 = __webpack_require__(5860);
const vote_1 = __importDefault(__webpack_require__(1130));
async function generateInitialVoteStaple(options) {
    const { network, initialTrustedAccount, voteSerial = 0n } = options;
    const { networkAddress, baseToken } = account_1.default.generateBaseAddresses(network);
    const blocks = {};
    const prevByKey = {};
    const getPrevious = function (account) {
        const pubKey = account.publicKeyString.get();
        return (prevByKey[pubKey] ?? block_1.default.NO_PREVIOUS);
    };
    const setPrevious = function (account, block) {
        const pubKey = account.publicKeyString.get();
        prevByKey[pubKey] = block.hash;
    };
    blocks.networkAddress = await new block_1.default.Builder({
        network: network,
        account: networkAddress,
        signer: initialTrustedAccount,
        previous: getPrevious(networkAddress),
        operations: [
            {
                type: block_1.default.OperationType.MODIFY_PERMISSIONS,
                method: block_1.default.AdjustMethod.SET,
                principal: initialTrustedAccount,
                permissions: new permissions_1.Permissions(['OWNER'])
            },
            {
                type: block_1.default.OperationType.SET_INFO,
                name: 'KEETANET',
                description: 'Network Address For KeetaNet',
                metadata: '',
                defaultPermission: new permissions_1.Permissions(['STORAGE_CREATE'])
            }
        ]
    }).seal();
    setPrevious(networkAddress, blocks.networkAddress);
    const additionalBaseTokenOperations = [];
    const shouldAddSupply = 'addSupply' in options;
    if (shouldAddSupply) {
        additionalBaseTokenOperations.push({
            type: block_1.default.OperationType.TOKEN_ADMIN_SUPPLY,
            amount: options.addSupply.amount,
            method: block_1.default.Builder.AdjustMethod.ADD
        });
    }
    blocks.baseToken = await new block_1.default.Builder({
        network: network,
        account: baseToken,
        signer: initialTrustedAccount,
        previous: getPrevious(baseToken),
        operations: [
            {
                type: block_1.default.OperationType.MODIFY_PERMISSIONS,
                method: block_1.default.AdjustMethod.SET,
                principal: initialTrustedAccount,
                permissions: new permissions_1.Permissions(['OWNER'])
            },
            {
                type: block_1.default.Builder.OperationType.SET_INFO,
                name: options.baseTokenInfo?.currencyCode ?? '',
                description: options.baseTokenInfo?.name ?? '',
                metadata: options.baseTokenInfo ? btoa(JSON.stringify({ decimalPlaces: options.baseTokenInfo.decimalPlaces })) : '',
                defaultPermission: new permissions_1.Permissions(['ACCESS'])
            },
            ...additionalBaseTokenOperations
        ]
    }).seal();
    setPrevious(baseToken, blocks.baseToken);
    if (shouldAddSupply) {
        const { recipient } = options.addSupply;
        blocks.recipient = await new block_1.default.Builder({
            network: network,
            account: recipient,
            signer: initialTrustedAccount,
            previous: getPrevious(recipient),
            operations: [{
                    type: block_1.default.OperationType.TOKEN_ADMIN_MODIFY_BALANCE,
                    amount: options.addSupply.amount,
                    method: block_1.default.Builder.AdjustMethod.ADD,
                    token: baseToken
                }]
        }).seal();
        setPrevious(recipient, blocks.recipient);
        if (options.addSupply.delegate) {
            if (!options.addSupply.delegateTo) {
                throw (new Error('generateInitialVoteStaple() - delegateTo must be defined when delegate is true'));
            }
            blocks.recipientSupply = blocks.recipient;
            blocks.recipient = await new block_1.default.Builder({
                network: network,
                account: recipient,
                previous: getPrevious(recipient),
                operations: [{
                        type: block_1.default.OperationType.SET_REP,
                        to: options.addSupply.delegateTo
                    }]
            }).seal();
        }
    }
    const voteWIP = new vote_1.default.Builder(initialTrustedAccount);
    const blockArray = [
        blocks.networkAddress,
        blocks.baseToken,
        blocks.recipientSupply,
        blocks.recipient
    ].filter(function (maybeBlock) {
        return (!!maybeBlock);
    });
    for (const block of blockArray) {
        voteWIP.addBlock(block);
    }
    const vote = await voteWIP.seal(voteSerial, null);
    const voteStaple = vote_1.default.Staple.fromVotesAndBlocks([vote], blockArray);
    // We know that we are returning the correct type here
    // eslint-disable-next-line @typescript-eslint/consistent-type-assertions
    return ({ voteStaple, blocks });
}


/***/ }),

/***/ 8692:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.assertNever = assertNever;
/**
 * Asserts that the provided value is never.
 *
 * This is useful for static type checking to ensure that all possible values
 * are handled.
 */
function assertNever(value) {
    /**
     * If we got to this point, it means that the value is not never and
     * so can be logged
     */
    // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
    throw (new Error(`Unexpected value: ${value}`));
}


/***/ }),

/***/ 1130:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

/*
 * KeetaNet Voting System
 *
 * Votes are indications that an operator will insert a group of blocks into
 * their ledger if enough cooperating operators agree.
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var _VoteBlockHashMap_instances, _VoteBlockHashMap_valueMap, _VoteBlockHashMap_keyMap, _VoteBlockHashMap_getLookupKey, _a, _VoteLikeBase_vote, _VoteLikeBase_options, _VoteLikeBase__hash, _VoteLikeBase__blocksHash, _VoteBlockBundle_value, _VoteBlockBundle_valueCompressed, _VoteBlockBundle__hash, _VoteBlockBundle__blocksHash, _BaseVoteBuilder_account, _BaseVoteBuilder_blocks, _BaseVoteBuilder_fee;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Testing = exports.VoteQuoteBuilder = exports.VoteBuilder = exports.BaseVoteBuilder = exports.VoteStaple = exports.VoteBlockBundle = exports.VoteQuote = exports.Vote = exports.PossiblyExpiredVote = exports.VoteBlockHash = exports.VoteBlockHashMap = void 0;
const block_1 = __webpack_require__(6158);
const hash_1 = __webpack_require__(7908);
const account_1 = __importStar(__webpack_require__(9415));
const asn1_1 = __webpack_require__(6045);
const helper_1 = __webpack_require__(3208);
const zlib_1 = __importDefault(__webpack_require__(3106));
const buffer_1 = __webpack_require__(3310);
const util_1 = __webpack_require__(9023);
const vote_1 = __importDefault(__webpack_require__(3689));
class VoteHash extends buffer_1.BufferStorage {
    constructor(blockhash) {
        super(blockhash, 32);
        this.storageKind = 'VoteHash';
    }
}
VoteHash.isInstance = (0, helper_1.checkableGenerator)(VoteHash);
const feeExtensionSchema = {
    type: 'context',
    value: 0,
    kind: 'explicit',
    contains: [
        asn1_1.ValidateASN1.IsBoolean,
        asn1_1.ValidateASN1.IsInteger,
        { optional: { type: 'context', value: 0, kind: 'implicit', contains: asn1_1.ValidateASN1.IsOctetString } },
        { optional: { type: 'context', value: 1, kind: 'implicit', contains: asn1_1.ValidateASN1.IsOctetString } }
    ]
};
/**
 * Parse a set of distinguished names
 */
function findRDN(input, findOID) {
    if (!Array.isArray(input)) {
        throw (new vote_1.default('VOTE_MALFORMED_FIND_RDN_INVALID_TYPE', 'internal error: DN must be a Sequence'));
    }
    if (input.length === 0) {
        throw (new vote_1.default('VOTE_MALFORMED_FIND_RDN_MUST_HAVE_ONE', 'internal error: DN must contain at least 1 entry'));
    }
    for (const part of input) {
        if (part === undefined || part === null) {
            throw (new vote_1.default('VOTE_MALFORMED_FIND_RDN_PART_WELL_FORMED', 'internal error: Each part of the RDN must be well-formed and not undefined'));
        }
        if (part.type !== 'set') {
            throw (new vote_1.default('VOTE_MALFORMED_FIND_RDN_MUST_BE_SET', 'internal error: Each part of the RDN must be a Set'));
        }
        const name = part.name;
        if (name === undefined || name === null) {
            throw (new vote_1.default('VOTE_MALFORMED_FIND_RDN_PART_WELL_FORMED', 'internal error: Each part of the RDN must be well-formed'));
        }
        if (name.type !== 'oid') {
            throw (new vote_1.default('VOTE_MALFORMED_FIND_RDN_TYPE_MUST_BE_OID', 'internal error: Name of the RDN must be an OID'));
        }
        if (name.oid !== findOID) {
            continue;
        }
        if (typeof part.value === 'string') {
            return (part.value);
        }
        if (typeof part.value === 'object' && part.value !== null) {
            if (part.value.type === 'string' && part.value.kind === 'utf8') {
                return (part.value.value);
            }
        }
        throw (new vote_1.default('VOTE_MALFORMED_FIND_RDN_PART_WELL_FORMED', 'internal error: Value of the RDN must be a string'));
    }
}
function blockHashesFromVote(input) {
    const blockHashInformation = (0, asn1_1.ASN1toJS)(input.buffer);
    if (!(0, asn1_1.isASN1Object)(blockHashInformation)) {
        throw (new vote_1.default('VOTE_MALFORMED_HASHES_FROM_VOTE_INVALID_INPUT', 'internal error: hashData extensions is not valid asn1 object'));
    }
    if (blockHashInformation.type !== 'context') {
        throw (new vote_1.default('VOTE_MALFORMED_HASHES_FROM_VOTE_INVALID_TYPE', 'internal error: hashData extension does not contain a context-specific tag'));
    }
    if (blockHashInformation.value !== 0) {
        throw (new vote_1.default('VOTE_MALFORMED_HASHES_FROM_VOTE_INVALID_CONTEXT_SPECIFIC', 'internal error: hashData must begin with a context-specific tag 0'));
    }
    const hashInformation = blockHashInformation.contains;
    if (!Array.isArray(hashInformation)) {
        throw (new vote_1.default('VOTE_MALFORMED_HASHES_FROM_VOTE_DATA_HASH_DATA_MUST_BE_SEQUENCE', 'internal error: hashData tag 0 must contain a Sequence'));
    }
    if (hashInformation.length !== 2) {
        throw (new vote_1.default('VOTE_MALFORMED_HASHES_FROM_VOTE_DATA_NOT_TWO_ITEMS', 'internal error: hashInformation must contain exactly 2 items'));
    }
    const hashAlgoOID = hashInformation[0];
    if (typeof hashAlgoOID !== 'object' || hashAlgoOID === null || !('type' in hashAlgoOID) || !('oid' in hashAlgoOID)) {
        throw (new vote_1.default('VOTE_MALFORMED_HASHES_FROM_VOTE_DATA_NEEDS_OID', 'internal error: hashInformation must begin with an OID describing the hash used'));
    }
    if (hashAlgoOID.type !== 'oid') {
        throw (new vote_1.default('VOTE_MALFORMED_HASHES_FROM_VOTE_DATA_NEEDS_OID', 'internal error: hashInformation must begin with an OID describing the hash used'));
    }
    if (hashAlgoOID.oid !== hash_1.Hash.functionName) {
        throw (new vote_1.default('VOTE_MALFORMED_HASHES_FROM_VOTE_DATA_UNSUPPORTED_HASH_FUNC', `Unsupported hash function: ${hashAlgoOID.oid}`));
    }
    const blocksSequence = hashInformation[1];
    if (!Array.isArray(blocksSequence)) {
        throw (new vote_1.default('VOTE_MALFORMED_HASHES_FROM_VOTE_DATA_SECOND_MUST_BE_SEQUENCE', 'internal error: hashInformation must contain a Sequence of blocks as the second item'));
    }
    const output = [];
    for (const block of blocksSequence) {
        if (!(Buffer.isBuffer(block))) {
            throw (new vote_1.default('VOTE_MALFORMED_HASHES_FROM_VOTE_DATA_UNSUPPORTED_HASH_TYPE', 'internal error: Each block hash must be an Octet String'));
        }
        output.push(new block_1.BlockHash(block));
    }
    return (output);
}
function feeFromVote(input) {
    const feeInformationAnyJS = (0, asn1_1.ASN1toJS)(input.buffer);
    const feeSchemaChecker = new asn1_1.ValidateASN1(feeExtensionSchema);
    const feeInformation = (function () {
        try {
            return (feeSchemaChecker.validate(feeInformationAnyJS));
        }
        catch (asn1ValidateError) {
            let message = 'internal error: fee asn1 schema is not the right format';
            if (asn1ValidateError instanceof Error) {
                message = `${message}: ${asn1ValidateError.message}`;
            }
            throw (new vote_1.default('VOTE_MALFORMED_FEES_FROM_VOTE_INVALID_INPUT', message));
        }
    })();
    const feeData = feeInformation.contains;
    const quote = feeData[0];
    const retval = {
        quote: quote,
        fee: {
            amount: feeData[1]
        }
    };
    const payToAsn1 = feeData[2];
    if (payToAsn1 !== undefined) {
        const payTo = account_1.default.fromPublicKeyAndType(Buffer.from(payToAsn1.contains));
        if (payTo.isStorage()) {
            retval.fee.payTo = payTo;
        }
        else {
            try {
                retval.fee.payTo = payTo.assertAccount();
            }
            catch {
                throw (new vote_1.default('VOTE_MALFORMED_FEES_PAY_TO_INVALID', 'internal error: payTo is not an Account or Storage Address'));
            }
        }
    }
    const tokenAsn1 = feeData[3];
    if (tokenAsn1 !== undefined) {
        const token = account_1.default.fromPublicKeyAndType(Buffer.from(tokenAsn1.contains));
        if (!token.isToken()) {
            throw (new vote_1.default('VOTE_MALFORMED_FEES_TOKEN_NOT_TOKEN', 'internal error: fees extension token is not a valid token'));
        }
        retval.fee.token = token;
    }
    return (retval);
}
/**
 * Convert an ASN1Date to a Date
 */
function convertDate(input) {
    if (util_1.types.isDate(input)) {
        return (input);
    }
    if (typeof input === 'object' && input !== null) {
        if ('type' in input && 'date' in input) {
            if (input.type === 'date' && util_1.types.isDate(input.date)) {
                return (input.date);
            }
        }
    }
    throw (new vote_1.default('VOTE_MALFORMED_VOTE_VALIDITY_INFORMATION', 'internal error: validFrom and validTo must be a Timestamp'));
}
/**
 * A map for VoteBlockHashes
 */
class VoteBlockHashMap {
    constructor() {
        _VoteBlockHashMap_instances.add(this);
        _VoteBlockHashMap_valueMap.set(this, void 0);
        _VoteBlockHashMap_keyMap.set(this, void 0);
        this[_a] = 'VoteBlockHashMap';
        __classPrivateFieldSet(this, _VoteBlockHashMap_valueMap, new Map(), "f");
        __classPrivateFieldSet(this, _VoteBlockHashMap_keyMap, new Map(), "f");
    }
    [(_VoteBlockHashMap_valueMap = new WeakMap(), _VoteBlockHashMap_keyMap = new WeakMap(), _VoteBlockHashMap_instances = new WeakSet(), _VoteBlockHashMap_getLookupKey = function _VoteBlockHashMap_getLookupKey(key) {
        return (key.toString('hex'));
    }, Symbol.iterator)]() {
        return (this.entries());
    }
    [Symbol.dispose]() {
        this.clear();
    }
    add(key, value) {
        const lookupKey = __classPrivateFieldGet(this, _VoteBlockHashMap_instances, "m", _VoteBlockHashMap_getLookupKey).call(this, key);
        __classPrivateFieldGet(this, _VoteBlockHashMap_valueMap, "f").set(lookupKey, value);
        __classPrivateFieldGet(this, _VoteBlockHashMap_keyMap, "f").set(lookupKey, key);
        return (this);
    }
    delete(key) {
        const lookupKey = __classPrivateFieldGet(this, _VoteBlockHashMap_instances, "m", _VoteBlockHashMap_getLookupKey).call(this, key);
        __classPrivateFieldGet(this, _VoteBlockHashMap_keyMap, "f").delete(lookupKey);
        return (__classPrivateFieldGet(this, _VoteBlockHashMap_valueMap, "f").delete(lookupKey));
    }
    get(key) {
        return (__classPrivateFieldGet(this, _VoteBlockHashMap_valueMap, "f").get(__classPrivateFieldGet(this, _VoteBlockHashMap_instances, "m", _VoteBlockHashMap_getLookupKey).call(this, key)));
    }
    forEach(callbackfn, thisArg) {
        __classPrivateFieldGet(this, _VoteBlockHashMap_valueMap, "f").forEach((value, lookupKey) => {
            /* We know this value exists in the key map */
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            const key = __classPrivateFieldGet(this, _VoteBlockHashMap_keyMap, "f").get(lookupKey);
            callbackfn.call(thisArg, value, key, this);
        });
    }
    has(key) {
        return (__classPrivateFieldGet(this, _VoteBlockHashMap_valueMap, "f").has(__classPrivateFieldGet(this, _VoteBlockHashMap_instances, "m", _VoteBlockHashMap_getLookupKey).call(this, key)));
    }
    set(key, value) {
        return (this.add(key, value));
    }
    get size() {
        return (__classPrivateFieldGet(this, _VoteBlockHashMap_valueMap, "f").size);
    }
    entries() {
        const keyMap = __classPrivateFieldGet(this, _VoteBlockHashMap_keyMap, "f");
        const valueMap = __classPrivateFieldGet(this, _VoteBlockHashMap_valueMap, "f");
        return ((function* () {
            for (const [lookupKey, value] of valueMap.entries()) {
                const key = keyMap.get(lookupKey);
                if (key === undefined) {
                    throw (new Error('Map changed while iterating !'));
                }
                yield ([key, value]);
            }
            return (undefined);
        })());
    }
    keys() {
        return (__classPrivateFieldGet(this, _VoteBlockHashMap_keyMap, "f").values());
    }
    values() {
        return (__classPrivateFieldGet(this, _VoteBlockHashMap_valueMap, "f").values());
    }
    clear() {
        __classPrivateFieldGet(this, _VoteBlockHashMap_valueMap, "f").clear();
        __classPrivateFieldGet(this, _VoteBlockHashMap_keyMap, "f").clear();
    }
}
exports.VoteBlockHashMap = VoteBlockHashMap;
_a = Symbol.toStringTag;
/**
 * A VoteBlockHash is a hash of the blocks in a vote staple or vote staple
 * it is a unique ID for the vote or vote staples contents regardless of which
 * votes are included in the staple -- every vote in a vote staple has the same
 * VoteBlockHash.
 */
class VoteBlockHash extends buffer_1.BufferStorage {
    get hashFunctionName() {
        return (hash_1.Hash.functionName);
    }
    static fromBlockHashes(blockHashes) {
        if (blockHashes.length < 1) {
            throw (new vote_1.default('VOTE_INVALID_CONSTRUCTION', 'Cannot construct vote block hash, no block hashes provided'));
        }
        const blockHashesBuffers = blockHashes.map(function (blockHash) {
            return (blockHash.getBuffer());
        });
        const blockHashesCombined = Buffer.concat(blockHashesBuffers);
        const voteHash = (0, hash_1.Hash)(blockHashesCombined);
        return (new VoteBlockHash(voteHash));
    }
    static fromVote(vote) {
        return (this.fromBlockHashes(vote.blocks));
    }
    static fromVoteStaple(voteStaple) {
        const representativeVote = voteStaple.votes[0];
        return (this.fromVote(representativeVote));
    }
    constructor(stapleHash) {
        super(stapleHash, 32);
        this.storageKind = 'VoteBlockHash';
    }
}
exports.VoteBlockHash = VoteBlockHash;
VoteBlockHash.isInstance = (0, helper_1.checkableGenerator)(VoteBlockHash);
VoteBlockHash.Map = VoteBlockHashMap;
class VoteLikeBase {
    getClass() {
        // eslint-disable-next-line @typescript-eslint/consistent-type-assertions
        return this.constructor;
    }
    static isValidJSON(voteJSON) {
        for (const checkField of ['issuer', 'serial', 'blocks', 'validityFrom', 'validityTo', 'signature']) {
            if (voteJSON[checkField] === undefined) {
                return (false);
            }
        }
        if ('fee' in voteJSON) {
            const fee = voteJSON['fee'];
            if (fee === undefined) {
                return (false);
            }
            if (fee['amount'] === undefined) {
                return (false);
            }
            if ('payTo' in fee && fee['payTo'] === undefined) {
                return (false);
            }
            if ('token' in fee && fee['token'] === undefined) {
                return (false);
            }
        }
        if ('quote' in voteJSON) {
            if (voteJSON['quote'] === undefined) {
                return (false);
            }
        }
        return (true);
    }
    static fromJSON(voteJSON, options = {}) {
        if (!VoteLikeBase.isValidJSON(voteJSON)) {
            throw (new vote_1.default('VOTE_INVALID_CONSTRUCTION_JSON', 'Cannot construct vote, it is not a valid vote JSON object'));
        }
        const issuer = account_1.default.toAccount(voteJSON.issuer);
        if (!issuer) {
            throw (new vote_1.default('VOTE_INVALID_CONSTRUCTION_JSON', 'Issuer is Missing, cannot reconstruct vote'));
        }
        const voteBuilder = new this.Builder(issuer);
        voteBuilder.addBlocks(voteJSON.blocks);
        let signature;
        if (!util_1.types.isArrayBuffer(voteJSON.signature)) {
            signature = (0, helper_1.bufferToArrayBuffer)(Buffer.from(voteJSON.signature, 'hex'));
        }
        else {
            signature = voteJSON.signature;
        }
        const validTo = new Date(voteJSON.validityTo);
        const validFrom = new Date(voteJSON.validityFrom);
        const signatureStorage = new buffer_1.BufferStorage(signature, signature.byteLength);
        if (this.expectedQuoteValue !== (voteJSON.quote ?? false)) {
            throw (new vote_1.default('VOTE_MALFORMED_FEES_QUOTE_INVALID', `internal error: fee quote mismatch found ${voteJSON.quote} - expected ${this.expectedQuoteValue}`));
        }
        if (voteJSON.quote === true && voteJSON.fee === undefined) {
            throw (new vote_1.default('VOTE_FEE_QUOTE_MISSING_FEES', 'internal error: requested quote but no fees provided'));
        }
        if (voteJSON.fee !== undefined) {
            voteBuilder.addFee(voteJSON.fee);
        }
        const { voteData, tbsCertificate, signatureInfo } = voteBuilder.generateVoteData(BigInt(voteJSON.serial), validTo, validFrom);
        const vote = voteBuilder.createVote(voteData, tbsCertificate, signatureInfo, signatureStorage);
        // eslint-disable-next-line @typescript-eslint/consistent-type-assertions
        return new this(vote, options);
    }
    constructor(vote, options = {}) {
        this.$trusted = false;
        this.$permanent = false;
        _VoteLikeBase_vote.set(this, void 0);
        _VoteLikeBase_options.set(this, void 0);
        _VoteLikeBase__hash.set(this, void 0);
        _VoteLikeBase__blocksHash.set(this, void 0);
        __classPrivateFieldSet(this, _VoteLikeBase_options, { ...options }, "f");
        if (VoteLikeBase.isInstance(vote, false)) {
            this.issuer = vote.issuer;
            this.serial = vote.serial;
            this.blocks = vote.blocks;
            this.validityFrom = vote.validityFrom;
            this.validityTo = vote.validityTo;
            this.signature = vote.signature;
            this.fee = vote.fee;
            this.quote = vote.quote;
            this.$trusted = vote.$trusted;
            this.$permanent = vote.$permanent;
            this.$uid = vote.$uid;
            this.$id = vote.$id;
            __classPrivateFieldSet(this, _VoteLikeBase_vote, __classPrivateFieldGet(vote, _VoteLikeBase_vote, "f"), "f");
            __classPrivateFieldSet(this, _VoteLikeBase_options, __classPrivateFieldGet(vote, _VoteLikeBase_options, "f"), "f");
            return;
        }
        if (typeof vote === 'string') {
            vote = Buffer.from(vote, 'base64');
        }
        if (util_1.types.isUint8Array(vote)) {
            vote = Buffer.from(vote);
        }
        if (Buffer.isBuffer(vote)) {
            vote = (0, helper_1.bufferToArrayBuffer)(vote);
        }
        if (!(util_1.types.isArrayBuffer(vote))) {
            if (VoteLikeBase.isValidJSON(vote)) {
                vote = VoteLikeBase.fromJSON(vote).toBytes();
            }
            else {
                throw (new vote_1.default('VOTE_INVALID_CONSTRUCTION', 'internal error: invalid vote constructor argument in VoteLikeBase'));
            }
        }
        __classPrivateFieldSet(this, _VoteLikeBase_vote, vote, "f");
        /**
         * Vote Wrapper contains the vote, signature info, and signature
         */
        const voteWrapper = (0, asn1_1.ASN1toJS)(__classPrivateFieldGet(this, _VoteLikeBase_vote, "f"));
        if (!Array.isArray(voteWrapper)) {
            throw (new vote_1.default('VOTE_MALFORMED_WRAPPER', 'internal error: Malformed vote wrapper (must be a sequence)'));
        }
        if (voteWrapper.length !== 3) {
            throw (new vote_1.default('VOTE_MALFORMED_WRAPPER', 'internal error: Malformed vote wrapper (must contain 3 parts: vote, signature info, signature)'));
        }
        /**
         * The contents of the X.509 certificate signed area
         */
        const voteContents = voteWrapper.shift();
        if (!Array.isArray(voteContents)) {
            throw (new vote_1.default('VOTE_MALFORMED_VOTE_WRAPPER', 'internal error: Malformed vote (must be sequence)'));
        }
        const tbsCertificate = (0, asn1_1.JStoASN1)([...voteContents]).toBER();
        /**
         * Vote version information, recorded as a context-specific
         * tag 0 containing an Integer
         */
        const voteVersionWrapper = voteContents.shift();
        if (typeof voteVersionWrapper !== 'object' || voteVersionWrapper === null || !('type' in voteVersionWrapper) || !('value' in voteVersionWrapper)) {
            throw (new vote_1.default('VOTE_MALFORMED_VOTE_CONTENT', 'internal error: Malformed vote (must begin with a context-specific tag)'));
        }
        if (voteVersionWrapper.type !== 'context') {
            throw (new vote_1.default('VOTE_MALFORMED_VOTE_CONTENT', 'internal error: Malformed vote (must begin with a context-specific tag)'));
        }
        if (voteVersionWrapper.value !== 0) {
            throw (new vote_1.default('VOTE_MALFORMED_VOTE_CONTENT', 'internal error: Malformed vote (must begin with a context-specific tag with a value of 0)'));
        }
        const voteVersionMultiValue = voteVersionWrapper.contains;
        if (typeof voteVersionMultiValue !== 'bigint') {
            throw (new vote_1.default('VOTE_MALFORMED_VOTE_VERSION', 'internal error: Vote version must be an Integer'));
        }
        const voteVersion = voteVersionMultiValue;
        if ((voteVersion + 1n) !== 3n) {
            throw (new vote_1.default('VOTE_INVALID_VERSION', 'internal error: Vote version must be 3'));
        }
        /**
         * Serial number
         */
        const serialMultiValue = voteContents.shift();
        if (typeof serialMultiValue !== 'bigint') {
            throw (new vote_1.default('VOTE_MALFORMED_VOTE_SERIAL', 'internal error: Vote serial number must be an Integer'));
        }
        this.serial = serialMultiValue;
        /**
         * Signature information
         */
        const signatureInfo = voteContents.shift();
        if (!Array.isArray(signatureInfo)) {
            throw (new vote_1.default('VOTE_MALFORMED_VOTE_SIGNATURE_INFORMATION', 'internal error: Vote signature information must be a Sequence'));
        }
        if (signatureInfo.length !== 1) {
            throw (new vote_1.default('VOTE_MALFORMED_VOTE_SIGNATURE_INFORMATION', 'internal error: Vote signature information must contain only 1 entry'));
        }
        const signatureOIDObject = signatureInfo[0];
        if (typeof signatureOIDObject !== 'object' || signatureOIDObject === null || !('type' in signatureOIDObject) || signatureOIDObject.type !== 'oid') {
            throw (new vote_1.default('VOTE_MALFORMED_VOTE_SIGNATURE_INFORMATION', 'internal error: Vote signature information must contain an OID'));
        }
        const signatureInfoOID = signatureOIDObject.oid;
        /**
         * Issuer information
         */
        const issuerWrapper = voteContents.shift();
        if (!Array.isArray(issuerWrapper)) {
            throw (new vote_1.default('VOTE_MALFORMED_VOTE_ISSUER_INFORMATION', 'internal error: Vote issuer must be a Sequence'));
        }
        const issuerCN = findRDN(issuerWrapper, 'commonName');
        if (issuerCN === undefined || issuerCN === null || typeof issuerCN !== 'string') {
            throw (new vote_1.default('VOTE_MALFORMED_VOTE_ISSUER_INFORMATION', 'internal error: Vote issuer must contain the common name (as a string)'));
        }
        this.issuer = account_1.default.fromPublicKeyString(issuerCN).assertAccount();
        /**
         * Validity period
         */
        const validityInfo = voteContents.shift();
        if (!Array.isArray(validityInfo)) {
            throw (new vote_1.default('VOTE_MALFORMED_VOTE_VALIDITY_INFORMATION', 'internal error: Validity information must be a sequence'));
        }
        if (validityInfo.length !== 2) {
            throw (new vote_1.default('VOTE_MALFORMED_VOTE_VALIDITY_INFORMATION', 'internal error: Validity information must contain exactly 2 elements'));
        }
        const validFrom = convertDate(validityInfo[0]);
        const validTo = convertDate(validityInfo[1]);
        this.validityFrom = validFrom;
        this.validityTo = validTo;
        /**
         * Votes must not have invalid validity periods
         */
        if (this.validityFrom.valueOf() > this.validityTo.valueOf()) {
            throw (new vote_1.default('VOTE_INVALID_VALIDITY', `Invalid validity period;  Expires on ${this.validityTo.toISOString()} but issued on ${this.validityFrom.toISOString()}`));
        }
        /**
         * The current instant
         */
        const expirationCheckMoment = this.expirationCheckMoment();
        /**
         * Votes must not be expired
         */
        const expirationCheckMomentISO = new Date(expirationCheckMoment).toISOString();
        if (expirationCheckMoment < (this.validityFrom.valueOf() - VoteLikeBase.allowedSlop)) {
            throw (new vote_1.default('VOTE_MOMENT_BEFORE_VALIDITY_FROM', `Vote was issued in the future (issued on ${validFrom.toISOString()}; moment: ${expirationCheckMomentISO})`));
        }
        /**
         * If the vote is forever viable, it is a permanent vote
         */
        if (this.validityTo.valueOf() > (expirationCheckMoment + VoteLikeBase.permanentVoteThreshold)) {
            this.$permanent = true;
        }
        /**
         * Subject
         */
        const subjectWrapper = voteContents.shift();
        if (!Array.isArray(subjectWrapper)) {
            throw (new vote_1.default('VOTE_MALFORMED_VOTE_SUBJECT_INFORMATION', 'internal error: Vote subject must be a Sequence'));
        }
        const subjectSerial = findRDN(subjectWrapper, 'serialNumber');
        if (typeof subjectSerial !== 'string') {
            throw (new vote_1.default('VOTE_MALFORMED_VOTE_SERIAL', 'internal error: Expected subject DN to contain serial number as a string'));
        }
        if (BigInt(`0x${subjectSerial}`) !== this.serial) {
            throw (new vote_1.default('VOTE_SERIAL_MISMATCH', 'internal error: Expected subject DN to contain serial number matching certificate serial number'));
        }
        /**
         * Subject Public Key, verified to be the same as the issuer
         */
        const subjectPubKeyInfo = voteContents.shift();
        if (!Array.isArray(subjectPubKeyInfo) || subjectPubKeyInfo.length !== 2) {
            throw (new vote_1.default('VOTE_MALFORMED_VOTE_SUBJECT_PUBLIC_KEY_INFORMATION', 'internal error: Expected subject public key information to be a sequence of length 2'));
        }
        const subjectPubKeyAlgoInfo = subjectPubKeyInfo[0];
        let subjectPublicKey = '';
        if (Array.isArray(subjectPubKeyAlgoInfo) && subjectPubKeyAlgoInfo.length === 2) {
            const algoRaw = subjectPubKeyAlgoInfo[1];
            if (typeof algoRaw !== 'object' || algoRaw === null || !('type' in algoRaw) || algoRaw.type !== 'oid') {
                throw (new vote_1.default('VOTE_MALFORMED_VOTE_SUBJECT_PUBLIC_KEY_INFORMATION', 'internal error: Expected subject public key information curve to be an OID'));
            }
            const subjectPubKeyAlgo = algoRaw.oid;
            const subjectPubKey = subjectPubKeyInfo[1];
            if (typeof subjectPubKey !== 'object' || subjectPubKey === null || !('type' in subjectPubKey) || subjectPubKey.type !== 'bitstring') {
                throw (new vote_1.default('VOTE_MALFORMED_VOTE_SUBJECT_PUBLIC_KEY_INFORMATION', 'internal error: Expected subject public key information to be a BitString'));
            }
            switch (subjectPubKeyAlgo) {
                case 'secp256k1':
                    subjectPublicKey = account_1.default.fromECDSASECP256K1PublicKey(subjectPubKey.value).publicKeyString.get();
                    break;
                case 'secp256r1':
                    subjectPublicKey = account_1.default.fromECDSASECP256R1PublicKey(subjectPubKey.value).publicKeyString.get();
                    break;
                case 'ed25519':
                    subjectPublicKey = account_1.default.fromED25519PublicKey(subjectPubKey.value).publicKeyString.get();
                    break;
                default:
                    throw (new vote_1.default('VOTE_MALFORMED_VOTE_SUBJECT_PUBLIC_KEY_INFORMATION', `internal error: Expected subject public key information algorithm to be EcDSA secp256k1, EcDSA secp256r1, or Ed25519, but got ${subjectPubKeyAlgo}`));
            }
        }
        /**
         * Extensions
         */
        const extensionsArea = voteContents.shift();
        if (typeof extensionsArea !== 'object' || extensionsArea === null || !('type' in extensionsArea) || extensionsArea.type !== 'context') {
            throw (new vote_1.default('VOTE_MALFORMED_VOTE_EXTENSIONS', 'internal error: Expected extensions to follow subject public key information'));
        }
        if (extensionsArea.value !== 3) {
            throw (new vote_1.default('VOTE_MALFORMED_VOTE_EXTENSIONS', `internal error: Got wrong kind of context-specific tag, expected 3 got ${extensionsArea.value}`));
        }
        const extensions = extensionsArea.contains;
        if (!Array.isArray(extensions)) {
            throw (new vote_1.default('VOTE_MALFORMED_VOTE_EXTENSIONS', 'internal error: Expected extensions to be a Sequence'));
        }
        let blocks;
        let feeAndKind;
        for (const extensionInfo of extensions) {
            if (!Array.isArray(extensionInfo)) {
                throw (new vote_1.default('VOTE_MALFORMED_VOTE_EXTENSIONS_VALUE', 'internal error: Expected each extension to be a Sequence'));
            }
            if (extensionInfo.length !== 2 && extensionInfo.length !== 3) {
                throw (new vote_1.default('VOTE_MALFORMED_VOTE_EXTENSIONS_VALUE', 'internal error: Extension information must contain 2 or 3 elements'));
            }
            const extensionOID = extensionInfo.shift();
            if (typeof extensionOID !== 'object' || extensionOID === null || !('type' in extensionOID) || extensionOID.type !== 'oid') {
                throw (new vote_1.default('VOTE_MALFORMED_VOTE_EXTENSIONS_VALUE_OID', 'internal error: Expected extension ID to be present and an OID'));
            }
            if (extensionOID.type !== 'oid') {
                throw (new vote_1.default('VOTE_MALFORMED_VOTE_EXTENSIONS_VALUE_OID', 'internal error: Expected extension ID to be an OID'));
            }
            let critical = true;
            if (extensionInfo.length === 2) {
                const criticalCheck = extensionInfo.shift();
                if (typeof criticalCheck !== 'boolean') {
                    throw (new vote_1.default('VOTE_MALFORMED_VOTE_EXTENSIONS_VALUE_CRITICAL', 'internal error: Expected critical flag to be a boolean'));
                }
                critical = criticalCheck;
            }
            const extensionData = extensionInfo.shift();
            if (!(Buffer.isBuffer(extensionData))) {
                throw (new vote_1.default('VOTE_MALFORMED_VOTE_EXTENSIONS_DATA', `internal error: ${extensionOID.oid} extensions are always Octet String`));
            }
            switch (extensionOID.oid) {
                case 'hashData':
                    blocks = blockHashesFromVote(extensionData);
                    break;
                case '1.3.6.1.4.1.62675.0.1.0':
                case 'fees': // replace with fees 1.3.6.1.4.1.62675.0.1.0
                    feeAndKind = feeFromVote(extensionData);
                    break;
                default:
                    if (critical) {
                        throw (new vote_1.default('VOTE_MALFORMED_VOTE_EXTENSIONS_VALUE_CRITICAL_TYPE', `internal error: Unknown critical extension ${extensionOID.oid}`));
                    }
            }
        }
        if (voteContents.length !== 0) {
            throw (new vote_1.default('VOTE_MALFORMED_VOTE_CONTENT_EXTRA_DATA', 'internal error: Extra data in vote certificate'));
        }
        if (!blocks || !Array.isArray(blocks)) {
            throw (new vote_1.default('VOTE_MALFORMED_VOTE_NO_BLOCKS_FOUND', 'No block hashes found within vote'));
        }
        this.blocks = blocks;
        if (feeAndKind !== undefined) {
            if (this.$permanent) {
                throw (new vote_1.default('VOTE_MALFORMED_FEES_IN_PERMANENT_VOTE', 'Permanent Vote cannot have fees'));
            }
            // Get the expected quote value from any child instances and compare
            if (feeAndKind.quote !== this.getClass().expectedQuoteValue) {
                throw (new vote_1.default('VOTE_MALFORMED_FEES_QUOTE_INVALID', `internal error: fee quote mismatch found ${feeAndKind.quote} - expected ${this.getClass().expectedQuoteValue}`));
            }
            this.fee = feeAndKind.fee;
            this.quote = feeAndKind.quote;
        }
        /**
         * Get the signature data
         */
        const voteSignatureInfoWrapper = voteWrapper.shift();
        if (!Array.isArray(voteSignatureInfoWrapper)) {
            throw (new vote_1.default('VOTE_MALFORMED_VOTE_SIGNATURE_INFORMATION', 'internal error: Vote signature information must be a sequence'));
        }
        if (voteSignatureInfoWrapper.length !== 1) {
            throw (new vote_1.default('VOTE_MALFORMED_VOTE_SIGNATURE_INFORMATION', 'internal error: Vote signature information should contain exactly 1 item'));
        }
        const voteSignatureInfo = voteSignatureInfoWrapper[0];
        if (voteSignatureInfo === undefined || voteSignatureInfo === null) {
            throw (new vote_1.default('VOTE_MALFORMED_VOTE_SIGNATURE_INFORMATION', 'internal error: Vote signature should contain an OID'));
        }
        if (typeof voteSignatureInfo !== 'object' || voteSignatureInfo === null || !('type' in voteSignatureInfo) || voteSignatureInfo.type !== 'oid') {
            throw (new vote_1.default('VOTE_MALFORMED_VOTE_SIGNATURE_INFORMATION', 'internal error: Vote signature should contain an OID'));
        }
        let toVerify;
        const voteSignatureInfoOID = voteSignatureInfo.oid;
        /**
         * Ensure the certificate and the wrapper agree on the signature method being used
         */
        if (voteSignatureInfoOID !== signatureInfoOID) {
            throw (new vote_1.default('VOTE_MALFORMED_VOTE_SIGNATURE_SCHEME_DOES_NOT_MATCH_WRAPPER', 'Signed signature information differs from wrapper'));
        }
        switch (voteSignatureInfoOID) {
            case `${hash_1.Hash.functionName}WithEcDSA`:
                if (this.issuer.keyType !== account_1.AccountKeyAlgorithm.ECDSA_SECP256K1 && this.issuer.keyType !== account_1.AccountKeyAlgorithm.ECDSA_SECP256R1) {
                    throw (new vote_1.default('VOTE_MALFORMED_VOTE_SIGNATURE_SCHEME_DOES_NOT_MATCH_ISSUER', 'internal error: Signature scheme does not match issuer ECDSA curve (EcDSA)'));
                }
                // For now we just verify that the vote was self signed
                if (this.issuer.publicKeyString.get() !== subjectPublicKey) {
                    throw (new vote_1.default('VOTE_MALFORMED_VOTE_SIGNATURE_SCHEME_DOES_NOT_MATCH_ISSUER', 'internal error: Signature scheme does not match issuer ECDSA curve (EcDSA)'));
                }
                toVerify = (0, hash_1.Hash)(Buffer.from(tbsCertificate));
                break;
            case 'ed25519':
                if (this.issuer.keyType !== account_1.AccountKeyAlgorithm.ED25519) {
                    throw (new vote_1.default('VOTE_MALFORMED_VOTE_SIGNATURE_SCHEME_DOES_NOT_MATCH_ISSUER', 'internal error: Signature scheme does not match issuer (Ed25519)'));
                }
                toVerify = tbsCertificate;
                break;
            default:
                throw (new vote_1.default('VOTE_MALFORMED_VOTE_SIGNATURE_UNSUPPORTED_SCHEME', `Unsupported signature scheme ${voteSignatureInfoOID}`));
        }
        /**
         * Get the signature
         */
        const voteSignature = voteWrapper.shift();
        if (typeof voteSignature !== 'object' || voteSignature === null || !('type' in voteSignature) || !('value' in voteSignature)) {
            throw (new vote_1.default('VOTE_MALFORMED_VOTE_SIGNATURE_VALUE', 'internal error: Vote signature must be provided'));
        }
        if (voteSignature.type !== 'bitstring' || !Buffer.isBuffer(voteSignature.value)) {
            throw (new vote_1.default('VOTE_MALFORMED_VOTE_SIGNATURE_VALUE', 'internal error: Vote signature must be a BitString with a buffer value'));
        }
        const isValid = this.issuer.verify(toVerify, voteSignature.value, {
            raw: true,
            forCert: true
        });
        if (isValid !== true) {
            throw (new vote_1.default('VOTE_SIGNATURE_INVALID', 'Vote signature could not be verified'));
        }
        this.signature = (0, helper_1.bufferToArrayBuffer)(voteSignature.value);
        /*
         * Set UID and its hash
         */
        this.$uid = `ID=${this.issuer.publicKeyString.get()}/Serial=${this.serial}`;
        this.$id = (new buffer_1.BufferStorage((0, hash_1.Hash)(Buffer.from(this.$uid)), 32)).toString('hex').toUpperCase();
        /**
        * The current instant
        */
        let now;
        if (options.now) {
            now = options.now.valueOf();
        }
        else {
            now = Date.now();
        }
        /**
         * If the vote is forever viable, it is a permanent vote
         */
        if (this.validityTo.valueOf() > (now + (100 /* y */ * 365 /* d */ * 86400 /* s */ * 1000 /* ms */))) {
            this.$permanent = true;
        }
    }
    toBytes() {
        return (__classPrivateFieldGet(this, _VoteLikeBase_vote, "f"));
    }
    get hash() {
        if (!__classPrivateFieldGet(this, _VoteLikeBase__hash, "f")) {
            __classPrivateFieldSet(this, _VoteLikeBase__hash, new VoteHash((0, hash_1.Hash)(Buffer.from(this.toBytes()))), "f");
        }
        return (__classPrivateFieldGet(this, _VoteLikeBase__hash, "f"));
    }
    get blocksHash() {
        if (!__classPrivateFieldGet(this, _VoteLikeBase__blocksHash, "f")) {
            __classPrivateFieldSet(this, _VoteLikeBase__blocksHash, VoteBlockHash.fromVote(this), "f");
        }
        return (__classPrivateFieldGet(this, _VoteLikeBase__blocksHash, "f"));
    }
    toString() {
        return (Buffer.from(this.toBytes()).toString('base64'));
    }
    toJSON(options) {
        const additionalFields = {};
        if (options?.addBinary) {
            additionalFields['$binary'] = Buffer.from(this.toBytes()).toString('base64');
        }
        if (this.fee !== undefined) {
            additionalFields['fee'] = this.fee;
        }
        if (this.quote !== undefined) {
            additionalFields['quote'] = this.quote;
        }
        return ({
            issuer: this.issuer,
            serial: this.serial,
            blocks: this.blocks,
            validityFrom: this.validityFrom,
            validityTo: this.validityTo,
            signature: this.signature,
            $trusted: this.$trusted,
            $permanent: this.$permanent,
            $uid: this.$uid,
            $id: this.$id,
            ...additionalFields
        });
    }
    expirationCheckMoment() {
        let now;
        if (__classPrivateFieldGet(this, _VoteLikeBase_options, "f").now) {
            now = __classPrivateFieldGet(this, _VoteLikeBase_options, "f").now.valueOf();
        }
        else {
            now = Date.now();
        }
        return (now);
    }
    get expired() {
        const now = this.expirationCheckMoment();
        const from = this.validityFrom.valueOf();
        const to = this.validityTo.valueOf();
        if ((now + VoteLikeBase.allowedSlop) < from || (now - VoteLikeBase.allowedSlop) > to) {
            return (true);
        }
        return (false);
    }
}
_VoteLikeBase_vote = new WeakMap(), _VoteLikeBase_options = new WeakMap(), _VoteLikeBase__hash = new WeakMap(), _VoteLikeBase__blocksHash = new WeakMap();
VoteLikeBase.expectedQuoteValue = false;
VoteLikeBase.allowedSlop = 60 /* s */ * 1000 /* ms */;
VoteLikeBase.permanentVoteThreshold = 100 /* y */ * 365 /* d */ * 86400 /* s */ * 1000 /* ms */;
VoteLikeBase.VoteBlocksHash = VoteBlockHash;
VoteLikeBase.isInstance = (0, helper_1.checkableGenerator)(VoteLikeBase);
class PossiblyExpiredVote extends VoteLikeBase {
    constructor(vote, options = {}) {
        super(vote, options);
        if (this.quote === true) {
            throw (new vote_1.default('VOTE_FEE_IS_QUOTE', `Tried to construct a vote but fee kind is QUOTE`));
        }
    }
}
exports.PossiblyExpiredVote = PossiblyExpiredVote;
PossiblyExpiredVote.isInstance = (0, helper_1.checkableGenerator)(PossiblyExpiredVote);
/**
 * A vote is a certificate issued indicating that the issuer "vouches" for the
 * blocks specified will fit into the ledger of the operator/issuer.
 */
class Vote extends PossiblyExpiredVote {
    constructor(vote, options = {}) {
        super(vote, options);
        // We add this so both classes have different signatures
        this.possiblyExpired = false;
        if (this.expired) {
            const expirationCheckMomentISO = new Date(this.expirationCheckMoment()).toISOString();
            throw (new vote_1.default('VOTE_EXPIRED', `Vote is expired (expired on ${this.validityTo.toISOString()}; issued on ${this.validityFrom.toISOString()}; moment: ${expirationCheckMomentISO})`));
        }
    }
}
exports.Vote = Vote;
Vote.isInstance = (0, helper_1.checkableGenerator)(Vote);
/**
 * A VoteQuote is a certificate issued indicating what the issuer will charge for fees
 */
class VoteQuote extends VoteLikeBase {
    constructor(vote, options = {}) {
        super(vote, options);
        // We add this so both classes have different signatures
        this.isVoteQuote = true;
        if (this.expired) {
            const expirationCheckMomentISO = new Date(this.expirationCheckMoment()).toISOString();
            throw (new vote_1.default('VOTE_EXPIRED', `VoteQuote is expired (expired on ${this.validityTo.toISOString()}; issued on ${this.validityFrom.toISOString()}; moment: ${expirationCheckMomentISO})`));
        }
        if (!this.quote) {
            throw (new vote_1.default('VOTE_FEE_NOT_QUOTE', `Tried to construct a quote but fee kind is note QUOTE`));
        }
    }
}
exports.VoteQuote = VoteQuote;
VoteQuote.expectedQuoteValue = true;
VoteQuote.isInstance = (0, helper_1.checkableGenerator)(VoteQuote);
/**
 * A vote staple is a distributable block consisting of one or more blocks
 * and one or more votes.
 */
class VoteStapleHash extends buffer_1.BufferStorage {
    get hashFunctionName() {
        return (hash_1.Hash.functionName);
    }
    constructor(stapleHash) {
        super(stapleHash, 32);
        this.storageKind = 'VoteStapleHash';
    }
}
VoteStapleHash.isInstance = (0, helper_1.checkableGenerator)(VoteStapleHash);
class VoteBlockBundle {
    /** @internal */
    static _Testing() {
        return ({
            fromVotesAndBlocksRaw: (votes, blocks, voteOptions = {}) => {
                const encoded = (0, asn1_1.JStoASN1)([
                    blocks.map(function (item) {
                        return (Buffer.from(item.toBytes()));
                    }),
                    votes.map(function (item) {
                        return (Buffer.from(item.toBytes()));
                    })
                ]);
                const buffer = Buffer.from(encoded.toBER(false));
                const compressedBuffer = zlib_1.default.deflateSync(buffer);
                return (new this(compressedBuffer, voteOptions));
            },
            voteBlockHash: VoteBlockHash
        });
    }
    /**
     * Construct a new vote bundle from votes and blocks
     */
    static fromVotesAndBlocks(votes, blocks, voteOptions = {}) {
        if (votes.length < 1) {
            throw (new vote_1.default('VOTE_STAPLE_INVALID_CONSTRUCTION', 'Vote Staples must contain at least one vote'));
        }
        const representativeVote = votes[0];
        const blockHashOrdering = Object.fromEntries(representativeVote.blocks.map(function (blockHash, index) {
            return ([blockHash.toString(), index]);
        }));
        const blocksOrdered = [...blocks].sort(function (a, b) {
            return (blockHashOrdering[a.hash.toString()] - blockHashOrdering[b.hash.toString()]);
        });
        const votesOrdered = [...votes].sort(function (a, b) {
            const aHash = BigInt(`0x${a.hash.toString('hex')}`);
            const bHash = BigInt(`0x${b.hash.toString('hex')}`);
            if (aHash < bHash) {
                return (-1);
            }
            else if (aHash > bHash) {
                return (1);
            }
            else {
                return (0);
            }
        });
        const encoded = (0, asn1_1.JStoASN1)([
            blocksOrdered.map(function (item) {
                return (Buffer.from(item.toBytes()));
            }),
            votesOrdered.map(function (item) {
                return (Buffer.from(item.toBytes()));
            })
        ]);
        const buffer = Buffer.from(encoded.toBER(false));
        const compressedBuffer = zlib_1.default.deflateSync(buffer);
        return (new this(compressedBuffer, voteOptions));
    }
    /**
     * Convert a list of Votes and Blocks into a VoteStaple
     * This is slightly different from VoteStaple.fromVotesAndBlocks in
     * that it will filter the supplied votes to only include those that
     * are permanent if any permanent votes are present, otherwise only
     * temporary votes will be included
     *
     * Additionally, it will filter out any votes that are expired
     */
    static fromVotesAndBlocksWithFiltering(votes, blocks, opts) {
        const permVotes = [];
        const tempVotes = [];
        for (const vote of votes) {
            if (vote.expired) {
                continue;
            }
            let validatedVote;
            if (Vote.isInstance(vote)) {
                validatedVote = vote;
            }
            else {
                validatedVote = new Vote(vote);
            }
            if (vote.$permanent) {
                permVotes.push(validatedVote);
            }
            else {
                tempVotes.push(validatedVote);
            }
        }
        let sameKindVotes = permVotes;
        if (permVotes.length === 0) {
            sameKindVotes = tempVotes;
        }
        if (sameKindVotes.length === 0) {
            return (null);
        }
        if (blocks.length === 0) {
            return (null);
        }
        const retval = this.fromVotesAndBlocks(sameKindVotes, blocks, opts);
        return (retval);
    }
    static fromVotesAndBlocksToHashMap(votes, blocks, opts) {
        const voteObjects = {};
        const blockObjects = {};
        const blockHashToVoteStapleID = new Map();
        /**
         * Process each vote and group them by Vote Staple
         */
        for (const vote of votes) {
            const voteStapleID = vote.blocksHash.toString();
            /* Keep track of which blocks we need to process and to which group they belong */
            for (const blockHash of vote.blocks) {
                const blockHashStr = blockHash.toString();
                blockHashToVoteStapleID.set(blockHashStr, voteStapleID);
            }
            /* Group votes by Vote Staple */
            if (voteObjects[voteStapleID] === undefined) {
                voteObjects[voteStapleID] = [];
                blockObjects[voteStapleID] = [];
            }
            voteObjects[voteStapleID].push(vote);
        }
        /* Group blocks by Vote Staple */
        for (const block of blocks) {
            const blocksHash = blockHashToVoteStapleID.get(block.hash.toString());
            if (blocksHash === undefined) {
                /* Ignore blocks for which no possible votes exist */
                continue;
            }
            blockObjects[blocksHash].push(block);
        }
        /**
         * Get list of VoteBlockHashes to return
         */
        let voteStapleIDsToReturn = [];
        if (opts.voteBlockHashes !== undefined) {
            voteStapleIDsToReturn = opts.voteBlockHashes;
        }
        else {
            voteStapleIDsToReturn = Object.keys(voteObjects).map(function (blockHash) {
                return (new VoteBlockHash(blockHash));
            });
        }
        /* Construct the final VoteStaples */
        const retval = new Vote.VoteBlocksHash.Map();
        for (const voteStapleID of voteStapleIDsToReturn) {
            const voteStapleIDStr = voteStapleID.toString();
            const votes = voteObjects[voteStapleIDStr];
            const blocks = blockObjects[voteStapleIDStr];
            if (votes === undefined || blocks === undefined) {
                retval.set(voteStapleID, null);
                continue;
            }
            const voteStaple = this.fromVotesAndBlocksWithFiltering(votes, blocks, opts);
            retval.set(voteStapleID, voteStaple);
        }
        return (retval);
    }
    static isValidJSON(staple) {
        if (!staple.votes || !staple.blocks) {
            return (false);
        }
        const { votes, blocks } = staple;
        if (!Array.isArray(votes) || !Array.isArray(blocks)) {
            return (false);
        }
        for (const vote of votes) {
            if (!Vote.isValidJSON(vote)) {
                return (false);
            }
        }
        for (const block of blocks) {
            if (!block_1.Block.isValidJSON(block)) {
                return (false);
            }
        }
        return (true);
    }
    static fromJSON(staple, voteOptions = {}) {
        const votes = staple.votes.map(vote => new Vote(vote));
        const blocks = staple.blocks.map(block => new block_1.Block(block));
        const voteStaple = this.fromVotesAndBlocks(votes, blocks, voteOptions);
        return (voteStaple);
    }
    /**
     * Construct a new staple from a message buffer
     */
    constructor(votesStapled, voteOptions = {}) {
        _VoteBlockBundle_value.set(this, void 0);
        _VoteBlockBundle_valueCompressed.set(this, void 0);
        _VoteBlockBundle__hash.set(this, void 0);
        _VoteBlockBundle__blocksHash.set(this, void 0);
        if (typeof votesStapled === 'string') {
            votesStapled = Buffer.from(votesStapled, 'base64');
        }
        if (VoteBlockBundle.isInstance(votesStapled)) {
            votesStapled = votesStapled.toBytes(true);
        }
        if (Buffer.isBuffer(votesStapled)) {
            votesStapled = (0, helper_1.bufferToArrayBuffer)(votesStapled);
        }
        if (!(util_1.types.isArrayBuffer(votesStapled))) {
            if (votesStapled instanceof VoteBlockBundle) {
                votesStapled = votesStapled.toBytes(true);
            }
            else if (VoteBlockBundle.isValidJSON(votesStapled)) {
                votesStapled = VoteBlockBundle.fromJSON(votesStapled, voteOptions).toBytes(true);
            }
            else {
                throw (new vote_1.default('VOTE_STAPLE_INVALID_CONSTRUCTION', 'internal error: votesStapled must be an ArrayBuffer'));
            }
        }
        /**
         * Decompress the buffer
         */
        try {
            __classPrivateFieldSet(this, _VoteBlockBundle_value, (0, helper_1.bufferToArrayBuffer)(zlib_1.default.inflateSync(Buffer.from(votesStapled))), "f");
            __classPrivateFieldSet(this, _VoteBlockBundle_valueCompressed, votesStapled, "f");
        }
        catch {
            __classPrivateFieldSet(this, _VoteBlockBundle_value, votesStapled, "f");
        }
        /**
         * Parse BER encoded data into objects
         */
        const data = (0, asn1_1.ASN1toJS)(__classPrivateFieldGet(this, _VoteBlockBundle_value, "f"));
        if (!Array.isArray(data)) {
            throw (new vote_1.default('VOTE_MALFORMED_STAPLE', 'Vote staple must be a Sequence'));
        }
        if (data.length !== 2) {
            throw (new vote_1.default('VOTE_MALFORMED_STAPLE', 'Vote staple must contain exactly 2 elements (votes, and blocks)'));
        }
        const [blocksRaw, votesRaw] = data;
        if (!Array.isArray(blocksRaw) || !Array.isArray(votesRaw)) {
            throw (new vote_1.default('VOTE_MALFORMED_STAPLE', 'Vote staple must contain exactly 2 elements (votes, and blocks)'));
        }
        if (blocksRaw.length < 1) {
            throw (new vote_1.default('VOTE_MALFORMED_STAPLE_BLOCKS_AT_LEAST_ONE', 'There must be at least 1 block'));
        }
        /**
         * List of blocks
         */
        const blocksUnsorted = blocksRaw.map(function (blockData) {
            if (!(Buffer.isBuffer(blockData))) {
                throw (new vote_1.default('VOTE_MALFORMED_STAPLE_BLOCKS', 'Each block must be an Octet String'));
            }
            return (new block_1.Block(blockData));
        });
        if (votesRaw.length < 1) {
            throw (new vote_1.default('VOTE_MALFORMED_STAPLE_VOTES_AT_LEAST_ONE', 'There must be at least one vote'));
        }
        /**
         * Get a list of every block hash
         */
        const blockHashes = {};
        for (const block of blocksUnsorted) {
            blockHashes[block.hash.toString()] = block;
        }
        /*
         * Ensure blocks are sorted the same way as the vote
         */
        this.votes = votesRaw.map(function (voteData) {
            if (!(Buffer.isBuffer(voteData))) {
                throw (new vote_1.default('VOTE_MALFORMED_STAPLE_VOTES', 'Each vote must be an Octet String'));
            }
            const vote = new Vote(voteData, voteOptions);
            if (vote.blocks.length !== blocksUnsorted.length) {
                throw (new vote_1.default('VOTE_STAPLE_ALL_VOTES_MUST_HAVE_SAME_BLOCKS_COUNT', `Each vote must vote on the exact set of blocks being stapled (same number) (vote: ${vote.blocks.length}; blocks: ${blocksUnsorted.length})`));
            }
            for (const voteBlockHash of vote.blocks) {
                const voteBlockHashCheck = blockHashes[voteBlockHash.toString()];
                if (voteBlockHashCheck === undefined) {
                    throw (new vote_1.default('VOTE_STAPLE_ALL_VOTES_MUST_HAVE_SAME_BLOCKS_MISSING', `Each vote must be on the exact set of blocks being stapled (missing ${voteBlockHash.toString()})`));
                }
            }
            return (vote);
        });
        /**
         * Order blocks by the vote ordering
         */
        this.blocks = this.votes[0].blocks.map(function (blockHash) {
            return (blockHashes[blockHash.toString()]);
        });
        /**
         * Ensure every vote has the block hashes in the same order
         */
        for (const vote of this.votes) {
            for (let blockHashIndex = 0; blockHashIndex < vote.blocks.length; blockHashIndex++) {
                const voteBlockHash = vote.blocks[blockHashIndex];
                const stapleBlockHash = this.blocks[blockHashIndex];
                if (voteBlockHash.toString() !== stapleBlockHash.hash.toString()) {
                    throw (new vote_1.default('VOTE_STAPLE_ALL_VOTES_MUST_HAVE_SAME_BLOCKS_ORDER', 'All votes must list blocks in the same order'));
                }
            }
        }
    }
    /**
     * Get the serialized version
     */
    toBytes(uncompressed) {
        if (uncompressed) {
            return (__classPrivateFieldGet(this, _VoteBlockBundle_value, "f"));
        }
        if (!__classPrivateFieldGet(this, _VoteBlockBundle_valueCompressed, "f")) {
            __classPrivateFieldSet(this, _VoteBlockBundle_valueCompressed, (0, helper_1.bufferToArrayBuffer)(zlib_1.default.deflateSync(Buffer.from(__classPrivateFieldGet(this, _VoteBlockBundle_value, "f")))), "f");
        }
        return (__classPrivateFieldGet(this, _VoteBlockBundle_valueCompressed, "f"));
    }
    toString() {
        return (Buffer.from(this.toBytes()).toString('base64'));
    }
    /**
     * Hash of the Vote Staple -- this is the hash of the data in the
     * canonical form of the staple, which may be different from
     * the hash of the data passed into the this object.
     */
    get hash() {
        if (!__classPrivateFieldGet(this, _VoteBlockBundle__hash, "f")) {
            const canonicalVoteStaple = VoteBlockBundle.fromVotesAndBlocks(this.votes, this.blocks);
            const hash = (0, hash_1.Hash)(Buffer.from(canonicalVoteStaple.toBytes(true)));
            __classPrivateFieldSet(this, _VoteBlockBundle__hash, new VoteStapleHash(hash), "f");
        }
        return (__classPrivateFieldGet(this, _VoteBlockBundle__hash, "f"));
    }
    /**
     * Get the hash of the blockhashes in the staple -- this is a stable ID
     * for the staple regardless of which votes are included in the staple.
     */
    get blocksHash() {
        if (!__classPrivateFieldGet(this, _VoteBlockBundle__blocksHash, "f")) {
            __classPrivateFieldSet(this, _VoteBlockBundle__blocksHash, VoteBlockHash.fromVoteStaple(this), "f");
        }
        return (__classPrivateFieldGet(this, _VoteBlockBundle__blocksHash, "f"));
    }
    /**
     * Get the timestamp of the staple
     *
     * This is the average of the timestamps of the votes, unless a
     * particular account is specified then that timestamp is used
     * if it issued a vote in the staple.
     */
    timestamp(preferRep) {
        /*
         * Compute the nominal timestamp of the vote staple by
         * averaging the timestamps of the votes.
         */
        let voteTimestampsMin = Number.MAX_SAFE_INTEGER;
        for (const vote of this.votes) {
            const voteTime = vote.validityFrom;
            if (preferRep?.comparePublicKey(vote.issuer)) {
                return (voteTime);
            }
            const voteTimestamp = voteTime.valueOf();
            if (voteTimestamp < voteTimestampsMin) {
                voteTimestampsMin = voteTimestamp;
            }
        }
        let voteTimestampsAccumulator = 0;
        let voteTimestampsCount = 0;
        for (const vote of this.votes) {
            const voteTimestamp = vote.validityFrom.valueOf();
            voteTimestampsAccumulator += voteTimestamp - voteTimestampsMin;
            voteTimestampsCount++;
        }
        const timestampValue = voteTimestampsMin + Math.floor(voteTimestampsAccumulator / voteTimestampsCount);
        const timestamp = new Date(timestampValue);
        return (timestamp);
    }
    toJSON(options) {
        const additionalFields = {};
        if (options?.addBinary) {
            additionalFields['$binary'] = Buffer.from(this.toBytes()).toString('base64');
        }
        return ({
            votes: this.votes.map(function (vote) {
                return (vote.toJSON());
            }),
            blocks: this.blocks.map(function (block) {
                return (block.toJSON());
            }),
            ...additionalFields
        });
    }
}
exports.VoteBlockBundle = VoteBlockBundle;
_VoteBlockBundle_value = new WeakMap(), _VoteBlockBundle_valueCompressed = new WeakMap(), _VoteBlockBundle__hash = new WeakMap(), _VoteBlockBundle__blocksHash = new WeakMap();
VoteBlockBundle.VoteBlockHash = VoteBlockHash;
VoteBlockBundle.isInstance = (0, helper_1.checkableGenerator)(VoteBlockBundle);
class VoteStaple extends VoteBlockBundle {
    constructor(votesStapled, voteOptions = {}) {
        super(votesStapled, voteOptions);
        /**
         * Ensure no representative has more than 1 vote in the bundle
         * and that every vote has the same level of permanence
         */
        const seenReps = new account_1.default.Set();
        let votesPermanence = undefined;
        for (const vote of this.votes) {
            if (seenReps.has(vote.issuer)) {
                throw (new vote_1.default('VOTE_STAPLE_DUPLICATE_VOTE_ISSUER', `Unable to parse vote information since account ${vote.issuer.publicKeyString.get()} has voted more than once`));
            }
            seenReps.add(vote.issuer);
            if (votesPermanence === undefined) {
                votesPermanence = vote.$permanent;
            }
            if (vote.$permanent !== votesPermanence) {
                throw (new vote_1.default('VOTE_STAPLE_PERMANENCE_MISMATCH', `Only votes with permanent set to ${votesPermanence} are permissible in a bundle, however we found a vote that expires on ${vote.validityTo.toISOString()}`));
            }
        }
    }
}
exports.VoteStaple = VoteStaple;
VoteStaple.isInstance = (0, helper_1.checkableGenerator)(VoteStaple);
class BaseVoteBuilder {
    constructor(account, blocks = [], options) {
        _BaseVoteBuilder_account.set(this, void 0);
        _BaseVoteBuilder_blocks.set(this, void 0);
        _BaseVoteBuilder_fee.set(this, undefined);
        this.quote = false;
        if (!account_1.default.isInstance(account)) {
            throw (new vote_1.default('VOTE_BUILDER_INVALID_CONSTRUCTION', 'internal error: account must be an Account'));
        }
        __classPrivateFieldSet(this, _BaseVoteBuilder_account, account, "f");
        __classPrivateFieldSet(this, _BaseVoteBuilder_blocks, [], "f");
        __classPrivateFieldSet(this, _BaseVoteBuilder_fee, options?.fee, "f");
        this.addBlocks(blocks);
    }
    addBlocks(blocks) {
        for (const block of blocks) {
            if (block_1.Block.isInstance(block)) {
                __classPrivateFieldGet(this, _BaseVoteBuilder_blocks, "f").push(block.hash);
                continue;
            }
            if (typeof block === 'string') {
                __classPrivateFieldGet(this, _BaseVoteBuilder_blocks, "f").push(new block_1.BlockHash(block));
                continue;
            }
            if (!block_1.BlockHash.isInstance(block)) {
                throw (new vote_1.default('VOTE_BUILDER_INVALID_BLOCK_TYPE', 'internal error: block must be Block, BlockHash, or string'));
            }
            __classPrivateFieldGet(this, _BaseVoteBuilder_blocks, "f").push(block);
        }
    }
    addBlock(block) {
        this.addBlocks([block]);
    }
    addFee(feeInput) {
        const fee = { amount: BigInt(feeInput.amount) };
        const payTo = account_1.default.toAccount(feeInput.payTo);
        if (payTo !== undefined) {
            if (payTo.isStorage()) {
                fee.payTo = payTo;
            }
            else {
                fee.payTo = payTo.assertAccount();
            }
        }
        const token = account_1.default.toAccount(feeInput.token);
        if (token !== undefined) {
            if (token.isToken()) {
                fee.token = token;
            }
            else {
                throw (new vote_1.default('VOTE_MALFORMED_FEES_TOKEN_NOT_TOKEN', 'Fee Token should be of type TOKEN'));
            }
        }
        __classPrivateFieldSet(this, _BaseVoteBuilder_fee, fee, "f");
    }
    generateVoteData(serial, validTo, validFrom) {
        /**
         * Signature algorithm identifier
         */
        let signatureInfoOID;
        /**
         * Whether or not to hash the data we are signing
         */
        let hashData = false;
        switch (__classPrivateFieldGet(this, _BaseVoteBuilder_account, "f").keyType) {
            case account_1.AccountKeyAlgorithm.ECDSA_SECP256K1:
            case account_1.AccountKeyAlgorithm.ECDSA_SECP256R1:
                {
                    /*
                     * Use the default hashing function
                     * throughout the application
                     */
                    const hashFunctionName = hash_1.Hash.functionName;
                    signatureInfoOID = `${hashFunctionName}WithEcDSA`;
                    hashData = true;
                }
                break;
            case account_1.AccountKeyAlgorithm.ED25519:
                /* Ed25519 data does not get hashed */
                signatureInfoOID = 'ed25519';
                hashData = false;
                break;
            default:
                throw (new Error('internal error: Unsupported key type'));
                /* We do not sign with identifier accounts */
                break;
        }
        /** Public Key */
        const publicKey = __classPrivateFieldGet(this, _BaseVoteBuilder_account, "f").publicKey.ASN1.getASN1();
        /** Signature Information */
        const signatureInfo = [
            { type: 'oid', oid: signatureInfoOID }
        ];
        let feeExtension = undefined;
        if (__classPrivateFieldGet(this, _BaseVoteBuilder_fee, "f") !== undefined) {
            /** Amount for this vote */
            const feeData = [this.quote, __classPrivateFieldGet(this, _BaseVoteBuilder_fee, "f").amount];
            /** Account to pay the fee too */
            const payToPublicKey = __classPrivateFieldGet(this, _BaseVoteBuilder_fee, "f").payTo?.publicKeyAndType;
            if (payToPublicKey !== undefined) {
                feeData.push({ type: 'context', value: 0, kind: 'implicit', contains: payToPublicKey });
            }
            /** Token in which to pay the fee */
            const tokenPublicKey = __classPrivateFieldGet(this, _BaseVoteBuilder_fee, "f").token?.publicKeyAndType;
            if (tokenPublicKey !== undefined) {
                feeData.push({ type: 'context', value: 1, kind: 'implicit', contains: tokenPublicKey });
            }
            feeExtension = [
                { type: 'oid', oid: '1.3.6.1.4.1.62675.0.1.0' }, // replace with 'fees' - 1.3.6.1.4.1.62675.0.1.0
                true,
                Buffer.from((0, asn1_1.JStoASN1)({
                    type: 'context',
                    value: 0,
                    kind: 'explicit',
                    contains: feeData
                }).toBER(false))
            ];
        }
        /*
         * Certificate to be signed
         */
        const tbsCertificate = [
            /** Version */
            {
                type: 'context',
                value: 0,
                kind: 'explicit',
                contains: 2n
            },
            /** Serial Number */
            serial,
            signatureInfo,
            /** Issuer */
            [
                {
                    type: 'set',
                    name: {
                        type: 'oid',
                        oid: 'commonName'
                    },
                    value: { type: 'string', kind: 'utf8', value: __classPrivateFieldGet(this, _BaseVoteBuilder_account, "f").publicKeyString.get() }
                }
            ],
            /** Validity */
            [
                { type: 'date', kind: 'general', date: validFrom },
                { type: 'date', kind: 'general', date: validTo }
            ],
            /** Subject */
            [
                {
                    type: 'set',
                    name: {
                        type: 'oid',
                        oid: 'serialNumber'
                    },
                    value: { type: 'string', kind: 'utf8', value: serial.toString(16) }
                }
            ],
            /**
             * Subject Public Key and Key Description
             *
             * The subject of this certificate is really the data,
             * so we can put something much smaller here to save
             * space XXX:TODO
             *
             * For now we just put the issuer public key for
             * testing, but the issuer public key is fully
             * encoded in the commonName attribute of the
             * issuer DN.
             */
            publicKey,
            /** Extensions */
            {
                type: 'context',
                value: 3,
                kind: 'explicit',
                contains: [
                    /** Extension: Hash data */
                    [
                        { type: 'oid', oid: 'hashData' /* XXX:TODO: There may be a better extension to use here */ },
                        true,
                        Buffer.from((0, asn1_1.JStoASN1)({
                            type: 'context',
                            value: 0,
                            kind: 'explicit',
                            contains: [
                                /** Hash algorithm used to hash blocks */
                                { type: 'oid', oid: hash_1.Hash.functionName },
                                /** List of block hashes */
                                __classPrivateFieldGet(this, _BaseVoteBuilder_blocks, "f").map(function (blockhash) {
                                    return (blockhash.getBuffer());
                                })
                            ]
                        }).toBER(false))
                    ],
                    ...(feeExtension ? [feeExtension] : [])
                ]
            }
        ];
        let toSign;
        const tbsCertificateDER = Buffer.from((0, asn1_1.JStoASN1)(tbsCertificate).toBER(false));
        if (hashData) {
            toSign = (0, hash_1.Hash)(tbsCertificateDER);
        }
        else {
            toSign = tbsCertificateDER;
        }
        return ({
            voteData: toSign,
            tbsCertificate: tbsCertificate,
            signatureInfo: signatureInfo
        });
    }
    createVote(voteData, tbsCertificate, signatureInfo, signature) {
        /**
         * Double-check that the signature we just created is valid for the data
         */
        const verification = __classPrivateFieldGet(this, _BaseVoteBuilder_account, "f").verify(voteData, signature, {
            raw: true,
            forCert: true
        });
        if (!verification) {
            throw (new vote_1.default('VOTE_SIGNATURE_INVALID', 'internal error: Verification of signature failed'));
        }
        /**
         * Entire certificate structure
         */
        const certificate = (0, asn1_1.JStoASN1)([
            tbsCertificate,
            signatureInfo,
            { 'type': 'bitstring', value: signature.getBuffer() }
        ]);
        /**
         * Vote: A DER-encoded certificate
         */
        const vote = certificate.toBER(false);
        return (vote);
    }
    async generate(serial, validTo, validFrom) {
        if (validFrom === undefined) {
            validFrom = new Date();
        }
        if (typeof serial !== 'bigint') {
            throw (new vote_1.default('VOTE_BUILDER_INVALID_SERIAL', `internal error: serial must be a bigint, instead got ${serial}`));
        }
        if (validTo === null && __classPrivateFieldGet(this, _BaseVoteBuilder_fee, "f") !== undefined) {
            throw (new vote_1.default('VOTE_MALFORMED_FEES_IN_PERMANENT_VOTE', 'internal error: permanent votes should not have fees'));
        }
        if (validTo === null) {
            /**
             * Issue a permanent vote
             */
            validTo = new Date();
            validTo.setUTCFullYear(validTo.getUTCFullYear() + 1000, 12, 31);
            validTo.setUTCHours(0, 0, 0, 0);
        }
        if (!(util_1.types.isDate(validFrom)) || !(util_1.types.isDate(validTo))) {
            throw (new vote_1.default('VOTE_BUILDER_INVALID_VALID_TO_FROM', 'internal error: validFrom must be Date'));
        }
        if (this.quote && __classPrivateFieldGet(this, _BaseVoteBuilder_fee, "f") === undefined) {
            throw (new vote_1.default('VOTE_FEE_QUOTE_MISSING_FEES', 'internal error: requested quote but no fees provided'));
        }
        const { voteData, tbsCertificate, signatureInfo } = this.generateVoteData(serial, validTo, validFrom);
        const signature = await __classPrivateFieldGet(this, _BaseVoteBuilder_account, "f").sign(voteData, {
            raw: true,
            forCert: true
        });
        const voteLike = this.createVote(voteData, tbsCertificate, signatureInfo, signature);
        return (voteLike);
    }
}
exports.BaseVoteBuilder = BaseVoteBuilder;
_BaseVoteBuilder_account = new WeakMap(), _BaseVoteBuilder_blocks = new WeakMap(), _BaseVoteBuilder_fee = new WeakMap();
BaseVoteBuilder.isInstance = (0, helper_1.checkableGenerator)(BaseVoteBuilder);
class VoteBuilder extends BaseVoteBuilder {
    async seal(serial, validTo, validFrom, voteOptions = {}) {
        const vote = await super.generate(serial, validTo, validFrom);
        return (new Vote(vote, voteOptions));
    }
}
exports.VoteBuilder = VoteBuilder;
VoteBuilder.isInstance = (0, helper_1.checkableGenerator)(VoteBuilder);
class VoteQuoteBuilder extends BaseVoteBuilder {
    constructor() {
        super(...arguments);
        this.quote = true;
    }
    async seal(serial, validTo, validFrom, voteOptions = {}) {
        const voteQuote = await super.generate(serial, validTo, validFrom);
        return (new VoteQuote(voteQuote, voteOptions));
    }
}
exports.VoteQuoteBuilder = VoteQuoteBuilder;
VoteQuoteBuilder.isInstance = (0, helper_1.checkableGenerator)(VoteQuoteBuilder);
// Add respective builders to each
VoteLikeBase.Builder = BaseVoteBuilder;
VoteQuote.Builder = VoteQuoteBuilder;
Vote.Builder = VoteBuilder;
// Add to default export
Vote.Staple = VoteStaple;
Vote.Quote = VoteQuote;
exports["default"] = Vote;
/** @internal */
exports.Testing = { findRDN, blockHashesFromVote, feeFromVote };


/***/ }),

/***/ 5672:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.version = void 0;
exports.version = '0.14.5+g7ab6fd7b04246202abe16df362295a3a022d514a';
exports["default"] = exports.version;


/***/ }),

/***/ 4527:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/**
 * Convert a typed array to a Buffer without a copy
 *
 * Author:   Feross Aboukhadijeh <https://feross.org>
 * License:  MIT
 *
 * `npm install typedarray-to-buffer`
 */

var isTypedArray = (__webpack_require__(9225).strict)

module.exports = function typedarrayToBuffer (arr) {
  if (isTypedArray(arr)) {
    // To avoid a copy, use the typed array's underlying ArrayBuffer to back new Buffer
    var buf = Buffer.from(arr.buffer)
    if (arr.byteLength !== arr.buffer.byteLength) {
      // Respect the "view", i.e. byteOffset and byteLength, without doing a copy
      buf = buf.slice(arr.byteOffset, arr.byteOffset + arr.byteLength)
    }
    return buf
  } else {
    // Pass through all other types to `Buffer.from`
    return Buffer.from(arr)
  }
}


/***/ }),

/***/ 7699:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const WebSocket = __webpack_require__(1060);

WebSocket.createWebSocketStream = __webpack_require__(3719);
WebSocket.Server = __webpack_require__(1722);
WebSocket.Receiver = __webpack_require__(6286);
WebSocket.Sender = __webpack_require__(914);

WebSocket.WebSocket = WebSocket;
WebSocket.WebSocketServer = WebSocket.Server;

module.exports = WebSocket;


/***/ }),

/***/ 3338:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { EMPTY_BUFFER } = __webpack_require__(2614);

const FastBuffer = Buffer[Symbol.species];

/**
 * Merges an array of buffers into a new buffer.
 *
 * @param {Buffer[]} list The array of buffers to concat
 * @param {Number} totalLength The total length of buffers in the list
 * @return {Buffer} The resulting buffer
 * @public
 */
function concat(list, totalLength) {
  if (list.length === 0) return EMPTY_BUFFER;
  if (list.length === 1) return list[0];

  const target = Buffer.allocUnsafe(totalLength);
  let offset = 0;

  for (let i = 0; i < list.length; i++) {
    const buf = list[i];
    target.set(buf, offset);
    offset += buf.length;
  }

  if (offset < totalLength) {
    return new FastBuffer(target.buffer, target.byteOffset, offset);
  }

  return target;
}

/**
 * Masks a buffer using the given mask.
 *
 * @param {Buffer} source The buffer to mask
 * @param {Buffer} mask The mask to use
 * @param {Buffer} output The buffer where to store the result
 * @param {Number} offset The offset at which to start writing
 * @param {Number} length The number of bytes to mask.
 * @public
 */
function _mask(source, mask, output, offset, length) {
  for (let i = 0; i < length; i++) {
    output[offset + i] = source[i] ^ mask[i & 3];
  }
}

/**
 * Unmasks a buffer using the given mask.
 *
 * @param {Buffer} buffer The buffer to unmask
 * @param {Buffer} mask The mask to use
 * @public
 */
function _unmask(buffer, mask) {
  for (let i = 0; i < buffer.length; i++) {
    buffer[i] ^= mask[i & 3];
  }
}

/**
 * Converts a buffer to an `ArrayBuffer`.
 *
 * @param {Buffer} buf The buffer to convert
 * @return {ArrayBuffer} Converted buffer
 * @public
 */
function toArrayBuffer(buf) {
  if (buf.length === buf.buffer.byteLength) {
    return buf.buffer;
  }

  return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.length);
}

/**
 * Converts `data` to a `Buffer`.
 *
 * @param {*} data The data to convert
 * @return {Buffer} The buffer
 * @throws {TypeError}
 * @public
 */
function toBuffer(data) {
  toBuffer.readOnly = true;

  if (Buffer.isBuffer(data)) return data;

  let buf;

  if (data instanceof ArrayBuffer) {
    buf = new FastBuffer(data);
  } else if (ArrayBuffer.isView(data)) {
    buf = new FastBuffer(data.buffer, data.byteOffset, data.byteLength);
  } else {
    buf = Buffer.from(data);
    toBuffer.readOnly = false;
  }

  return buf;
}

module.exports = {
  concat,
  mask: _mask,
  toArrayBuffer,
  toBuffer,
  unmask: _unmask
};

/* istanbul ignore else  */
if (!process.env.WS_NO_BUFFER_UTIL) {
  try {
    const bufferUtil = __webpack_require__(1962);

    module.exports.mask = function (source, mask, output, offset, length) {
      if (length < 48) _mask(source, mask, output, offset, length);
      else bufferUtil.mask(source, mask, output, offset, length);
    };

    module.exports.unmask = function (buffer, mask) {
      if (buffer.length < 32) _unmask(buffer, mask);
      else bufferUtil.unmask(buffer, mask);
    };
  } catch (e) {
    // Continue regardless of the error.
  }
}


/***/ }),

/***/ 2614:
/***/ ((module) => {

"use strict";


const BINARY_TYPES = ['nodebuffer', 'arraybuffer', 'fragments'];
const hasBlob = typeof Blob !== 'undefined';

if (hasBlob) BINARY_TYPES.push('blob');

module.exports = {
  BINARY_TYPES,
  EMPTY_BUFFER: Buffer.alloc(0),
  GUID: '258EAFA5-E914-47DA-95CA-C5AB0DC85B11',
  hasBlob,
  kForOnEventAttribute: Symbol('kIsForOnEventAttribute'),
  kListener: Symbol('kListener'),
  kStatusCode: Symbol('status-code'),
  kWebSocket: Symbol('websocket'),
  NOOP: () => {}
};


/***/ }),

/***/ 597:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { kForOnEventAttribute, kListener } = __webpack_require__(2614);

const kCode = Symbol('kCode');
const kData = Symbol('kData');
const kError = Symbol('kError');
const kMessage = Symbol('kMessage');
const kReason = Symbol('kReason');
const kTarget = Symbol('kTarget');
const kType = Symbol('kType');
const kWasClean = Symbol('kWasClean');

/**
 * Class representing an event.
 */
class Event {
  /**
   * Create a new `Event`.
   *
   * @param {String} type The name of the event
   * @throws {TypeError} If the `type` argument is not specified
   */
  constructor(type) {
    this[kTarget] = null;
    this[kType] = type;
  }

  /**
   * @type {*}
   */
  get target() {
    return this[kTarget];
  }

  /**
   * @type {String}
   */
  get type() {
    return this[kType];
  }
}

Object.defineProperty(Event.prototype, 'target', { enumerable: true });
Object.defineProperty(Event.prototype, 'type', { enumerable: true });

/**
 * Class representing a close event.
 *
 * @extends Event
 */
class CloseEvent extends Event {
  /**
   * Create a new `CloseEvent`.
   *
   * @param {String} type The name of the event
   * @param {Object} [options] A dictionary object that allows for setting
   *     attributes via object members of the same name
   * @param {Number} [options.code=0] The status code explaining why the
   *     connection was closed
   * @param {String} [options.reason=''] A human-readable string explaining why
   *     the connection was closed
   * @param {Boolean} [options.wasClean=false] Indicates whether or not the
   *     connection was cleanly closed
   */
  constructor(type, options = {}) {
    super(type);

    this[kCode] = options.code === undefined ? 0 : options.code;
    this[kReason] = options.reason === undefined ? '' : options.reason;
    this[kWasClean] = options.wasClean === undefined ? false : options.wasClean;
  }

  /**
   * @type {Number}
   */
  get code() {
    return this[kCode];
  }

  /**
   * @type {String}
   */
  get reason() {
    return this[kReason];
  }

  /**
   * @type {Boolean}
   */
  get wasClean() {
    return this[kWasClean];
  }
}

Object.defineProperty(CloseEvent.prototype, 'code', { enumerable: true });
Object.defineProperty(CloseEvent.prototype, 'reason', { enumerable: true });
Object.defineProperty(CloseEvent.prototype, 'wasClean', { enumerable: true });

/**
 * Class representing an error event.
 *
 * @extends Event
 */
class ErrorEvent extends Event {
  /**
   * Create a new `ErrorEvent`.
   *
   * @param {String} type The name of the event
   * @param {Object} [options] A dictionary object that allows for setting
   *     attributes via object members of the same name
   * @param {*} [options.error=null] The error that generated this event
   * @param {String} [options.message=''] The error message
   */
  constructor(type, options = {}) {
    super(type);

    this[kError] = options.error === undefined ? null : options.error;
    this[kMessage] = options.message === undefined ? '' : options.message;
  }

  /**
   * @type {*}
   */
  get error() {
    return this[kError];
  }

  /**
   * @type {String}
   */
  get message() {
    return this[kMessage];
  }
}

Object.defineProperty(ErrorEvent.prototype, 'error', { enumerable: true });
Object.defineProperty(ErrorEvent.prototype, 'message', { enumerable: true });

/**
 * Class representing a message event.
 *
 * @extends Event
 */
class MessageEvent extends Event {
  /**
   * Create a new `MessageEvent`.
   *
   * @param {String} type The name of the event
   * @param {Object} [options] A dictionary object that allows for setting
   *     attributes via object members of the same name
   * @param {*} [options.data=null] The message content
   */
  constructor(type, options = {}) {
    super(type);

    this[kData] = options.data === undefined ? null : options.data;
  }

  /**
   * @type {*}
   */
  get data() {
    return this[kData];
  }
}

Object.defineProperty(MessageEvent.prototype, 'data', { enumerable: true });

/**
 * This provides methods for emulating the `EventTarget` interface. It's not
 * meant to be used directly.
 *
 * @mixin
 */
const EventTarget = {
  /**
   * Register an event listener.
   *
   * @param {String} type A string representing the event type to listen for
   * @param {(Function|Object)} handler The listener to add
   * @param {Object} [options] An options object specifies characteristics about
   *     the event listener
   * @param {Boolean} [options.once=false] A `Boolean` indicating that the
   *     listener should be invoked at most once after being added. If `true`,
   *     the listener would be automatically removed when invoked.
   * @public
   */
  addEventListener(type, handler, options = {}) {
    for (const listener of this.listeners(type)) {
      if (
        !options[kForOnEventAttribute] &&
        listener[kListener] === handler &&
        !listener[kForOnEventAttribute]
      ) {
        return;
      }
    }

    let wrapper;

    if (type === 'message') {
      wrapper = function onMessage(data, isBinary) {
        const event = new MessageEvent('message', {
          data: isBinary ? data : data.toString()
        });

        event[kTarget] = this;
        callListener(handler, this, event);
      };
    } else if (type === 'close') {
      wrapper = function onClose(code, message) {
        const event = new CloseEvent('close', {
          code,
          reason: message.toString(),
          wasClean: this._closeFrameReceived && this._closeFrameSent
        });

        event[kTarget] = this;
        callListener(handler, this, event);
      };
    } else if (type === 'error') {
      wrapper = function onError(error) {
        const event = new ErrorEvent('error', {
          error,
          message: error.message
        });

        event[kTarget] = this;
        callListener(handler, this, event);
      };
    } else if (type === 'open') {
      wrapper = function onOpen() {
        const event = new Event('open');

        event[kTarget] = this;
        callListener(handler, this, event);
      };
    } else {
      return;
    }

    wrapper[kForOnEventAttribute] = !!options[kForOnEventAttribute];
    wrapper[kListener] = handler;

    if (options.once) {
      this.once(type, wrapper);
    } else {
      this.on(type, wrapper);
    }
  },

  /**
   * Remove an event listener.
   *
   * @param {String} type A string representing the event type to remove
   * @param {(Function|Object)} handler The listener to remove
   * @public
   */
  removeEventListener(type, handler) {
    for (const listener of this.listeners(type)) {
      if (listener[kListener] === handler && !listener[kForOnEventAttribute]) {
        this.removeListener(type, listener);
        break;
      }
    }
  }
};

module.exports = {
  CloseEvent,
  ErrorEvent,
  Event,
  EventTarget,
  MessageEvent
};

/**
 * Call an event listener
 *
 * @param {(Function|Object)} listener The listener to call
 * @param {*} thisArg The value to use as `this`` when calling the listener
 * @param {Event} event The event to pass to the listener
 * @private
 */
function callListener(listener, thisArg, event) {
  if (typeof listener === 'object' && listener.handleEvent) {
    listener.handleEvent.call(listener, event);
  } else {
    listener.call(thisArg, event);
  }
}


/***/ }),

/***/ 5926:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { tokenChars } = __webpack_require__(5880);

/**
 * Adds an offer to the map of extension offers or a parameter to the map of
 * parameters.
 *
 * @param {Object} dest The map of extension offers or parameters
 * @param {String} name The extension or parameter name
 * @param {(Object|Boolean|String)} elem The extension parameters or the
 *     parameter value
 * @private
 */
function push(dest, name, elem) {
  if (dest[name] === undefined) dest[name] = [elem];
  else dest[name].push(elem);
}

/**
 * Parses the `Sec-WebSocket-Extensions` header into an object.
 *
 * @param {String} header The field value of the header
 * @return {Object} The parsed object
 * @public
 */
function parse(header) {
  const offers = Object.create(null);
  let params = Object.create(null);
  let mustUnescape = false;
  let isEscaping = false;
  let inQuotes = false;
  let extensionName;
  let paramName;
  let start = -1;
  let code = -1;
  let end = -1;
  let i = 0;

  for (; i < header.length; i++) {
    code = header.charCodeAt(i);

    if (extensionName === undefined) {
      if (end === -1 && tokenChars[code] === 1) {
        if (start === -1) start = i;
      } else if (
        i !== 0 &&
        (code === 0x20 /* ' ' */ || code === 0x09) /* '\t' */
      ) {
        if (end === -1 && start !== -1) end = i;
      } else if (code === 0x3b /* ';' */ || code === 0x2c /* ',' */) {
        if (start === -1) {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }

        if (end === -1) end = i;
        const name = header.slice(start, end);
        if (code === 0x2c) {
          push(offers, name, params);
          params = Object.create(null);
        } else {
          extensionName = name;
        }

        start = end = -1;
      } else {
        throw new SyntaxError(`Unexpected character at index ${i}`);
      }
    } else if (paramName === undefined) {
      if (end === -1 && tokenChars[code] === 1) {
        if (start === -1) start = i;
      } else if (code === 0x20 || code === 0x09) {
        if (end === -1 && start !== -1) end = i;
      } else if (code === 0x3b || code === 0x2c) {
        if (start === -1) {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }

        if (end === -1) end = i;
        push(params, header.slice(start, end), true);
        if (code === 0x2c) {
          push(offers, extensionName, params);
          params = Object.create(null);
          extensionName = undefined;
        }

        start = end = -1;
      } else if (code === 0x3d /* '=' */ && start !== -1 && end === -1) {
        paramName = header.slice(start, i);
        start = end = -1;
      } else {
        throw new SyntaxError(`Unexpected character at index ${i}`);
      }
    } else {
      //
      // The value of a quoted-string after unescaping must conform to the
      // token ABNF, so only token characters are valid.
      // Ref: https://tools.ietf.org/html/rfc6455#section-9.1
      //
      if (isEscaping) {
        if (tokenChars[code] !== 1) {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }
        if (start === -1) start = i;
        else if (!mustUnescape) mustUnescape = true;
        isEscaping = false;
      } else if (inQuotes) {
        if (tokenChars[code] === 1) {
          if (start === -1) start = i;
        } else if (code === 0x22 /* '"' */ && start !== -1) {
          inQuotes = false;
          end = i;
        } else if (code === 0x5c /* '\' */) {
          isEscaping = true;
        } else {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }
      } else if (code === 0x22 && header.charCodeAt(i - 1) === 0x3d) {
        inQuotes = true;
      } else if (end === -1 && tokenChars[code] === 1) {
        if (start === -1) start = i;
      } else if (start !== -1 && (code === 0x20 || code === 0x09)) {
        if (end === -1) end = i;
      } else if (code === 0x3b || code === 0x2c) {
        if (start === -1) {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }

        if (end === -1) end = i;
        let value = header.slice(start, end);
        if (mustUnescape) {
          value = value.replace(/\\/g, '');
          mustUnescape = false;
        }
        push(params, paramName, value);
        if (code === 0x2c) {
          push(offers, extensionName, params);
          params = Object.create(null);
          extensionName = undefined;
        }

        paramName = undefined;
        start = end = -1;
      } else {
        throw new SyntaxError(`Unexpected character at index ${i}`);
      }
    }
  }

  if (start === -1 || inQuotes || code === 0x20 || code === 0x09) {
    throw new SyntaxError('Unexpected end of input');
  }

  if (end === -1) end = i;
  const token = header.slice(start, end);
  if (extensionName === undefined) {
    push(offers, token, params);
  } else {
    if (paramName === undefined) {
      push(params, token, true);
    } else if (mustUnescape) {
      push(params, paramName, token.replace(/\\/g, ''));
    } else {
      push(params, paramName, token);
    }
    push(offers, extensionName, params);
  }

  return offers;
}

/**
 * Builds the `Sec-WebSocket-Extensions` header field value.
 *
 * @param {Object} extensions The map of extensions and parameters to format
 * @return {String} A string representing the given object
 * @public
 */
function format(extensions) {
  return Object.keys(extensions)
    .map((extension) => {
      let configurations = extensions[extension];
      if (!Array.isArray(configurations)) configurations = [configurations];
      return configurations
        .map((params) => {
          return [extension]
            .concat(
              Object.keys(params).map((k) => {
                let values = params[k];
                if (!Array.isArray(values)) values = [values];
                return values
                  .map((v) => (v === true ? k : `${k}=${v}`))
                  .join('; ');
              })
            )
            .join('; ');
        })
        .join(', ');
    })
    .join(', ');
}

module.exports = { format, parse };


/***/ }),

/***/ 4759:
/***/ ((module) => {

"use strict";


const kDone = Symbol('kDone');
const kRun = Symbol('kRun');

/**
 * A very simple job queue with adjustable concurrency. Adapted from
 * https://github.com/STRML/async-limiter
 */
class Limiter {
  /**
   * Creates a new `Limiter`.
   *
   * @param {Number} [concurrency=Infinity] The maximum number of jobs allowed
   *     to run concurrently
   */
  constructor(concurrency) {
    this[kDone] = () => {
      this.pending--;
      this[kRun]();
    };
    this.concurrency = concurrency || Infinity;
    this.jobs = [];
    this.pending = 0;
  }

  /**
   * Adds a job to the queue.
   *
   * @param {Function} job The job to run
   * @public
   */
  add(job) {
    this.jobs.push(job);
    this[kRun]();
  }

  /**
   * Removes a job from the queue and runs it if possible.
   *
   * @private
   */
  [kRun]() {
    if (this.pending === this.concurrency) return;

    if (this.jobs.length) {
      const job = this.jobs.shift();

      this.pending++;
      job(this[kDone]);
    }
  }
}

module.exports = Limiter;


/***/ }),

/***/ 2971:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const zlib = __webpack_require__(3106);

const bufferUtil = __webpack_require__(3338);
const Limiter = __webpack_require__(4759);
const { kStatusCode } = __webpack_require__(2614);

const FastBuffer = Buffer[Symbol.species];
const TRAILER = Buffer.from([0x00, 0x00, 0xff, 0xff]);
const kPerMessageDeflate = Symbol('permessage-deflate');
const kTotalLength = Symbol('total-length');
const kCallback = Symbol('callback');
const kBuffers = Symbol('buffers');
const kError = Symbol('error');

//
// We limit zlib concurrency, which prevents severe memory fragmentation
// as documented in https://github.com/nodejs/node/issues/8871#issuecomment-250915913
// and https://github.com/websockets/ws/issues/1202
//
// Intentionally global; it's the global thread pool that's an issue.
//
let zlibLimiter;

/**
 * permessage-deflate implementation.
 */
class PerMessageDeflate {
  /**
   * Creates a PerMessageDeflate instance.
   *
   * @param {Object} [options] Configuration options
   * @param {(Boolean|Number)} [options.clientMaxWindowBits] Advertise support
   *     for, or request, a custom client window size
   * @param {Boolean} [options.clientNoContextTakeover=false] Advertise/
   *     acknowledge disabling of client context takeover
   * @param {Number} [options.concurrencyLimit=10] The number of concurrent
   *     calls to zlib
   * @param {(Boolean|Number)} [options.serverMaxWindowBits] Request/confirm the
   *     use of a custom server window size
   * @param {Boolean} [options.serverNoContextTakeover=false] Request/accept
   *     disabling of server context takeover
   * @param {Number} [options.threshold=1024] Size (in bytes) below which
   *     messages should not be compressed if context takeover is disabled
   * @param {Object} [options.zlibDeflateOptions] Options to pass to zlib on
   *     deflate
   * @param {Object} [options.zlibInflateOptions] Options to pass to zlib on
   *     inflate
   * @param {Boolean} [isServer=false] Create the instance in either server or
   *     client mode
   * @param {Number} [maxPayload=0] The maximum allowed message length
   */
  constructor(options, isServer, maxPayload) {
    this._maxPayload = maxPayload | 0;
    this._options = options || {};
    this._threshold =
      this._options.threshold !== undefined ? this._options.threshold : 1024;
    this._isServer = !!isServer;
    this._deflate = null;
    this._inflate = null;

    this.params = null;

    if (!zlibLimiter) {
      const concurrency =
        this._options.concurrencyLimit !== undefined
          ? this._options.concurrencyLimit
          : 10;
      zlibLimiter = new Limiter(concurrency);
    }
  }

  /**
   * @type {String}
   */
  static get extensionName() {
    return 'permessage-deflate';
  }

  /**
   * Create an extension negotiation offer.
   *
   * @return {Object} Extension parameters
   * @public
   */
  offer() {
    const params = {};

    if (this._options.serverNoContextTakeover) {
      params.server_no_context_takeover = true;
    }
    if (this._options.clientNoContextTakeover) {
      params.client_no_context_takeover = true;
    }
    if (this._options.serverMaxWindowBits) {
      params.server_max_window_bits = this._options.serverMaxWindowBits;
    }
    if (this._options.clientMaxWindowBits) {
      params.client_max_window_bits = this._options.clientMaxWindowBits;
    } else if (this._options.clientMaxWindowBits == null) {
      params.client_max_window_bits = true;
    }

    return params;
  }

  /**
   * Accept an extension negotiation offer/response.
   *
   * @param {Array} configurations The extension negotiation offers/reponse
   * @return {Object} Accepted configuration
   * @public
   */
  accept(configurations) {
    configurations = this.normalizeParams(configurations);

    this.params = this._isServer
      ? this.acceptAsServer(configurations)
      : this.acceptAsClient(configurations);

    return this.params;
  }

  /**
   * Releases all resources used by the extension.
   *
   * @public
   */
  cleanup() {
    if (this._inflate) {
      this._inflate.close();
      this._inflate = null;
    }

    if (this._deflate) {
      const callback = this._deflate[kCallback];

      this._deflate.close();
      this._deflate = null;

      if (callback) {
        callback(
          new Error(
            'The deflate stream was closed while data was being processed'
          )
        );
      }
    }
  }

  /**
   *  Accept an extension negotiation offer.
   *
   * @param {Array} offers The extension negotiation offers
   * @return {Object} Accepted configuration
   * @private
   */
  acceptAsServer(offers) {
    const opts = this._options;
    const accepted = offers.find((params) => {
      if (
        (opts.serverNoContextTakeover === false &&
          params.server_no_context_takeover) ||
        (params.server_max_window_bits &&
          (opts.serverMaxWindowBits === false ||
            (typeof opts.serverMaxWindowBits === 'number' &&
              opts.serverMaxWindowBits > params.server_max_window_bits))) ||
        (typeof opts.clientMaxWindowBits === 'number' &&
          !params.client_max_window_bits)
      ) {
        return false;
      }

      return true;
    });

    if (!accepted) {
      throw new Error('None of the extension offers can be accepted');
    }

    if (opts.serverNoContextTakeover) {
      accepted.server_no_context_takeover = true;
    }
    if (opts.clientNoContextTakeover) {
      accepted.client_no_context_takeover = true;
    }
    if (typeof opts.serverMaxWindowBits === 'number') {
      accepted.server_max_window_bits = opts.serverMaxWindowBits;
    }
    if (typeof opts.clientMaxWindowBits === 'number') {
      accepted.client_max_window_bits = opts.clientMaxWindowBits;
    } else if (
      accepted.client_max_window_bits === true ||
      opts.clientMaxWindowBits === false
    ) {
      delete accepted.client_max_window_bits;
    }

    return accepted;
  }

  /**
   * Accept the extension negotiation response.
   *
   * @param {Array} response The extension negotiation response
   * @return {Object} Accepted configuration
   * @private
   */
  acceptAsClient(response) {
    const params = response[0];

    if (
      this._options.clientNoContextTakeover === false &&
      params.client_no_context_takeover
    ) {
      throw new Error('Unexpected parameter "client_no_context_takeover"');
    }

    if (!params.client_max_window_bits) {
      if (typeof this._options.clientMaxWindowBits === 'number') {
        params.client_max_window_bits = this._options.clientMaxWindowBits;
      }
    } else if (
      this._options.clientMaxWindowBits === false ||
      (typeof this._options.clientMaxWindowBits === 'number' &&
        params.client_max_window_bits > this._options.clientMaxWindowBits)
    ) {
      throw new Error(
        'Unexpected or invalid parameter "client_max_window_bits"'
      );
    }

    return params;
  }

  /**
   * Normalize parameters.
   *
   * @param {Array} configurations The extension negotiation offers/reponse
   * @return {Array} The offers/response with normalized parameters
   * @private
   */
  normalizeParams(configurations) {
    configurations.forEach((params) => {
      Object.keys(params).forEach((key) => {
        let value = params[key];

        if (value.length > 1) {
          throw new Error(`Parameter "${key}" must have only a single value`);
        }

        value = value[0];

        if (key === 'client_max_window_bits') {
          if (value !== true) {
            const num = +value;
            if (!Number.isInteger(num) || num < 8 || num > 15) {
              throw new TypeError(
                `Invalid value for parameter "${key}": ${value}`
              );
            }
            value = num;
          } else if (!this._isServer) {
            throw new TypeError(
              `Invalid value for parameter "${key}": ${value}`
            );
          }
        } else if (key === 'server_max_window_bits') {
          const num = +value;
          if (!Number.isInteger(num) || num < 8 || num > 15) {
            throw new TypeError(
              `Invalid value for parameter "${key}": ${value}`
            );
          }
          value = num;
        } else if (
          key === 'client_no_context_takeover' ||
          key === 'server_no_context_takeover'
        ) {
          if (value !== true) {
            throw new TypeError(
              `Invalid value for parameter "${key}": ${value}`
            );
          }
        } else {
          throw new Error(`Unknown parameter "${key}"`);
        }

        params[key] = value;
      });
    });

    return configurations;
  }

  /**
   * Decompress data. Concurrency limited.
   *
   * @param {Buffer} data Compressed data
   * @param {Boolean} fin Specifies whether or not this is the last fragment
   * @param {Function} callback Callback
   * @public
   */
  decompress(data, fin, callback) {
    zlibLimiter.add((done) => {
      this._decompress(data, fin, (err, result) => {
        done();
        callback(err, result);
      });
    });
  }

  /**
   * Compress data. Concurrency limited.
   *
   * @param {(Buffer|String)} data Data to compress
   * @param {Boolean} fin Specifies whether or not this is the last fragment
   * @param {Function} callback Callback
   * @public
   */
  compress(data, fin, callback) {
    zlibLimiter.add((done) => {
      this._compress(data, fin, (err, result) => {
        done();
        callback(err, result);
      });
    });
  }

  /**
   * Decompress data.
   *
   * @param {Buffer} data Compressed data
   * @param {Boolean} fin Specifies whether or not this is the last fragment
   * @param {Function} callback Callback
   * @private
   */
  _decompress(data, fin, callback) {
    const endpoint = this._isServer ? 'client' : 'server';

    if (!this._inflate) {
      const key = `${endpoint}_max_window_bits`;
      const windowBits =
        typeof this.params[key] !== 'number'
          ? zlib.Z_DEFAULT_WINDOWBITS
          : this.params[key];

      this._inflate = zlib.createInflateRaw({
        ...this._options.zlibInflateOptions,
        windowBits
      });
      this._inflate[kPerMessageDeflate] = this;
      this._inflate[kTotalLength] = 0;
      this._inflate[kBuffers] = [];
      this._inflate.on('error', inflateOnError);
      this._inflate.on('data', inflateOnData);
    }

    this._inflate[kCallback] = callback;

    this._inflate.write(data);
    if (fin) this._inflate.write(TRAILER);

    this._inflate.flush(() => {
      const err = this._inflate[kError];

      if (err) {
        this._inflate.close();
        this._inflate = null;
        callback(err);
        return;
      }

      const data = bufferUtil.concat(
        this._inflate[kBuffers],
        this._inflate[kTotalLength]
      );

      if (this._inflate._readableState.endEmitted) {
        this._inflate.close();
        this._inflate = null;
      } else {
        this._inflate[kTotalLength] = 0;
        this._inflate[kBuffers] = [];

        if (fin && this.params[`${endpoint}_no_context_takeover`]) {
          this._inflate.reset();
        }
      }

      callback(null, data);
    });
  }

  /**
   * Compress data.
   *
   * @param {(Buffer|String)} data Data to compress
   * @param {Boolean} fin Specifies whether or not this is the last fragment
   * @param {Function} callback Callback
   * @private
   */
  _compress(data, fin, callback) {
    const endpoint = this._isServer ? 'server' : 'client';

    if (!this._deflate) {
      const key = `${endpoint}_max_window_bits`;
      const windowBits =
        typeof this.params[key] !== 'number'
          ? zlib.Z_DEFAULT_WINDOWBITS
          : this.params[key];

      this._deflate = zlib.createDeflateRaw({
        ...this._options.zlibDeflateOptions,
        windowBits
      });

      this._deflate[kTotalLength] = 0;
      this._deflate[kBuffers] = [];

      this._deflate.on('data', deflateOnData);
    }

    this._deflate[kCallback] = callback;

    this._deflate.write(data);
    this._deflate.flush(zlib.Z_SYNC_FLUSH, () => {
      if (!this._deflate) {
        //
        // The deflate stream was closed while data was being processed.
        //
        return;
      }

      let data = bufferUtil.concat(
        this._deflate[kBuffers],
        this._deflate[kTotalLength]
      );

      if (fin) {
        data = new FastBuffer(data.buffer, data.byteOffset, data.length - 4);
      }

      //
      // Ensure that the callback will not be called again in
      // `PerMessageDeflate#cleanup()`.
      //
      this._deflate[kCallback] = null;

      this._deflate[kTotalLength] = 0;
      this._deflate[kBuffers] = [];

      if (fin && this.params[`${endpoint}_no_context_takeover`]) {
        this._deflate.reset();
      }

      callback(null, data);
    });
  }
}

module.exports = PerMessageDeflate;

/**
 * The listener of the `zlib.DeflateRaw` stream `'data'` event.
 *
 * @param {Buffer} chunk A chunk of data
 * @private
 */
function deflateOnData(chunk) {
  this[kBuffers].push(chunk);
  this[kTotalLength] += chunk.length;
}

/**
 * The listener of the `zlib.InflateRaw` stream `'data'` event.
 *
 * @param {Buffer} chunk A chunk of data
 * @private
 */
function inflateOnData(chunk) {
  this[kTotalLength] += chunk.length;

  if (
    this[kPerMessageDeflate]._maxPayload < 1 ||
    this[kTotalLength] <= this[kPerMessageDeflate]._maxPayload
  ) {
    this[kBuffers].push(chunk);
    return;
  }

  this[kError] = new RangeError('Max payload size exceeded');
  this[kError].code = 'WS_ERR_UNSUPPORTED_MESSAGE_LENGTH';
  this[kError][kStatusCode] = 1009;
  this.removeListener('data', inflateOnData);
  this.reset();
}

/**
 * The listener of the `zlib.InflateRaw` stream `'error'` event.
 *
 * @param {Error} err The emitted error
 * @private
 */
function inflateOnError(err) {
  //
  // There is no need to call `Zlib#close()` as the handle is automatically
  // closed when an error is emitted.
  //
  this[kPerMessageDeflate]._inflate = null;
  err[kStatusCode] = 1007;
  this[kCallback](err);
}


/***/ }),

/***/ 6286:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { Writable } = __webpack_require__(2203);

const PerMessageDeflate = __webpack_require__(2971);
const {
  BINARY_TYPES,
  EMPTY_BUFFER,
  kStatusCode,
  kWebSocket
} = __webpack_require__(2614);
const { concat, toArrayBuffer, unmask } = __webpack_require__(3338);
const { isValidStatusCode, isValidUTF8 } = __webpack_require__(5880);

const FastBuffer = Buffer[Symbol.species];

const GET_INFO = 0;
const GET_PAYLOAD_LENGTH_16 = 1;
const GET_PAYLOAD_LENGTH_64 = 2;
const GET_MASK = 3;
const GET_DATA = 4;
const INFLATING = 5;
const DEFER_EVENT = 6;

/**
 * HyBi Receiver implementation.
 *
 * @extends Writable
 */
class Receiver extends Writable {
  /**
   * Creates a Receiver instance.
   *
   * @param {Object} [options] Options object
   * @param {Boolean} [options.allowSynchronousEvents=true] Specifies whether
   *     any of the `'message'`, `'ping'`, and `'pong'` events can be emitted
   *     multiple times in the same tick
   * @param {String} [options.binaryType=nodebuffer] The type for binary data
   * @param {Object} [options.extensions] An object containing the negotiated
   *     extensions
   * @param {Boolean} [options.isServer=false] Specifies whether to operate in
   *     client or server mode
   * @param {Number} [options.maxPayload=0] The maximum allowed message length
   * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
   *     not to skip UTF-8 validation for text and close messages
   */
  constructor(options = {}) {
    super();

    this._allowSynchronousEvents =
      options.allowSynchronousEvents !== undefined
        ? options.allowSynchronousEvents
        : true;
    this._binaryType = options.binaryType || BINARY_TYPES[0];
    this._extensions = options.extensions || {};
    this._isServer = !!options.isServer;
    this._maxPayload = options.maxPayload | 0;
    this._skipUTF8Validation = !!options.skipUTF8Validation;
    this[kWebSocket] = undefined;

    this._bufferedBytes = 0;
    this._buffers = [];

    this._compressed = false;
    this._payloadLength = 0;
    this._mask = undefined;
    this._fragmented = 0;
    this._masked = false;
    this._fin = false;
    this._opcode = 0;

    this._totalPayloadLength = 0;
    this._messageLength = 0;
    this._fragments = [];

    this._errored = false;
    this._loop = false;
    this._state = GET_INFO;
  }

  /**
   * Implements `Writable.prototype._write()`.
   *
   * @param {Buffer} chunk The chunk of data to write
   * @param {String} encoding The character encoding of `chunk`
   * @param {Function} cb Callback
   * @private
   */
  _write(chunk, encoding, cb) {
    if (this._opcode === 0x08 && this._state == GET_INFO) return cb();

    this._bufferedBytes += chunk.length;
    this._buffers.push(chunk);
    this.startLoop(cb);
  }

  /**
   * Consumes `n` bytes from the buffered data.
   *
   * @param {Number} n The number of bytes to consume
   * @return {Buffer} The consumed bytes
   * @private
   */
  consume(n) {
    this._bufferedBytes -= n;

    if (n === this._buffers[0].length) return this._buffers.shift();

    if (n < this._buffers[0].length) {
      const buf = this._buffers[0];
      this._buffers[0] = new FastBuffer(
        buf.buffer,
        buf.byteOffset + n,
        buf.length - n
      );

      return new FastBuffer(buf.buffer, buf.byteOffset, n);
    }

    const dst = Buffer.allocUnsafe(n);

    do {
      const buf = this._buffers[0];
      const offset = dst.length - n;

      if (n >= buf.length) {
        dst.set(this._buffers.shift(), offset);
      } else {
        dst.set(new Uint8Array(buf.buffer, buf.byteOffset, n), offset);
        this._buffers[0] = new FastBuffer(
          buf.buffer,
          buf.byteOffset + n,
          buf.length - n
        );
      }

      n -= buf.length;
    } while (n > 0);

    return dst;
  }

  /**
   * Starts the parsing loop.
   *
   * @param {Function} cb Callback
   * @private
   */
  startLoop(cb) {
    this._loop = true;

    do {
      switch (this._state) {
        case GET_INFO:
          this.getInfo(cb);
          break;
        case GET_PAYLOAD_LENGTH_16:
          this.getPayloadLength16(cb);
          break;
        case GET_PAYLOAD_LENGTH_64:
          this.getPayloadLength64(cb);
          break;
        case GET_MASK:
          this.getMask();
          break;
        case GET_DATA:
          this.getData(cb);
          break;
        case INFLATING:
        case DEFER_EVENT:
          this._loop = false;
          return;
      }
    } while (this._loop);

    if (!this._errored) cb();
  }

  /**
   * Reads the first two bytes of a frame.
   *
   * @param {Function} cb Callback
   * @private
   */
  getInfo(cb) {
    if (this._bufferedBytes < 2) {
      this._loop = false;
      return;
    }

    const buf = this.consume(2);

    if ((buf[0] & 0x30) !== 0x00) {
      const error = this.createError(
        RangeError,
        'RSV2 and RSV3 must be clear',
        true,
        1002,
        'WS_ERR_UNEXPECTED_RSV_2_3'
      );

      cb(error);
      return;
    }

    const compressed = (buf[0] & 0x40) === 0x40;

    if (compressed && !this._extensions[PerMessageDeflate.extensionName]) {
      const error = this.createError(
        RangeError,
        'RSV1 must be clear',
        true,
        1002,
        'WS_ERR_UNEXPECTED_RSV_1'
      );

      cb(error);
      return;
    }

    this._fin = (buf[0] & 0x80) === 0x80;
    this._opcode = buf[0] & 0x0f;
    this._payloadLength = buf[1] & 0x7f;

    if (this._opcode === 0x00) {
      if (compressed) {
        const error = this.createError(
          RangeError,
          'RSV1 must be clear',
          true,
          1002,
          'WS_ERR_UNEXPECTED_RSV_1'
        );

        cb(error);
        return;
      }

      if (!this._fragmented) {
        const error = this.createError(
          RangeError,
          'invalid opcode 0',
          true,
          1002,
          'WS_ERR_INVALID_OPCODE'
        );

        cb(error);
        return;
      }

      this._opcode = this._fragmented;
    } else if (this._opcode === 0x01 || this._opcode === 0x02) {
      if (this._fragmented) {
        const error = this.createError(
          RangeError,
          `invalid opcode ${this._opcode}`,
          true,
          1002,
          'WS_ERR_INVALID_OPCODE'
        );

        cb(error);
        return;
      }

      this._compressed = compressed;
    } else if (this._opcode > 0x07 && this._opcode < 0x0b) {
      if (!this._fin) {
        const error = this.createError(
          RangeError,
          'FIN must be set',
          true,
          1002,
          'WS_ERR_EXPECTED_FIN'
        );

        cb(error);
        return;
      }

      if (compressed) {
        const error = this.createError(
          RangeError,
          'RSV1 must be clear',
          true,
          1002,
          'WS_ERR_UNEXPECTED_RSV_1'
        );

        cb(error);
        return;
      }

      if (
        this._payloadLength > 0x7d ||
        (this._opcode === 0x08 && this._payloadLength === 1)
      ) {
        const error = this.createError(
          RangeError,
          `invalid payload length ${this._payloadLength}`,
          true,
          1002,
          'WS_ERR_INVALID_CONTROL_PAYLOAD_LENGTH'
        );

        cb(error);
        return;
      }
    } else {
      const error = this.createError(
        RangeError,
        `invalid opcode ${this._opcode}`,
        true,
        1002,
        'WS_ERR_INVALID_OPCODE'
      );

      cb(error);
      return;
    }

    if (!this._fin && !this._fragmented) this._fragmented = this._opcode;
    this._masked = (buf[1] & 0x80) === 0x80;

    if (this._isServer) {
      if (!this._masked) {
        const error = this.createError(
          RangeError,
          'MASK must be set',
          true,
          1002,
          'WS_ERR_EXPECTED_MASK'
        );

        cb(error);
        return;
      }
    } else if (this._masked) {
      const error = this.createError(
        RangeError,
        'MASK must be clear',
        true,
        1002,
        'WS_ERR_UNEXPECTED_MASK'
      );

      cb(error);
      return;
    }

    if (this._payloadLength === 126) this._state = GET_PAYLOAD_LENGTH_16;
    else if (this._payloadLength === 127) this._state = GET_PAYLOAD_LENGTH_64;
    else this.haveLength(cb);
  }

  /**
   * Gets extended payload length (7+16).
   *
   * @param {Function} cb Callback
   * @private
   */
  getPayloadLength16(cb) {
    if (this._bufferedBytes < 2) {
      this._loop = false;
      return;
    }

    this._payloadLength = this.consume(2).readUInt16BE(0);
    this.haveLength(cb);
  }

  /**
   * Gets extended payload length (7+64).
   *
   * @param {Function} cb Callback
   * @private
   */
  getPayloadLength64(cb) {
    if (this._bufferedBytes < 8) {
      this._loop = false;
      return;
    }

    const buf = this.consume(8);
    const num = buf.readUInt32BE(0);

    //
    // The maximum safe integer in JavaScript is 2^53 - 1. An error is returned
    // if payload length is greater than this number.
    //
    if (num > Math.pow(2, 53 - 32) - 1) {
      const error = this.createError(
        RangeError,
        'Unsupported WebSocket frame: payload length > 2^53 - 1',
        false,
        1009,
        'WS_ERR_UNSUPPORTED_DATA_PAYLOAD_LENGTH'
      );

      cb(error);
      return;
    }

    this._payloadLength = num * Math.pow(2, 32) + buf.readUInt32BE(4);
    this.haveLength(cb);
  }

  /**
   * Payload length has been read.
   *
   * @param {Function} cb Callback
   * @private
   */
  haveLength(cb) {
    if (this._payloadLength && this._opcode < 0x08) {
      this._totalPayloadLength += this._payloadLength;
      if (this._totalPayloadLength > this._maxPayload && this._maxPayload > 0) {
        const error = this.createError(
          RangeError,
          'Max payload size exceeded',
          false,
          1009,
          'WS_ERR_UNSUPPORTED_MESSAGE_LENGTH'
        );

        cb(error);
        return;
      }
    }

    if (this._masked) this._state = GET_MASK;
    else this._state = GET_DATA;
  }

  /**
   * Reads mask bytes.
   *
   * @private
   */
  getMask() {
    if (this._bufferedBytes < 4) {
      this._loop = false;
      return;
    }

    this._mask = this.consume(4);
    this._state = GET_DATA;
  }

  /**
   * Reads data bytes.
   *
   * @param {Function} cb Callback
   * @private
   */
  getData(cb) {
    let data = EMPTY_BUFFER;

    if (this._payloadLength) {
      if (this._bufferedBytes < this._payloadLength) {
        this._loop = false;
        return;
      }

      data = this.consume(this._payloadLength);

      if (
        this._masked &&
        (this._mask[0] | this._mask[1] | this._mask[2] | this._mask[3]) !== 0
      ) {
        unmask(data, this._mask);
      }
    }

    if (this._opcode > 0x07) {
      this.controlMessage(data, cb);
      return;
    }

    if (this._compressed) {
      this._state = INFLATING;
      this.decompress(data, cb);
      return;
    }

    if (data.length) {
      //
      // This message is not compressed so its length is the sum of the payload
      // length of all fragments.
      //
      this._messageLength = this._totalPayloadLength;
      this._fragments.push(data);
    }

    this.dataMessage(cb);
  }

  /**
   * Decompresses data.
   *
   * @param {Buffer} data Compressed data
   * @param {Function} cb Callback
   * @private
   */
  decompress(data, cb) {
    const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];

    perMessageDeflate.decompress(data, this._fin, (err, buf) => {
      if (err) return cb(err);

      if (buf.length) {
        this._messageLength += buf.length;
        if (this._messageLength > this._maxPayload && this._maxPayload > 0) {
          const error = this.createError(
            RangeError,
            'Max payload size exceeded',
            false,
            1009,
            'WS_ERR_UNSUPPORTED_MESSAGE_LENGTH'
          );

          cb(error);
          return;
        }

        this._fragments.push(buf);
      }

      this.dataMessage(cb);
      if (this._state === GET_INFO) this.startLoop(cb);
    });
  }

  /**
   * Handles a data message.
   *
   * @param {Function} cb Callback
   * @private
   */
  dataMessage(cb) {
    if (!this._fin) {
      this._state = GET_INFO;
      return;
    }

    const messageLength = this._messageLength;
    const fragments = this._fragments;

    this._totalPayloadLength = 0;
    this._messageLength = 0;
    this._fragmented = 0;
    this._fragments = [];

    if (this._opcode === 2) {
      let data;

      if (this._binaryType === 'nodebuffer') {
        data = concat(fragments, messageLength);
      } else if (this._binaryType === 'arraybuffer') {
        data = toArrayBuffer(concat(fragments, messageLength));
      } else if (this._binaryType === 'blob') {
        data = new Blob(fragments);
      } else {
        data = fragments;
      }

      if (this._allowSynchronousEvents) {
        this.emit('message', data, true);
        this._state = GET_INFO;
      } else {
        this._state = DEFER_EVENT;
        setImmediate(() => {
          this.emit('message', data, true);
          this._state = GET_INFO;
          this.startLoop(cb);
        });
      }
    } else {
      const buf = concat(fragments, messageLength);

      if (!this._skipUTF8Validation && !isValidUTF8(buf)) {
        const error = this.createError(
          Error,
          'invalid UTF-8 sequence',
          true,
          1007,
          'WS_ERR_INVALID_UTF8'
        );

        cb(error);
        return;
      }

      if (this._state === INFLATING || this._allowSynchronousEvents) {
        this.emit('message', buf, false);
        this._state = GET_INFO;
      } else {
        this._state = DEFER_EVENT;
        setImmediate(() => {
          this.emit('message', buf, false);
          this._state = GET_INFO;
          this.startLoop(cb);
        });
      }
    }
  }

  /**
   * Handles a control message.
   *
   * @param {Buffer} data Data to handle
   * @return {(Error|RangeError|undefined)} A possible error
   * @private
   */
  controlMessage(data, cb) {
    if (this._opcode === 0x08) {
      if (data.length === 0) {
        this._loop = false;
        this.emit('conclude', 1005, EMPTY_BUFFER);
        this.end();
      } else {
        const code = data.readUInt16BE(0);

        if (!isValidStatusCode(code)) {
          const error = this.createError(
            RangeError,
            `invalid status code ${code}`,
            true,
            1002,
            'WS_ERR_INVALID_CLOSE_CODE'
          );

          cb(error);
          return;
        }

        const buf = new FastBuffer(
          data.buffer,
          data.byteOffset + 2,
          data.length - 2
        );

        if (!this._skipUTF8Validation && !isValidUTF8(buf)) {
          const error = this.createError(
            Error,
            'invalid UTF-8 sequence',
            true,
            1007,
            'WS_ERR_INVALID_UTF8'
          );

          cb(error);
          return;
        }

        this._loop = false;
        this.emit('conclude', code, buf);
        this.end();
      }

      this._state = GET_INFO;
      return;
    }

    if (this._allowSynchronousEvents) {
      this.emit(this._opcode === 0x09 ? 'ping' : 'pong', data);
      this._state = GET_INFO;
    } else {
      this._state = DEFER_EVENT;
      setImmediate(() => {
        this.emit(this._opcode === 0x09 ? 'ping' : 'pong', data);
        this._state = GET_INFO;
        this.startLoop(cb);
      });
    }
  }

  /**
   * Builds an error object.
   *
   * @param {function(new:Error|RangeError)} ErrorCtor The error constructor
   * @param {String} message The error message
   * @param {Boolean} prefix Specifies whether or not to add a default prefix to
   *     `message`
   * @param {Number} statusCode The status code
   * @param {String} errorCode The exposed error code
   * @return {(Error|RangeError)} The error
   * @private
   */
  createError(ErrorCtor, message, prefix, statusCode, errorCode) {
    this._loop = false;
    this._errored = true;

    const err = new ErrorCtor(
      prefix ? `Invalid WebSocket frame: ${message}` : message
    );

    Error.captureStackTrace(err, this.createError);
    err.code = errorCode;
    err[kStatusCode] = statusCode;
    return err;
  }
}

module.exports = Receiver;


/***/ }),

/***/ 914:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* eslint no-unused-vars: ["error", { "varsIgnorePattern": "^Duplex" }] */



const { Duplex } = __webpack_require__(2203);
const { randomFillSync } = __webpack_require__(6982);

const PerMessageDeflate = __webpack_require__(2971);
const { EMPTY_BUFFER, kWebSocket, NOOP } = __webpack_require__(2614);
const { isBlob, isValidStatusCode } = __webpack_require__(5880);
const { mask: applyMask, toBuffer } = __webpack_require__(3338);

const kByteLength = Symbol('kByteLength');
const maskBuffer = Buffer.alloc(4);
const RANDOM_POOL_SIZE = 8 * 1024;
let randomPool;
let randomPoolPointer = RANDOM_POOL_SIZE;

const DEFAULT = 0;
const DEFLATING = 1;
const GET_BLOB_DATA = 2;

/**
 * HyBi Sender implementation.
 */
class Sender {
  /**
   * Creates a Sender instance.
   *
   * @param {Duplex} socket The connection socket
   * @param {Object} [extensions] An object containing the negotiated extensions
   * @param {Function} [generateMask] The function used to generate the masking
   *     key
   */
  constructor(socket, extensions, generateMask) {
    this._extensions = extensions || {};

    if (generateMask) {
      this._generateMask = generateMask;
      this._maskBuffer = Buffer.alloc(4);
    }

    this._socket = socket;

    this._firstFragment = true;
    this._compress = false;

    this._bufferedBytes = 0;
    this._queue = [];
    this._state = DEFAULT;
    this.onerror = NOOP;
    this[kWebSocket] = undefined;
  }

  /**
   * Frames a piece of data according to the HyBi WebSocket protocol.
   *
   * @param {(Buffer|String)} data The data to frame
   * @param {Object} options Options object
   * @param {Boolean} [options.fin=false] Specifies whether or not to set the
   *     FIN bit
   * @param {Function} [options.generateMask] The function used to generate the
   *     masking key
   * @param {Boolean} [options.mask=false] Specifies whether or not to mask
   *     `data`
   * @param {Buffer} [options.maskBuffer] The buffer used to store the masking
   *     key
   * @param {Number} options.opcode The opcode
   * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be
   *     modified
   * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the
   *     RSV1 bit
   * @return {(Buffer|String)[]} The framed data
   * @public
   */
  static frame(data, options) {
    let mask;
    let merge = false;
    let offset = 2;
    let skipMasking = false;

    if (options.mask) {
      mask = options.maskBuffer || maskBuffer;

      if (options.generateMask) {
        options.generateMask(mask);
      } else {
        if (randomPoolPointer === RANDOM_POOL_SIZE) {
          /* istanbul ignore else  */
          if (randomPool === undefined) {
            //
            // This is lazily initialized because server-sent frames must not
            // be masked so it may never be used.
            //
            randomPool = Buffer.alloc(RANDOM_POOL_SIZE);
          }

          randomFillSync(randomPool, 0, RANDOM_POOL_SIZE);
          randomPoolPointer = 0;
        }

        mask[0] = randomPool[randomPoolPointer++];
        mask[1] = randomPool[randomPoolPointer++];
        mask[2] = randomPool[randomPoolPointer++];
        mask[3] = randomPool[randomPoolPointer++];
      }

      skipMasking = (mask[0] | mask[1] | mask[2] | mask[3]) === 0;
      offset = 6;
    }

    let dataLength;

    if (typeof data === 'string') {
      if (
        (!options.mask || skipMasking) &&
        options[kByteLength] !== undefined
      ) {
        dataLength = options[kByteLength];
      } else {
        data = Buffer.from(data);
        dataLength = data.length;
      }
    } else {
      dataLength = data.length;
      merge = options.mask && options.readOnly && !skipMasking;
    }

    let payloadLength = dataLength;

    if (dataLength >= 65536) {
      offset += 8;
      payloadLength = 127;
    } else if (dataLength > 125) {
      offset += 2;
      payloadLength = 126;
    }

    const target = Buffer.allocUnsafe(merge ? dataLength + offset : offset);

    target[0] = options.fin ? options.opcode | 0x80 : options.opcode;
    if (options.rsv1) target[0] |= 0x40;

    target[1] = payloadLength;

    if (payloadLength === 126) {
      target.writeUInt16BE(dataLength, 2);
    } else if (payloadLength === 127) {
      target[2] = target[3] = 0;
      target.writeUIntBE(dataLength, 4, 6);
    }

    if (!options.mask) return [target, data];

    target[1] |= 0x80;
    target[offset - 4] = mask[0];
    target[offset - 3] = mask[1];
    target[offset - 2] = mask[2];
    target[offset - 1] = mask[3];

    if (skipMasking) return [target, data];

    if (merge) {
      applyMask(data, mask, target, offset, dataLength);
      return [target];
    }

    applyMask(data, mask, data, 0, dataLength);
    return [target, data];
  }

  /**
   * Sends a close message to the other peer.
   *
   * @param {Number} [code] The status code component of the body
   * @param {(String|Buffer)} [data] The message component of the body
   * @param {Boolean} [mask=false] Specifies whether or not to mask the message
   * @param {Function} [cb] Callback
   * @public
   */
  close(code, data, mask, cb) {
    let buf;

    if (code === undefined) {
      buf = EMPTY_BUFFER;
    } else if (typeof code !== 'number' || !isValidStatusCode(code)) {
      throw new TypeError('First argument must be a valid error code number');
    } else if (data === undefined || !data.length) {
      buf = Buffer.allocUnsafe(2);
      buf.writeUInt16BE(code, 0);
    } else {
      const length = Buffer.byteLength(data);

      if (length > 123) {
        throw new RangeError('The message must not be greater than 123 bytes');
      }

      buf = Buffer.allocUnsafe(2 + length);
      buf.writeUInt16BE(code, 0);

      if (typeof data === 'string') {
        buf.write(data, 2);
      } else {
        buf.set(data, 2);
      }
    }

    const options = {
      [kByteLength]: buf.length,
      fin: true,
      generateMask: this._generateMask,
      mask,
      maskBuffer: this._maskBuffer,
      opcode: 0x08,
      readOnly: false,
      rsv1: false
    };

    if (this._state !== DEFAULT) {
      this.enqueue([this.dispatch, buf, false, options, cb]);
    } else {
      this.sendFrame(Sender.frame(buf, options), cb);
    }
  }

  /**
   * Sends a ping message to the other peer.
   *
   * @param {*} data The message to send
   * @param {Boolean} [mask=false] Specifies whether or not to mask `data`
   * @param {Function} [cb] Callback
   * @public
   */
  ping(data, mask, cb) {
    let byteLength;
    let readOnly;

    if (typeof data === 'string') {
      byteLength = Buffer.byteLength(data);
      readOnly = false;
    } else if (isBlob(data)) {
      byteLength = data.size;
      readOnly = false;
    } else {
      data = toBuffer(data);
      byteLength = data.length;
      readOnly = toBuffer.readOnly;
    }

    if (byteLength > 125) {
      throw new RangeError('The data size must not be greater than 125 bytes');
    }

    const options = {
      [kByteLength]: byteLength,
      fin: true,
      generateMask: this._generateMask,
      mask,
      maskBuffer: this._maskBuffer,
      opcode: 0x09,
      readOnly,
      rsv1: false
    };

    if (isBlob(data)) {
      if (this._state !== DEFAULT) {
        this.enqueue([this.getBlobData, data, false, options, cb]);
      } else {
        this.getBlobData(data, false, options, cb);
      }
    } else if (this._state !== DEFAULT) {
      this.enqueue([this.dispatch, data, false, options, cb]);
    } else {
      this.sendFrame(Sender.frame(data, options), cb);
    }
  }

  /**
   * Sends a pong message to the other peer.
   *
   * @param {*} data The message to send
   * @param {Boolean} [mask=false] Specifies whether or not to mask `data`
   * @param {Function} [cb] Callback
   * @public
   */
  pong(data, mask, cb) {
    let byteLength;
    let readOnly;

    if (typeof data === 'string') {
      byteLength = Buffer.byteLength(data);
      readOnly = false;
    } else if (isBlob(data)) {
      byteLength = data.size;
      readOnly = false;
    } else {
      data = toBuffer(data);
      byteLength = data.length;
      readOnly = toBuffer.readOnly;
    }

    if (byteLength > 125) {
      throw new RangeError('The data size must not be greater than 125 bytes');
    }

    const options = {
      [kByteLength]: byteLength,
      fin: true,
      generateMask: this._generateMask,
      mask,
      maskBuffer: this._maskBuffer,
      opcode: 0x0a,
      readOnly,
      rsv1: false
    };

    if (isBlob(data)) {
      if (this._state !== DEFAULT) {
        this.enqueue([this.getBlobData, data, false, options, cb]);
      } else {
        this.getBlobData(data, false, options, cb);
      }
    } else if (this._state !== DEFAULT) {
      this.enqueue([this.dispatch, data, false, options, cb]);
    } else {
      this.sendFrame(Sender.frame(data, options), cb);
    }
  }

  /**
   * Sends a data message to the other peer.
   *
   * @param {*} data The message to send
   * @param {Object} options Options object
   * @param {Boolean} [options.binary=false] Specifies whether `data` is binary
   *     or text
   * @param {Boolean} [options.compress=false] Specifies whether or not to
   *     compress `data`
   * @param {Boolean} [options.fin=false] Specifies whether the fragment is the
   *     last one
   * @param {Boolean} [options.mask=false] Specifies whether or not to mask
   *     `data`
   * @param {Function} [cb] Callback
   * @public
   */
  send(data, options, cb) {
    const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
    let opcode = options.binary ? 2 : 1;
    let rsv1 = options.compress;

    let byteLength;
    let readOnly;

    if (typeof data === 'string') {
      byteLength = Buffer.byteLength(data);
      readOnly = false;
    } else if (isBlob(data)) {
      byteLength = data.size;
      readOnly = false;
    } else {
      data = toBuffer(data);
      byteLength = data.length;
      readOnly = toBuffer.readOnly;
    }

    if (this._firstFragment) {
      this._firstFragment = false;
      if (
        rsv1 &&
        perMessageDeflate &&
        perMessageDeflate.params[
          perMessageDeflate._isServer
            ? 'server_no_context_takeover'
            : 'client_no_context_takeover'
        ]
      ) {
        rsv1 = byteLength >= perMessageDeflate._threshold;
      }
      this._compress = rsv1;
    } else {
      rsv1 = false;
      opcode = 0;
    }

    if (options.fin) this._firstFragment = true;

    const opts = {
      [kByteLength]: byteLength,
      fin: options.fin,
      generateMask: this._generateMask,
      mask: options.mask,
      maskBuffer: this._maskBuffer,
      opcode,
      readOnly,
      rsv1
    };

    if (isBlob(data)) {
      if (this._state !== DEFAULT) {
        this.enqueue([this.getBlobData, data, this._compress, opts, cb]);
      } else {
        this.getBlobData(data, this._compress, opts, cb);
      }
    } else if (this._state !== DEFAULT) {
      this.enqueue([this.dispatch, data, this._compress, opts, cb]);
    } else {
      this.dispatch(data, this._compress, opts, cb);
    }
  }

  /**
   * Gets the contents of a blob as binary data.
   *
   * @param {Blob} blob The blob
   * @param {Boolean} [compress=false] Specifies whether or not to compress
   *     the data
   * @param {Object} options Options object
   * @param {Boolean} [options.fin=false] Specifies whether or not to set the
   *     FIN bit
   * @param {Function} [options.generateMask] The function used to generate the
   *     masking key
   * @param {Boolean} [options.mask=false] Specifies whether or not to mask
   *     `data`
   * @param {Buffer} [options.maskBuffer] The buffer used to store the masking
   *     key
   * @param {Number} options.opcode The opcode
   * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be
   *     modified
   * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the
   *     RSV1 bit
   * @param {Function} [cb] Callback
   * @private
   */
  getBlobData(blob, compress, options, cb) {
    this._bufferedBytes += options[kByteLength];
    this._state = GET_BLOB_DATA;

    blob
      .arrayBuffer()
      .then((arrayBuffer) => {
        if (this._socket.destroyed) {
          const err = new Error(
            'The socket was closed while the blob was being read'
          );

          //
          // `callCallbacks` is called in the next tick to ensure that errors
          // that might be thrown in the callbacks behave like errors thrown
          // outside the promise chain.
          //
          process.nextTick(callCallbacks, this, err, cb);
          return;
        }

        this._bufferedBytes -= options[kByteLength];
        const data = toBuffer(arrayBuffer);

        if (!compress) {
          this._state = DEFAULT;
          this.sendFrame(Sender.frame(data, options), cb);
          this.dequeue();
        } else {
          this.dispatch(data, compress, options, cb);
        }
      })
      .catch((err) => {
        //
        // `onError` is called in the next tick for the same reason that
        // `callCallbacks` above is.
        //
        process.nextTick(onError, this, err, cb);
      });
  }

  /**
   * Dispatches a message.
   *
   * @param {(Buffer|String)} data The message to send
   * @param {Boolean} [compress=false] Specifies whether or not to compress
   *     `data`
   * @param {Object} options Options object
   * @param {Boolean} [options.fin=false] Specifies whether or not to set the
   *     FIN bit
   * @param {Function} [options.generateMask] The function used to generate the
   *     masking key
   * @param {Boolean} [options.mask=false] Specifies whether or not to mask
   *     `data`
   * @param {Buffer} [options.maskBuffer] The buffer used to store the masking
   *     key
   * @param {Number} options.opcode The opcode
   * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be
   *     modified
   * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the
   *     RSV1 bit
   * @param {Function} [cb] Callback
   * @private
   */
  dispatch(data, compress, options, cb) {
    if (!compress) {
      this.sendFrame(Sender.frame(data, options), cb);
      return;
    }

    const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];

    this._bufferedBytes += options[kByteLength];
    this._state = DEFLATING;
    perMessageDeflate.compress(data, options.fin, (_, buf) => {
      if (this._socket.destroyed) {
        const err = new Error(
          'The socket was closed while data was being compressed'
        );

        callCallbacks(this, err, cb);
        return;
      }

      this._bufferedBytes -= options[kByteLength];
      this._state = DEFAULT;
      options.readOnly = false;
      this.sendFrame(Sender.frame(buf, options), cb);
      this.dequeue();
    });
  }

  /**
   * Executes queued send operations.
   *
   * @private
   */
  dequeue() {
    while (this._state === DEFAULT && this._queue.length) {
      const params = this._queue.shift();

      this._bufferedBytes -= params[3][kByteLength];
      Reflect.apply(params[0], this, params.slice(1));
    }
  }

  /**
   * Enqueues a send operation.
   *
   * @param {Array} params Send operation parameters.
   * @private
   */
  enqueue(params) {
    this._bufferedBytes += params[3][kByteLength];
    this._queue.push(params);
  }

  /**
   * Sends a frame.
   *
   * @param {Buffer[]} list The frame to send
   * @param {Function} [cb] Callback
   * @private
   */
  sendFrame(list, cb) {
    if (list.length === 2) {
      this._socket.cork();
      this._socket.write(list[0]);
      this._socket.write(list[1], cb);
      this._socket.uncork();
    } else {
      this._socket.write(list[0], cb);
    }
  }
}

module.exports = Sender;

/**
 * Calls queued callbacks with an error.
 *
 * @param {Sender} sender The `Sender` instance
 * @param {Error} err The error to call the callbacks with
 * @param {Function} [cb] The first callback
 * @private
 */
function callCallbacks(sender, err, cb) {
  if (typeof cb === 'function') cb(err);

  for (let i = 0; i < sender._queue.length; i++) {
    const params = sender._queue[i];
    const callback = params[params.length - 1];

    if (typeof callback === 'function') callback(err);
  }
}

/**
 * Handles a `Sender` error.
 *
 * @param {Sender} sender The `Sender` instance
 * @param {Error} err The error
 * @param {Function} [cb] The first pending callback
 * @private
 */
function onError(sender, err, cb) {
  callCallbacks(sender, err, cb);
  sender.onerror(err);
}


/***/ }),

/***/ 3719:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { Duplex } = __webpack_require__(2203);

/**
 * Emits the `'close'` event on a stream.
 *
 * @param {Duplex} stream The stream.
 * @private
 */
function emitClose(stream) {
  stream.emit('close');
}

/**
 * The listener of the `'end'` event.
 *
 * @private
 */
function duplexOnEnd() {
  if (!this.destroyed && this._writableState.finished) {
    this.destroy();
  }
}

/**
 * The listener of the `'error'` event.
 *
 * @param {Error} err The error
 * @private
 */
function duplexOnError(err) {
  this.removeListener('error', duplexOnError);
  this.destroy();
  if (this.listenerCount('error') === 0) {
    // Do not suppress the throwing behavior.
    this.emit('error', err);
  }
}

/**
 * Wraps a `WebSocket` in a duplex stream.
 *
 * @param {WebSocket} ws The `WebSocket` to wrap
 * @param {Object} [options] The options for the `Duplex` constructor
 * @return {Duplex} The duplex stream
 * @public
 */
function createWebSocketStream(ws, options) {
  let terminateOnDestroy = true;

  const duplex = new Duplex({
    ...options,
    autoDestroy: false,
    emitClose: false,
    objectMode: false,
    writableObjectMode: false
  });

  ws.on('message', function message(msg, isBinary) {
    const data =
      !isBinary && duplex._readableState.objectMode ? msg.toString() : msg;

    if (!duplex.push(data)) ws.pause();
  });

  ws.once('error', function error(err) {
    if (duplex.destroyed) return;

    // Prevent `ws.terminate()` from being called by `duplex._destroy()`.
    //
    // - If the `'error'` event is emitted before the `'open'` event, then
    //   `ws.terminate()` is a noop as no socket is assigned.
    // - Otherwise, the error is re-emitted by the listener of the `'error'`
    //   event of the `Receiver` object. The listener already closes the
    //   connection by calling `ws.close()`. This allows a close frame to be
    //   sent to the other peer. If `ws.terminate()` is called right after this,
    //   then the close frame might not be sent.
    terminateOnDestroy = false;
    duplex.destroy(err);
  });

  ws.once('close', function close() {
    if (duplex.destroyed) return;

    duplex.push(null);
  });

  duplex._destroy = function (err, callback) {
    if (ws.readyState === ws.CLOSED) {
      callback(err);
      process.nextTick(emitClose, duplex);
      return;
    }

    let called = false;

    ws.once('error', function error(err) {
      called = true;
      callback(err);
    });

    ws.once('close', function close() {
      if (!called) callback(err);
      process.nextTick(emitClose, duplex);
    });

    if (terminateOnDestroy) ws.terminate();
  };

  duplex._final = function (callback) {
    if (ws.readyState === ws.CONNECTING) {
      ws.once('open', function open() {
        duplex._final(callback);
      });
      return;
    }

    // If the value of the `_socket` property is `null` it means that `ws` is a
    // client websocket and the handshake failed. In fact, when this happens, a
    // socket is never assigned to the websocket. Wait for the `'error'` event
    // that will be emitted by the websocket.
    if (ws._socket === null) return;

    if (ws._socket._writableState.finished) {
      callback();
      if (duplex._readableState.endEmitted) duplex.destroy();
    } else {
      ws._socket.once('finish', function finish() {
        // `duplex` is not destroyed here because the `'end'` event will be
        // emitted on `duplex` after this `'finish'` event. The EOF signaling
        // `null` chunk is, in fact, pushed when the websocket emits `'close'`.
        callback();
      });
      ws.close();
    }
  };

  duplex._read = function () {
    if (ws.isPaused) ws.resume();
  };

  duplex._write = function (chunk, encoding, callback) {
    if (ws.readyState === ws.CONNECTING) {
      ws.once('open', function open() {
        duplex._write(chunk, encoding, callback);
      });
      return;
    }

    ws.send(chunk, callback);
  };

  duplex.on('end', duplexOnEnd);
  duplex.on('error', duplexOnError);
  return duplex;
}

module.exports = createWebSocketStream;


/***/ }),

/***/ 8237:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { tokenChars } = __webpack_require__(5880);

/**
 * Parses the `Sec-WebSocket-Protocol` header into a set of subprotocol names.
 *
 * @param {String} header The field value of the header
 * @return {Set} The subprotocol names
 * @public
 */
function parse(header) {
  const protocols = new Set();
  let start = -1;
  let end = -1;
  let i = 0;

  for (i; i < header.length; i++) {
    const code = header.charCodeAt(i);

    if (end === -1 && tokenChars[code] === 1) {
      if (start === -1) start = i;
    } else if (
      i !== 0 &&
      (code === 0x20 /* ' ' */ || code === 0x09) /* '\t' */
    ) {
      if (end === -1 && start !== -1) end = i;
    } else if (code === 0x2c /* ',' */) {
      if (start === -1) {
        throw new SyntaxError(`Unexpected character at index ${i}`);
      }

      if (end === -1) end = i;

      const protocol = header.slice(start, end);

      if (protocols.has(protocol)) {
        throw new SyntaxError(`The "${protocol}" subprotocol is duplicated`);
      }

      protocols.add(protocol);
      start = end = -1;
    } else {
      throw new SyntaxError(`Unexpected character at index ${i}`);
    }
  }

  if (start === -1 || end !== -1) {
    throw new SyntaxError('Unexpected end of input');
  }

  const protocol = header.slice(start, i);

  if (protocols.has(protocol)) {
    throw new SyntaxError(`The "${protocol}" subprotocol is duplicated`);
  }

  protocols.add(protocol);
  return protocols;
}

module.exports = { parse };


/***/ }),

/***/ 5880:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { isUtf8 } = __webpack_require__(181);

const { hasBlob } = __webpack_require__(2614);

//
// Allowed token characters:
//
// '!', '#', '$', '%', '&', ''', '*', '+', '-',
// '.', 0-9, A-Z, '^', '_', '`', a-z, '|', '~'
//
// tokenChars[32] === 0 // ' '
// tokenChars[33] === 1 // '!'
// tokenChars[34] === 0 // '"'
// ...
//
// prettier-ignore
const tokenChars = [
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 0 - 15
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 16 - 31
  0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, // 32 - 47
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, // 48 - 63
  0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 64 - 79
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, // 80 - 95
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 96 - 111
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0 // 112 - 127
];

/**
 * Checks if a status code is allowed in a close frame.
 *
 * @param {Number} code The status code
 * @return {Boolean} `true` if the status code is valid, else `false`
 * @public
 */
function isValidStatusCode(code) {
  return (
    (code >= 1000 &&
      code <= 1014 &&
      code !== 1004 &&
      code !== 1005 &&
      code !== 1006) ||
    (code >= 3000 && code <= 4999)
  );
}

/**
 * Checks if a given buffer contains only correct UTF-8.
 * Ported from https://www.cl.cam.ac.uk/%7Emgk25/ucs/utf8_check.c by
 * Markus Kuhn.
 *
 * @param {Buffer} buf The buffer to check
 * @return {Boolean} `true` if `buf` contains only correct UTF-8, else `false`
 * @public
 */
function _isValidUTF8(buf) {
  const len = buf.length;
  let i = 0;

  while (i < len) {
    if ((buf[i] & 0x80) === 0) {
      // 0xxxxxxx
      i++;
    } else if ((buf[i] & 0xe0) === 0xc0) {
      // 110xxxxx 10xxxxxx
      if (
        i + 1 === len ||
        (buf[i + 1] & 0xc0) !== 0x80 ||
        (buf[i] & 0xfe) === 0xc0 // Overlong
      ) {
        return false;
      }

      i += 2;
    } else if ((buf[i] & 0xf0) === 0xe0) {
      // 1110xxxx 10xxxxxx 10xxxxxx
      if (
        i + 2 >= len ||
        (buf[i + 1] & 0xc0) !== 0x80 ||
        (buf[i + 2] & 0xc0) !== 0x80 ||
        (buf[i] === 0xe0 && (buf[i + 1] & 0xe0) === 0x80) || // Overlong
        (buf[i] === 0xed && (buf[i + 1] & 0xe0) === 0xa0) // Surrogate (U+D800 - U+DFFF)
      ) {
        return false;
      }

      i += 3;
    } else if ((buf[i] & 0xf8) === 0xf0) {
      // 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
      if (
        i + 3 >= len ||
        (buf[i + 1] & 0xc0) !== 0x80 ||
        (buf[i + 2] & 0xc0) !== 0x80 ||
        (buf[i + 3] & 0xc0) !== 0x80 ||
        (buf[i] === 0xf0 && (buf[i + 1] & 0xf0) === 0x80) || // Overlong
        (buf[i] === 0xf4 && buf[i + 1] > 0x8f) ||
        buf[i] > 0xf4 // > U+10FFFF
      ) {
        return false;
      }

      i += 4;
    } else {
      return false;
    }
  }

  return true;
}

/**
 * Determines whether a value is a `Blob`.
 *
 * @param {*} value The value to be tested
 * @return {Boolean} `true` if `value` is a `Blob`, else `false`
 * @private
 */
function isBlob(value) {
  return (
    hasBlob &&
    typeof value === 'object' &&
    typeof value.arrayBuffer === 'function' &&
    typeof value.type === 'string' &&
    typeof value.stream === 'function' &&
    (value[Symbol.toStringTag] === 'Blob' ||
      value[Symbol.toStringTag] === 'File')
  );
}

module.exports = {
  isBlob,
  isValidStatusCode,
  isValidUTF8: _isValidUTF8,
  tokenChars
};

if (isUtf8) {
  module.exports.isValidUTF8 = function (buf) {
    return buf.length < 24 ? _isValidUTF8(buf) : isUtf8(buf);
  };
} /* istanbul ignore else  */ else if (!process.env.WS_NO_UTF_8_VALIDATE) {
  try {
    const isValidUTF8 = __webpack_require__(6809);

    module.exports.isValidUTF8 = function (buf) {
      return buf.length < 32 ? _isValidUTF8(buf) : isValidUTF8(buf);
    };
  } catch (e) {
    // Continue regardless of the error.
  }
}


/***/ }),

/***/ 1722:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* eslint no-unused-vars: ["error", { "varsIgnorePattern": "^Duplex$", "caughtErrors": "none" }] */



const EventEmitter = __webpack_require__(4434);
const http = __webpack_require__(8611);
const { Duplex } = __webpack_require__(2203);
const { createHash } = __webpack_require__(6982);

const extension = __webpack_require__(5926);
const PerMessageDeflate = __webpack_require__(2971);
const subprotocol = __webpack_require__(8237);
const WebSocket = __webpack_require__(1060);
const { GUID, kWebSocket } = __webpack_require__(2614);

const keyRegex = /^[+/0-9A-Za-z]{22}==$/;

const RUNNING = 0;
const CLOSING = 1;
const CLOSED = 2;

/**
 * Class representing a WebSocket server.
 *
 * @extends EventEmitter
 */
class WebSocketServer extends EventEmitter {
  /**
   * Create a `WebSocketServer` instance.
   *
   * @param {Object} options Configuration options
   * @param {Boolean} [options.allowSynchronousEvents=true] Specifies whether
   *     any of the `'message'`, `'ping'`, and `'pong'` events can be emitted
   *     multiple times in the same tick
   * @param {Boolean} [options.autoPong=true] Specifies whether or not to
   *     automatically send a pong in response to a ping
   * @param {Number} [options.backlog=511] The maximum length of the queue of
   *     pending connections
   * @param {Boolean} [options.clientTracking=true] Specifies whether or not to
   *     track clients
   * @param {Function} [options.handleProtocols] A hook to handle protocols
   * @param {String} [options.host] The hostname where to bind the server
   * @param {Number} [options.maxPayload=104857600] The maximum allowed message
   *     size
   * @param {Boolean} [options.noServer=false] Enable no server mode
   * @param {String} [options.path] Accept only connections matching this path
   * @param {(Boolean|Object)} [options.perMessageDeflate=false] Enable/disable
   *     permessage-deflate
   * @param {Number} [options.port] The port where to bind the server
   * @param {(http.Server|https.Server)} [options.server] A pre-created HTTP/S
   *     server to use
   * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
   *     not to skip UTF-8 validation for text and close messages
   * @param {Function} [options.verifyClient] A hook to reject connections
   * @param {Function} [options.WebSocket=WebSocket] Specifies the `WebSocket`
   *     class to use. It must be the `WebSocket` class or class that extends it
   * @param {Function} [callback] A listener for the `listening` event
   */
  constructor(options, callback) {
    super();

    options = {
      allowSynchronousEvents: true,
      autoPong: true,
      maxPayload: 100 * 1024 * 1024,
      skipUTF8Validation: false,
      perMessageDeflate: false,
      handleProtocols: null,
      clientTracking: true,
      verifyClient: null,
      noServer: false,
      backlog: null, // use default (511 as implemented in net.js)
      server: null,
      host: null,
      path: null,
      port: null,
      WebSocket,
      ...options
    };

    if (
      (options.port == null && !options.server && !options.noServer) ||
      (options.port != null && (options.server || options.noServer)) ||
      (options.server && options.noServer)
    ) {
      throw new TypeError(
        'One and only one of the "port", "server", or "noServer" options ' +
          'must be specified'
      );
    }

    if (options.port != null) {
      this._server = http.createServer((req, res) => {
        const body = http.STATUS_CODES[426];

        res.writeHead(426, {
          'Content-Length': body.length,
          'Content-Type': 'text/plain'
        });
        res.end(body);
      });
      this._server.listen(
        options.port,
        options.host,
        options.backlog,
        callback
      );
    } else if (options.server) {
      this._server = options.server;
    }

    if (this._server) {
      const emitConnection = this.emit.bind(this, 'connection');

      this._removeListeners = addListeners(this._server, {
        listening: this.emit.bind(this, 'listening'),
        error: this.emit.bind(this, 'error'),
        upgrade: (req, socket, head) => {
          this.handleUpgrade(req, socket, head, emitConnection);
        }
      });
    }

    if (options.perMessageDeflate === true) options.perMessageDeflate = {};
    if (options.clientTracking) {
      this.clients = new Set();
      this._shouldEmitClose = false;
    }

    this.options = options;
    this._state = RUNNING;
  }

  /**
   * Returns the bound address, the address family name, and port of the server
   * as reported by the operating system if listening on an IP socket.
   * If the server is listening on a pipe or UNIX domain socket, the name is
   * returned as a string.
   *
   * @return {(Object|String|null)} The address of the server
   * @public
   */
  address() {
    if (this.options.noServer) {
      throw new Error('The server is operating in "noServer" mode');
    }

    if (!this._server) return null;
    return this._server.address();
  }

  /**
   * Stop the server from accepting new connections and emit the `'close'` event
   * when all existing connections are closed.
   *
   * @param {Function} [cb] A one-time listener for the `'close'` event
   * @public
   */
  close(cb) {
    if (this._state === CLOSED) {
      if (cb) {
        this.once('close', () => {
          cb(new Error('The server is not running'));
        });
      }

      process.nextTick(emitClose, this);
      return;
    }

    if (cb) this.once('close', cb);

    if (this._state === CLOSING) return;
    this._state = CLOSING;

    if (this.options.noServer || this.options.server) {
      if (this._server) {
        this._removeListeners();
        this._removeListeners = this._server = null;
      }

      if (this.clients) {
        if (!this.clients.size) {
          process.nextTick(emitClose, this);
        } else {
          this._shouldEmitClose = true;
        }
      } else {
        process.nextTick(emitClose, this);
      }
    } else {
      const server = this._server;

      this._removeListeners();
      this._removeListeners = this._server = null;

      //
      // The HTTP/S server was created internally. Close it, and rely on its
      // `'close'` event.
      //
      server.close(() => {
        emitClose(this);
      });
    }
  }

  /**
   * See if a given request should be handled by this server instance.
   *
   * @param {http.IncomingMessage} req Request object to inspect
   * @return {Boolean} `true` if the request is valid, else `false`
   * @public
   */
  shouldHandle(req) {
    if (this.options.path) {
      const index = req.url.indexOf('?');
      const pathname = index !== -1 ? req.url.slice(0, index) : req.url;

      if (pathname !== this.options.path) return false;
    }

    return true;
  }

  /**
   * Handle a HTTP Upgrade request.
   *
   * @param {http.IncomingMessage} req The request object
   * @param {Duplex} socket The network socket between the server and client
   * @param {Buffer} head The first packet of the upgraded stream
   * @param {Function} cb Callback
   * @public
   */
  handleUpgrade(req, socket, head, cb) {
    socket.on('error', socketOnError);

    const key = req.headers['sec-websocket-key'];
    const upgrade = req.headers.upgrade;
    const version = +req.headers['sec-websocket-version'];

    if (req.method !== 'GET') {
      const message = 'Invalid HTTP method';
      abortHandshakeOrEmitwsClientError(this, req, socket, 405, message);
      return;
    }

    if (upgrade === undefined || upgrade.toLowerCase() !== 'websocket') {
      const message = 'Invalid Upgrade header';
      abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
      return;
    }

    if (key === undefined || !keyRegex.test(key)) {
      const message = 'Missing or invalid Sec-WebSocket-Key header';
      abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
      return;
    }

    if (version !== 8 && version !== 13) {
      const message = 'Missing or invalid Sec-WebSocket-Version header';
      abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
      return;
    }

    if (!this.shouldHandle(req)) {
      abortHandshake(socket, 400);
      return;
    }

    const secWebSocketProtocol = req.headers['sec-websocket-protocol'];
    let protocols = new Set();

    if (secWebSocketProtocol !== undefined) {
      try {
        protocols = subprotocol.parse(secWebSocketProtocol);
      } catch (err) {
        const message = 'Invalid Sec-WebSocket-Protocol header';
        abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
        return;
      }
    }

    const secWebSocketExtensions = req.headers['sec-websocket-extensions'];
    const extensions = {};

    if (
      this.options.perMessageDeflate &&
      secWebSocketExtensions !== undefined
    ) {
      const perMessageDeflate = new PerMessageDeflate(
        this.options.perMessageDeflate,
        true,
        this.options.maxPayload
      );

      try {
        const offers = extension.parse(secWebSocketExtensions);

        if (offers[PerMessageDeflate.extensionName]) {
          perMessageDeflate.accept(offers[PerMessageDeflate.extensionName]);
          extensions[PerMessageDeflate.extensionName] = perMessageDeflate;
        }
      } catch (err) {
        const message =
          'Invalid or unacceptable Sec-WebSocket-Extensions header';
        abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
        return;
      }
    }

    //
    // Optionally call external client verification handler.
    //
    if (this.options.verifyClient) {
      const info = {
        origin:
          req.headers[`${version === 8 ? 'sec-websocket-origin' : 'origin'}`],
        secure: !!(req.socket.authorized || req.socket.encrypted),
        req
      };

      if (this.options.verifyClient.length === 2) {
        this.options.verifyClient(info, (verified, code, message, headers) => {
          if (!verified) {
            return abortHandshake(socket, code || 401, message, headers);
          }

          this.completeUpgrade(
            extensions,
            key,
            protocols,
            req,
            socket,
            head,
            cb
          );
        });
        return;
      }

      if (!this.options.verifyClient(info)) return abortHandshake(socket, 401);
    }

    this.completeUpgrade(extensions, key, protocols, req, socket, head, cb);
  }

  /**
   * Upgrade the connection to WebSocket.
   *
   * @param {Object} extensions The accepted extensions
   * @param {String} key The value of the `Sec-WebSocket-Key` header
   * @param {Set} protocols The subprotocols
   * @param {http.IncomingMessage} req The request object
   * @param {Duplex} socket The network socket between the server and client
   * @param {Buffer} head The first packet of the upgraded stream
   * @param {Function} cb Callback
   * @throws {Error} If called more than once with the same socket
   * @private
   */
  completeUpgrade(extensions, key, protocols, req, socket, head, cb) {
    //
    // Destroy the socket if the client has already sent a FIN packet.
    //
    if (!socket.readable || !socket.writable) return socket.destroy();

    if (socket[kWebSocket]) {
      throw new Error(
        'server.handleUpgrade() was called more than once with the same ' +
          'socket, possibly due to a misconfiguration'
      );
    }

    if (this._state > RUNNING) return abortHandshake(socket, 503);

    const digest = createHash('sha1')
      .update(key + GUID)
      .digest('base64');

    const headers = [
      'HTTP/1.1 101 Switching Protocols',
      'Upgrade: websocket',
      'Connection: Upgrade',
      `Sec-WebSocket-Accept: ${digest}`
    ];

    const ws = new this.options.WebSocket(null, undefined, this.options);

    if (protocols.size) {
      //
      // Optionally call external protocol selection handler.
      //
      const protocol = this.options.handleProtocols
        ? this.options.handleProtocols(protocols, req)
        : protocols.values().next().value;

      if (protocol) {
        headers.push(`Sec-WebSocket-Protocol: ${protocol}`);
        ws._protocol = protocol;
      }
    }

    if (extensions[PerMessageDeflate.extensionName]) {
      const params = extensions[PerMessageDeflate.extensionName].params;
      const value = extension.format({
        [PerMessageDeflate.extensionName]: [params]
      });
      headers.push(`Sec-WebSocket-Extensions: ${value}`);
      ws._extensions = extensions;
    }

    //
    // Allow external modification/inspection of handshake headers.
    //
    this.emit('headers', headers, req);

    socket.write(headers.concat('\r\n').join('\r\n'));
    socket.removeListener('error', socketOnError);

    ws.setSocket(socket, head, {
      allowSynchronousEvents: this.options.allowSynchronousEvents,
      maxPayload: this.options.maxPayload,
      skipUTF8Validation: this.options.skipUTF8Validation
    });

    if (this.clients) {
      this.clients.add(ws);
      ws.on('close', () => {
        this.clients.delete(ws);

        if (this._shouldEmitClose && !this.clients.size) {
          process.nextTick(emitClose, this);
        }
      });
    }

    cb(ws, req);
  }
}

module.exports = WebSocketServer;

/**
 * Add event listeners on an `EventEmitter` using a map of <event, listener>
 * pairs.
 *
 * @param {EventEmitter} server The event emitter
 * @param {Object.<String, Function>} map The listeners to add
 * @return {Function} A function that will remove the added listeners when
 *     called
 * @private
 */
function addListeners(server, map) {
  for (const event of Object.keys(map)) server.on(event, map[event]);

  return function removeListeners() {
    for (const event of Object.keys(map)) {
      server.removeListener(event, map[event]);
    }
  };
}

/**
 * Emit a `'close'` event on an `EventEmitter`.
 *
 * @param {EventEmitter} server The event emitter
 * @private
 */
function emitClose(server) {
  server._state = CLOSED;
  server.emit('close');
}

/**
 * Handle socket errors.
 *
 * @private
 */
function socketOnError() {
  this.destroy();
}

/**
 * Close the connection when preconditions are not fulfilled.
 *
 * @param {Duplex} socket The socket of the upgrade request
 * @param {Number} code The HTTP response status code
 * @param {String} [message] The HTTP response body
 * @param {Object} [headers] Additional HTTP response headers
 * @private
 */
function abortHandshake(socket, code, message, headers) {
  //
  // The socket is writable unless the user destroyed or ended it before calling
  // `server.handleUpgrade()` or in the `verifyClient` function, which is a user
  // error. Handling this does not make much sense as the worst that can happen
  // is that some of the data written by the user might be discarded due to the
  // call to `socket.end()` below, which triggers an `'error'` event that in
  // turn causes the socket to be destroyed.
  //
  message = message || http.STATUS_CODES[code];
  headers = {
    Connection: 'close',
    'Content-Type': 'text/html',
    'Content-Length': Buffer.byteLength(message),
    ...headers
  };

  socket.once('finish', socket.destroy);

  socket.end(
    `HTTP/1.1 ${code} ${http.STATUS_CODES[code]}\r\n` +
      Object.keys(headers)
        .map((h) => `${h}: ${headers[h]}`)
        .join('\r\n') +
      '\r\n\r\n' +
      message
  );
}

/**
 * Emit a `'wsClientError'` event on a `WebSocketServer` if there is at least
 * one listener for it, otherwise call `abortHandshake()`.
 *
 * @param {WebSocketServer} server The WebSocket server
 * @param {http.IncomingMessage} req The request object
 * @param {Duplex} socket The socket of the upgrade request
 * @param {Number} code The HTTP response status code
 * @param {String} message The HTTP response body
 * @private
 */
function abortHandshakeOrEmitwsClientError(server, req, socket, code, message) {
  if (server.listenerCount('wsClientError')) {
    const err = new Error(message);
    Error.captureStackTrace(err, abortHandshakeOrEmitwsClientError);

    server.emit('wsClientError', err, socket, req);
  } else {
    abortHandshake(socket, code, message);
  }
}


/***/ }),

/***/ 1060:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* eslint no-unused-vars: ["error", { "varsIgnorePattern": "^Duplex|Readable$", "caughtErrors": "none" }] */



const EventEmitter = __webpack_require__(4434);
const https = __webpack_require__(5692);
const http = __webpack_require__(8611);
const net = __webpack_require__(9278);
const tls = __webpack_require__(4756);
const { randomBytes, createHash } = __webpack_require__(6982);
const { Duplex, Readable } = __webpack_require__(2203);
const { URL } = __webpack_require__(7016);

const PerMessageDeflate = __webpack_require__(2971);
const Receiver = __webpack_require__(6286);
const Sender = __webpack_require__(914);
const { isBlob } = __webpack_require__(5880);

const {
  BINARY_TYPES,
  EMPTY_BUFFER,
  GUID,
  kForOnEventAttribute,
  kListener,
  kStatusCode,
  kWebSocket,
  NOOP
} = __webpack_require__(2614);
const {
  EventTarget: { addEventListener, removeEventListener }
} = __webpack_require__(597);
const { format, parse } = __webpack_require__(5926);
const { toBuffer } = __webpack_require__(3338);

const closeTimeout = 30 * 1000;
const kAborted = Symbol('kAborted');
const protocolVersions = [8, 13];
const readyStates = ['CONNECTING', 'OPEN', 'CLOSING', 'CLOSED'];
const subprotocolRegex = /^[!#$%&'*+\-.0-9A-Z^_`|a-z~]+$/;

/**
 * Class representing a WebSocket.
 *
 * @extends EventEmitter
 */
class WebSocket extends EventEmitter {
  /**
   * Create a new `WebSocket`.
   *
   * @param {(String|URL)} address The URL to which to connect
   * @param {(String|String[])} [protocols] The subprotocols
   * @param {Object} [options] Connection options
   */
  constructor(address, protocols, options) {
    super();

    this._binaryType = BINARY_TYPES[0];
    this._closeCode = 1006;
    this._closeFrameReceived = false;
    this._closeFrameSent = false;
    this._closeMessage = EMPTY_BUFFER;
    this._closeTimer = null;
    this._errorEmitted = false;
    this._extensions = {};
    this._paused = false;
    this._protocol = '';
    this._readyState = WebSocket.CONNECTING;
    this._receiver = null;
    this._sender = null;
    this._socket = null;

    if (address !== null) {
      this._bufferedAmount = 0;
      this._isServer = false;
      this._redirects = 0;

      if (protocols === undefined) {
        protocols = [];
      } else if (!Array.isArray(protocols)) {
        if (typeof protocols === 'object' && protocols !== null) {
          options = protocols;
          protocols = [];
        } else {
          protocols = [protocols];
        }
      }

      initAsClient(this, address, protocols, options);
    } else {
      this._autoPong = options.autoPong;
      this._isServer = true;
    }
  }

  /**
   * For historical reasons, the custom "nodebuffer" type is used by the default
   * instead of "blob".
   *
   * @type {String}
   */
  get binaryType() {
    return this._binaryType;
  }

  set binaryType(type) {
    if (!BINARY_TYPES.includes(type)) return;

    this._binaryType = type;

    //
    // Allow to change `binaryType` on the fly.
    //
    if (this._receiver) this._receiver._binaryType = type;
  }

  /**
   * @type {Number}
   */
  get bufferedAmount() {
    if (!this._socket) return this._bufferedAmount;

    return this._socket._writableState.length + this._sender._bufferedBytes;
  }

  /**
   * @type {String}
   */
  get extensions() {
    return Object.keys(this._extensions).join();
  }

  /**
   * @type {Boolean}
   */
  get isPaused() {
    return this._paused;
  }

  /**
   * @type {Function}
   */
  /* istanbul ignore next */
  get onclose() {
    return null;
  }

  /**
   * @type {Function}
   */
  /* istanbul ignore next */
  get onerror() {
    return null;
  }

  /**
   * @type {Function}
   */
  /* istanbul ignore next */
  get onopen() {
    return null;
  }

  /**
   * @type {Function}
   */
  /* istanbul ignore next */
  get onmessage() {
    return null;
  }

  /**
   * @type {String}
   */
  get protocol() {
    return this._protocol;
  }

  /**
   * @type {Number}
   */
  get readyState() {
    return this._readyState;
  }

  /**
   * @type {String}
   */
  get url() {
    return this._url;
  }

  /**
   * Set up the socket and the internal resources.
   *
   * @param {Duplex} socket The network socket between the server and client
   * @param {Buffer} head The first packet of the upgraded stream
   * @param {Object} options Options object
   * @param {Boolean} [options.allowSynchronousEvents=false] Specifies whether
   *     any of the `'message'`, `'ping'`, and `'pong'` events can be emitted
   *     multiple times in the same tick
   * @param {Function} [options.generateMask] The function used to generate the
   *     masking key
   * @param {Number} [options.maxPayload=0] The maximum allowed message size
   * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
   *     not to skip UTF-8 validation for text and close messages
   * @private
   */
  setSocket(socket, head, options) {
    const receiver = new Receiver({
      allowSynchronousEvents: options.allowSynchronousEvents,
      binaryType: this.binaryType,
      extensions: this._extensions,
      isServer: this._isServer,
      maxPayload: options.maxPayload,
      skipUTF8Validation: options.skipUTF8Validation
    });

    const sender = new Sender(socket, this._extensions, options.generateMask);

    this._receiver = receiver;
    this._sender = sender;
    this._socket = socket;

    receiver[kWebSocket] = this;
    sender[kWebSocket] = this;
    socket[kWebSocket] = this;

    receiver.on('conclude', receiverOnConclude);
    receiver.on('drain', receiverOnDrain);
    receiver.on('error', receiverOnError);
    receiver.on('message', receiverOnMessage);
    receiver.on('ping', receiverOnPing);
    receiver.on('pong', receiverOnPong);

    sender.onerror = senderOnError;

    //
    // These methods may not be available if `socket` is just a `Duplex`.
    //
    if (socket.setTimeout) socket.setTimeout(0);
    if (socket.setNoDelay) socket.setNoDelay();

    if (head.length > 0) socket.unshift(head);

    socket.on('close', socketOnClose);
    socket.on('data', socketOnData);
    socket.on('end', socketOnEnd);
    socket.on('error', socketOnError);

    this._readyState = WebSocket.OPEN;
    this.emit('open');
  }

  /**
   * Emit the `'close'` event.
   *
   * @private
   */
  emitClose() {
    if (!this._socket) {
      this._readyState = WebSocket.CLOSED;
      this.emit('close', this._closeCode, this._closeMessage);
      return;
    }

    if (this._extensions[PerMessageDeflate.extensionName]) {
      this._extensions[PerMessageDeflate.extensionName].cleanup();
    }

    this._receiver.removeAllListeners();
    this._readyState = WebSocket.CLOSED;
    this.emit('close', this._closeCode, this._closeMessage);
  }

  /**
   * Start a closing handshake.
   *
   *          +----------+   +-----------+   +----------+
   *     - - -|ws.close()|-->|close frame|-->|ws.close()|- - -
   *    |     +----------+   +-----------+   +----------+     |
   *          +----------+   +-----------+         |
   * CLOSING  |ws.close()|<--|close frame|<--+-----+       CLOSING
   *          +----------+   +-----------+   |
   *    |           |                        |   +---+        |
   *                +------------------------+-->|fin| - - - -
   *    |         +---+                      |   +---+
   *     - - - - -|fin|<---------------------+
   *              +---+
   *
   * @param {Number} [code] Status code explaining why the connection is closing
   * @param {(String|Buffer)} [data] The reason why the connection is
   *     closing
   * @public
   */
  close(code, data) {
    if (this.readyState === WebSocket.CLOSED) return;
    if (this.readyState === WebSocket.CONNECTING) {
      const msg = 'WebSocket was closed before the connection was established';
      abortHandshake(this, this._req, msg);
      return;
    }

    if (this.readyState === WebSocket.CLOSING) {
      if (
        this._closeFrameSent &&
        (this._closeFrameReceived || this._receiver._writableState.errorEmitted)
      ) {
        this._socket.end();
      }

      return;
    }

    this._readyState = WebSocket.CLOSING;
    this._sender.close(code, data, !this._isServer, (err) => {
      //
      // This error is handled by the `'error'` listener on the socket. We only
      // want to know if the close frame has been sent here.
      //
      if (err) return;

      this._closeFrameSent = true;

      if (
        this._closeFrameReceived ||
        this._receiver._writableState.errorEmitted
      ) {
        this._socket.end();
      }
    });

    setCloseTimer(this);
  }

  /**
   * Pause the socket.
   *
   * @public
   */
  pause() {
    if (
      this.readyState === WebSocket.CONNECTING ||
      this.readyState === WebSocket.CLOSED
    ) {
      return;
    }

    this._paused = true;
    this._socket.pause();
  }

  /**
   * Send a ping.
   *
   * @param {*} [data] The data to send
   * @param {Boolean} [mask] Indicates whether or not to mask `data`
   * @param {Function} [cb] Callback which is executed when the ping is sent
   * @public
   */
  ping(data, mask, cb) {
    if (this.readyState === WebSocket.CONNECTING) {
      throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');
    }

    if (typeof data === 'function') {
      cb = data;
      data = mask = undefined;
    } else if (typeof mask === 'function') {
      cb = mask;
      mask = undefined;
    }

    if (typeof data === 'number') data = data.toString();

    if (this.readyState !== WebSocket.OPEN) {
      sendAfterClose(this, data, cb);
      return;
    }

    if (mask === undefined) mask = !this._isServer;
    this._sender.ping(data || EMPTY_BUFFER, mask, cb);
  }

  /**
   * Send a pong.
   *
   * @param {*} [data] The data to send
   * @param {Boolean} [mask] Indicates whether or not to mask `data`
   * @param {Function} [cb] Callback which is executed when the pong is sent
   * @public
   */
  pong(data, mask, cb) {
    if (this.readyState === WebSocket.CONNECTING) {
      throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');
    }

    if (typeof data === 'function') {
      cb = data;
      data = mask = undefined;
    } else if (typeof mask === 'function') {
      cb = mask;
      mask = undefined;
    }

    if (typeof data === 'number') data = data.toString();

    if (this.readyState !== WebSocket.OPEN) {
      sendAfterClose(this, data, cb);
      return;
    }

    if (mask === undefined) mask = !this._isServer;
    this._sender.pong(data || EMPTY_BUFFER, mask, cb);
  }

  /**
   * Resume the socket.
   *
   * @public
   */
  resume() {
    if (
      this.readyState === WebSocket.CONNECTING ||
      this.readyState === WebSocket.CLOSED
    ) {
      return;
    }

    this._paused = false;
    if (!this._receiver._writableState.needDrain) this._socket.resume();
  }

  /**
   * Send a data message.
   *
   * @param {*} data The message to send
   * @param {Object} [options] Options object
   * @param {Boolean} [options.binary] Specifies whether `data` is binary or
   *     text
   * @param {Boolean} [options.compress] Specifies whether or not to compress
   *     `data`
   * @param {Boolean} [options.fin=true] Specifies whether the fragment is the
   *     last one
   * @param {Boolean} [options.mask] Specifies whether or not to mask `data`
   * @param {Function} [cb] Callback which is executed when data is written out
   * @public
   */
  send(data, options, cb) {
    if (this.readyState === WebSocket.CONNECTING) {
      throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');
    }

    if (typeof options === 'function') {
      cb = options;
      options = {};
    }

    if (typeof data === 'number') data = data.toString();

    if (this.readyState !== WebSocket.OPEN) {
      sendAfterClose(this, data, cb);
      return;
    }

    const opts = {
      binary: typeof data !== 'string',
      mask: !this._isServer,
      compress: true,
      fin: true,
      ...options
    };

    if (!this._extensions[PerMessageDeflate.extensionName]) {
      opts.compress = false;
    }

    this._sender.send(data || EMPTY_BUFFER, opts, cb);
  }

  /**
   * Forcibly close the connection.
   *
   * @public
   */
  terminate() {
    if (this.readyState === WebSocket.CLOSED) return;
    if (this.readyState === WebSocket.CONNECTING) {
      const msg = 'WebSocket was closed before the connection was established';
      abortHandshake(this, this._req, msg);
      return;
    }

    if (this._socket) {
      this._readyState = WebSocket.CLOSING;
      this._socket.destroy();
    }
  }
}

/**
 * @constant {Number} CONNECTING
 * @memberof WebSocket
 */
Object.defineProperty(WebSocket, 'CONNECTING', {
  enumerable: true,
  value: readyStates.indexOf('CONNECTING')
});

/**
 * @constant {Number} CONNECTING
 * @memberof WebSocket.prototype
 */
Object.defineProperty(WebSocket.prototype, 'CONNECTING', {
  enumerable: true,
  value: readyStates.indexOf('CONNECTING')
});

/**
 * @constant {Number} OPEN
 * @memberof WebSocket
 */
Object.defineProperty(WebSocket, 'OPEN', {
  enumerable: true,
  value: readyStates.indexOf('OPEN')
});

/**
 * @constant {Number} OPEN
 * @memberof WebSocket.prototype
 */
Object.defineProperty(WebSocket.prototype, 'OPEN', {
  enumerable: true,
  value: readyStates.indexOf('OPEN')
});

/**
 * @constant {Number} CLOSING
 * @memberof WebSocket
 */
Object.defineProperty(WebSocket, 'CLOSING', {
  enumerable: true,
  value: readyStates.indexOf('CLOSING')
});

/**
 * @constant {Number} CLOSING
 * @memberof WebSocket.prototype
 */
Object.defineProperty(WebSocket.prototype, 'CLOSING', {
  enumerable: true,
  value: readyStates.indexOf('CLOSING')
});

/**
 * @constant {Number} CLOSED
 * @memberof WebSocket
 */
Object.defineProperty(WebSocket, 'CLOSED', {
  enumerable: true,
  value: readyStates.indexOf('CLOSED')
});

/**
 * @constant {Number} CLOSED
 * @memberof WebSocket.prototype
 */
Object.defineProperty(WebSocket.prototype, 'CLOSED', {
  enumerable: true,
  value: readyStates.indexOf('CLOSED')
});

[
  'binaryType',
  'bufferedAmount',
  'extensions',
  'isPaused',
  'protocol',
  'readyState',
  'url'
].forEach((property) => {
  Object.defineProperty(WebSocket.prototype, property, { enumerable: true });
});

//
// Add the `onopen`, `onerror`, `onclose`, and `onmessage` attributes.
// See https://html.spec.whatwg.org/multipage/comms.html#the-websocket-interface
//
['open', 'error', 'close', 'message'].forEach((method) => {
  Object.defineProperty(WebSocket.prototype, `on${method}`, {
    enumerable: true,
    get() {
      for (const listener of this.listeners(method)) {
        if (listener[kForOnEventAttribute]) return listener[kListener];
      }

      return null;
    },
    set(handler) {
      for (const listener of this.listeners(method)) {
        if (listener[kForOnEventAttribute]) {
          this.removeListener(method, listener);
          break;
        }
      }

      if (typeof handler !== 'function') return;

      this.addEventListener(method, handler, {
        [kForOnEventAttribute]: true
      });
    }
  });
});

WebSocket.prototype.addEventListener = addEventListener;
WebSocket.prototype.removeEventListener = removeEventListener;

module.exports = WebSocket;

/**
 * Initialize a WebSocket client.
 *
 * @param {WebSocket} websocket The client to initialize
 * @param {(String|URL)} address The URL to which to connect
 * @param {Array} protocols The subprotocols
 * @param {Object} [options] Connection options
 * @param {Boolean} [options.allowSynchronousEvents=true] Specifies whether any
 *     of the `'message'`, `'ping'`, and `'pong'` events can be emitted multiple
 *     times in the same tick
 * @param {Boolean} [options.autoPong=true] Specifies whether or not to
 *     automatically send a pong in response to a ping
 * @param {Function} [options.finishRequest] A function which can be used to
 *     customize the headers of each http request before it is sent
 * @param {Boolean} [options.followRedirects=false] Whether or not to follow
 *     redirects
 * @param {Function} [options.generateMask] The function used to generate the
 *     masking key
 * @param {Number} [options.handshakeTimeout] Timeout in milliseconds for the
 *     handshake request
 * @param {Number} [options.maxPayload=104857600] The maximum allowed message
 *     size
 * @param {Number} [options.maxRedirects=10] The maximum number of redirects
 *     allowed
 * @param {String} [options.origin] Value of the `Origin` or
 *     `Sec-WebSocket-Origin` header
 * @param {(Boolean|Object)} [options.perMessageDeflate=true] Enable/disable
 *     permessage-deflate
 * @param {Number} [options.protocolVersion=13] Value of the
 *     `Sec-WebSocket-Version` header
 * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
 *     not to skip UTF-8 validation for text and close messages
 * @private
 */
function initAsClient(websocket, address, protocols, options) {
  const opts = {
    allowSynchronousEvents: true,
    autoPong: true,
    protocolVersion: protocolVersions[1],
    maxPayload: 100 * 1024 * 1024,
    skipUTF8Validation: false,
    perMessageDeflate: true,
    followRedirects: false,
    maxRedirects: 10,
    ...options,
    socketPath: undefined,
    hostname: undefined,
    protocol: undefined,
    timeout: undefined,
    method: 'GET',
    host: undefined,
    path: undefined,
    port: undefined
  };

  websocket._autoPong = opts.autoPong;

  if (!protocolVersions.includes(opts.protocolVersion)) {
    throw new RangeError(
      `Unsupported protocol version: ${opts.protocolVersion} ` +
        `(supported versions: ${protocolVersions.join(', ')})`
    );
  }

  let parsedUrl;

  if (address instanceof URL) {
    parsedUrl = address;
  } else {
    try {
      parsedUrl = new URL(address);
    } catch (e) {
      throw new SyntaxError(`Invalid URL: ${address}`);
    }
  }

  if (parsedUrl.protocol === 'http:') {
    parsedUrl.protocol = 'ws:';
  } else if (parsedUrl.protocol === 'https:') {
    parsedUrl.protocol = 'wss:';
  }

  websocket._url = parsedUrl.href;

  const isSecure = parsedUrl.protocol === 'wss:';
  const isIpcUrl = parsedUrl.protocol === 'ws+unix:';
  let invalidUrlMessage;

  if (parsedUrl.protocol !== 'ws:' && !isSecure && !isIpcUrl) {
    invalidUrlMessage =
      'The URL\'s protocol must be one of "ws:", "wss:", ' +
      '"http:", "https", or "ws+unix:"';
  } else if (isIpcUrl && !parsedUrl.pathname) {
    invalidUrlMessage = "The URL's pathname is empty";
  } else if (parsedUrl.hash) {
    invalidUrlMessage = 'The URL contains a fragment identifier';
  }

  if (invalidUrlMessage) {
    const err = new SyntaxError(invalidUrlMessage);

    if (websocket._redirects === 0) {
      throw err;
    } else {
      emitErrorAndClose(websocket, err);
      return;
    }
  }

  const defaultPort = isSecure ? 443 : 80;
  const key = randomBytes(16).toString('base64');
  const request = isSecure ? https.request : http.request;
  const protocolSet = new Set();
  let perMessageDeflate;

  opts.createConnection =
    opts.createConnection || (isSecure ? tlsConnect : netConnect);
  opts.defaultPort = opts.defaultPort || defaultPort;
  opts.port = parsedUrl.port || defaultPort;
  opts.host = parsedUrl.hostname.startsWith('[')
    ? parsedUrl.hostname.slice(1, -1)
    : parsedUrl.hostname;
  opts.headers = {
    ...opts.headers,
    'Sec-WebSocket-Version': opts.protocolVersion,
    'Sec-WebSocket-Key': key,
    Connection: 'Upgrade',
    Upgrade: 'websocket'
  };
  opts.path = parsedUrl.pathname + parsedUrl.search;
  opts.timeout = opts.handshakeTimeout;

  if (opts.perMessageDeflate) {
    perMessageDeflate = new PerMessageDeflate(
      opts.perMessageDeflate !== true ? opts.perMessageDeflate : {},
      false,
      opts.maxPayload
    );
    opts.headers['Sec-WebSocket-Extensions'] = format({
      [PerMessageDeflate.extensionName]: perMessageDeflate.offer()
    });
  }
  if (protocols.length) {
    for (const protocol of protocols) {
      if (
        typeof protocol !== 'string' ||
        !subprotocolRegex.test(protocol) ||
        protocolSet.has(protocol)
      ) {
        throw new SyntaxError(
          'An invalid or duplicated subprotocol was specified'
        );
      }

      protocolSet.add(protocol);
    }

    opts.headers['Sec-WebSocket-Protocol'] = protocols.join(',');
  }
  if (opts.origin) {
    if (opts.protocolVersion < 13) {
      opts.headers['Sec-WebSocket-Origin'] = opts.origin;
    } else {
      opts.headers.Origin = opts.origin;
    }
  }
  if (parsedUrl.username || parsedUrl.password) {
    opts.auth = `${parsedUrl.username}:${parsedUrl.password}`;
  }

  if (isIpcUrl) {
    const parts = opts.path.split(':');

    opts.socketPath = parts[0];
    opts.path = parts[1];
  }

  let req;

  if (opts.followRedirects) {
    if (websocket._redirects === 0) {
      websocket._originalIpc = isIpcUrl;
      websocket._originalSecure = isSecure;
      websocket._originalHostOrSocketPath = isIpcUrl
        ? opts.socketPath
        : parsedUrl.host;

      const headers = options && options.headers;

      //
      // Shallow copy the user provided options so that headers can be changed
      // without mutating the original object.
      //
      options = { ...options, headers: {} };

      if (headers) {
        for (const [key, value] of Object.entries(headers)) {
          options.headers[key.toLowerCase()] = value;
        }
      }
    } else if (websocket.listenerCount('redirect') === 0) {
      const isSameHost = isIpcUrl
        ? websocket._originalIpc
          ? opts.socketPath === websocket._originalHostOrSocketPath
          : false
        : websocket._originalIpc
          ? false
          : parsedUrl.host === websocket._originalHostOrSocketPath;

      if (!isSameHost || (websocket._originalSecure && !isSecure)) {
        //
        // Match curl 7.77.0 behavior and drop the following headers. These
        // headers are also dropped when following a redirect to a subdomain.
        //
        delete opts.headers.authorization;
        delete opts.headers.cookie;

        if (!isSameHost) delete opts.headers.host;

        opts.auth = undefined;
      }
    }

    //
    // Match curl 7.77.0 behavior and make the first `Authorization` header win.
    // If the `Authorization` header is set, then there is nothing to do as it
    // will take precedence.
    //
    if (opts.auth && !options.headers.authorization) {
      options.headers.authorization =
        'Basic ' + Buffer.from(opts.auth).toString('base64');
    }

    req = websocket._req = request(opts);

    if (websocket._redirects) {
      //
      // Unlike what is done for the `'upgrade'` event, no early exit is
      // triggered here if the user calls `websocket.close()` or
      // `websocket.terminate()` from a listener of the `'redirect'` event. This
      // is because the user can also call `request.destroy()` with an error
      // before calling `websocket.close()` or `websocket.terminate()` and this
      // would result in an error being emitted on the `request` object with no
      // `'error'` event listeners attached.
      //
      websocket.emit('redirect', websocket.url, req);
    }
  } else {
    req = websocket._req = request(opts);
  }

  if (opts.timeout) {
    req.on('timeout', () => {
      abortHandshake(websocket, req, 'Opening handshake has timed out');
    });
  }

  req.on('error', (err) => {
    if (req === null || req[kAborted]) return;

    req = websocket._req = null;
    emitErrorAndClose(websocket, err);
  });

  req.on('response', (res) => {
    const location = res.headers.location;
    const statusCode = res.statusCode;

    if (
      location &&
      opts.followRedirects &&
      statusCode >= 300 &&
      statusCode < 400
    ) {
      if (++websocket._redirects > opts.maxRedirects) {
        abortHandshake(websocket, req, 'Maximum redirects exceeded');
        return;
      }

      req.abort();

      let addr;

      try {
        addr = new URL(location, address);
      } catch (e) {
        const err = new SyntaxError(`Invalid URL: ${location}`);
        emitErrorAndClose(websocket, err);
        return;
      }

      initAsClient(websocket, addr, protocols, options);
    } else if (!websocket.emit('unexpected-response', req, res)) {
      abortHandshake(
        websocket,
        req,
        `Unexpected server response: ${res.statusCode}`
      );
    }
  });

  req.on('upgrade', (res, socket, head) => {
    websocket.emit('upgrade', res);

    //
    // The user may have closed the connection from a listener of the
    // `'upgrade'` event.
    //
    if (websocket.readyState !== WebSocket.CONNECTING) return;

    req = websocket._req = null;

    const upgrade = res.headers.upgrade;

    if (upgrade === undefined || upgrade.toLowerCase() !== 'websocket') {
      abortHandshake(websocket, socket, 'Invalid Upgrade header');
      return;
    }

    const digest = createHash('sha1')
      .update(key + GUID)
      .digest('base64');

    if (res.headers['sec-websocket-accept'] !== digest) {
      abortHandshake(websocket, socket, 'Invalid Sec-WebSocket-Accept header');
      return;
    }

    const serverProt = res.headers['sec-websocket-protocol'];
    let protError;

    if (serverProt !== undefined) {
      if (!protocolSet.size) {
        protError = 'Server sent a subprotocol but none was requested';
      } else if (!protocolSet.has(serverProt)) {
        protError = 'Server sent an invalid subprotocol';
      }
    } else if (protocolSet.size) {
      protError = 'Server sent no subprotocol';
    }

    if (protError) {
      abortHandshake(websocket, socket, protError);
      return;
    }

    if (serverProt) websocket._protocol = serverProt;

    const secWebSocketExtensions = res.headers['sec-websocket-extensions'];

    if (secWebSocketExtensions !== undefined) {
      if (!perMessageDeflate) {
        const message =
          'Server sent a Sec-WebSocket-Extensions header but no extension ' +
          'was requested';
        abortHandshake(websocket, socket, message);
        return;
      }

      let extensions;

      try {
        extensions = parse(secWebSocketExtensions);
      } catch (err) {
        const message = 'Invalid Sec-WebSocket-Extensions header';
        abortHandshake(websocket, socket, message);
        return;
      }

      const extensionNames = Object.keys(extensions);

      if (
        extensionNames.length !== 1 ||
        extensionNames[0] !== PerMessageDeflate.extensionName
      ) {
        const message = 'Server indicated an extension that was not requested';
        abortHandshake(websocket, socket, message);
        return;
      }

      try {
        perMessageDeflate.accept(extensions[PerMessageDeflate.extensionName]);
      } catch (err) {
        const message = 'Invalid Sec-WebSocket-Extensions header';
        abortHandshake(websocket, socket, message);
        return;
      }

      websocket._extensions[PerMessageDeflate.extensionName] =
        perMessageDeflate;
    }

    websocket.setSocket(socket, head, {
      allowSynchronousEvents: opts.allowSynchronousEvents,
      generateMask: opts.generateMask,
      maxPayload: opts.maxPayload,
      skipUTF8Validation: opts.skipUTF8Validation
    });
  });

  if (opts.finishRequest) {
    opts.finishRequest(req, websocket);
  } else {
    req.end();
  }
}

/**
 * Emit the `'error'` and `'close'` events.
 *
 * @param {WebSocket} websocket The WebSocket instance
 * @param {Error} The error to emit
 * @private
 */
function emitErrorAndClose(websocket, err) {
  websocket._readyState = WebSocket.CLOSING;
  //
  // The following assignment is practically useless and is done only for
  // consistency.
  //
  websocket._errorEmitted = true;
  websocket.emit('error', err);
  websocket.emitClose();
}

/**
 * Create a `net.Socket` and initiate a connection.
 *
 * @param {Object} options Connection options
 * @return {net.Socket} The newly created socket used to start the connection
 * @private
 */
function netConnect(options) {
  options.path = options.socketPath;
  return net.connect(options);
}

/**
 * Create a `tls.TLSSocket` and initiate a connection.
 *
 * @param {Object} options Connection options
 * @return {tls.TLSSocket} The newly created socket used to start the connection
 * @private
 */
function tlsConnect(options) {
  options.path = undefined;

  if (!options.servername && options.servername !== '') {
    options.servername = net.isIP(options.host) ? '' : options.host;
  }

  return tls.connect(options);
}

/**
 * Abort the handshake and emit an error.
 *
 * @param {WebSocket} websocket The WebSocket instance
 * @param {(http.ClientRequest|net.Socket|tls.Socket)} stream The request to
 *     abort or the socket to destroy
 * @param {String} message The error message
 * @private
 */
function abortHandshake(websocket, stream, message) {
  websocket._readyState = WebSocket.CLOSING;

  const err = new Error(message);
  Error.captureStackTrace(err, abortHandshake);

  if (stream.setHeader) {
    stream[kAborted] = true;
    stream.abort();

    if (stream.socket && !stream.socket.destroyed) {
      //
      // On Node.js >= 14.3.0 `request.abort()` does not destroy the socket if
      // called after the request completed. See
      // https://github.com/websockets/ws/issues/1869.
      //
      stream.socket.destroy();
    }

    process.nextTick(emitErrorAndClose, websocket, err);
  } else {
    stream.destroy(err);
    stream.once('error', websocket.emit.bind(websocket, 'error'));
    stream.once('close', websocket.emitClose.bind(websocket));
  }
}

/**
 * Handle cases where the `ping()`, `pong()`, or `send()` methods are called
 * when the `readyState` attribute is `CLOSING` or `CLOSED`.
 *
 * @param {WebSocket} websocket The WebSocket instance
 * @param {*} [data] The data to send
 * @param {Function} [cb] Callback
 * @private
 */
function sendAfterClose(websocket, data, cb) {
  if (data) {
    const length = isBlob(data) ? data.size : toBuffer(data).length;

    //
    // The `_bufferedAmount` property is used only when the peer is a client and
    // the opening handshake fails. Under these circumstances, in fact, the
    // `setSocket()` method is not called, so the `_socket` and `_sender`
    // properties are set to `null`.
    //
    if (websocket._socket) websocket._sender._bufferedBytes += length;
    else websocket._bufferedAmount += length;
  }

  if (cb) {
    const err = new Error(
      `WebSocket is not open: readyState ${websocket.readyState} ` +
        `(${readyStates[websocket.readyState]})`
    );
    process.nextTick(cb, err);
  }
}

/**
 * The listener of the `Receiver` `'conclude'` event.
 *
 * @param {Number} code The status code
 * @param {Buffer} reason The reason for closing
 * @private
 */
function receiverOnConclude(code, reason) {
  const websocket = this[kWebSocket];

  websocket._closeFrameReceived = true;
  websocket._closeMessage = reason;
  websocket._closeCode = code;

  if (websocket._socket[kWebSocket] === undefined) return;

  websocket._socket.removeListener('data', socketOnData);
  process.nextTick(resume, websocket._socket);

  if (code === 1005) websocket.close();
  else websocket.close(code, reason);
}

/**
 * The listener of the `Receiver` `'drain'` event.
 *
 * @private
 */
function receiverOnDrain() {
  const websocket = this[kWebSocket];

  if (!websocket.isPaused) websocket._socket.resume();
}

/**
 * The listener of the `Receiver` `'error'` event.
 *
 * @param {(RangeError|Error)} err The emitted error
 * @private
 */
function receiverOnError(err) {
  const websocket = this[kWebSocket];

  if (websocket._socket[kWebSocket] !== undefined) {
    websocket._socket.removeListener('data', socketOnData);

    //
    // On Node.js < 14.0.0 the `'error'` event is emitted synchronously. See
    // https://github.com/websockets/ws/issues/1940.
    //
    process.nextTick(resume, websocket._socket);

    websocket.close(err[kStatusCode]);
  }

  if (!websocket._errorEmitted) {
    websocket._errorEmitted = true;
    websocket.emit('error', err);
  }
}

/**
 * The listener of the `Receiver` `'finish'` event.
 *
 * @private
 */
function receiverOnFinish() {
  this[kWebSocket].emitClose();
}

/**
 * The listener of the `Receiver` `'message'` event.
 *
 * @param {Buffer|ArrayBuffer|Buffer[])} data The message
 * @param {Boolean} isBinary Specifies whether the message is binary or not
 * @private
 */
function receiverOnMessage(data, isBinary) {
  this[kWebSocket].emit('message', data, isBinary);
}

/**
 * The listener of the `Receiver` `'ping'` event.
 *
 * @param {Buffer} data The data included in the ping frame
 * @private
 */
function receiverOnPing(data) {
  const websocket = this[kWebSocket];

  if (websocket._autoPong) websocket.pong(data, !this._isServer, NOOP);
  websocket.emit('ping', data);
}

/**
 * The listener of the `Receiver` `'pong'` event.
 *
 * @param {Buffer} data The data included in the pong frame
 * @private
 */
function receiverOnPong(data) {
  this[kWebSocket].emit('pong', data);
}

/**
 * Resume a readable stream
 *
 * @param {Readable} stream The readable stream
 * @private
 */
function resume(stream) {
  stream.resume();
}

/**
 * The `Sender` error event handler.
 *
 * @param {Error} The error
 * @private
 */
function senderOnError(err) {
  const websocket = this[kWebSocket];

  if (websocket.readyState === WebSocket.CLOSED) return;
  if (websocket.readyState === WebSocket.OPEN) {
    websocket._readyState = WebSocket.CLOSING;
    setCloseTimer(websocket);
  }

  //
  // `socket.end()` is used instead of `socket.destroy()` to allow the other
  // peer to finish sending queued data. There is no need to set a timer here
  // because `CLOSING` means that it is already set or not needed.
  //
  this._socket.end();

  if (!websocket._errorEmitted) {
    websocket._errorEmitted = true;
    websocket.emit('error', err);
  }
}

/**
 * Set a timer to destroy the underlying raw socket of a WebSocket.
 *
 * @param {WebSocket} websocket The WebSocket instance
 * @private
 */
function setCloseTimer(websocket) {
  websocket._closeTimer = setTimeout(
    websocket._socket.destroy.bind(websocket._socket),
    closeTimeout
  );
}

/**
 * The listener of the socket `'close'` event.
 *
 * @private
 */
function socketOnClose() {
  const websocket = this[kWebSocket];

  this.removeListener('close', socketOnClose);
  this.removeListener('data', socketOnData);
  this.removeListener('end', socketOnEnd);

  websocket._readyState = WebSocket.CLOSING;

  let chunk;

  //
  // The close frame might not have been received or the `'end'` event emitted,
  // for example, if the socket was destroyed due to an error. Ensure that the
  // `receiver` stream is closed after writing any remaining buffered data to
  // it. If the readable side of the socket is in flowing mode then there is no
  // buffered data as everything has been already written and `readable.read()`
  // will return `null`. If instead, the socket is paused, any possible buffered
  // data will be read as a single chunk.
  //
  if (
    !this._readableState.endEmitted &&
    !websocket._closeFrameReceived &&
    !websocket._receiver._writableState.errorEmitted &&
    (chunk = websocket._socket.read()) !== null
  ) {
    websocket._receiver.write(chunk);
  }

  websocket._receiver.end();

  this[kWebSocket] = undefined;

  clearTimeout(websocket._closeTimer);

  if (
    websocket._receiver._writableState.finished ||
    websocket._receiver._writableState.errorEmitted
  ) {
    websocket.emitClose();
  } else {
    websocket._receiver.on('error', receiverOnFinish);
    websocket._receiver.on('finish', receiverOnFinish);
  }
}

/**
 * The listener of the socket `'data'` event.
 *
 * @param {Buffer} chunk A chunk of data
 * @private
 */
function socketOnData(chunk) {
  if (!this[kWebSocket]._receiver.write(chunk)) {
    this.pause();
  }
}

/**
 * The listener of the socket `'end'` event.
 *
 * @private
 */
function socketOnEnd() {
  const websocket = this[kWebSocket];

  websocket._readyState = WebSocket.CLOSING;
  websocket._receiver.end();
  this.end();
}

/**
 * The listener of the socket `'error'` event.
 *
 * @private
 */
function socketOnError() {
  const websocket = this[kWebSocket];

  this.removeListener('error', socketOnError);
  this.on('error', NOOP);

  if (websocket) {
    websocket._readyState = WebSocket.CLOSING;
    this.destroy();
  }
}


/***/ }),

/***/ 9134:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = {
	h32: __webpack_require__(2492)
,	h64: __webpack_require__(7470)
}


/***/ }),

/***/ 2492:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/**
xxHash implementation in pure Javascript

Copyright (C) 2013, Pierre Curto
MIT license
*/
var UINT32 = (__webpack_require__(7898).UINT32)

/*
	Merged this sequence of method calls as it speeds up
	the calculations by a factor of 2
 */
// this.v1.add( other.multiply(PRIME32_2) ).rotl(13).multiply(PRIME32_1);
UINT32.prototype.xxh_update = function (low, high) {
	var b00 = PRIME32_2._low
	var b16 = PRIME32_2._high

	var c16, c00
	c00 = low * b00
	c16 = c00 >>> 16

	c16 += high * b00
	c16 &= 0xFFFF		// Not required but improves performance
	c16 += low * b16

	var a00 = this._low + (c00 & 0xFFFF)
	var a16 = a00 >>> 16

	a16 += this._high + (c16 & 0xFFFF)

	var v = (a16 << 16) | (a00 & 0xFFFF)
	v = (v << 13) | (v >>> 19)

	a00 = v & 0xFFFF
	a16 = v >>> 16

	b00 = PRIME32_1._low
	b16 = PRIME32_1._high

	c00 = a00 * b00
	c16 = c00 >>> 16

	c16 += a16 * b00
	c16 &= 0xFFFF		// Not required but improves performance
	c16 += a00 * b16

	this._low = c00 & 0xFFFF
	this._high = c16 & 0xFFFF
}

/*
 * Constants
 */
var PRIME32_1 = UINT32( '2654435761' )
var PRIME32_2 = UINT32( '2246822519' )
var PRIME32_3 = UINT32( '3266489917' )
var PRIME32_4 = UINT32(  '668265263' )
var PRIME32_5 = UINT32(  '374761393' )

/**
* Convert string to proper UTF-8 array
* @param str Input string
* @returns {Uint8Array} UTF8 array is returned as uint8 array
*/
function toUTF8Array (str) {
	var utf8 = []
	for (var i=0, n=str.length; i < n; i++) {
		var charcode = str.charCodeAt(i)
		if (charcode < 0x80) utf8.push(charcode)
		else if (charcode < 0x800) {
			utf8.push(0xc0 | (charcode >> 6),
			0x80 | (charcode & 0x3f))
		}
		else if (charcode < 0xd800 || charcode >= 0xe000) {
			utf8.push(0xe0 | (charcode >> 12),
			0x80 | ((charcode>>6) & 0x3f),
			0x80 | (charcode & 0x3f))
		}
		// surrogate pair
		else {
			i++;
			// UTF-16 encodes 0x10000-0x10FFFF by
			// subtracting 0x10000 and splitting the
			// 20 bits of 0x0-0xFFFFF into two halves
			charcode = 0x10000 + (((charcode & 0x3ff)<<10)
			| (str.charCodeAt(i) & 0x3ff))
			utf8.push(0xf0 | (charcode >>18),
			0x80 | ((charcode>>12) & 0x3f),
			0x80 | ((charcode>>6) & 0x3f),
			0x80 | (charcode & 0x3f))
		}
	}

	return new Uint8Array(utf8)
}

/**
 * XXH object used as a constructor or a function
 * @constructor
 * or
 * @param {Object|String} input data
 * @param {Number|UINT32} seed
 * @return ThisExpression
 * or
 * @return {UINT32} xxHash
 */
function XXH () {
	if (arguments.length == 2)
		return new XXH( arguments[1] ).update( arguments[0] ).digest()

	if (!(this instanceof XXH))
		return new XXH( arguments[0] )

	init.call(this, arguments[0])
}

/**
 * Initialize the XXH instance with the given seed
 * @method init
 * @param {Number|Object} seed as a number or an unsigned 32 bits integer
 * @return ThisExpression
 */
 function init (seed) {
	this.seed = seed instanceof UINT32 ? seed.clone() : UINT32(seed)
	this.v1 = this.seed.clone().add(PRIME32_1).add(PRIME32_2)
	this.v2 = this.seed.clone().add(PRIME32_2)
	this.v3 = this.seed.clone()
	this.v4 = this.seed.clone().subtract(PRIME32_1)
	this.total_len = 0
	this.memsize = 0
	this.memory = null

	return this
}
XXH.prototype.init = init

/**
 * Add data to be computed for the XXH hash
 * @method update
 * @param {String|Buffer|ArrayBuffer} input as a string or nodejs Buffer or ArrayBuffer
 * @return ThisExpression
 */
XXH.prototype.update = function (input) {
	var isString = typeof input == 'string'
	var isArrayBuffer

	// Convert all strings to utf-8 first (issue #5)
	if (isString) {
		input = toUTF8Array(input)
		isString = false
		isArrayBuffer = true
	}

	if (typeof ArrayBuffer !== "undefined" && input instanceof ArrayBuffer)
	{
		isArrayBuffer = true
		input = new Uint8Array(input);
	}

	var p = 0
	var len = input.length
	var bEnd = p + len

	if (len == 0) return this

	this.total_len += len

	if (this.memsize == 0)
	{
		if (isString) {
			this.memory = ''
		} else if (isArrayBuffer) {
			this.memory = new Uint8Array(16)
		} else {
			this.memory = new Buffer(16)
		}
	}

	if (this.memsize + len < 16)   // fill in tmp buffer
	{
		// XXH_memcpy(this.memory + this.memsize, input, len)
		if (isString) {
			this.memory += input
		} else if (isArrayBuffer) {
			this.memory.set( input.subarray(0, len), this.memsize )
		} else {
			input.copy( this.memory, this.memsize, 0, len )
		}

		this.memsize += len
		return this
	}

	if (this.memsize > 0)   // some data left from previous update
	{
		// XXH_memcpy(this.memory + this.memsize, input, 16-this.memsize);
		if (isString) {
			this.memory += input.slice(0, 16 - this.memsize)
		} else if (isArrayBuffer) {
			this.memory.set( input.subarray(0, 16 - this.memsize), this.memsize )
		} else {
			input.copy( this.memory, this.memsize, 0, 16 - this.memsize )
		}

		var p32 = 0
		if (isString) {
			this.v1.xxh_update(
				(this.memory.charCodeAt(p32+1) << 8) | this.memory.charCodeAt(p32)
			,	(this.memory.charCodeAt(p32+3) << 8) | this.memory.charCodeAt(p32+2)
			)
			p32 += 4
			this.v2.xxh_update(
				(this.memory.charCodeAt(p32+1) << 8) | this.memory.charCodeAt(p32)
			,	(this.memory.charCodeAt(p32+3) << 8) | this.memory.charCodeAt(p32+2)
			)
			p32 += 4
			this.v3.xxh_update(
				(this.memory.charCodeAt(p32+1) << 8) | this.memory.charCodeAt(p32)
			,	(this.memory.charCodeAt(p32+3) << 8) | this.memory.charCodeAt(p32+2)
			)
			p32 += 4
			this.v4.xxh_update(
				(this.memory.charCodeAt(p32+1) << 8) | this.memory.charCodeAt(p32)
			,	(this.memory.charCodeAt(p32+3) << 8) | this.memory.charCodeAt(p32+2)
			)
		} else {
			this.v1.xxh_update(
				(this.memory[p32+1] << 8) | this.memory[p32]
			,	(this.memory[p32+3] << 8) | this.memory[p32+2]
			)
			p32 += 4
			this.v2.xxh_update(
				(this.memory[p32+1] << 8) | this.memory[p32]
			,	(this.memory[p32+3] << 8) | this.memory[p32+2]
			)
			p32 += 4
			this.v3.xxh_update(
				(this.memory[p32+1] << 8) | this.memory[p32]
			,	(this.memory[p32+3] << 8) | this.memory[p32+2]
			)
			p32 += 4
			this.v4.xxh_update(
				(this.memory[p32+1] << 8) | this.memory[p32]
			,	(this.memory[p32+3] << 8) | this.memory[p32+2]
			)
		}

		p += 16 - this.memsize
		this.memsize = 0
		if (isString) this.memory = ''
	}

	if (p <= bEnd - 16)
	{
		var limit = bEnd - 16

		do
		{
			if (isString) {
				this.v1.xxh_update(
					(input.charCodeAt(p+1) << 8) | input.charCodeAt(p)
				,	(input.charCodeAt(p+3) << 8) | input.charCodeAt(p+2)
				)
				p += 4
				this.v2.xxh_update(
					(input.charCodeAt(p+1) << 8) | input.charCodeAt(p)
				,	(input.charCodeAt(p+3) << 8) | input.charCodeAt(p+2)
				)
				p += 4
				this.v3.xxh_update(
					(input.charCodeAt(p+1) << 8) | input.charCodeAt(p)
				,	(input.charCodeAt(p+3) << 8) | input.charCodeAt(p+2)
				)
				p += 4
				this.v4.xxh_update(
					(input.charCodeAt(p+1) << 8) | input.charCodeAt(p)
				,	(input.charCodeAt(p+3) << 8) | input.charCodeAt(p+2)
				)
			} else {
				this.v1.xxh_update(
					(input[p+1] << 8) | input[p]
				,	(input[p+3] << 8) | input[p+2]
				)
				p += 4
				this.v2.xxh_update(
					(input[p+1] << 8) | input[p]
				,	(input[p+3] << 8) | input[p+2]
				)
				p += 4
				this.v3.xxh_update(
					(input[p+1] << 8) | input[p]
				,	(input[p+3] << 8) | input[p+2]
				)
				p += 4
				this.v4.xxh_update(
					(input[p+1] << 8) | input[p]
				,	(input[p+3] << 8) | input[p+2]
				)
			}
			p += 4
		} while (p <= limit)
	}

	if (p < bEnd)
	{
		// XXH_memcpy(this.memory, p, bEnd-p);
		if (isString) {
			this.memory += input.slice(p)
		} else if (isArrayBuffer) {
			this.memory.set( input.subarray(p, bEnd), this.memsize )
		} else {
			input.copy( this.memory, this.memsize, p, bEnd )
		}

		this.memsize = bEnd - p
	}

	return this
}

/**
 * Finalize the XXH computation. The XXH instance is ready for reuse for the given seed
 * @method digest
 * @return {UINT32} xxHash
 */
XXH.prototype.digest = function () {
	var input = this.memory
	var isString = typeof input == 'string'
	var p = 0
	var bEnd = this.memsize
	var h32, h
	var u = new UINT32

	if (this.total_len >= 16)
	{
		h32 = this.v1.rotl(1).add( this.v2.rotl(7).add( this.v3.rotl(12).add( this.v4.rotl(18) ) ) )
	}
	else
	{
		h32  = this.seed.clone().add( PRIME32_5 )
	}

	h32.add( u.fromNumber(this.total_len) )

	while (p <= bEnd - 4)
	{
		if (isString) {
			u.fromBits(
				(input.charCodeAt(p+1) << 8) | input.charCodeAt(p)
			,	(input.charCodeAt(p+3) << 8) | input.charCodeAt(p+2)
			)
		} else {
			u.fromBits(
				(input[p+1] << 8) | input[p]
			,	(input[p+3] << 8) | input[p+2]
			)
		}
		h32
			.add( u.multiply(PRIME32_3) )
			.rotl(17)
			.multiply( PRIME32_4 )
		p += 4
	}

	while (p < bEnd)
	{
		u.fromBits( isString ? input.charCodeAt(p++) : input[p++], 0 )
		h32
			.add( u.multiply(PRIME32_5) )
			.rotl(11)
			.multiply(PRIME32_1)
	}

	h = h32.clone().shiftRight(15)
	h32.xor(h).multiply(PRIME32_2)

	h = h32.clone().shiftRight(13)
	h32.xor(h).multiply(PRIME32_3)

	h = h32.clone().shiftRight(16)
	h32.xor(h)

	// Reset the state
	this.init( this.seed )

	return h32
}

module.exports = XXH


/***/ }),

/***/ 7470:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/**
xxHash64 implementation in pure Javascript

Copyright (C) 2016, Pierre Curto
MIT license
*/
var UINT64 = (__webpack_require__(7898).UINT64)

/*
 * Constants
 */
var PRIME64_1 = UINT64( '11400714785074694791' )
var PRIME64_2 = UINT64( '14029467366897019727' )
var PRIME64_3 = UINT64(  '1609587929392839161' )
var PRIME64_4 = UINT64(  '9650029242287828579' )
var PRIME64_5 = UINT64(  '2870177450012600261' )

/**
* Convert string to proper UTF-8 array
* @param str Input string
* @returns {Uint8Array} UTF8 array is returned as uint8 array
*/
function toUTF8Array (str) {
	var utf8 = []
	for (var i=0, n=str.length; i < n; i++) {
		var charcode = str.charCodeAt(i)
		if (charcode < 0x80) utf8.push(charcode)
		else if (charcode < 0x800) {
			utf8.push(0xc0 | (charcode >> 6),
			0x80 | (charcode & 0x3f))
		}
		else if (charcode < 0xd800 || charcode >= 0xe000) {
			utf8.push(0xe0 | (charcode >> 12),
			0x80 | ((charcode>>6) & 0x3f),
			0x80 | (charcode & 0x3f))
		}
		// surrogate pair
		else {
			i++;
			// UTF-16 encodes 0x10000-0x10FFFF by
			// subtracting 0x10000 and splitting the
			// 20 bits of 0x0-0xFFFFF into two halves
			charcode = 0x10000 + (((charcode & 0x3ff)<<10)
			| (str.charCodeAt(i) & 0x3ff))
			utf8.push(0xf0 | (charcode >>18),
			0x80 | ((charcode>>12) & 0x3f),
			0x80 | ((charcode>>6) & 0x3f),
			0x80 | (charcode & 0x3f))
		}
	}

	return new Uint8Array(utf8)
}

/**
 * XXH64 object used as a constructor or a function
 * @constructor
 * or
 * @param {Object|String} input data
 * @param {Number|UINT64} seed
 * @return ThisExpression
 * or
 * @return {UINT64} xxHash
 */
function XXH64 () {
	if (arguments.length == 2)
		return new XXH64( arguments[1] ).update( arguments[0] ).digest()

	if (!(this instanceof XXH64))
		return new XXH64( arguments[0] )

	init.call(this, arguments[0])
}

/**
 * Initialize the XXH64 instance with the given seed
 * @method init
 * @param {Number|Object} seed as a number or an unsigned 32 bits integer
 * @return ThisExpression
 */
 function init (seed) {
	this.seed = seed instanceof UINT64 ? seed.clone() : UINT64(seed)
	this.v1 = this.seed.clone().add(PRIME64_1).add(PRIME64_2)
	this.v2 = this.seed.clone().add(PRIME64_2)
	this.v3 = this.seed.clone()
	this.v4 = this.seed.clone().subtract(PRIME64_1)
	this.total_len = 0
	this.memsize = 0
	this.memory = null

	return this
}
XXH64.prototype.init = init

/**
 * Add data to be computed for the XXH64 hash
 * @method update
 * @param {String|Buffer|ArrayBuffer} input as a string or nodejs Buffer or ArrayBuffer
 * @return ThisExpression
 */
XXH64.prototype.update = function (input) {
	var isString = typeof input == 'string'
	var isArrayBuffer

	// Convert all strings to utf-8 first (issue #5)
	if (isString) {
		input = toUTF8Array(input)
		isString = false
		isArrayBuffer = true
	}

	if (typeof ArrayBuffer !== "undefined" && input instanceof ArrayBuffer)
	{
		isArrayBuffer = true
		input = new Uint8Array(input);
	}

	var p = 0
	var len = input.length
	var bEnd = p + len

	if (len == 0) return this

	this.total_len += len

	if (this.memsize == 0)
	{
		if (isString) {
			this.memory = ''
		} else if (isArrayBuffer) {
			this.memory = new Uint8Array(32)
		} else {
			this.memory = new Buffer(32)
		}
	}

	if (this.memsize + len < 32)   // fill in tmp buffer
	{
		// XXH64_memcpy(this.memory + this.memsize, input, len)
		if (isString) {
			this.memory += input
		} else if (isArrayBuffer) {
			this.memory.set( input.subarray(0, len), this.memsize )
		} else {
			input.copy( this.memory, this.memsize, 0, len )
		}

		this.memsize += len
		return this
	}

	if (this.memsize > 0)   // some data left from previous update
	{
		// XXH64_memcpy(this.memory + this.memsize, input, 16-this.memsize);
		if (isString) {
			this.memory += input.slice(0, 32 - this.memsize)
		} else if (isArrayBuffer) {
			this.memory.set( input.subarray(0, 32 - this.memsize), this.memsize )
		} else {
			input.copy( this.memory, this.memsize, 0, 32 - this.memsize )
		}

		var p64 = 0
		if (isString) {
			var other
			other = UINT64(
					(this.memory.charCodeAt(p64+1) << 8) | this.memory.charCodeAt(p64)
				,	(this.memory.charCodeAt(p64+3) << 8) | this.memory.charCodeAt(p64+2)
				,	(this.memory.charCodeAt(p64+5) << 8) | this.memory.charCodeAt(p64+4)
				,	(this.memory.charCodeAt(p64+7) << 8) | this.memory.charCodeAt(p64+6)
				)
			this.v1.add( other.multiply(PRIME64_2) ).rotl(31).multiply(PRIME64_1);
			p64 += 8
			other = UINT64(
					(this.memory.charCodeAt(p64+1) << 8) | this.memory.charCodeAt(p64)
				,	(this.memory.charCodeAt(p64+3) << 8) | this.memory.charCodeAt(p64+2)
				,	(this.memory.charCodeAt(p64+5) << 8) | this.memory.charCodeAt(p64+4)
				,	(this.memory.charCodeAt(p64+7) << 8) | this.memory.charCodeAt(p64+6)
				)
			this.v2.add( other.multiply(PRIME64_2) ).rotl(31).multiply(PRIME64_1);
			p64 += 8
			other = UINT64(
					(this.memory.charCodeAt(p64+1) << 8) | this.memory.charCodeAt(p64)
				,	(this.memory.charCodeAt(p64+3) << 8) | this.memory.charCodeAt(p64+2)
				,	(this.memory.charCodeAt(p64+5) << 8) | this.memory.charCodeAt(p64+4)
				,	(this.memory.charCodeAt(p64+7) << 8) | this.memory.charCodeAt(p64+6)
				)
			this.v3.add( other.multiply(PRIME64_2) ).rotl(31).multiply(PRIME64_1);
			p64 += 8
			other = UINT64(
					(this.memory.charCodeAt(p64+1) << 8) | this.memory.charCodeAt(p64)
				,	(this.memory.charCodeAt(p64+3) << 8) | this.memory.charCodeAt(p64+2)
				,	(this.memory.charCodeAt(p64+5) << 8) | this.memory.charCodeAt(p64+4)
				,	(this.memory.charCodeAt(p64+7) << 8) | this.memory.charCodeAt(p64+6)
				)
			this.v4.add( other.multiply(PRIME64_2) ).rotl(31).multiply(PRIME64_1);
		} else {
			var other
			other = UINT64(
					(this.memory[p64+1] << 8) | this.memory[p64]
				,	(this.memory[p64+3] << 8) | this.memory[p64+2]
				,	(this.memory[p64+5] << 8) | this.memory[p64+4]
				,	(this.memory[p64+7] << 8) | this.memory[p64+6]
				)
			this.v1.add( other.multiply(PRIME64_2) ).rotl(31).multiply(PRIME64_1);
			p64 += 8
			other = UINT64(
					(this.memory[p64+1] << 8) | this.memory[p64]
				,	(this.memory[p64+3] << 8) | this.memory[p64+2]
				,	(this.memory[p64+5] << 8) | this.memory[p64+4]
				,	(this.memory[p64+7] << 8) | this.memory[p64+6]
				)
			this.v2.add( other.multiply(PRIME64_2) ).rotl(31).multiply(PRIME64_1);
			p64 += 8
			other = UINT64(
					(this.memory[p64+1] << 8) | this.memory[p64]
				,	(this.memory[p64+3] << 8) | this.memory[p64+2]
				,	(this.memory[p64+5] << 8) | this.memory[p64+4]
				,	(this.memory[p64+7] << 8) | this.memory[p64+6]
				)
			this.v3.add( other.multiply(PRIME64_2) ).rotl(31).multiply(PRIME64_1);
			p64 += 8
			other = UINT64(
					(this.memory[p64+1] << 8) | this.memory[p64]
				,	(this.memory[p64+3] << 8) | this.memory[p64+2]
				,	(this.memory[p64+5] << 8) | this.memory[p64+4]
				,	(this.memory[p64+7] << 8) | this.memory[p64+6]
				)
			this.v4.add( other.multiply(PRIME64_2) ).rotl(31).multiply(PRIME64_1);
		}

		p += 32 - this.memsize
		this.memsize = 0
		if (isString) this.memory = ''
	}

	if (p <= bEnd - 32)
	{
		var limit = bEnd - 32

		do
		{
			if (isString) {
				var other
				other = UINT64(
						(input.charCodeAt(p+1) << 8) | input.charCodeAt(p)
					,	(input.charCodeAt(p+3) << 8) | input.charCodeAt(p+2)
					,	(input.charCodeAt(p+5) << 8) | input.charCodeAt(p+4)
					,	(input.charCodeAt(p+7) << 8) | input.charCodeAt(p+6)
					)
				this.v1.add( other.multiply(PRIME64_2) ).rotl(31).multiply(PRIME64_1);
				p += 8
				other = UINT64(
						(input.charCodeAt(p+1) << 8) | input.charCodeAt(p)
					,	(input.charCodeAt(p+3) << 8) | input.charCodeAt(p+2)
					,	(input.charCodeAt(p+5) << 8) | input.charCodeAt(p+4)
					,	(input.charCodeAt(p+7) << 8) | input.charCodeAt(p+6)
					)
				this.v2.add( other.multiply(PRIME64_2) ).rotl(31).multiply(PRIME64_1);
				p += 8
				other = UINT64(
						(input.charCodeAt(p+1) << 8) | input.charCodeAt(p)
					,	(input.charCodeAt(p+3) << 8) | input.charCodeAt(p+2)
					,	(input.charCodeAt(p+5) << 8) | input.charCodeAt(p+4)
					,	(input.charCodeAt(p+7) << 8) | input.charCodeAt(p+6)
					)
				this.v3.add( other.multiply(PRIME64_2) ).rotl(31).multiply(PRIME64_1);
				p += 8
				other = UINT64(
						(input.charCodeAt(p+1) << 8) | input.charCodeAt(p)
					,	(input.charCodeAt(p+3) << 8) | input.charCodeAt(p+2)
					,	(input.charCodeAt(p+5) << 8) | input.charCodeAt(p+4)
					,	(input.charCodeAt(p+7) << 8) | input.charCodeAt(p+6)
					)
				this.v4.add( other.multiply(PRIME64_2) ).rotl(31).multiply(PRIME64_1);
			} else {
				var other
				other = UINT64(
						(input[p+1] << 8) | input[p]
					,	(input[p+3] << 8) | input[p+2]
					,	(input[p+5] << 8) | input[p+4]
					,	(input[p+7] << 8) | input[p+6]
					)
				this.v1.add( other.multiply(PRIME64_2) ).rotl(31).multiply(PRIME64_1);
				p += 8
				other = UINT64(
						(input[p+1] << 8) | input[p]
					,	(input[p+3] << 8) | input[p+2]
					,	(input[p+5] << 8) | input[p+4]
					,	(input[p+7] << 8) | input[p+6]
					)
				this.v2.add( other.multiply(PRIME64_2) ).rotl(31).multiply(PRIME64_1);
				p += 8
				other = UINT64(
						(input[p+1] << 8) | input[p]
					,	(input[p+3] << 8) | input[p+2]
					,	(input[p+5] << 8) | input[p+4]
					,	(input[p+7] << 8) | input[p+6]
					)
				this.v3.add( other.multiply(PRIME64_2) ).rotl(31).multiply(PRIME64_1);
				p += 8
				other = UINT64(
						(input[p+1] << 8) | input[p]
					,	(input[p+3] << 8) | input[p+2]
					,	(input[p+5] << 8) | input[p+4]
					,	(input[p+7] << 8) | input[p+6]
					)
				this.v4.add( other.multiply(PRIME64_2) ).rotl(31).multiply(PRIME64_1);
			}
			p += 8
		} while (p <= limit)
	}

	if (p < bEnd)
	{
		// XXH64_memcpy(this.memory, p, bEnd-p);
		if (isString) {
			this.memory += input.slice(p)
		} else if (isArrayBuffer) {
			this.memory.set( input.subarray(p, bEnd), this.memsize )
		} else {
			input.copy( this.memory, this.memsize, p, bEnd )
		}

		this.memsize = bEnd - p
	}

	return this
}

/**
 * Finalize the XXH64 computation. The XXH64 instance is ready for reuse for the given seed
 * @method digest
 * @return {UINT64} xxHash
 */
XXH64.prototype.digest = function () {
	var input = this.memory
	var isString = typeof input == 'string'
	var p = 0
	var bEnd = this.memsize
	var h64, h
	var u = new UINT64

	if (this.total_len >= 32)
	{
		h64 = this.v1.clone().rotl(1)
		h64.add( this.v2.clone().rotl(7) )
		h64.add( this.v3.clone().rotl(12) )
		h64.add( this.v4.clone().rotl(18) )

		h64.xor( this.v1.multiply(PRIME64_2).rotl(31).multiply(PRIME64_1) )
		h64.multiply(PRIME64_1).add(PRIME64_4)

		h64.xor( this.v2.multiply(PRIME64_2).rotl(31).multiply(PRIME64_1) )
		h64.multiply(PRIME64_1).add(PRIME64_4)

		h64.xor( this.v3.multiply(PRIME64_2).rotl(31).multiply(PRIME64_1) )
		h64.multiply(PRIME64_1).add(PRIME64_4)

		h64.xor( this.v4.multiply(PRIME64_2).rotl(31).multiply(PRIME64_1) )
		h64.multiply(PRIME64_1).add(PRIME64_4)
	}
	else
	{
		h64  = this.seed.clone().add( PRIME64_5 )
	}

	h64.add( u.fromNumber(this.total_len) )

	while (p <= bEnd - 8)
	{
		if (isString) {
			u.fromBits(
				(input.charCodeAt(p+1) << 8) | input.charCodeAt(p)
			,	(input.charCodeAt(p+3) << 8) | input.charCodeAt(p+2)
			,	(input.charCodeAt(p+5) << 8) | input.charCodeAt(p+4)
			,	(input.charCodeAt(p+7) << 8) | input.charCodeAt(p+6)
			)
		} else {
			u.fromBits(
				(input[p+1] << 8) | input[p]
			,	(input[p+3] << 8) | input[p+2]
			,	(input[p+5] << 8) | input[p+4]
			,	(input[p+7] << 8) | input[p+6]
			)
		}
		u.multiply(PRIME64_2).rotl(31).multiply(PRIME64_1)
		h64
			.xor(u)
			.rotl(27)
			.multiply( PRIME64_1 )
			.add( PRIME64_4 )
		p += 8
	}

	if (p + 4 <= bEnd) {
		if (isString) {
			u.fromBits(
				(input.charCodeAt(p+1) << 8) | input.charCodeAt(p)
			,	(input.charCodeAt(p+3) << 8) | input.charCodeAt(p+2)
			,	0
			,	0
			)
		} else {
			u.fromBits(
				(input[p+1] << 8) | input[p]
			,	(input[p+3] << 8) | input[p+2]
			,	0
			,	0
			)
		}
		h64
			.xor( u.multiply(PRIME64_1) )
			.rotl(23)
			.multiply( PRIME64_2 )
			.add( PRIME64_3 )
		p += 4
	}

	while (p < bEnd)
	{
		u.fromBits( isString ? input.charCodeAt(p++) : input[p++], 0, 0, 0 )
		h64
			.xor( u.multiply(PRIME64_5) )
			.rotl(11)
			.multiply(PRIME64_1)
	}

	h = h64.clone().shiftRight(33)
	h64.xor(h).multiply(PRIME64_2)

	h = h64.clone().shiftRight(29)
	h64.xor(h).multiply(PRIME64_3)

	h = h64.clone().shiftRight(32)
	h64.xor(h)

	// Reset the state
	this.init( this.seed )

	return h64
}

module.exports = XXH64


/***/ }),

/***/ 9529:
/***/ ((module) => {

"use strict";
module.exports = require("@keetanetwork/asn1-napi-rs");

/***/ }),

/***/ 1962:
/***/ ((module) => {

"use strict";
module.exports = require("bufferutil");

/***/ }),

/***/ 560:
/***/ ((module) => {

"use strict";
module.exports = require("secp256k1");

/***/ }),

/***/ 6809:
/***/ ((module) => {

"use strict";
module.exports = require("utf-8-validate");

/***/ }),

/***/ 2613:
/***/ ((module) => {

"use strict";
module.exports = require("assert");

/***/ }),

/***/ 181:
/***/ ((module) => {

"use strict";
module.exports = require("buffer");

/***/ }),

/***/ 6982:
/***/ ((module) => {

"use strict";
module.exports = require("crypto");

/***/ }),

/***/ 4434:
/***/ ((module) => {

"use strict";
module.exports = require("events");

/***/ }),

/***/ 8611:
/***/ ((module) => {

"use strict";
module.exports = require("http");

/***/ }),

/***/ 5692:
/***/ ((module) => {

"use strict";
module.exports = require("https");

/***/ }),

/***/ 9278:
/***/ ((module) => {

"use strict";
module.exports = require("net");

/***/ }),

/***/ 7598:
/***/ ((module) => {

"use strict";
module.exports = require("node:crypto");

/***/ }),

/***/ 2203:
/***/ ((module) => {

"use strict";
module.exports = require("stream");

/***/ }),

/***/ 4756:
/***/ ((module) => {

"use strict";
module.exports = require("tls");

/***/ }),

/***/ 7016:
/***/ ((module) => {

"use strict";
module.exports = require("url");

/***/ }),

/***/ 9023:
/***/ ((module) => {

"use strict";
module.exports = require("util");

/***/ }),

/***/ 3106:
/***/ ((module) => {

"use strict";
module.exports = require("zlib");

/***/ }),

/***/ 5652:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

/* file : api.ts
MIT License

Copyright (c) 2017-2020 Thomas Minier & Arnaud Grall

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ScalableBloomFilter = exports.DeprecatedHashing = exports.Hashing = exports.Cell = exports.InvertibleBloomFilter = exports.CuckooFilter = exports.MinHashFactory = exports.MinHash = exports.TopK = exports.HyperLogLog = exports.CountMinSketch = exports.PartitionedBloomFilter = exports.CountingBloomFilter = exports.XorFilter = exports.BitSet = exports.BloomFilter = exports.BaseFilter = void 0;
var base_filter_1 = __webpack_require__(4914);
Object.defineProperty(exports, "BaseFilter", ({ enumerable: true, get: function () { return __importDefault(base_filter_1).default; } }));
var bloom_filter_1 = __webpack_require__(74);
Object.defineProperty(exports, "BloomFilter", ({ enumerable: true, get: function () { return __importDefault(bloom_filter_1).default; } }));
var bit_set_1 = __webpack_require__(2410);
Object.defineProperty(exports, "BitSet", ({ enumerable: true, get: function () { return __importDefault(bit_set_1).default; } }));
var xor_filter_1 = __webpack_require__(8620);
Object.defineProperty(exports, "XorFilter", ({ enumerable: true, get: function () { return __importDefault(xor_filter_1).default; } }));
var counting_bloom_filter_1 = __webpack_require__(6800);
Object.defineProperty(exports, "CountingBloomFilter", ({ enumerable: true, get: function () { return __importDefault(counting_bloom_filter_1).default; } }));
var partitioned_bloom_filter_1 = __webpack_require__(4204);
Object.defineProperty(exports, "PartitionedBloomFilter", ({ enumerable: true, get: function () { return __importDefault(partitioned_bloom_filter_1).default; } }));
var count_min_sketch_1 = __webpack_require__(7044);
Object.defineProperty(exports, "CountMinSketch", ({ enumerable: true, get: function () { return __importDefault(count_min_sketch_1).default; } }));
var hyperloglog_1 = __webpack_require__(1515);
Object.defineProperty(exports, "HyperLogLog", ({ enumerable: true, get: function () { return __importDefault(hyperloglog_1).default; } }));
var topk_1 = __webpack_require__(6101);
Object.defineProperty(exports, "TopK", ({ enumerable: true, get: function () { return __importDefault(topk_1).default; } }));
var min_hash_1 = __webpack_require__(3294);
Object.defineProperty(exports, "MinHash", ({ enumerable: true, get: function () { return min_hash_1.MinHash; } }));
var min_hash_factory_1 = __webpack_require__(7577);
Object.defineProperty(exports, "MinHashFactory", ({ enumerable: true, get: function () { return __importDefault(min_hash_factory_1).default; } }));
var cuckoo_filter_1 = __webpack_require__(1544);
Object.defineProperty(exports, "CuckooFilter", ({ enumerable: true, get: function () { return __importDefault(cuckoo_filter_1).default; } }));
var invertible_bloom_lookup_tables_1 = __webpack_require__(223);
Object.defineProperty(exports, "InvertibleBloomFilter", ({ enumerable: true, get: function () { return __importDefault(invertible_bloom_lookup_tables_1).default; } }));
var cell_1 = __webpack_require__(9592);
Object.defineProperty(exports, "Cell", ({ enumerable: true, get: function () { return __importDefault(cell_1).default; } }));
var hashing_1 = __webpack_require__(8367);
Object.defineProperty(exports, "Hashing", ({ enumerable: true, get: function () { return __importDefault(hashing_1).default; } }));
var deprecated_hashing_1 = __webpack_require__(9573);
Object.defineProperty(exports, "DeprecatedHashing", ({ enumerable: true, get: function () { return __importDefault(deprecated_hashing_1).default; } }));
var scalable_bloom_filter_1 = __webpack_require__(8642);
Object.defineProperty(exports, "ScalableBloomFilter", ({ enumerable: true, get: function () { return __importDefault(scalable_bloom_filter_1).default; } }));


/***/ }),

/***/ 4914:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

/* file : base-filter.ts
MIT License

Copyright (c) 2017-2020 Thomas Minier & Arnaud Grall

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var seedrandom_1 = __importDefault(__webpack_require__(7391));
var hashing_1 = __importDefault(__webpack_require__(8367));
var utils_1 = __webpack_require__(8609);
/**
 * A base class for implementing probailistic filters
 * @author Thomas Minier
 * @author Arnaud Grall
 */
var BaseFilter = /** @class */ (function () {
    function BaseFilter() {
        this._seed = (0, utils_1.getDefaultSeed)();
        this._rng = (0, seedrandom_1.default)("".concat(this._seed));
        this._hashing = new hashing_1.default();
    }
    Object.defineProperty(BaseFilter.prototype, "seed", {
        /**
         * Get the seed used in this structure
         */
        get: function () {
            return this._seed;
        },
        /**
         * Set the seed for this structure
         * @param  seed the new seed that will be used in this structure
         */
        set: function (seed) {
            this._seed = seed;
            this._rng = (0, seedrandom_1.default)("".concat(this._seed));
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(BaseFilter.prototype, "random", {
        /**
         * Get a function used to draw random number
         * @return A factory function used to draw random integer
         */
        get: function () {
            return this._rng;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Return a next random seeded int32 integer
     * @returns
     */
    BaseFilter.prototype.nextInt32 = function () {
        return this._rng.int32();
    };
    /**
     * Save the current structure as a JSON
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    BaseFilter.prototype.saveAsJSON = function () {
        throw new Error('not-implemented');
    };
    /**
     * Load an Object from a provided JSON object
     * @param json the JSON object to load
     * @return Return the Object loaded from the provided JSON object
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/no-unused-vars
    BaseFilter.fromJSON = function (json) {
        throw new Error("not-implemented");
    };
    return BaseFilter;
}());
exports["default"] = BaseFilter;


/***/ }),

/***/ 2410:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* file : BitSet.ts
MIT License

Copyright (c) 2021 David Leppik

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/
Object.defineProperty(exports, "__esModule", ({ value: true }));
var base64_arraybuffer_1 = __webpack_require__(6257);
var bitsPerWord = 8;
/**
 * A memory-efficient Boolean array. Contains just the minimal operations needed for our Bloom filter implementation.
 *
 * @author David Leppik
 */
var BitSet = /** @class */ (function () {
    /**
     * Constructor. All bits are initially set to false.
     * @param size the number of bits that can be stored. (This is NOT required to be a multiple of 8.)
     */
    function BitSet(size) {
        var diff = bitsPerWord - (size % bitsPerWord);
        this.size = size + ([0, 8].includes(diff) ? 0 : diff);
        this.array = new Uint8Array(Math.ceil(this.size / bitsPerWord));
    }
    /**
     * Returns the value of the bit at the given index
     * @param index position of the bit, zero-indexed
     */
    BitSet.prototype.has = function (index) {
        var wordIndex = Math.floor(index / bitsPerWord);
        var mask = 1 << index % bitsPerWord;
        return (this.array[wordIndex] & mask) !== 0;
    };
    /**
     * Set the bit to true
     * @param index position of the bit, zero-indexed
     */
    BitSet.prototype.add = function (index) {
        var wordIndex = Math.floor(index / bitsPerWord);
        var mask = 1 << index % bitsPerWord;
        this.array[wordIndex] = this.array[wordIndex] | mask;
    };
    /**
     * Returns the maximum true bit.
     */
    BitSet.prototype.max = function () {
        for (var i = this.array.length - 1; i >= 0; i--) {
            var bits = this.array[i];
            if (bits) {
                return BitSet.highBit(bits) + i * bitsPerWord;
            }
        }
        return 0;
    };
    /**
     * Returns the number of true bits.
     */
    BitSet.prototype.bitCount = function () {
        var result = 0;
        for (var i = 0; i < this.array.length; i++) {
            result += BitSet.countBits(this.array[i]); // Assumes we never have bits set beyond the end
        }
        return result;
    };
    /**
     * Returns true if the size and contents are identical.
     * @param other another BitSet
     */
    BitSet.prototype.equals = function (other) {
        if (other.size !== this.size) {
            return false;
        }
        for (var i = 0; i < this.array.length; i++) {
            if (this.array[i] !== other.array[i]) {
                return false;
            }
        }
        return true;
    };
    /**
     * Returns a JSON-encodable object readable by {@link import}.
     */
    BitSet.prototype.export = function () {
        return {
            size: this.size,
            content: (0, base64_arraybuffer_1.encode)(this.array),
        };
    };
    /**
     * Returns an object written by {@link export}.
     * @param data an object written by {@link export}
     */
    BitSet.import = function (data) {
        if (typeof data.size !== 'number') {
            throw Error('BitSet missing size');
        }
        if (typeof data.content !== 'string') {
            throw Error('BitSet: missing content');
        }
        var result = new BitSet(data.size);
        var buffer = (0, base64_arraybuffer_1.decode)(data.content);
        result.array = new Uint8Array(buffer);
        return result;
    };
    /**
     * Returns the index of the maximum bit in the number, or -1 for 0
     * @bits an unsigned 8-bit number
     * ```js
     * @example
     * BitSet.highBit(0) // returns -1
     * BitSet.highBit(5) // returns 2
     * ```
     */
    BitSet.highBit = function (bits) {
        var result = bitsPerWord - 1;
        var mask = 1 << result;
        while (result >= 0 && (mask & bits) !== mask) {
            mask >>>= 1;
            result--;
        }
        return result;
    };
    /**
     * Returns the number of true bits in the number
     * @bits an unsigned 8-bit number
     * @example
     * ```js
     * BitSet.countBits(0) // returns 0
     * BitSet.countBits(3) // returns 2
     * ```
     */
    BitSet.countBits = function (bits) {
        var result = bits & 1;
        while (bits !== 0) {
            bits = bits >>> 1;
            result += bits & 1;
        }
        return result;
    };
    return BitSet;
}());
exports["default"] = BitSet;


/***/ }),

/***/ 74:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

/* file : bloom-filter.ts
MIT License

Copyright (c) 2017 Thomas Minier & Arnaud Grall

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var base_filter_1 = __importDefault(__webpack_require__(4914));
var bit_set_1 = __importDefault(__webpack_require__(2410));
var exportable_1 = __webpack_require__(8044);
var formulas_1 = __webpack_require__(9757);
/**
 * A Bloom filter is a space-efficient probabilistic data structure, conceived by Burton Howard Bloom in 1970,
 * that is used to test whether an element is a member of a set. False positive matches are possible, but false negatives are not.
 *
 * Reference: Bloom, B. H. (1970). Space/time trade-offs in hash coding with allowable errors. Communications of the ACM, 13(7), 422-426.
 * @see {@link http://crystal.uta.edu/~mcguigan/cse6350/papers/Bloom.pdf} for more details about classic Bloom Filters.
 * @author Thomas Minier
 * @author Arnaud Grall
 */
var BloomFilter = /** @class */ (function (_super) {
    __extends(BloomFilter, _super);
    /**
     * Constructor
     * @param size - The number of cells
     * @param nbHashes - The number of hash functions used
     */
    function BloomFilter(size, nbHashes) {
        var _this = _super.call(this) || this;
        if (nbHashes < 1) {
            throw new Error("A BloomFilter cannot uses less than one hash function, while you tried to use ".concat(nbHashes, "."));
        }
        _this._size = size;
        _this._nbHashes = nbHashes;
        _this._filter = new bit_set_1.default(size);
        return _this;
    }
    BloomFilter_1 = BloomFilter;
    /**
     * Create an optimal bloom filter providing the maximum of elements stored and the error rate desired
     * @param  nbItems      - The maximum number of item to store
     * @param  errorRate  - The error rate desired for a maximum of items inserted
     * @return A new {@link BloomFilter}
     */
    BloomFilter.create = function (nbItems, errorRate) {
        var size = (0, formulas_1.optimalFilterSize)(nbItems, errorRate);
        var hashes = (0, formulas_1.optimalHashes)(size, nbItems);
        return new this(size, hashes);
    };
    /**
     * Build a new Bloom Filter from an existing iterable with a fixed error rate
     * @param items - The iterable used to populate the filter
     * @param errorRate - The error rate, i.e. 'false positive' rate, targeted by the filter
     * @param seed - The random number seed (optional)
     * @return A new Bloom Filter filled with the iterable's elements
     * @example
     * ```js
     * // create a filter with a false positive rate of 0.1
     * const filter = BloomFilter.from(['alice', 'bob', 'carl'], 0.1);
     * ```
     */
    BloomFilter.from = function (items, errorRate, seed) {
        var array = Array.from(items);
        var filter = BloomFilter_1.create(array.length, errorRate);
        if (typeof seed === 'number') {
            filter.seed = seed;
        }
        array.forEach(function (element) { return filter.add(element); });
        return filter;
    };
    Object.defineProperty(BloomFilter.prototype, "size", {
        /**
         * Get the optimal size of the filter
         * @return The size of the filter
         */
        get: function () {
            return this._size;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(BloomFilter.prototype, "length", {
        /**
         * Get the number of bits currently set in the filter
         * @return The filter length
         */
        get: function () {
            return this._filter.bitCount();
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Add an element to the filter
     * @param element - The element to add
     * @example
     * ```js
     * const filter = new BloomFilter(15, 0.1);
     * filter.add('foo');
     * ```
     */
    BloomFilter.prototype.add = function (element) {
        var indexes = this._hashing.getIndexes(element, this._size, this._nbHashes, this.seed);
        for (var i = 0; i < indexes.length; i++) {
            this._filter.add(indexes[i]);
        }
    };
    /**
     * Test an element for membership
     * @param element - The element to look for in the filter
     * @return False if the element is definitively not in the filter, True is the element might be in the filter
     * @example
     * ```js
     * const filter = new BloomFilter(15, 0.1);
     * filter.add('foo');
     * console.log(filter.has('foo')); // output: true
     * console.log(filter.has('bar')); // output: false
     * ```
     */
    BloomFilter.prototype.has = function (element) {
        var indexes = this._hashing.getIndexes(element, this._size, this._nbHashes, this.seed);
        for (var i = 0; i < indexes.length; i++) {
            if (!this._filter.has(indexes[i])) {
                return false;
            }
        }
        return true;
    };
    /**
     * Get the current false positive rate (or error rate) of the filter
     * @return The current false positive rate of the filter
     * @example
     * ```js
     * const filter = new BloomFilter(15, 0.1);
     * console.log(filter.rate()); // output: something around 0.1
     * ```
     */
    BloomFilter.prototype.rate = function () {
        return Math.pow(1 - Math.exp(-this.length / this._size), this._nbHashes);
    };
    /**
     * Check if another Bloom Filter is equal to this one
     * @param  other - The filter to compare to this one
     * @return True if they are equal, false otherwise
     */
    BloomFilter.prototype.equals = function (other) {
        if (this._size !== other._size || this._nbHashes !== other._nbHashes) {
            return false;
        }
        return this._filter.equals(other._filter);
    };
    var BloomFilter_1;
    __decorate([
        (0, exportable_1.Field)(),
        __metadata("design:type", Number)
    ], BloomFilter.prototype, "_size", void 0);
    __decorate([
        (0, exportable_1.Field)(),
        __metadata("design:type", Number)
    ], BloomFilter.prototype, "_nbHashes", void 0);
    __decorate([
        (0, exportable_1.Field)(function (f) { return f.export(); }, function (data) {
            // create the bitset from new and old array-based exported structure
            if (Array.isArray(data)) {
                var bs_1 = new bit_set_1.default(data.length);
                data.forEach(function (val, index) {
                    if (val !== 0) {
                        bs_1.add(index);
                    }
                });
                return bs_1;
            }
            else {
                return bit_set_1.default.import(data);
            }
        }),
        __metadata("design:type", bit_set_1.default
        /**
         * Constructor
         * @param size - The number of cells
         * @param nbHashes - The number of hash functions used
         */
        )
    ], BloomFilter.prototype, "_filter", void 0);
    BloomFilter = BloomFilter_1 = __decorate([
        (0, exportable_1.AutoExportable)('BloomFilter', ['_seed']),
        __param(0, (0, exportable_1.Parameter)('_size')),
        __param(1, (0, exportable_1.Parameter)('_nbHashes')),
        __metadata("design:paramtypes", [Number, Number])
    ], BloomFilter);
    return BloomFilter;
}(base_filter_1.default));
exports["default"] = BloomFilter;


/***/ }),

/***/ 6800:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

/* file : counting-bloom-filter.ts
MIT License

Copyright (c) 2017 Thomas Minier & Arnaud Grall

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var base_filter_1 = __importDefault(__webpack_require__(4914));
var exportable_1 = __webpack_require__(8044);
var formulas_1 = __webpack_require__(9757);
var utils_1 = __webpack_require__(8609);
/**
 * A Counting Bloom filter works in a similar manner as a regular Bloom filter; however, it is able to keep track of insertions and deletions. In a counting Bloom filter, each entry in the Bloom filter is a small counter associated with a basic Bloom filter bit.
 *
 * Reference: F. Bonomi, M. Mitzenmacher, R. Panigrahy, S. Singh, and G. Varghese, ‚ÄúAn Improved Construction for Counting Bloom Filters,‚Äù in 14th Annual European Symposium on Algorithms, LNCS 4168, 2006, pp.
684‚Äì695.
 * @author Thomas Minier & Arnaud Grall
 */
var CountingBloomFilter = /** @class */ (function (_super) {
    __extends(CountingBloomFilter, _super);
    /**
     * Constructor
     * @param size - The size of the filter
     * @param nbHashes - The number of hash functions
     */
    function CountingBloomFilter(size, nbHashes) {
        var _this = _super.call(this) || this;
        if (nbHashes < 1) {
            throw new Error("A CountingBloomFilter must used at least one hash function, but you tried to use ".concat(nbHashes, " functions. Consider increasing it."));
        }
        _this._size = size; // fm.optimalFilterSize(capacity, errorRate)
        _this._nbHashes = nbHashes; // fm.optimalHashes(this._size, capacity)
        // the filter contains tuples [bit, counter]
        _this._filter = (0, utils_1.allocateArray)(_this._size, function () { return [0, 0]; });
        _this._length = 0;
        return _this;
    }
    CountingBloomFilter_1 = CountingBloomFilter;
    /**
     * Allocate a CountingBloomFilter with a target maximum capacity and error rate
     * @param  capacity - The maximum capacity of the filter
     * @param  errorRate - The error rate of the filter
     * @return A new {@link CountingBloomFilter}
     */
    CountingBloomFilter.create = function (capacity, errorRate) {
        var s = (0, formulas_1.optimalFilterSize)(capacity, errorRate);
        return new CountingBloomFilter_1(s, (0, formulas_1.optimalHashes)(s, capacity));
    };
    /**
     * Build a new Bloom Filter from an iterable with a fixed error rate
     * @param items - Iterable used to populate the filter
     * @param errorRate - The error rate of the filter
     * @return A new Bloom Filter filled with the iterable's elements
     * @example
     * ```js
     * // create a filter with a false positive rate of 0.1
     * const filter = CountingBloomFilter.from(['alice', 'bob', 'carl'], 0.1);
     * ```
     */
    CountingBloomFilter.from = function (items, errorRate) {
        var array = Array.from(items);
        var filter = CountingBloomFilter_1.create(array.length, errorRate);
        array.forEach(function (element) { return filter.add(element); });
        return filter;
    };
    Object.defineProperty(CountingBloomFilter.prototype, "size", {
        /**
         * Get the optimal size of the filter
         */
        get: function () {
            return this._size;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(CountingBloomFilter.prototype, "length", {
        /**
         * Get the number of elements currently in the filter
         */
        get: function () {
            return this._length;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Add an element to the filter
     * @param element - The element to add
     * @example
     * ```js
     * const filter = new CountingBloomFilter(15, 0.1);
     * filter.add('foo');
     * ```
     */
    CountingBloomFilter.prototype.add = function (element) {
        var indexes = this._hashing.getIndexes(element, this._size, this._nbHashes, this.seed);
        for (var i = 0; i < indexes.length; i++) {
            // increment counter
            this._filter[indexes[i]][1] += 1;
            // set bit if necessary
            if (this._filter[indexes[i]][1] > 0) {
                this._filter[indexes[i]][0] = 1;
            }
        }
        this._length++;
    };
    /**
     * Remove an element from the filter
     * @param element - The element to delete
     * @example
     * ```js
     * const filter = new CountingBloomFilter(15, 0.1);
     * filter.remove('foo');
     * ```
     */
    CountingBloomFilter.prototype.remove = function (element) {
        var indexes = this._hashing.getIndexes(element, this._size, this._nbHashes, this.seed);
        var success = true;
        for (var i = 0; i < indexes.length; i++) {
            // decrement counter
            this._filter[indexes[i]][1] -= 1;
            // set bit if necessary
            if (this._filter[indexes[i]][1] <= 0) {
                this._filter[indexes[i]][0] = 0;
            }
        }
        this._length--;
        return success;
    };
    /**
     * Test an element for membership
     * @param element - The element to look for in the filter
     * @return False if the element is definitively not in the filter, True is the element might be in the filter
     * @example
     * ```js
     * const filter = new CountingBloomFilter(15, 0.1);
     * filter.add('foo');
     * console.log(filter.has('foo')); // output: true
     * console.log(filter.has('bar')); // output: false
     * ```
     */
    CountingBloomFilter.prototype.has = function (element) {
        var indexes = this._hashing.getIndexes(element, this._size, this._nbHashes, this.seed);
        for (var i = 0; i < indexes.length; i++) {
            if (!this._filter[indexes[i]][0]) {
                return false;
            }
        }
        return true;
    };
    /**
     * Get the current false positive rate (or error rate) of the filter
     * @return The current false positive rate of the filter
     * @example
     * ```js
     * const filter = new BloomFilter(15, 0.1);
     * console.log(filter.rate()); // output: something around 0.1
     * ```
     */
    CountingBloomFilter.prototype.rate = function () {
        return Math.pow(1 - Math.exp((-this._nbHashes * this._length) / this._size), this._nbHashes);
    };
    /**
     * Check if another Counting Bloom Filter is equal to this one
     * @param  filter - The filter to compare to this one
     * @return True if they are equal, false otherwise
     */
    CountingBloomFilter.prototype.equals = function (other) {
        if (this._size !== other._size ||
            this._nbHashes !== other._nbHashes ||
            this._length !== other._length) {
            return false;
        }
        return this._filter.every(function (value, index) {
            return other._filter[index][0] === value[0] &&
                other._filter[index][1] === value[1];
        });
    };
    var CountingBloomFilter_1;
    __decorate([
        (0, exportable_1.Field)(),
        __metadata("design:type", Number)
    ], CountingBloomFilter.prototype, "_size", void 0);
    __decorate([
        (0, exportable_1.Field)(),
        __metadata("design:type", Number)
    ], CountingBloomFilter.prototype, "_nbHashes", void 0);
    __decorate([
        (0, exportable_1.Field)(),
        __metadata("design:type", Array)
    ], CountingBloomFilter.prototype, "_filter", void 0);
    __decorate([
        (0, exportable_1.Field)(),
        __metadata("design:type", Number)
    ], CountingBloomFilter.prototype, "_length", void 0);
    CountingBloomFilter = CountingBloomFilter_1 = __decorate([
        (0, exportable_1.AutoExportable)('CountingBloomFilter', ['_seed']),
        __param(0, (0, exportable_1.Parameter)('_size')),
        __param(1, (0, exportable_1.Parameter)('_nbHashes')),
        __metadata("design:paramtypes", [Number, Number])
    ], CountingBloomFilter);
    return CountingBloomFilter;
}(base_filter_1.default));
exports["default"] = CountingBloomFilter;


/***/ }),

/***/ 4204:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

/* file : partitioned-bloom-filter.ts
MIT License

Copyright (c) 2017-2020 Thomas Minier & Arnaud Grall

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var base_filter_1 = __importDefault(__webpack_require__(4914));
var exportable_1 = __webpack_require__(8044);
var utils_1 = __webpack_require__(8609);
var bit_set_1 = __importDefault(__webpack_require__(2410));
/**
 * Return the optimal number of hashes needed for a given error rate and load factor
 * P = p^k <=> k = ln(P)/ln(p)
 * @param  errorRate - The provided error rate
 * @param  loadFactor - The load factor, ideally 0.5
 * @return The number of hash function to use
 */
function computeOptimalNumberOfhashes(errorRate, loadFactor) {
    // P = p^k <=> k = ln(P)/ln(p)
    return Math.ceil(Math.log(errorRate) / Math.log(loadFactor));
}
/**
 * Return the total number of bits needed for this filter
 * n = M*(ln(p)ln(1-p))/(-ln(P)) <=> M = (n*-ln(P)/(ln(p)ln(1-p))
 * @param  size - The number of desired items
 * @param  rate - The error rate desired
 * @param  loadFactor - The load factor desired
 * @return The total number of cells this filter will have
 */
function computeOptimalNumberOfCells(size, rate, loadFactor) {
    // n=M*(ln(p)ln(1-p))/(-ln(P)) <=> M=(n*-ln(P)/(ln(p)ln(1-p))
    return Math.ceil((size * -Math.log(rate)) / (Math.log(loadFactor) * Math.log(1 - loadFactor)));
}
/**
 * Return the maximum number of items this filter can store
 * @param  totalBits - The total number of cells in the filter
 * @param  loadFactor - The load factor desired
 * @param  nbHashes - The number of hash functions used
 * @return The maximum number of items this filter store
 */
function computeNumberOfItems(totalBits, loadFactor, nbHashes) {
    return Math.ceil((totalBits * (Math.log(loadFactor) * Math.log(1 - loadFactor))) /
        -(nbHashes * Math.log(loadFactor)));
}
/**
 * A Partitioned Bloom Filter is a variation of a classic Bloom filter.
 *
 * This filter works by partitioning the M-sized bit array into k slices of size m = M/k bits, k = nb of hash functions in the filter.
 * Each hash function produces an index over m for its respective slice.
 * Thus, each element is described by exactly k bits, meaning the distribution of false positives is uniform across all elements.
 *
 * Be careful, as a Partitioned Bloom Filter have much higher collison risks that a classic Bloom Filter on small sets of data.
 *
 * Reference: Chang, F., Feng, W. C., & Li, K. (2004, March). Approximate caches for packet classification. In INFOCOM 2004. Twenty-third AnnualJoint Conference of the IEEE Computer and Communications Societies (Vol. 4, pp. 2196-2207). IEEE.
 * @see {@link https://pdfs.semanticscholar.org/0e18/e24b37a1f4196fddf8c9ff8e4368b74cfd88.pdf} for more details about Partitioned Bloom Filters
 * @author Thomas Minier & Arnaud Grall
 */
var PartitionedBloomFilter = /** @class */ (function (_super) {
    __extends(PartitionedBloomFilter, _super);
    /**
     * Constructor
     * @param size - The total number of cells
     * @param nbHashes - The number of hash functions
     * @param loadFactor - The load factor
     * @param capacity - The filter capacity
     */
    function PartitionedBloomFilter(size, nbHashes, loadFactor, capacity) {
        var _this = _super.call(this) || this;
        _this._size = size;
        _this._nbHashes = nbHashes;
        _this._loadFactor = loadFactor;
        _this._m = Math.ceil(_this._size / _this._nbHashes);
        _this._filter = (0, utils_1.allocateArray)(_this._nbHashes, function () { return new bit_set_1.default(_this._m); });
        _this._capacity =
            capacity !== undefined
                ? capacity
                : computeNumberOfItems(_this._size, loadFactor, nbHashes);
        return _this;
    }
    PartitionedBloomFilter_1 = PartitionedBloomFilter;
    /**
     * Return a PartitionedBloomFilter for a given number of elements and under a given error rate
     * @param  size - The max allowable number of items to insert
     * @param  errorRate - The desired error rate
     * @return A new PartitionedBloomFilter optimal for the given parameters
     */
    PartitionedBloomFilter.create = function (size, errorRate, loadFactor) {
        if (loadFactor === void 0) { loadFactor = 0.5; }
        var capacity = computeOptimalNumberOfCells(size, errorRate, loadFactor);
        var nbHashes = computeOptimalNumberOfhashes(errorRate, loadFactor);
        return new PartitionedBloomFilter_1(capacity, nbHashes, loadFactor, size);
    };
    /**
     * Build a new Partitioned Bloom Filter from an existing iterable with a fixed error rate
     * @param items - The iterable used to populate the filter
     * @param errorRate - The error rate, i.e. 'false positive' rate, targetted by the filter
     * @param loadFactor - The filter's load factor
     * @return A new Bloom Filter filled with the iterable's elements
     * @example
     * ```js
     * // create a filter with a false positive rate of 0.1
     * const filter = PartitionedBloomFilter.from(['alice', 'bob', 'carl'], 0.1);
     * ```
     */
    PartitionedBloomFilter.from = function (items, errorRate, loadFactor) {
        if (loadFactor === void 0) { loadFactor = 0.5; }
        var array = Array.from(items);
        var filter = PartitionedBloomFilter_1.create(array.length, errorRate, loadFactor);
        array.forEach(function (element) { return filter.add(element); });
        return filter;
    };
    Object.defineProperty(PartitionedBloomFilter.prototype, "capacity", {
        /**
         * Get the filter capacity, i.e. the maximum number of elements it will contains
         */
        get: function () {
            return this._capacity;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(PartitionedBloomFilter.prototype, "size", {
        /**
         * Get the size of the filter
         */
        get: function () {
            return this._size;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(PartitionedBloomFilter.prototype, "loadFactor", {
        /**
         * Get the filter's load factor
         */
        get: function () {
            return this._loadFactor;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Add an element to the filter
     * @param element - The element to add
     * @example
     * ```js
     * const filter = new PartitionedBloomFilter(15, 0.1);
     * filter.add('foo');
     * ```
     */
    PartitionedBloomFilter.prototype.add = function (element) {
        var indexes = this._hashing.getIndexes(element, this._m, this._nbHashes, this.seed);
        for (var i = 0; i < this._nbHashes; i++) {
            this._filter[i].add(indexes[i]);
        }
    };
    /**
     * Test an element for membership
     * @param element - The element to look for in the filter
     * @return False if the element is definitively not in the filter, True is the element might be in the filter
     * @example
     * ```js
     * const filter = new PartitionedBloomFilter(15, 0.1);
     * filter.add('foo');
     * console.log(filter.has('foo')); // output: true
     * console.log(filter.has('bar')); // output: false
     * ```
     */
    PartitionedBloomFilter.prototype.has = function (element) {
        var indexes = this._hashing.getIndexes(element, this._m, this._nbHashes, this.seed);
        for (var i = 0; i < this._nbHashes; i++) {
            if (!this._filter[i].has(indexes[i])) {
                return false;
            }
        }
        return true;
    };
    /**
     * Compute the current false positive rate (or error rate) of the filter
     * @return The current false positive rate of the filter
     * @example
     * ```js
     * const filter = PartitionedBloomFilter.create(15, 0.1);
     * console.log(filter.rate()); // output: something around 0.1
     * ```
     */
    PartitionedBloomFilter.prototype.rate = function () {
        // get the error rate for the first bucket (1 - (1 - 1/m)^n), where m is the size of a slice and n is the number of inserted elements
        var p = this._currentload();
        // P = p^k
        return Math.pow(p, this._nbHashes);
    };
    /**
     * Check if another Partitioned Bloom Filter is equal to this one
     * @param  filter - The filter to compare to this one
     * @return True if they are equal, false otherwise
     */
    PartitionedBloomFilter.prototype.equals = function (other) {
        if (this._size !== other._size ||
            this._nbHashes !== other._nbHashes ||
            this._loadFactor !== other._loadFactor) {
            return false;
        }
        return this._filter.every(function (array, outerIndex) {
            return other._filter[outerIndex].equals(array);
        });
    };
    /**
     * Return the current load of this filter, iterate on all buckets
     * @return An integer between 0 and 1, where 0 = filter empty and 1 = filter full
     */
    PartitionedBloomFilter.prototype._currentload = function () {
        var values = this._filter.map(function (bucket) {
            return bucket.bitCount();
        });
        var used = values.reduce(function (a, b) { return a + b; }, 0);
        return used / this._size;
    };
    var PartitionedBloomFilter_1;
    __decorate([
        (0, exportable_1.Field)(),
        __metadata("design:type", Number)
    ], PartitionedBloomFilter.prototype, "_size", void 0);
    __decorate([
        (0, exportable_1.Field)(),
        __metadata("design:type", Number)
    ], PartitionedBloomFilter.prototype, "_nbHashes", void 0);
    __decorate([
        (0, exportable_1.Field)(),
        __metadata("design:type", Number)
    ], PartitionedBloomFilter.prototype, "_loadFactor", void 0);
    __decorate([
        (0, exportable_1.Field)(),
        __metadata("design:type", Number)
    ], PartitionedBloomFilter.prototype, "_m", void 0);
    __decorate([
        (0, exportable_1.Field)(function (sets) { return sets.map(function (s) { return s.export(); }); }, function (array) {
            return array.map(function (data) {
                // create the bitset from new and old array-based exported structure
                if (Array.isArray(data)) {
                    var bs_1 = new bit_set_1.default(data.length);
                    data.forEach(function (val, index) {
                        if (val !== 0) {
                            bs_1.add(index);
                        }
                    });
                    return bs_1;
                }
                else {
                    return bit_set_1.default.import(data);
                }
            });
        }),
        __metadata("design:type", Array)
    ], PartitionedBloomFilter.prototype, "_filter", void 0);
    __decorate([
        (0, exportable_1.Field)(),
        __metadata("design:type", Number)
    ], PartitionedBloomFilter.prototype, "_capacity", void 0);
    PartitionedBloomFilter = PartitionedBloomFilter_1 = __decorate([
        (0, exportable_1.AutoExportable)('PartitionedBloomFilter', ['_seed']),
        __param(0, (0, exportable_1.Parameter)('_size')),
        __param(1, (0, exportable_1.Parameter)('_nbHashes')),
        __param(2, (0, exportable_1.Parameter)('_loadFactor')),
        __param(3, (0, exportable_1.Parameter)('_capacity')),
        __metadata("design:paramtypes", [Number, Number, Number, Number])
    ], PartitionedBloomFilter);
    return PartitionedBloomFilter;
}(base_filter_1.default));
exports["default"] = PartitionedBloomFilter;


/***/ }),

/***/ 8642:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

/* file : scalable-bloom-filter.ts
MIT License

Copyright (c) 2022 Thomas Minier & Arnaud Grall

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var base_filter_1 = __importDefault(__webpack_require__(4914));
var exportable_1 = __webpack_require__(8044);
var partitioned_bloom_filter_1 = __importDefault(__webpack_require__(4204));
var seedrandom_1 = __importDefault(__webpack_require__(7391));
/**
 * A Scalable Bloom Filter is a variant of Bloom Filters that can adapt dynamically to the
number of elements stored, while assuring a maximum false positive probability
 *
 * Reference: ALMEIDA, Paulo S√©rgio, BAQUERO, Carlos, PREGUI√áA, Nuno, et al. Scalable bloom filters. Information Processing Letters, 2007, vol. 101, no 6, p. 255-261.
 * @see {@link https://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.725.390&rep=rep1&type=pdf}
 * @author Thomas Minier & Arnaud Grall
 */
var ScalableBloomFilter = /** @class */ (function (_super) {
    __extends(ScalableBloomFilter, _super);
    function ScalableBloomFilter(_initial_size, _error_rate, _ratio) {
        if (_initial_size === void 0) { _initial_size = 8; }
        if (_error_rate === void 0) { _error_rate = 0.01; }
        if (_ratio === void 0) { _ratio = 0.5; }
        var _this = _super.call(this) || this;
        /**
         * Internal Partition Bloom Filters
         */
        _this._filters = [];
        _this._initial_size = _initial_size;
        _this._error_rate = _error_rate;
        _this._ratio = _ratio;
        _this._filters.push(partitioned_bloom_filter_1.default.create(_this._initial_size, _this._error_rate, _this._ratio));
        _this._filters[_this._filters.length - 1].seed = _this.seed;
        return _this;
    }
    ScalableBloomFilter_1 = ScalableBloomFilter;
    Object.defineProperty(ScalableBloomFilter.prototype, "seed", {
        /**
         * @override
         * Return the current seed.
         * For obscure reason we must code this function...
         */
        get: function () {
            return this._seed;
        },
        /**
         * @override
         * Set the seed for this structure. If you override the seed after adding data,
         * all the filters will be updated and you may get wrong indexes for already indexed data
         * due to the seed change. So only change it once before adding data.
         * @param  seed the new seed that will be used in this structure
         */
        set: function (seed) {
            var _this = this;
            this._seed = seed;
            this._rng = (0, seedrandom_1.default)("".concat(this._seed));
            this._filters.forEach(function (filter) {
                filter.seed = _this.seed;
            });
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Add a new element to the filter
     * @param element
     */
    ScalableBloomFilter.prototype.add = function (element) {
        // determine if we need to create a new filter
        var currentFilter = this._filters[this._filters.length - 1];
        if (currentFilter._currentload() > currentFilter._loadFactor) {
            // create a new filter
            var newSize = this._initial_size *
                Math.pow(ScalableBloomFilter_1._s, this._filters.length + 1) *
                Math.LN2;
            var newErrorRate = this._error_rate * Math.pow(this._ratio, this._filters.length);
            this._filters.push(partitioned_bloom_filter_1.default.create(newSize, newErrorRate, this._ratio));
            this._filters[this._filters.length - 1].seed = this.seed;
        }
        // get the newly created filter
        this._filters[this._filters.length - 1].add(element);
    };
    /**
     * Return True if the element has been found, false otherwise.
     * Check until we found the value in a filter otherwise stop on the first value found.
     * @param element
     * @returns
     */
    ScalableBloomFilter.prototype.has = function (element) {
        return this._filters.some(function (filter) { return filter.has(element); });
    };
    /**
     * Return the current capacity (number of elements) of this filter
     * @returns
     */
    ScalableBloomFilter.prototype.capacity = function () {
        return this._filters.map(function (f) { return f._capacity; }).reduce(function (p, c) { return p + c; }, 0);
    };
    /**
     * Return the current false positive rate of this structure
     * @returns
     */
    ScalableBloomFilter.prototype.rate = function () {
        return this._filters[this._filters.length - 1].rate();
    };
    /**
     * Check if two ScalableBloomFilter are equal
     * @param filter
     * @returns
     */
    ScalableBloomFilter.prototype.equals = function (filter) {
        // assert the seed, the ratio and the capacity are equals
        if (this.seed !== filter.seed ||
            this._ratio !== filter._ratio ||
            this.capacity() !== filter.capacity()) {
            return false;
        }
        return this._filters.every(function (currentFilter, index) {
            return filter._filters[index].equals(currentFilter);
        });
    };
    /**
     * Create a Scalable Bloom Filter based on Partitionned Bloom Filter.
     * @param _size the starting size of the filter
     * @param _error_rate ther error rate desired of the filter
     * @param _ratio the load factor desired
     * @returns
     */
    ScalableBloomFilter.create = function (_size, _error_rate, _ratio) {
        if (_ratio === void 0) { _ratio = 0.5; }
        return new ScalableBloomFilter_1(_size, _error_rate, _ratio);
    };
    var ScalableBloomFilter_1;
    /**
     * Static value, will power the size of the new set, by default we will follow a power of 2.
     */
    ScalableBloomFilter._s = 2;
    __decorate([
        (0, exportable_1.Field)(),
        __metadata("design:type", Number)
    ], ScalableBloomFilter.prototype, "_initial_size", void 0);
    __decorate([
        (0, exportable_1.Field)(),
        __metadata("design:type", Number)
    ], ScalableBloomFilter.prototype, "_error_rate", void 0);
    __decorate([
        (0, exportable_1.Field)(),
        __metadata("design:type", Number)
    ], ScalableBloomFilter.prototype, "_ratio", void 0);
    __decorate([
        (0, exportable_1.Field)(function (filters) {
            return filters.map(function (filter) { return filter.saveAsJSON(); });
        }, // eslint-disable-line @typescript-eslint/no-unsafe-return
        function (array) {
            return array.map(function (data) { return partitioned_bloom_filter_1.default.fromJSON(data); });
        }),
        __metadata("design:type", Array)
    ], ScalableBloomFilter.prototype, "_filters", void 0);
    ScalableBloomFilter = ScalableBloomFilter_1 = __decorate([
        (0, exportable_1.AutoExportable)('ScalableBloomFilter', ['_seed']),
        __param(0, (0, exportable_1.Parameter)('_initial_size')),
        __param(1, (0, exportable_1.Parameter)('_error_rate')),
        __param(2, (0, exportable_1.Parameter)('_ratio')),
        __metadata("design:paramtypes", [Object, Object, Object])
    ], ScalableBloomFilter);
    return ScalableBloomFilter;
}(base_filter_1.default));
exports["default"] = ScalableBloomFilter;


/***/ }),

/***/ 8620:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

/* file : xor-filter.ts
MIT License

Copyright (c) 2017 Arnaud Grall

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
// Code inspired by the java implementation (https://github.com/FastFilter/fastfilter_java/blob/master/fastfilter/src/main/java/org/fastfilter/xor/Xor8.java)
var base_filter_1 = __importDefault(__webpack_require__(4914));
var exportable_1 = __webpack_require__(8044);
var utils_1 = __webpack_require__(8609);
var xxhashjs_1 = __importDefault(__webpack_require__(9134));
var long_1 = __importDefault(__webpack_require__(5017));
var base64_arraybuffer_1 = __webpack_require__(6257);
var CONSTANTS = new Map();
CONSTANTS.set(8, 0xff);
CONSTANTS.set(16, 0xffff);
/**
 * XOR-Filter for 8-bits and 16-bits fingerprint length.
 *
 * To use for fixed sets of elements only
 * Inspired from @see https://github.com/FastFilter/fastfilter_java
 * @author Arnaud GRALL
 * @example
 * ```js
 * const xor8 = new XorFilter(1) // default fingerprint of 8 bits
 * xor8.add(['a'])
 * xor8.has('a') // true
 * xor8.has('b') // false
 * const xor16 = new XorFilter(1, 16)
 * xor16.add(['a'])
 * xor16.has('a') // true
 * xor16.has('b') // false
 * ```
 */
var XorFilter = /** @class */ (function (_super) {
    __extends(XorFilter, _super);
    /**
     * Create an empty XorFilter for a number of `size` elements.
     * The fingerprint length can be choosen
     * @param size
     * @param bits_per_fingerprint
     */
    function XorFilter(size, bits_per_fingerprint) {
        var _this = _super.call(this) || this;
        _this.ALLOWED_FINGERPRINT_SIZES = [8, 16];
        _this.HASHES = 3;
        _this.OFFSET = 32;
        _this.FACTOR_TIMES_100 = 123;
        /**
         * Number of bits per fingerprint
         */
        _this._bits = 8;
        // try to use the Buffer class or reject by throwing an error
        if (!Buffer) {
            throw new Error(utils_1.BufferError);
        }
        if (bits_per_fingerprint) {
            if (!_this.ALLOWED_FINGERPRINT_SIZES.includes(bits_per_fingerprint)) {
                throw new Error("bits_per_fingerprint parameter must be one of: [".concat(_this.ALLOWED_FINGERPRINT_SIZES.join(','), "], got: ").concat(bits_per_fingerprint));
            }
            _this._bits = bits_per_fingerprint;
        }
        if (size <= 0) {
            throw new Error('a XorFilter must be calibrated for a given number of elements');
        }
        _this._size = size;
        var arrayLength = _this._getOptimalFilterSize(_this._size);
        _this._blockLength = arrayLength / _this.HASHES;
        _this._filter = (0, utils_1.allocateArray)(arrayLength, function () {
            return Buffer.allocUnsafe(_this._bits / 8).fill(0);
        });
        return _this;
    }
    XorFilter_1 = XorFilter;
    /**
     * Return False if the element is not in the filter, True if it might be in the set with certain probability.
     * @param element
     * @returns
     */
    XorFilter.prototype.has = function (element) {
        var hash = this._hash64(element instanceof long_1.default
            ? element
            : this._hashable_to_long(element, this.seed), this.seed);
        var fingerprint = this._fingerprint(hash).toInt();
        var r0 = long_1.default.fromInt(hash.toInt());
        var r1 = long_1.default.fromInt(hash.rotl(21).toInt());
        var r2 = long_1.default.fromInt(hash.rotl(42).toInt());
        var h0 = this._reduce(r0, this._blockLength);
        var h1 = this._reduce(r1, this._blockLength) + this._blockLength;
        var h2 = this._reduce(r2, this._blockLength) + 2 * this._blockLength;
        var l0 = this._readBuffer(this._filter[h0]);
        var l1 = this._readBuffer(this._filter[h1]);
        var l2 = this._readBuffer(this._filter[h2]);
        var xored = fingerprint ^ l0 ^ l1 ^ l2;
        var constant = CONSTANTS.get(this._bits); // eslint-disable-line @typescript-eslint/no-non-null-assertion
        return (xored & constant) === 0;
    };
    /**
     * Add elements to the filter, modify the filter in place.
     * Warning: Another call will override the previously created filter.
     * @param elements
     * @example
     * ```js
     * const xor = new XorFilter(1, 8)
     * xor.add(['alice'])
     * xor.has('alice') // true
     * xor.has('bob') // false
     * ```
     */
    XorFilter.prototype.add = function (elements) {
        if (elements.length !== this._size) {
            throw new Error("This filter has been created for exactly ".concat(this._size, " elements"));
        }
        else {
            this._create(elements, this._filter.length);
        }
    };
    /**
     * Return True if the other XorFilter is equal
     * @param filter
     * @returns
     */
    XorFilter.prototype.equals = function (filter) {
        // first check the seed
        if (this.seed !== filter.seed) {
            return false;
        }
        // check the number of bits per fingerprint used
        if (this._bits !== filter._bits) {
            return false;
        }
        // check the number of elements inserted
        if (this._size !== filter._size) {
            return false;
        }
        // now check each entry of the filter
        var broken = true;
        var i = 0;
        while (broken && i < this._filter.length) {
            if (!filter._filter[i].equals(this._filter[i])) {
                broken = false;
            }
            else {
                i++;
            }
        }
        return broken;
    };
    /**
     * Return a XorFilter for a specified set of elements
     * @param elements
     * @returns
     */
    XorFilter.create = function (elements, bits_per_fingerprint) {
        var a = new XorFilter_1(elements.length, bits_per_fingerprint);
        a.add(elements);
        return a;
    };
    // ===================================
    // ==== PRIVATE METHODS/FUNCTIONS ====
    // ===================================
    /**
     * @internal
     * @private
     * Return the optimal xor filter size
     * @param size
     * @returns
     */
    XorFilter.prototype._getOptimalFilterSize = function (size) {
        // optimal size
        var s = long_1.default.ONE.multiply(this.FACTOR_TIMES_100)
            .multiply(size)
            .divide(100)
            .add(this.OFFSET);
        // return a size which is a multiple of hashes for optimal blocklength
        return s.add(-s.mod(this.HASHES)).toInt();
    };
    /**
     * @internal
     * @private
     * Read the buffer provided as int8, int16 or int32le based on the size of the finger prints
     * @param buffer
     * @returns
     */
    XorFilter.prototype._readBuffer = function (buffer) {
        var val;
        switch (this._bits) {
            case 16:
                val = buffer.readInt16LE();
                break;
            case 8:
            default:
                val = buffer.readInt8();
                break;
        }
        return val;
    };
    /**
     * @internal
     * @private
     * Generate the fingerprint of the hash
     * @param hash hash of the element
     * @returns
     */
    XorFilter.prototype._fingerprint = function (hash) {
        return hash.and((1 << this._bits) - 1);
    };
    /**
     * @internal
     * @private
     * Transform any HashableInput into its Long representation
     * @param element
     * @param seed
     * @returns
     */
    XorFilter.prototype._hashable_to_long = function (element, seed) {
        return long_1.default.fromString(xxhashjs_1.default.h64(element, seed).toString(10), 10);
    };
    /**
     * @internal
     * @private
     * Hash a long into a Long
     * @param element
     * @returns
     */
    XorFilter.prototype._hash64 = function (element, seed) {
        var h = element.add(seed);
        h = h
            .xor(h.shiftRightUnsigned(33))
            .multiply(long_1.default.fromString('0xff51afd7ed558ccd', 16));
        h = h = h
            .xor(h.shiftRightUnsigned(33))
            .multiply(long_1.default.fromString('0xc4ceb9fe1a85ec53', 16));
        h = h.xor(h.shiftRightUnsigned(33));
        return h;
    };
    /**
     * Perform a modulo reduction using an optimiaze technique
     * @param hash
     * @param size
     * @returns
     */
    XorFilter.prototype._reduce = function (hash, size) {
        // http://lemire.me/blog/2016/06/27/a-fast-alternative-to-the-modulo-reduction/
        return hash
            .and(long_1.default.fromString('0xffffffff', 16))
            .multiply(size)
            .shiftRightUnsigned(32)
            .toInt();
    };
    /**
     * Hash the element
     * @param element
     * @param seed
     * @returns
     */
    XorFilter.prototype._getHash = function (element, seed, index) {
        var hash = this._hash64(element, seed);
        var r = hash.rotl(21 * index);
        var rn = this._reduce(r, this._blockLength);
        var sum = rn + index * this._blockLength;
        return sum;
    };
    /**
     * Create the filter representing the elements to store.
     * We eliminate all duplicated entries before creating the array.
     * Follow the algorithm 2 and 3 of the paper (@see https://arxiv.org/pdf/1912.08258.pdf)
     * Inspired by Go impl from (@see https://github.com/FastFilter/xorfilter/blob/master/xorfilter.go)
     * @param elements array of elements to add in the filter
     * @param arraylength length of the filter
     * @returns
     */
    XorFilter.prototype._create = function (elements, arrayLength) {
        var _this = this;
        var reverseOrder = (0, utils_1.allocateArray)(this._size, long_1.default.ZERO);
        var reverseH = (0, utils_1.allocateArray)(this._size, 0);
        var reverseOrderPos;
        var _loop_1 = function () {
            this_1.seed = this_1.nextInt32();
            var t2count = (0, utils_1.allocateArray)(arrayLength, 0);
            var t2 = (0, utils_1.allocateArray)(arrayLength, long_1.default.ZERO);
            elements
                .map(function (k) {
                if (k instanceof long_1.default) {
                    return k;
                }
                else {
                    return _this._hashable_to_long(k, _this.seed);
                }
            })
                .forEach(function (k) {
                for (var hi = 0; hi < _this.HASHES; hi++) {
                    var h = _this._getHash(k, _this.seed, hi);
                    t2[h] = t2[h].xor(k);
                    if (t2count[h] > 120) {
                        // probably something wrong with the hash function
                        throw new Error("Probably something wrong with the hash function, t2count[".concat(h, "]=").concat(t2count[h]));
                    }
                    t2count[h]++;
                }
            });
            reverseOrderPos = 0;
            var alone = (0, utils_1.allocateArray)(this_1.HASHES, function () {
                return (0, utils_1.allocateArray)(_this._blockLength, 0);
            });
            var alonePos = (0, utils_1.allocateArray)(this_1.HASHES, 0);
            for (var nextAlone = 0; nextAlone < this_1.HASHES; nextAlone++) {
                for (var i_1 = 0; i_1 < this_1._blockLength; i_1++) {
                    if (t2count[nextAlone * this_1._blockLength + i_1] === 1) {
                        alone[nextAlone][alonePos[nextAlone]++] =
                            nextAlone * this_1._blockLength + i_1;
                    }
                }
            }
            var found = -1;
            var i = 0;
            while (i !== -1) {
                i = -1;
                for (var hi = 0; hi < this_1.HASHES; hi++) {
                    if (alonePos[hi] > 0) {
                        i = alone[hi][--alonePos[hi]];
                        found = hi;
                        break;
                    }
                }
                if (i === -1) {
                    // no entry found
                    break;
                }
                if (t2count[i] <= 0) {
                    continue;
                }
                var k = t2[i];
                if (t2count[i] !== 1) {
                    throw new Error('At this step, the count must not be different of 1');
                }
                --t2count[i];
                for (var hi = 0; hi < this_1.HASHES; hi++) {
                    if (hi !== found) {
                        var h = this_1._getHash(k, this_1.seed, hi);
                        var newCount = --t2count[h];
                        if (newCount === 1) {
                            alone[hi][alonePos[hi]++] = h;
                        }
                        t2[h] = t2[h].xor(k);
                    }
                }
                reverseOrder[reverseOrderPos] = k;
                reverseH[reverseOrderPos] = found;
                reverseOrderPos++;
            }
        };
        var this_1 = this;
        do {
            _loop_1();
        } while (reverseOrderPos !== this._size);
        for (var i = reverseOrderPos - 1; i >= 0; i--) {
            var k = reverseOrder[i];
            var found = reverseH[i];
            var change = -1;
            var hash = this._hash64(k, this.seed);
            var xor = this._fingerprint(hash).toInt();
            for (var hi = 0; hi < this.HASHES; hi++) {
                var h = this._getHash(k, this.seed, hi);
                if (found === hi) {
                    change = h;
                }
                else {
                    xor ^= this._readBuffer(this._filter[h]);
                }
            }
            // the value is in 32 bits format, so we must cast it to the desired number of bytes
            var buf = Buffer.from((0, utils_1.allocateArray)(4, 0));
            buf.writeInt32LE(xor);
            this._filter[change] = buf.slice(0, this._bits / 8);
        }
    };
    var XorFilter_1;
    __decorate([
        (0, exportable_1.Field)(function (d) { return d.map(base64_arraybuffer_1.encode); }, function (d) { return d.map(function (e) { return Buffer.from((0, base64_arraybuffer_1.decode)(e)); }); }),
        __metadata("design:type", Array)
    ], XorFilter.prototype, "_filter", void 0);
    __decorate([
        (0, exportable_1.Field)(),
        __metadata("design:type", Object)
    ], XorFilter.prototype, "_bits", void 0);
    __decorate([
        (0, exportable_1.Field)(),
        __metadata("design:type", Number)
    ], XorFilter.prototype, "_size", void 0);
    __decorate([
        (0, exportable_1.Field)(),
        __metadata("design:type", Number)
    ], XorFilter.prototype, "_blockLength", void 0);
    XorFilter = XorFilter_1 = __decorate([
        (0, exportable_1.AutoExportable)('XorFilter', ['_seed']),
        __param(0, (0, exportable_1.Parameter)('_size')),
        __param(1, (0, exportable_1.Parameter)('_bits')),
        __metadata("design:paramtypes", [Number, Number])
    ], XorFilter);
    return XorFilter;
}(base_filter_1.default));
exports["default"] = XorFilter;


/***/ }),

/***/ 4067:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

/* file : bucket.ts
MIT License

Copyright (c) 2017-2020 Thomas Minier & Arnaud Grall

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var lodash_1 = __webpack_require__(2543);
var utils = __importStar(__webpack_require__(8609));
var exportable_1 = __webpack_require__(8044);
var exportable_2 = __webpack_require__(8044);
/**
 * A Bucket is a container of a fixed number of values, used in various bloom filters.
 * @extends Exportable
 * @author Thomas Minier
 * @private
 */
var Bucket = /** @class */ (function () {
    /**
     * Constructor
     * @param size - The maximum number of elements in the bucket
     */
    function Bucket(size) {
        this._elements = utils.allocateArray(size, null);
        this._size = size;
        this._length = 0;
    }
    Bucket_1 = Bucket;
    Object.defineProperty(Bucket.prototype, "size", {
        /**
         * Get the maximum number of element in the bucket
         */
        get: function () {
            return this._size;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Bucket.prototype, "length", {
        /**
         * Get the number of elements currenlty in the bucket
         */
        get: function () {
            return this._length;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Test if the bucket has any space available
     * @return True if te bucket has any space available, False if if its full
     */
    Bucket.prototype.isFree = function () {
        return this._length < this._size;
    };
    /**
     * Get the index of the first empty slot in the bucket
     * @return The index of the first empty slot, or -1 if the bucket is full
     */
    Bucket.prototype.nextEmptySlot = function () {
        return (0, lodash_1.indexOf)(this._elements, null);
    };
    /**
     * Get the element at the given index in the bucket
     * @param index - The index to access
     * @return The element at the given index
     */
    Bucket.prototype.at = function (index) {
        return this._elements[index];
    };
    /**
     * Try to add an element to the bucket
     * @param element - The element to add in the bucket
     * @return True if the insertion is a success, False if the bucket is full
     */
    Bucket.prototype.add = function (element) {
        if (element === null || !this.isFree()) {
            return false;
        }
        this.set(this.nextEmptySlot(), element);
        this._length++;
        return true;
    };
    /**
     * Try to remove an element from the bucket
     * @param element - The element to remove from the bucket
     * @return True if the element has been successfully removed, False if it was not in the bucket
     */
    Bucket.prototype.remove = function (element) {
        var index = (0, lodash_1.indexOf)(this._elements, element);
        if (index <= -1) {
            return false;
        }
        this.unset(index);
        return true;
    };
    /**
     * Test an element for membership
     * @param element - The element to look for in the bucket
     * @return True is the element is in the bucket, otherwise False
     */
    Bucket.prototype.has = function (element) {
        return (0, lodash_1.indexOf)(this._elements, element) > -1;
    };
    /**
     * Set an element at the given index in the bucket
     * @param index - The index at where the element should be inserted
     * @param element - The element to insert
     */
    Bucket.prototype.set = function (index, element) {
        this._elements[index] = element;
    };
    /**
     * Unset the element at the given index
     * @param index - The index of the element that should be unset
     */
    Bucket.prototype.unset = function (index) {
        this._elements[index] = null;
        this._length--;
    };
    /**
     * Randomly swap an element of the bucket with a given element, then return the replaced element
     * @param element - The element to be inserted
     * @param random - Factory function used to generate random function
     * @return The element that have been swapped with the parameter
     */
    Bucket.prototype.swapRandom = function (element, random) {
        if (random === void 0) { random = Math.random; }
        var index = utils.randomInt(0, this._length - 1, random);
        var tmp = this._elements[index];
        this._elements[index] = element;
        return tmp;
    };
    /**
     * Swap an element of the bucket with a given index and element, then return the replaced element
     * @param index - The index at where the element should be inserted
     * @param element - The element to be inserted
     * @return The element that have been swapped with the parameter
     */
    Bucket.prototype.swap = function (index, element) {
        var tmp = this._elements[index];
        this._elements[index] = element;
        return tmp;
    };
    /**
     * Test if two buckets are equals: they have the same size, length and content
     * @param bucket - The other bucket with which to compare
     * @return True if the two buckets are equals, False otherwise
     */
    Bucket.prototype.equals = function (bucket) {
        if (this._size !== bucket.size || this._length !== bucket.length)
            return false;
        return this._elements.every(function (elt, index) { return (0, lodash_1.eq)(bucket.at(index), elt); });
    };
    var Bucket_1;
    Bucket = Bucket_1 = __decorate([
        (0, exportable_1.Exportable)({
            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
            export: (0, exportable_2.cloneObject)('Bucket', '_size', '_elements'),
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            import: function (json) {
                if ((json.type !== 'Bucket' || !('_size' in json), !('_elements' in json)) // eslint-disable-line @typescript-eslint/no-unsafe-member-access
                ) {
                    throw new Error('Cannot create a Bucket from a JSON export which does not represent a bucket');
                }
                var bucket = new Bucket_1(json._size); // eslint-disable-line @typescript-eslint/no-unsafe-member-access
                // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-unsafe-call
                json._elements.forEach(function (elt, i) {
                    if (elt !== null) {
                        bucket._elements[i] = elt;
                        bucket._length++;
                    }
                });
                return bucket;
            },
        }),
        __metadata("design:paramtypes", [Number])
    ], Bucket);
    return Bucket;
}());
exports["default"] = Bucket;


/***/ }),

/***/ 1544:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

/* file : cuckoo-filter.ts
MIT License

Copyright (c) 2017-2020 Thomas Minier & Arnaud Grall

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var base_filter_1 = __importDefault(__webpack_require__(4914));
var bucket_1 = __importDefault(__webpack_require__(4067));
var exportable_1 = __webpack_require__(8044);
var utils_1 = __webpack_require__(8609);
/**
 * Compute the optimal fingerprint length in bytes for a given bucket size
 * and a false positive rate.
 * @param  {int} size - The filter bucket size
 * @param  {int} rate - The error rate, i.e. 'false positive' rate, targetted by the filter
 * @return {int} The optimal fingerprint length in bytes
 * @private
 */
function computeFingerpintLength(size, rate) {
    var f = Math.ceil(Math.log2(1 / rate) + Math.log2(2 * size));
    return Math.ceil(f / 8); // because we use 64-bits hashes
}
/**
 * Cuckoo filters improve on Bloom filters by supporting deletion, limited counting,
 * and bounded False positive rate with similar storage efficiency as a standard Bloom filter.
 *
 * Reference: Fan, B., Andersen, D. G., Kaminsky, M., & Mitzenmacher, M. D. (2014, December). Cuckoo filter: Practically better than bloom.
 * In Proceedings of the 10th ACM International on Conference on emerging Networking Experiments and Technologies (pp. 75-88). ACM.
 * @see {@link https://www.cs.cmu.edu/~dga/papers/cuckoo-conext2014.pdf} for more details about Cuckoo filters
 * @author Thomas Minier & Arnaud Grall
 */
var CuckooFilter = /** @class */ (function (_super) {
    __extends(CuckooFilter, _super);
    /**
     * Constructor
     * @param size - The filter size
     * @param fLength - The length of the fingerprints
     * @param bucketSize - The size of the buckets in the filter
     * @param maxKicks - (optional) The max number of kicks when resolving collision at insertion, default to 1
     */
    function CuckooFilter(size, fLength, bucketSize, maxKicks) {
        if (maxKicks === void 0) { maxKicks = 500; }
        var _this = _super.call(this) || this;
        _this._filter = (0, utils_1.allocateArray)(size, function () { return new bucket_1.default(bucketSize); });
        _this._size = size;
        _this._bucketSize = bucketSize;
        _this._fingerprintLength = fLength;
        _this._length = 0;
        _this._maxKicks = maxKicks;
        return _this;
    }
    CuckooFilter_1 = CuckooFilter;
    /**
     * Return a new optimal CuckooFilter given the number of maximum elements to store and the error rate desired
     * @param  size - The number of items to store
     * @param  errorRate - The desired error rate
     * @param  bucketSize - The number of buckets desired per cell
     * @param  maxKicks - The number of kicks done when a collision occurs
     * @return A Cuckoo Filter optimal for these parameters
     */
    CuckooFilter.create = function (size, errorRate, bucketSize, maxKicks) {
        if (bucketSize === void 0) { bucketSize = 4; }
        if (maxKicks === void 0) { maxKicks = 500; }
        var fl = computeFingerpintLength(bucketSize, errorRate);
        var capacity = Math.ceil(size / bucketSize / 0.955);
        return new CuckooFilter_1(capacity, fl, bucketSize, maxKicks);
    };
    /**
     * Build a new optimal CuckooFilter from an iterable with a fixed error rate
     * @param items - Iterable used to populate the filter
     * @param errorRate - The error rate of the filter
     * @param  bucketSize - The number of buckets desired per cell
     * @param  maxKicks - The number of kicks done when a collision occurs
     * @return A new Cuckoo Filter filled with the iterable's elements
     */
    CuckooFilter.from = function (items, errorRate, bucketSize, maxKicks) {
        if (bucketSize === void 0) { bucketSize = 4; }
        if (maxKicks === void 0) { maxKicks = 500; }
        var array = Array.from(items);
        var filter = CuckooFilter_1.create(array.length, errorRate, bucketSize, maxKicks);
        array.forEach(function (item) { return filter.add(item); });
        return filter;
    };
    Object.defineProperty(CuckooFilter.prototype, "size", {
        /**
         * Get the filter size
         */
        get: function () {
            return this._size;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(CuckooFilter.prototype, "fullSize", {
        /**
         * Get the filter full size, i.e., the total number of cells
         */
        get: function () {
            return this.size * this.bucketSize;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(CuckooFilter.prototype, "length", {
        /**
         * Get the filter length, i.e. the current number of elements in the filter
         */
        get: function () {
            return this._length;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(CuckooFilter.prototype, "fingerprintLength", {
        /**
         * Get the length of the fingerprints in the filter
         */
        get: function () {
            return this._fingerprintLength;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(CuckooFilter.prototype, "bucketSize", {
        /**
         * Get the size of the buckets in the filter
         */
        get: function () {
            return this._bucketSize;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(CuckooFilter.prototype, "maxKicks", {
        /**
         * Get the max number of kicks when resolving collision at insertion
         */
        get: function () {
            return this._maxKicks;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Add an element to the filter, if false is returned, it means that the filter is considered as full.
     * @param element - The element to add
     * @return True if the insertion is a success, False if the filter is full
     * @example
     * ```js
     * const filter = new CuckooFilter(15, 3, 2);
     * filter.add('alice');
     * filter.add('bob');
     * ```
     */
    CuckooFilter.prototype.add = function (element, throwError, destructive) {
        if (throwError === void 0) { throwError = false; }
        if (destructive === void 0) { destructive = false; }
        // TODO do the recovery if return false or throw error because we altered values
        var locations = this._locations(element);
        // store fingerprint in an available empty bucket
        if (this._filter[locations.firstIndex].isFree()) {
            this._filter[locations.firstIndex].add(locations.fingerprint);
        }
        else if (this._filter[locations.secondIndex].isFree()) {
            this._filter[locations.secondIndex].add(locations.fingerprint);
        }
        else {
            // buckets are full, we must relocate one of them
            var index = this.random() < 0.5 ? locations.firstIndex : locations.secondIndex;
            var movedElement = locations.fingerprint;
            var logs = [];
            for (var nbTry = 0; nbTry < this._maxKicks; nbTry++) {
                var rndIndex = (0, utils_1.randomInt)(0, this._filter[index].length - 1, this.random);
                var tmp = this._filter[index].at(rndIndex); // eslint-disable-line @typescript-eslint/no-non-null-assertion
                logs.push([index, rndIndex, tmp]);
                this._filter[index].set(rndIndex, movedElement);
                movedElement = tmp;
                // movedElement = this._filter[index].set(rndswapRandom(movedElement, this._rng)
                var newHash = this._hashing.hashAsInt(movedElement, this.seed);
                index = Math.abs(index ^ Math.abs(newHash)) % this._filter.length;
                // add the moved element to the bucket if possible
                if (this._filter[index].isFree()) {
                    this._filter[index].add(movedElement);
                    this._length++;
                    return true;
                }
            }
            if (!destructive) {
                // rollback all modified entries to their initial states
                for (var i = logs.length - 1; i >= 0; i--) {
                    var log = logs[i];
                    this._filter[log[0]].set(log[1], log[2]);
                }
            }
            // considered full
            if (throwError) {
                // rollback all operations
                throw new Error("The Cuckoo Filter is full, cannot insert element \"".concat(element, "\"") // eslint-disable-line @typescript-eslint/restrict-template-expressions
                );
            }
            else {
                return false;
            }
        }
        this._length++;
        return true;
    };
    /**
     * Remove an element from the filter
     * @param element - The element to remove
     * @return True if the element has been removed from the filter, False if it wasn't in the filter
     * @example
     * ```js
     * const filter = new CuckooFilter(15, 3, 2);
     * filter.add('alice');
     * filter.add('bob');
     *
     * // remove an element
     * filter.remove('bob');
     * ```
     */
    CuckooFilter.prototype.remove = function (element) {
        var locations = this._locations(element);
        if (this._filter[locations.firstIndex].has(locations.fingerprint)) {
            this._filter[locations.firstIndex].remove(locations.fingerprint);
            this._length--;
            return true;
        }
        else if (this._filter[locations.secondIndex].has(locations.fingerprint)) {
            this._filter[locations.secondIndex].remove(locations.fingerprint);
            this._length--;
            return true;
        }
        return false;
    };
    /**
     * Test an element for membership
     * @param element - The element to look for in the filter
     * @return False if the element is definitively not in the filter, True is the element might be in the filter
     * @example
     * ```js
     * const filter = new CuckooFilter(15, 3, 2);
     * filter.add('alice');
     *
     * console.log(filter.has('alice')); // output: true
     * console.log(filter.has('bob')); // output: false
     * ```
     */
    CuckooFilter.prototype.has = function (element) {
        var locations = this._locations(element);
        return (this._filter[locations.firstIndex].has(locations.fingerprint) ||
            this._filter[locations.secondIndex].has(locations.fingerprint));
    };
    /**
     * Return the false positive rate for this cuckoo filter
     * @return The false positive rate
     */
    CuckooFilter.prototype.rate = function () {
        var load = this._computeHashTableLoad();
        var c = this._fingerprintLength / load.load;
        return Math.pow(2, Math.log2(2 * this._bucketSize) - load.load * c);
    };
    /**
     * Return the load of this filter
     * @return {Object} load: is the load, size is the number of entries, free is the free number of entries, used is the number of entry used
     */
    CuckooFilter.prototype._computeHashTableLoad = function () {
        var max = this._filter.length * this._bucketSize;
        var used = this._filter.reduce(function (acc, val) { return acc + val.length; }, 0);
        return {
            used: used,
            free: max - used,
            size: max,
            load: used / max,
        };
    };
    /**
     * For a element, compute its fingerprint and the index of its two buckets
     * @param element - The element to hash
     * @return The fingerprint of the element and the index of its two buckets
     * @private
     */
    CuckooFilter.prototype._locations = function (element) {
        var hashes = this._hashing.hashIntAndString(element, this.seed);
        var hash = hashes.int;
        if (this._fingerprintLength > hashes.string.length) {
            throw new Error("The fingerprint length (".concat(this._fingerprintLength, ") is higher than the hash length (").concat(hashes.string.length, "). Please reduce the fingerprint length or report if it is an unexpected behavior."));
        }
        var fingerprint = hashes.string.substring(0, this._fingerprintLength);
        var firstIndex = Math.abs(hash);
        var secondHash = Math.abs(this._hashing.hashAsInt(fingerprint, this.seed));
        var secondIndex = Math.abs(firstIndex ^ secondHash);
        var res = {
            fingerprint: fingerprint,
            firstIndex: firstIndex % this._size,
            secondIndex: secondIndex % this._size,
        };
        return res;
    };
    /**
     * Check if another Cuckoo filter is equal to this one
     * @param  filter - The cuckoo filter to compare to this one
     * @return True if they are equal, false otherwise
     */
    CuckooFilter.prototype.equals = function (filter) {
        var i = 0;
        var res = true;
        while (res && i < this._filter.length) {
            var bucket = this._filter[i];
            if (!filter._filter[i].equals(bucket)) {
                res = false;
            }
            i++;
        }
        return res;
    };
    var CuckooFilter_1;
    CuckooFilter = CuckooFilter_1 = __decorate([
        (0, exportable_1.Exportable)({
            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
            export: (0, exportable_1.cloneObject)('CuckooFilter', '_size', '_fingerprintLength', '_length', '_maxKicks', '_filter', '_seed'),
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            import: function (json) {
                /* eslint-disable @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-unsafe-call */
                if (json.type !== 'CuckooFilter' ||
                    !('_size' in json) ||
                    !('_fingerprintLength' in json) ||
                    !('_length' in json) ||
                    !('_maxKicks' in json) ||
                    !('_filter' in json) ||
                    !('_seed' in json)) {
                    throw new Error('Cannot create a CuckooFilter from a JSON export which does not represent a cuckoo filter');
                }
                var filter = new CuckooFilter_1(json._size, json._fingerprintLength, json._bucketSize, json._maxKicks);
                filter._length = json._length;
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                filter._filter = json._filter.map(function (j) {
                    var bucket = new bucket_1.default(j._size);
                    // eslint-disable-next-line @typescript-eslint/no-explicit-any
                    j._elements.forEach(function (elt, i) {
                        if (elt !== null) {
                            bucket._elements[i] = elt;
                            bucket._length++;
                        }
                    });
                    return bucket;
                });
                filter.seed = json._seed;
                return filter;
                /* eslint-enable @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-unsafe-call */
            },
        }),
        __metadata("design:paramtypes", [Number, Number, Number, Object])
    ], CuckooFilter);
    return CuckooFilter;
}(base_filter_1.default));
exports["default"] = CuckooFilter;


/***/ }),

/***/ 8044:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

/* file : exportable.ts
MIT License

Copyright (c) 2017-2020 Thomas Minier & Arnaud Grall

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/
// !disable all rules referring to `any` for exportable because we are dealing with all types so any is allowed
/* eslint-disable @typescript-eslint/no-explicit-any, @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-unsafe-return, @typescript-eslint/no-unsafe-call, @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-argument */
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AutoExportable = exports.Parameter = exports.Field = exports.Exportable = exports.cloneObject = exports.cloneField = void 0;
__webpack_require__(4741);
/**
 * Clone a field of a filter (array, object or any primary type)
 * @param  {*} v - Value to clone
 * @return {*} Cloned value
 */
function cloneField(v) {
    if (v === null || v === undefined) {
        return v;
    }
    if (Array.isArray(v)) {
        return v.map(cloneField);
    }
    else if (typeof v === 'object') {
        if ('saveAsJSON' in v) {
            return v.saveAsJSON();
        }
        return Object.assign({}, v);
    }
    return v;
}
exports.cloneField = cloneField;
/**
 * Get a function used to clone an object
 * @param type - Object type
 * @param fields - Object's fields to clone
 * @return A function that clones the given fields of an input object
 */
function cloneObject(type) {
    var fields = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        fields[_i - 1] = arguments[_i];
    }
    return function (obj) {
        var json = { type: type };
        fields.forEach(function (field) {
            json[field] = cloneField(obj[field]);
        });
        return json;
    };
}
exports.cloneObject = cloneObject;
/**
 * Turn a datastructure into an exportable one, so it can be serialized from/to JSON objects.
 * @param specs - An object that describes how the datastructure should be exported/imported
 * @author Thomas Minier
 */
function Exportable(specs) {
    return function (target) {
        target.prototype.saveAsJSON = function () {
            return specs.export(this);
        };
        target.fromJSON = function (json) {
            return specs.import(json);
        };
        return target;
    };
}
exports.Exportable = Exportable;
var METADATA_CLASSNAME = Symbol('bloom-filters:exportable:class-name');
var METADATA_FIELDS = Symbol('bloom-filters:exportable:fields');
var METADATA_PARAMETERS = Symbol('bloom-filters:exportable:constructor-parameters');
/**
 * Register a field to be exportable/importable
 * @param importer - Function invoked on the JSON field to convert it into JavaScript
 */
function Field(exporter, importer) {
    if (exporter === undefined) {
        exporter = cloneField;
    }
    if (importer === undefined) {
        importer = function (v) { return v; };
    }
    return function (target, propertyKey) {
        var fields = [];
        if (Reflect.hasMetadata(METADATA_FIELDS, target)) {
            fields = Reflect.getMetadata(METADATA_FIELDS, target);
        }
        fields.push({
            name: propertyKey,
            exporter: exporter,
            importer: importer, // eslint-disable-line @typescript-eslint/no-non-null-assertion
        });
        Reflect.defineMetadata(METADATA_FIELDS, fields, target);
    };
}
exports.Field = Field;
function Parameter(fieldName) {
    return function (target, propertyKey, parameterIndex) {
        var parameters = new Map();
        if (Reflect.hasMetadata(METADATA_PARAMETERS, target)) {
            parameters = Reflect.getMetadata(METADATA_PARAMETERS, target);
        }
        parameters.set(fieldName, parameterIndex);
        Reflect.defineMetadata(METADATA_PARAMETERS, parameters, target);
    };
}
exports.Parameter = Parameter;
/**
 * Augment a TypeScript class to make it exportable/importable, using @Field and @Parameter decorator
 * @param className - Name of the exportable/importable class
 */
function AutoExportable(className, otherFields) {
    if (otherFields === void 0) { otherFields = []; }
    return function (target) {
        Reflect.defineMetadata(METADATA_CLASSNAME, className, target.prototype);
        if (!Reflect.hasMetadata(METADATA_FIELDS, target.prototype) ||
            otherFields.length === 0) {
            throw new SyntaxError('No exported fields declared when @AutoExportable is called');
        }
        // define empty parameters map, for object with a constructor without parameters
        if (!Reflect.hasMetadata(METADATA_PARAMETERS, target)) {
            Reflect.defineMetadata(METADATA_PARAMETERS, new Map(), target);
        }
        target.prototype.saveAsJSON = function () {
            var _this = this;
            var json = {
                type: Reflect.getMetadata(METADATA_CLASSNAME, target.prototype),
            };
            // export fields defined using the @Field decorator
            var fields = Reflect.getMetadata(METADATA_FIELDS, target.prototype);
            fields.forEach(function (field) {
                json[field.name] = field.exporter(_this[field.name]);
            });
            // export fields declared through the otherFields parameter
            otherFields.forEach(function (field) {
                json[field] = cloneField(_this[field]);
            });
            return json;
        };
        target.fromJSON = function (json) {
            var className = Reflect.getMetadata(METADATA_CLASSNAME, target.prototype);
            var parameters = Reflect.getMetadata(METADATA_PARAMETERS, target);
            var fields = Reflect.getMetadata(METADATA_FIELDS, target.prototype);
            // validate the input JSON
            if (json.type !== className) {
                throw new Error("Cannot create an object ".concat(className, " from a JSON export with type \"").concat(json.type, "\"") // eslint-disable-line @typescript-eslint/restrict-template-expressions
                );
            }
            var constructorArgs = [];
            var copyFields = [];
            otherFields
                .map(function (name) { return ({ name: name, importer: function (v) { return v; } }); })
                .concat(fields)
                .forEach(function (field) {
                if (!(field.name in json)) {
                    throw new Error("Invalid import: required field \"".concat(field, "\" not found in JSON export \"").concat(json, "\"") // eslint-disable-line @typescript-eslint/restrict-template-expressions
                    );
                }
                // build constructor/copy arguments
                if (parameters.has(field.name)) {
                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                    constructorArgs[parameters.get(field.name)] = field.importer(json[field.name]);
                }
                else {
                    copyFields.push({
                        name: field.name,
                        value: field.importer(json[field.name]),
                    });
                }
            });
            // build new object
            var obj = new (target.bind.apply(target, __spreadArray([void 0], __read(constructorArgs), false)))();
            // write non-constructor exported fields
            copyFields.forEach(function (arg) {
                obj[arg.name] = arg.value;
            });
            return obj;
        };
    };
}
exports.AutoExportable = AutoExportable;


/***/ }),

/***/ 9757:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/* file : formulas.ts
MIT License

Copyright (c) 2017-2020 Thomas Minier & Arnaud Grall

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.optimalHashes = exports.optimalFilterSize = void 0;
/**
 * Various formulas used with Bloom Filters
 * @namespace Formulas
 * @private
 */
/**
 * Compute the optimal size of a Bloom Filter
 * @param  length - The length of the set used to fill the filter
 * @param  errorRate - The targeted false positive rate
 * @return The optimal size of a Bloom Filter
 * @memberof Formulas
 */
function optimalFilterSize(length, errorRate) {
    return Math.ceil(-((length * Math.log(errorRate)) / Math.pow(Math.log(2), 2)));
}
exports.optimalFilterSize = optimalFilterSize;
/**
 * Compute the optimal number of hash functions to be used by a Bloom Filter
 * @param  size - The size of the filter
 * @param  length - The length of the set used to fill the filter
 * @return The optimal number of hash functions to be used by a Bloom Filter
 * @memberof Formulas
 */
function optimalHashes(size, length) {
    return Math.ceil((size / length) * Math.log(2));
}
exports.optimalHashes = optimalHashes;


/***/ }),

/***/ 9573:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var utils_1 = __webpack_require__(8609);
var hashing_1 = __importDefault(__webpack_require__(8367));
/**
 * @deprecated
 * Hashing class to use before v1.3.7
 */
var DeprecatedHashing = /** @class */ (function (_super) {
    __extends(DeprecatedHashing, _super);
    function DeprecatedHashing() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        /**
         * Apply Double Hashing to produce a n-hash
         * @param  n - The indice of the hash function we want to produce
         * @param  hashA - The result of the first hash function applied to a value.
         * @param  hashB - The result of the second hash function applied to a value.
         * @param  size - The size of the datastructures associated to the hash context (ex: the size of a Bloom Filter)
         * @return The result of hash_n applied to a value.
         * @returns
         */
        _this.doubleHashing = function (n, hashA, hashB, size) {
            return Math.abs((hashA + n * hashB) % size);
        };
        return _this;
    }
    /**
     * Generate N indexes on range [0, size)
     * It uses the double hashing technique to generate the indexes.
     * It hash twice the value only once before generating the indexes.
     * Warning: you can have a lot of modulo collisions.
     * @param  element    - The element to hash
     * @param  size       - The range on which we can generate the index, exclusive
     * @param  hashCount  - The number of indexes we want
     * @return An array of indexes on range [0, size)
     */
    DeprecatedHashing.prototype.getIndexes = function (element, size, hashCount, seed) {
        return this.getDistinctIndexes(element, size, hashCount, seed);
    };
    /**
     * Generate a set of distinct indexes on interval [0, size) using the double hashing technique
     * This function is the old method called by a lot of filters.
     * To work in the current version, replace, the getIndexes function of the filters by this one
     * @param  element  - The element to hash
     * @param  size     - the range on which we can generate an index [0, size) = size
     * @param  number   - The number of indexes desired
     * @param  seed     - The seed used
     * @return A array of indexes
     * @author Arnaud Grall
     */
    DeprecatedHashing.prototype.getDistinctIndexes = function (element, size, number, seed) {
        var _this = this;
        if (seed === undefined) {
            seed = (0, utils_1.getDefaultSeed)();
        }
        var getDistinctIndicesBis = function (n, elem, size, count, indexes) {
            if (indexes === void 0) { indexes = []; }
            if (indexes.length === count) {
                return indexes;
            }
            else {
                var hashes = _this.hashTwice(elem, seed + (size % n)); // eslint-disable-line @typescript-eslint/no-non-null-assertion
                var ind = _this.doubleHashing(n, hashes.first, hashes.second, size);
                if (indexes.includes(ind)) {
                    // console.log('generate index: %d for %s', ind, elem)
                    return getDistinctIndicesBis(n + 1, elem, size, count, indexes);
                }
                else {
                    // console.log('already found: %d for %s', ind, elem)
                    indexes.push(ind);
                    return getDistinctIndicesBis(n + 1, elem, size, count, indexes);
                }
            }
        };
        return getDistinctIndicesBis(1, element, size, number);
    };
    return DeprecatedHashing;
}(hashing_1.default));
exports["default"] = DeprecatedHashing;


/***/ }),

/***/ 8367:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var xxhashjs_1 = __importDefault(__webpack_require__(9134));
var utils_1 = __webpack_require__(8609);
var Hashing = /** @class */ (function () {
    function Hashing() {
    }
    /**
     * Apply enhanced Double Hashing to produce a n-hash
     * @see {@link http://peterd.org/pcd-diss.pdf} s6.5.4
     * @param  n - The indice of the hash function we want to produce
     * @param  hashA - The result of the first hash function applied to a value.
     * @param  hashB - The result of the second hash function applied to a value.
     * @param  size - The size of the datastructures associated to the hash context (ex: the size of a Bloom Filter)
     * @return The result of hash_n applied to a value.
     * @memberof Hashing
     * @author Thomas Minier
     * @author Arnaud Grall
     */
    Hashing.prototype.doubleHashing = function (n, hashA, hashB, size) {
        return Math.abs((hashA + n * hashB + Math.floor((Math.pow(n, 3) - n) / 6)) % size);
    };
    /**
     * Generate a set of distinct indexes on interval [0, size) using the double hashing technique
     * For generating efficiently distinct indexes we re-hash after detecting a cycle by changing slightly the seed.
     * It has the effect of generating faster distinct indexes without loosing entirely the utility of the double hashing.
     * For small number of indexes it will work perfectly. For a number close to the size, and size very large
     * Advise: do not generate `size` indexes for a large interval. In practice, size should be equal
     * to the number of hash functions used and is often low.
     *
     * @param  element  - The element to hash
     * @param  size     - the range on which we can generate an index [0, size) = size
     * @param  number   - The number of indexes desired
     * @param  seed     - The seed used
     * @return Array<number>
     * @author Arnaud Grall
     * @author Simon Woolf (SimonWoolf)
     */
    Hashing.prototype.getDistinctIndexes = function (element, size, number, seed) {
        if (seed === undefined) {
            seed = (0, utils_1.getDefaultSeed)();
        }
        var n = 0;
        var indexes = new Set();
        var hashes = this.hashTwice(element, seed);
        // let cycle = 0
        while (indexes.size < number) {
            var ind = hashes.first % size;
            if (!indexes.has(ind)) {
                indexes.add(ind);
            }
            hashes.first = (hashes.first + hashes.second) % size;
            hashes.second = (hashes.second + n) % size;
            n++;
            if (n > size) {
                // Enhanced double hashing stops cycles of length less than `size` in the case where
                // size is coprime with the second hash. But you still get cycles of length `size`.
                // So if we reach there and haven't finished, append a prime to the input and
                // rehash.
                seed++;
                hashes = this.hashTwice(element, seed);
            }
        }
        return __spreadArray([], __read(indexes.values()), false);
    };
    /**
     * Generate N indexes on range [0, size)
     * It uses the double hashing technique to generate the indexes.
     * It hash twice the value only once before generating the indexes.
     * Warning: you can have a lot of modulo collisions.
     * @param  element    - The element to hash
     * @param  size       - The range on which we can generate the index, exclusive
     * @param  hashCount  - The number of indexes we want
     * @return An array of indexes on range [0, size)
     */
    Hashing.prototype.getIndexes = function (element, size, hashCount, seed) {
        if (seed === undefined) {
            seed = (0, utils_1.getDefaultSeed)();
        }
        var arr = [];
        var hashes = this.hashTwice(element, seed);
        for (var i = 0; i < hashCount; i++) {
            arr.push(this.doubleHashing(i, hashes.first, hashes.second, size));
        }
        return arr;
    };
    /**
     * @internal
     * Hash an element of type {@link HashableInput} into {@link Number}
     * Can be overrided as long as you return a value of type {@link Number}
     * Don't forget to use the seed when hashing, otherwise if some kind of randomness is in the process
     * you may have inconsistent behaviors between 2 runs.
     * @param element
     * @param seed
     * @returns A 64bits floating point {@link Number}
     */
    Hashing.prototype.serialize = function (element, seed) {
        if (!seed) {
            seed = (0, utils_1.getDefaultSeed)();
        }
        return Number(xxhashjs_1.default.h64(element, seed).toNumber());
    };
    /**
     * (64-bits only) Hash a value into two values (in hex or integer format)
     * @param  value - The value to hash
     * @param  asInt - (optional) If True, the values will be returned as an integer. Otherwise, as hexadecimal values.
     * @param seed the seed used for hashing
     * @return The results of the hash functions applied to the value (in hex or integer)
     * @author Arnaud Grall & Thomas Minier
     */
    Hashing.prototype.hashTwice = function (value, seed) {
        if (seed === undefined) {
            seed = (0, utils_1.getDefaultSeed)();
        }
        return {
            first: this.serialize(value, seed + 1),
            second: this.serialize(value, seed + 2),
        };
    };
    /**
     * Hash twice an element into their HEX string representations
     * @param value
     * @param seed
     * @returns TwoHashesTemplated<string>
     */
    Hashing.prototype.hashTwiceAsString = function (value, seed) {
        var _a = this.hashTwice(value, seed), first = _a.first, second = _a.second;
        return {
            first: (0, utils_1.numberToHex)(first),
            second: (0, utils_1.numberToHex)(second),
        };
    };
    /**
     * (64-bits only) Same as hashTwice but return Numbers and String equivalent
     * @param  val the value to hash
     * @param  seed the seed to change when hashing
     * @return TwoHashesIntAndString
     * @author Arnaud Grall
     */
    Hashing.prototype.hashTwiceIntAndString = function (val, seed) {
        if (seed === undefined) {
            seed = (0, utils_1.getDefaultSeed)();
        }
        var one = this.hashIntAndString(val, seed + 1);
        var two = this.hashIntAndString(val, seed + 2);
        return {
            int: {
                first: one.int,
                second: two.int,
            },
            string: {
                first: one.string,
                second: two.string,
            },
        };
    };
    /**
     * Hash an item as an unsigned int
     * @param  elem - Element to hash
     * @param  seed - The hash seed. If its is UINT32 make sure to set the length to 32
     * @param  length - The length of hashes (defaults to 32 bits)
     * @return The hash value as an unsigned int
     * @author Arnaud Grall
     */
    Hashing.prototype.hashAsInt = function (elem, seed) {
        if (seed === undefined) {
            seed = (0, utils_1.getDefaultSeed)();
        }
        return this.serialize(elem, seed);
    };
    /**
     * Hash an item and return its number and HEX string representation
     * @param  elem - Element to hash
     * @param  seed - The hash seed. If its is UINT32 make sure to set the length to 32
     * @param  base - The base in which the string will be returned, default: 16
     * @param  length - The length of hashes (defaults to 32 bits)
     * @return The item hased as an int and a string
     * @author Arnaud Grall
     */
    Hashing.prototype.hashIntAndString = function (elem, seed) {
        var hash = this.hashAsInt(elem, seed);
        return { int: hash, string: (0, utils_1.numberToHex)(hash) };
    };
    return Hashing;
}());
exports["default"] = Hashing;


/***/ }),

/***/ 9592:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

/* file: cell.ts
MIT License

Copyright (c) 2019-2020 Thomas Minier

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the 'Software'), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var utils_1 = __webpack_require__(8609);
var exportable_1 = __webpack_require__(8044);
var base_filter_1 = __importDefault(__webpack_require__(4914));
var inspect = Symbol.for('nodejs.util.inspect.custom');
/**
 * A cell is an internal datastructure of an {@link InvertibleBloomFilter}.
 * It is composed of an idSum (the XOR of all element inserted in that cell), a hashSum (the XOR of all hashed element in that cell) and a counter (the number of elements inserted in that cell).
 * @author Arnaud Grall
 * @author Thomas Minier
 */
var Cell = /** @class */ (function (_super) {
    __extends(Cell, _super);
    /**
     * Constructor.
     * To create an empty cell, you might want to use the static Cell#empty() method.
     * @param idSum - The XOR of all element inserted in that cell
     * @param hashSum - The XOR of all hashed element in that cell
     * @param count - The number of elements inserted in that cell
     */
    function Cell(idSum, hashSum, count) {
        var _this = _super.call(this) || this;
        _this._idSum = idSum;
        _this._hashSum = hashSum;
        _this._count = count;
        return _this;
    }
    Cell_1 = Cell;
    /**
     * Create an empty cell
     * @return An empty Cell
     */
    Cell.empty = function () {
        return new Cell_1(Buffer.allocUnsafe(0).fill(0), Buffer.allocUnsafe(0).fill(0), 0);
    };
    Cell.prototype[inspect] = function () {
        return "Cell:<".concat(JSON.stringify(this._idSum.toJSON().data), ", ").concat(JSON.stringify(this._hashSum.toJSON().data), ", ").concat(this._count, ">");
    };
    Object.defineProperty(Cell.prototype, "idSum", {
        /**
         * Get the id sum of the Cell (The XOR of all element inserted in that cell)
         */
        get: function () {
            return this._idSum;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Cell.prototype, "hashSum", {
        /**
         * Get the hash sum of the Cell (The XOR of all hashed element in that cell)
         */
        get: function () {
            return this._hashSum;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Cell.prototype, "count", {
        /**
         * Get the number of elements inserted in that cell
         */
        get: function () {
            return this._count;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Add an element in this cell
     * @param idSum - The element to XOR in this cell
     * @param hashSum - The hash of the element to XOR in this cell
     */
    Cell.prototype.add = function (idSum, hashSum) {
        this._idSum = (0, utils_1.xorBuffer)(this._idSum, idSum);
        this._hashSum = (0, utils_1.xorBuffer)(this._hashSum, hashSum);
        this._count++;
    };
    /**
     * Perform the XOR operation between this Cell and another one and returns a resulting Cell.
     * A XOR between two cells is the XOR between their id sum and hash sum,
     * and the difference between their count.
     * @param cell - Cell to perform XOR with
     * @return A new Cell, resulting from the XOR operation
     */
    Cell.prototype.xorm = function (cell) {
        return new Cell_1((0, utils_1.xorBuffer)(this._idSum, cell.idSum), (0, utils_1.xorBuffer)(this._hashSum, cell.hashSum), this._count - cell.count);
    };
    /**
     * Test if the Cell is empty
     * @return True if the Cell is empty, False otherwise
     */
    Cell.prototype.isEmpty = function () {
        return (this._idSum.equals(Buffer.from('')) &&
            this._hashSum.equals(Buffer.from('')) &&
            this._count === 0);
    };
    /**
     * Test if another Cell is equals to this one
     * @param  cell - The cell to compare with
     * @return True if the two Cells are equals, False otherwise
     */
    Cell.prototype.equals = function (cell) {
        return (this._count === cell.count &&
            this._idSum.equals(cell.idSum) &&
            this._hashSum.equals(cell.hashSum));
    };
    /**
     * Test if the cell is "Pure".
     * A pure cell is a cell with a counter equal to 1 or -1, and with a hash sum equal to the id sum
     * @return True if the cell ius pure, False otherwise
     */
    Cell.prototype.isPure = function () {
        // A pure cell cannot be empty or must have a count equals to 1 or -1
        if (this.isEmpty() || (this._count !== 1 && this._count !== -1)) {
            return false;
        }
        // compare the hashes
        var hashes = this._hashing.hashTwiceAsString(JSON.stringify(this._idSum.toJSON()), this.seed);
        return this._hashSum.equals(Buffer.from(hashes.first));
    };
    var Cell_1;
    __decorate([
        (0, exportable_1.Field)(function (elt) { return elt.toString(); }, Buffer.from),
        __metadata("design:type", Buffer
        // eslint-disable-next-line @typescript-eslint/unbound-method
        )
    ], Cell.prototype, "_idSum", void 0);
    __decorate([
        (0, exportable_1.Field)(function (elt) { return elt.toString(); }, Buffer.from),
        __metadata("design:type", Buffer)
    ], Cell.prototype, "_hashSum", void 0);
    __decorate([
        (0, exportable_1.Field)(),
        __metadata("design:type", Number)
    ], Cell.prototype, "_count", void 0);
    Cell = Cell_1 = __decorate([
        (0, exportable_1.AutoExportable)('Cell', ['_seed']),
        __param(0, (0, exportable_1.Parameter)('_idSum')),
        __param(1, (0, exportable_1.Parameter)('_hashSum')),
        __param(2, (0, exportable_1.Parameter)('_count')),
        __metadata("design:paramtypes", [Buffer,
            Buffer, Number])
    ], Cell);
    return Cell;
}(base_filter_1.default));
exports["default"] = Cell;


/***/ }),

/***/ 223:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

/* file : invertible-bloom-lookup-tables.ts
MIT License

Copyright (c) 2017-2020 Thomas Minier & Arnaud Grall

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var base_filter_1 = __importDefault(__webpack_require__(4914));
var cell_1 = __importDefault(__webpack_require__(9592));
var exportable_1 = __webpack_require__(8044);
var utils_1 = __webpack_require__(8609);
var formulas_1 = __webpack_require__(9757);
/**
 * An Invertible Bloom Lookup Table is a space-efficient and probabilistic data-structure for solving the set-difference problem efficiently without the use of logs or other prior context. It computes the set difference with communication proportional to the size of the difference between the sets being compared.
 * They can simultaneously calculate D(A‚àíB) and D(B‚àíA) using O(d) space. This data structure encodes sets in a fashion that is similar in spirit to Tornado codes‚Äô construction [6], in that it randomly combines elements using the XOR function
 * Reference: Eppstein, D., Goodrich, M. T., Uyeda, F., & Varghese, G. (2011). What's the difference?: efficient set reconciliation without prior context. ACM SIGCOMM Computer Communication Review, 41(4), 218-229.
 * @see {@link http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.220.6282&rep=rep1&type=pdf} for more details about Invertible Bloom Lookup Tables
 * @author Arnaud Grall
 * @author Thomas Minier
 */
var InvertibleBloomFilter = /** @class */ (function (_super) {
    __extends(InvertibleBloomFilter, _super);
    /**
     * Construct an Invertible Bloom Lookup Table
     * @param size - The number of cells in the InvertibleBloomFilter. It should be set to d * alpha, where d is the number of difference and alpha is a constant
     * @param hashCount - The number of hash functions used (empirically studied to be 3 or 4 in most cases)
     */
    function InvertibleBloomFilter(size, hashCount) {
        if (hashCount === void 0) { hashCount = 3; }
        var _this = _super.call(this) || this;
        if (Buffer === undefined) {
            throw new Error('No native Buffer implementation bound in your JavaScript env. If you are in a Web browser, consider importing the polyfill "feross/buffer" (https://github.com/feross/buffer).');
        }
        if (hashCount <= 0) {
            throw new Error('The hashCount must be a non-zero, positive integer');
        }
        _this._size = size;
        _this._hashCount = hashCount;
        // the number of elements in the array is n = alpha * size
        _this._elements = (0, utils_1.allocateArray)(_this._size, function () { return cell_1.default.empty(); });
        return _this;
    }
    InvertibleBloomFilter_1 = InvertibleBloomFilter;
    /**
     * Create an Invertible Bloom filter optimal for an expected size and error rate.
     * @param nbItems - Number of items expected to insert into the IBLT
     * @param errorRate - Expected error rate
     * @return A new Invertible Bloom filter optimal for the given parameters.
     */
    InvertibleBloomFilter.create = function (nbItems, errorRate) {
        var size = (0, formulas_1.optimalFilterSize)(nbItems, errorRate);
        var nbHashes = (0, formulas_1.optimalHashes)(size, nbItems);
        return new InvertibleBloomFilter_1(size, nbHashes);
    };
    /**
     * Create an Invertible Bloom filter from a set of Buffer and optimal for an error rate.
     * @param items - An iterable to yield Buffers to be inserted into the filter
     * @param errorRate - Expected error rate
     * @return A new Invertible Bloom filter filled with the iterable's items.
     */
    InvertibleBloomFilter.from = function (items, errorRate) {
        var array = Array.from(items);
        var filter = InvertibleBloomFilter_1.create(array.length, errorRate);
        array.forEach(function (item) { return filter.add(item); });
        return filter;
    };
    Object.defineProperty(InvertibleBloomFilter.prototype, "hashCount", {
        /**
         * Return the number of hash functions used
         * @return {Number}
         */
        get: function () {
            return this._hashCount;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(InvertibleBloomFilter.prototype, "size", {
        /**
         * Get the number of cells of the filter
         */
        get: function () {
            return this._size;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(InvertibleBloomFilter.prototype, "length", {
        /**
         * Get the number of elements added in the filter
         * Complexity in time: O(alpha*d)
         */
        get: function () {
            return this._elements.reduce(function (a, b) { return a + b.count; }, 0) / this._hashCount;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(InvertibleBloomFilter.prototype, "elements", {
        /**
         * Return the cells used to store elements in this InvertibleBloomFilter
         */
        get: function () {
            return this._elements;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Add an element to the InvertibleBloomFilter
     * @param element - The element to insert
     */
    InvertibleBloomFilter.prototype.add = function (element) {
        var hashes = this._hashing.hashTwiceAsString(JSON.stringify(element.toJSON()), this.seed);
        var indexes = this._hashing.getDistinctIndexes(hashes.first, this._size, this._hashCount, this.seed);
        for (var i = 0; i < this._hashCount; ++i) {
            this._elements[indexes[i]].add(element, Buffer.from(hashes.first));
        }
    };
    /**
     * Remove an element from the filter
     * @param element - The element to remove
     * @return True if the element has been removed, False otheriwse
     */
    InvertibleBloomFilter.prototype.remove = function (element) {
        var hashes = this._hashing.hashTwiceAsString(JSON.stringify(element.toJSON()), this.seed);
        var indexes = this._hashing.getDistinctIndexes(hashes.first, this._size, this._hashCount, this.seed);
        for (var i = 0; i < this._hashCount; ++i) {
            this._elements[indexes[i]] = this._elements[indexes[i]].xorm(new cell_1.default(Buffer.from(element), Buffer.from(hashes.first), 1));
        }
        return true;
    };
    /**
     * Test if an item is in the filter.
     * @param  element - The element to test
     * @return False if the element is not in the filter, true if "may be" in the filter.
     */
    InvertibleBloomFilter.prototype.has = function (element) {
        var hashes = this._hashing.hashTwiceAsString(JSON.stringify(element.toJSON()), this.seed);
        var indexes = this._hashing.getDistinctIndexes(hashes.first, this._size, this._hashCount, this.seed);
        for (var i = 0; i < this._hashCount; ++i) {
            if (this._elements[indexes[i]].count === 0) {
                return false;
            }
            else if (this._elements[indexes[i]].count === 1) {
                if (this._elements[indexes[i]].idSum.equals(element)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        return true;
    };
    /**
     * List all entries from the filter using a Generator.
     * The generator ends with True if the operation has not failed, False otheriwse.
     * It is not recommended to modify an IBLT while listing its entries!
     * @return A generator that yields all filter's entries.
     */
    InvertibleBloomFilter.prototype.listEntries = function () {
        // eslint-disable-next-line @typescript-eslint/no-this-alias
        var that = this;
        var seenBefore = [];
        return (function () {
            var _loop_1, index, state_1;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        _loop_1 = function (index) {
                            var localCell;
                            return __generator(this, function (_b) {
                                switch (_b.label) {
                                    case 0:
                                        localCell = that._elements[index];
                                        if (!(localCell.count > 0 &&
                                            seenBefore.findIndex(function (b) { return b.equals(localCell.idSum); }) === -1)) return [3 /*break*/, 3];
                                        if (!that.has(localCell.idSum)) return [3 /*break*/, 2];
                                        seenBefore.push(localCell.idSum);
                                        return [4 /*yield*/, localCell.idSum];
                                    case 1:
                                        _b.sent();
                                        return [3 /*break*/, 3];
                                    case 2: return [2 /*return*/, { value: false }];
                                    case 3: return [2 /*return*/];
                                }
                            });
                        };
                        index = 0;
                        _a.label = 1;
                    case 1:
                        if (!(index < that._elements.length - 1)) return [3 /*break*/, 4];
                        return [5 /*yield**/, _loop_1(index)];
                    case 2:
                        state_1 = _a.sent();
                        if (typeof state_1 === "object")
                            return [2 /*return*/, state_1.value];
                        _a.label = 3;
                    case 3:
                        index++;
                        return [3 /*break*/, 1];
                    case 4: return [2 /*return*/, true];
                }
            });
        })();
    };
    /**
     * Substract the filter with another {@link InvertibleBloomFilter}, and returns the resulting filter.
     * @param  remote - The filter to substract with
     * @return A new InvertibleBloomFilter which is the XOR of the local and remote one
     */
    InvertibleBloomFilter.prototype.substract = function (iblt) {
        if (this.size !== iblt.size) {
            throw new Error('The two Invertible Bloom Filters must be of the same size');
        }
        var res = new InvertibleBloomFilter_1(iblt._size, iblt._hashCount);
        res.seed = this.seed;
        for (var i = 0; i < this.size; ++i) {
            res._elements[i] = this._elements[i].xorm(iblt._elements[i]);
        }
        return res;
    };
    /**
     * Test if two InvertibleBloomFilters are equals
     * @param iblt - The filter to compare with
     * @return True if the two filters are equals, False otherwise
     */
    InvertibleBloomFilter.prototype.equals = function (iblt) {
        if (iblt._size !== this._size ||
            iblt._hashCount !== this._hashCount ||
            iblt.seed !== this.seed) {
            return false;
        }
        else {
            for (var i = 0; i < iblt._elements.length; ++i) {
                if (!iblt._elements[i].equals(this._elements[i])) {
                    return false;
                }
            }
            return true;
        }
    };
    /**
     * Decode an InvertibleBloomFilter based on its substracted version
     * @return The results of the deconding process
     */
    InvertibleBloomFilter.prototype.decode = function (additional, missing) {
        if (additional === void 0) { additional = []; }
        if (missing === void 0) { missing = []; }
        var pureList = [];
        var cell = null;
        // checking for all pure cells
        for (var i = 0; i < this._elements.length; ++i) {
            cell = this._elements[i];
            if (cell.isPure()) {
                pureList.push(i);
            }
        }
        while (pureList.length !== 0) {
            cell = this._elements[pureList.pop()]; // eslint-disable-line @typescript-eslint/no-non-null-assertion
            var id = cell.idSum;
            var c = cell.count;
            if (cell.isPure()) {
                if (c === 1) {
                    additional.push(id);
                }
                else if (c === -1) {
                    missing.push(id);
                }
                else {
                    throw new Error('Please report, not possible');
                }
                var hashes = this._hashing.hashTwiceAsString(JSON.stringify(id.toJSON()), this.seed);
                var indexes = this._hashing.getDistinctIndexes(hashes.first, this._size, this._hashCount, this.seed);
                for (var i = 0; i < indexes.length; ++i) {
                    this._elements[indexes[i]] = this._elements[indexes[i]].xorm(new cell_1.default(id, Buffer.from(hashes.first), c));
                    if (this._elements[indexes[i]].isPure()) {
                        pureList.push(indexes[i]);
                    }
                }
            }
        }
        if (this._elements.findIndex(function (e) { return !e.isEmpty(); }) > -1) {
            return {
                success: false,
                reason: {
                    cell: cell,
                    iblt: this,
                },
                additional: additional,
                missing: missing,
            };
        }
        else {
            return {
                success: true,
                additional: additional,
                missing: missing,
            };
        }
    };
    var InvertibleBloomFilter_1;
    __decorate([
        (0, exportable_1.Field)(),
        __metadata("design:type", Number)
    ], InvertibleBloomFilter.prototype, "_size", void 0);
    __decorate([
        (0, exportable_1.Field)(),
        __metadata("design:type", Number)
    ], InvertibleBloomFilter.prototype, "_hashCount", void 0);
    __decorate([
        (0, exportable_1.Field)(undefined, function (json) {
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            var res = json.map(function (elt) {
                var c = new cell_1.default(Buffer.from(elt._idSum), Buffer.from(elt._hashSum), elt._count);
                c.seed = elt._seed;
                return c;
            });
            return res;
        }),
        __metadata("design:type", Array)
    ], InvertibleBloomFilter.prototype, "_elements", void 0);
    InvertibleBloomFilter = InvertibleBloomFilter_1 = __decorate([
        (0, exportable_1.AutoExportable)('InvertibleBloomFilter', ['_seed']),
        __param(0, (0, exportable_1.Parameter)('_size')),
        __param(1, (0, exportable_1.Parameter)('_hashCount')),
        __metadata("design:paramtypes", [Number, Object])
    ], InvertibleBloomFilter);
    return InvertibleBloomFilter;
}(base_filter_1.default));
exports["default"] = InvertibleBloomFilter;


/***/ }),

/***/ 7044:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

/* file : count-min-sketch.ts
MIT License

Copyright (c) 2017-2020 Thomas Minier & Arnaud Grall

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var base_filter_1 = __importDefault(__webpack_require__(4914));
var exportable_1 = __webpack_require__(8044);
var utils_1 = __webpack_require__(8609);
/**
 * The count‚Äìmin sketch (CM sketch) is a probabilistic data structure that serves as a frequency table of events in a stream of data.
 * It uses hash functions to map events to frequencies, but unlike a hash table uses only sub-linear space, at the expense of overcounting some events due to collisions.
 *
 * Reference: Cormode, G., & Muthukrishnan, S. (2005). An improved data stream summary: the count-min sketch and its applications. Journal of Algorithms, 55(1), 58-75.
 * @see {@link http://vaffanculo.twiki.di.uniroma1.it/pub/Ing_algo/WebHome/p14_Cormode_JAl_05.pdf} for more details on Count Min Sketch
 * @extends Exportable
 * @author Thomas Minier & Arnaud Grall
 */
var CountMinSketch = /** @class */ (function (_super) {
    __extends(CountMinSketch, _super);
    /**
     * Constructor
     * @param columns - Number of columns
     * @param rows - Number of rows
     */
    function CountMinSketch(columns, rows) {
        var _this = _super.call(this) || this;
        _this._columns = columns;
        _this._rows = rows;
        _this._matrix = (0, utils_1.allocateArray)(_this._rows, function () {
            return (0, utils_1.allocateArray)(_this._columns, 0);
        });
        _this._allSums = 0;
        return _this;
    }
    CountMinSketch_1 = CountMinSketch;
    /**
     * Create a count-min sketch, with a target error rate and probability of accuracy
     * @param  errorRate - The error rate
     * @param  accuracy  - The probability of accuracy
     * @return A new Count Min Sketch optimal for the input parameters
     */
    CountMinSketch.create = function (errorRate, accuracy) {
        if (accuracy === void 0) { accuracy = 0.999; }
        // columns = Math.ceil(Math.E / epsilon) and rows = Math.ceil(Math.log(1 / delta))
        var columns = Math.ceil(Math.E / errorRate);
        var rows = Math.ceil(Math.log(1 / accuracy));
        return new CountMinSketch_1(columns, rows);
    };
    /**
     * Create a Count Min Sketch from a set of items, with a target error rate and probability of accuracy
     * @param items - An iterable to yield items to be inserted into the filter
     * @param  errorRate - The error rate
     * @param  accuracy  - The probability of accuracy
     * @return A new Count Min Sketch filled with the iterable's items.
     */
    CountMinSketch.from = function (items, errorRate, accuracy) {
        var e_1, _a;
        if (accuracy === void 0) { accuracy = 0.999; }
        var filter = CountMinSketch_1.create(errorRate, accuracy);
        try {
            for (var items_1 = __values(items), items_1_1 = items_1.next(); !items_1_1.done; items_1_1 = items_1.next()) {
                var item = items_1_1.value;
                filter.update(item);
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (items_1_1 && !items_1_1.done && (_a = items_1.return)) _a.call(items_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return filter;
    };
    Object.defineProperty(CountMinSketch.prototype, "columns", {
        /**
         * Return the number of columns in the sketch
         */
        get: function () {
            return this._columns;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(CountMinSketch.prototype, "rows", {
        /**
         * Return the number of rows in the sketch
         */
        get: function () {
            return this._rows;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(CountMinSketch.prototype, "sum", {
        /**
         * Get the sum of all counts in the sketch
         */
        get: function () {
            return this._allSums;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Update the count min sketch with a new occurrence of an element
     * @param element - The new element
     * @param count - Number of occurences of the elemnt (defauls to one)
     */
    CountMinSketch.prototype.update = function (element, count) {
        if (count === void 0) { count = 1; }
        this._allSums += count;
        var indexes = this._hashing.getIndexes(element, this._columns, this._rows, this.seed);
        for (var i = 0; i < this._rows; i++) {
            this._matrix[i][indexes[i]] += count;
        }
    };
    /**
     * Perform a point query: estimate the number of occurence of an element
     * @param element - The element we want to count
     * @return The estimate number of occurence of the element
     */
    CountMinSketch.prototype.count = function (element) {
        var min = Infinity;
        var indexes = this._hashing.getIndexes(element, this._columns, this._rows, this.seed);
        for (var i = 0; i < this._rows; i++) {
            var v = this._matrix[i][indexes[i]];
            min = Math.min(v, min);
        }
        return min;
    };
    /**
     * Check if another Count Min Sketch is equal to this one
     * @param  filter - The filter to compare to this one
     * @return True if they are equal, false otherwise
     */
    CountMinSketch.prototype.equals = function (other) {
        if (this._columns !== other._columns || this._rows !== other._rows) {
            return false;
        }
        for (var i = 0; i < this._rows; i++) {
            for (var j = 0; j < this._columns; j++) {
                if (this._matrix[i][j] !== other._matrix[i][j]) {
                    return false;
                }
            }
        }
        return true;
    };
    /**
     * Merge (in place) this sketch with another sketch, if they have the same number of columns and rows.
     * @param sketch - The sketch to merge with
     */
    CountMinSketch.prototype.merge = function (sketch) {
        if (this._columns !== sketch._columns) {
            throw new Error('Cannot merge two sketches with different number of columns');
        }
        if (this._rows !== sketch._rows) {
            throw new Error('Cannot merge two sketches with different number of rows');
        }
        for (var i = 0; i < this._rows; i++) {
            for (var j = 0; j < this._columns; j++) {
                this._matrix[i][j] += sketch._matrix[i][j];
            }
        }
    };
    /**
     * Clone the sketch
     * @return A new cloned sketch
     */
    CountMinSketch.prototype.clone = function () {
        var sketch = new CountMinSketch_1(this._columns, this._rows);
        sketch.merge(this);
        sketch.seed = this.seed;
        return sketch;
    };
    var CountMinSketch_1;
    __decorate([
        (0, exportable_1.Field)(),
        __metadata("design:type", Number)
    ], CountMinSketch.prototype, "_columns", void 0);
    __decorate([
        (0, exportable_1.Field)(),
        __metadata("design:type", Number)
    ], CountMinSketch.prototype, "_rows", void 0);
    __decorate([
        (0, exportable_1.Field)(),
        __metadata("design:type", Array)
    ], CountMinSketch.prototype, "_matrix", void 0);
    __decorate([
        (0, exportable_1.Field)(),
        __metadata("design:type", Number)
    ], CountMinSketch.prototype, "_allSums", void 0);
    CountMinSketch = CountMinSketch_1 = __decorate([
        (0, exportable_1.AutoExportable)('CountMinSketch', ['_seed']),
        __param(0, (0, exportable_1.Parameter)('_columns')),
        __param(1, (0, exportable_1.Parameter)('_rows')),
        __metadata("design:paramtypes", [Number, Number])
    ], CountMinSketch);
    return CountMinSketch;
}(base_filter_1.default));
exports["default"] = CountMinSketch;


/***/ }),

/***/ 1515:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

/* file: hyperloglog.ts
MIT License

Copyright (c) 2019-2020 Thomas Minier

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the 'Software'), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var xxhashjs_1 = __importDefault(__webpack_require__(9134));
var base_filter_1 = __importDefault(__webpack_require__(4914));
var exportable_1 = __webpack_require__(8044);
var utils_1 = __webpack_require__(8609);
// 2^32, computed as a constant as we use it a lot in the HyperLogLog algorithm
var TWO_POW_32 = Math.pow(2, 32);
/**
 * Estimlate the bias-correction constant, denoted alpha in the algorithm, based on the number of registers.
 * As alpha is pretty expensive to compute, we estimate it with the formula from Flajolet et al.
 * @param m - Number of registers in the HyperLogLog algorithm
 * @return The estimated bias-correction constant
 */
function computeAlpha(m) {
    if (m < 16) {
        return 1;
    }
    else if (m < 32) {
        return 0.673;
    }
    else if (m < 64) {
        return 0.697;
    }
    else if (m < 128) {
        return 0.709;
    }
    else {
        // >= 128
        return 0.7213 / (1.0 + 1.079 / m);
    }
}
/**
 * HyperLogLog is an algorithm for the count-distinct problem, approximating the number of distinct elements in a multiset.
 * @see HyperLogLog: the analysis of a near-optimal cardinality estimation algorithm {@link http://algo.inria.fr/flajolet/Publications/FlFuGaMe07.pdf}
 * @author Thomas Minier
 */
var HyperLogLog = /** @class */ (function (_super) {
    __extends(HyperLogLog, _super);
    /**
     * Constructor
     * @param nbRegisters - The number of registers to use
     */
    function HyperLogLog(nbRegisters) {
        var _this = _super.call(this) || this;
        if ((nbRegisters & (nbRegisters - 1)) !== 0) {
            throw new Error('The number of registers should be a power of 2');
        }
        _this._nbRegisters = nbRegisters;
        _this._nbBytesPerHash = Math.ceil(Math.log2(nbRegisters));
        _this._correctionBias = computeAlpha(nbRegisters);
        _this._registers = (0, utils_1.allocateArray)(_this._nbRegisters, 0);
        return _this;
    }
    HyperLogLog_1 = HyperLogLog;
    Object.defineProperty(HyperLogLog.prototype, "nbRegisters", {
        /**
         * Get the number of registers used by the HyperLogLog
         */
        get: function () {
            return this._nbRegisters;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Update The multiset with a new element
     * @param element - Element to add
     */
    HyperLogLog.prototype.update = function (element) {
        var hashedValue = xxhashjs_1.default.h64(element, this.seed)
            .toString(2)
            .padStart(64, '0');
        var k = 64 - this._nbBytesPerHash;
        var registerIndex = parseInt(hashedValue.slice(k), 2);
        // find the left most 1-bit in the second part of the buffer
        var second = hashedValue.slice(0, k);
        var leftmost_pos = k - 1;
        var found = false;
        var i = 0;
        while (!found && i < second.length) {
            if (second[i] === '1') {
                found = true;
                leftmost_pos = i;
            }
            else {
                i++;
            }
        }
        // update the register
        this._registers[registerIndex] = Math.max(this._registers[registerIndex], leftmost_pos);
    };
    /**
     * Estimate the cardinality of the multiset
     * @return The estimated cardinality of the multiset
     */
    HyperLogLog.prototype.count = function (round) {
        if (round === void 0) { round = false; }
        // Use the standard HyperLogLog estimator
        var Z = this._registers.reduce(function (acc, value) { return acc + Math.pow(2, -value); }, 0);
        var raw_estimation = (this._correctionBias * this._nbRegisters * this._nbRegisters * 2) / Z;
        var corrected_estimation;
        if (raw_estimation <= (5 / 2) * this._nbRegisters) {
            // use linear counting to correct the estimation if E < 5m/2 and some registers are set to zero
            var V = this._registers.filter(function (value) { return value === 0; }).length;
            if (V > 0) {
                // small range correction: linear counting
                corrected_estimation =
                    this._nbRegisters * Math.log(this._nbRegisters / V);
            }
            else {
                corrected_estimation = raw_estimation;
            }
        }
        else if (raw_estimation <= TWO_POW_32 / 30) {
            // middle range correction; no correction
            corrected_estimation = raw_estimation;
        }
        else {
            // raw_estimation > TWO_POW_32 / 30
            // large range correction
            corrected_estimation =
                -TWO_POW_32 * Math.log(1 - raw_estimation / TWO_POW_32);
        }
        if (round) {
            return Math.round(corrected_estimation);
        }
        return corrected_estimation;
    };
    /**
     * Compute the accuracy of the cardinality estimation produced by this HyperLogLog
     * @return The accuracy of the cardinality estimation
     */
    HyperLogLog.prototype.accuracy = function () {
        return 1.04 / Math.sqrt(this._nbRegisters);
    };
    /**
     * Perform the union with another HyperLogLog multiset
     * @param other - Multiset ot merge with
     * @return The union of the two multisets
     */
    HyperLogLog.prototype.merge = function (other) {
        if (this.nbRegisters !== other.nbRegisters) {
            throw new Error("Two HyperLogLog must have the same number of registers to be merged. Tried to merge two HyperLogLog with m = ".concat(this.nbRegisters, " and m = ").concat(other.nbRegisters));
        }
        var newSketch = new HyperLogLog_1(this.nbRegisters);
        for (var i = 0; i < this.nbRegisters; i++) {
            newSketch._registers[i] = Math.max(this._registers[i], other._registers[i]);
        }
        return newSketch;
    };
    /**
     * Check if another HyperLogLog is equal to this one
     * @param  other - The HyperLogLog to compare to this one
     * @return True if they are equal, false otherwise
     */
    HyperLogLog.prototype.equals = function (other) {
        if (this.nbRegisters !== other.nbRegisters) {
            return false;
        }
        for (var i = 0; i < this.nbRegisters - 1; i++) {
            if (this._registers[i] !== other._registers[i]) {
                return false;
            }
        }
        return true;
    };
    var HyperLogLog_1;
    __decorate([
        (0, exportable_1.Field)(),
        __metadata("design:type", Number)
    ], HyperLogLog.prototype, "_nbRegisters", void 0);
    __decorate([
        (0, exportable_1.Field)(),
        __metadata("design:type", Number)
    ], HyperLogLog.prototype, "_nbBytesPerHash", void 0);
    __decorate([
        (0, exportable_1.Field)(),
        __metadata("design:type", Number)
    ], HyperLogLog.prototype, "_correctionBias", void 0);
    __decorate([
        (0, exportable_1.Field)(),
        __metadata("design:type", Array)
    ], HyperLogLog.prototype, "_registers", void 0);
    HyperLogLog = HyperLogLog_1 = __decorate([
        (0, exportable_1.AutoExportable)('HyperLogLog', ['_seed']),
        __param(0, (0, exportable_1.Parameter)('_nbRegisters')),
        __metadata("design:paramtypes", [Number])
    ], HyperLogLog);
    return HyperLogLog;
}(base_filter_1.default));
exports["default"] = HyperLogLog;


/***/ }),

/***/ 7577:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* file: min-hash-factory.ts
MIT License

Copyright (c) 2019-2020 Thomas Minier

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the 'Software'), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/
Object.defineProperty(exports, "__esModule", ({ value: true }));
var min_hash_1 = __webpack_require__(3294);
var lodash_1 = __webpack_require__(2543);
/**
 * Test if a number is a prime number
 * @param x - Number to test
 * @return True if the input is a prime number, False otherwise
 */
function isPrime(x) {
    if (x !== 2 && x % 2 === 0) {
        return false;
    }
    for (var i = 2; i < Math.sqrt(x); i++) {
        if (x % i === 0) {
            return false;
        }
    }
    return true;
}
/**
 * Find the fist prime number superior to a number
 * @param x - Input number
 * @return The fist prime number superior to the input number
 */
function closestPrime(x) {
    var i = 0;
    var stop = false;
    var to_return = i;
    while (!stop) {
        if (isPrime(x + i)) {
            to_return = x + i;
            stop = true;
        }
        i++;
    }
    return to_return;
}
/**
 * A factory to create MinHash sketches using the same set of hash functions.
 *
 * **WARNING**: Only the MinHash produced by the same factory can be compared between them.
 * @author Thomas Minier
 */
var MinHashFactory = /** @class */ (function () {
    /**
     * Constructor
     * @param nbHashes - Number of hash functions to use for comouting the MinHash signature
     * @param maxValue - The highest value that can be found in the set to compare
     */
    function MinHashFactory(nbHashes, maxValue) {
        this._nbHashes = nbHashes;
        this._maxValue = maxValue;
        this._hashFunctions = [];
        // generate hash functions
        var c = closestPrime(this._maxValue);
        for (var i = 0; i < this._nbHashes; i++) {
            var a = (0, lodash_1.random)(0, this._maxValue, false);
            var b = (0, lodash_1.random)(0, this._maxValue, false);
            this._hashFunctions.push({ a: a, b: b, c: c });
        }
    }
    /**
     * Create a new MinHash set
     * @return A new MinHash set
     */
    MinHashFactory.prototype.create = function () {
        return new min_hash_1.MinHash(this._nbHashes, this._hashFunctions);
    };
    return MinHashFactory;
}());
exports["default"] = MinHashFactory;


/***/ }),

/***/ 3294:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

/* file: min-hash.ts
MIT License

Copyright (c) 2019-2020 Thomas Minier

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the 'Software'), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MinHash = void 0;
var base_filter_1 = __importDefault(__webpack_require__(4914));
var exportable_1 = __webpack_require__(8044);
var utils_1 = __webpack_require__(8609);
/**
 * An error thrown when we try to compute the Jaccard Similarity with an empty MinHash
 * @author Thomas Minier
 */
var EmptyMinHashError = /** @class */ (function (_super) {
    __extends(EmptyMinHashError, _super);
    function EmptyMinHashError() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return EmptyMinHashError;
}(Error));
/**
 * Apply a hash function to a number to produce a hash
 * @param x - Value to hash
 * @param fn - HashFunction to apply
 * @return The hashed value
 */
function applyHashFunction(x, fn) {
    return (fn.a * x + fn.b) % fn.c;
}
/**
 * MinHash (or the min-wise independent permutations locality sensitive hashing scheme) is a technique for quickly estimating how similar two sets are.
 * It is able to estimate the Jaccard similarity between two large sets of numbers using random hashing.
 *
 * **WARNING**: Only the MinHash produced by the same {@link MinHashFactory} can be compared between them.
 *
 * @see "On the resemblance and containment of documents", by Andrei Z. Broder, in Compression and Complexity of Sequences: Proceedings, Positano, Amalfitan Coast, Salerno, Italy, June 11-13, 1997.
 * @author Thomas Minier
 */
var MinHash = /** @class */ (function (_super) {
    __extends(MinHash, _super);
    /**
     * Constructor
     * @param nbHashes - Number of hash functions to use for comouting the MinHash signature
     * @param hashFunctions - Hash functions used to compute the signature
     */
    function MinHash(nbHashes, hashFunctions) {
        var _this = _super.call(this) || this;
        _this._nbHashes = nbHashes;
        _this._hashFunctions = hashFunctions;
        _this._signature = (0, utils_1.allocateArray)(_this._nbHashes, Infinity);
        return _this;
    }
    Object.defineProperty(MinHash.prototype, "nbHashes", {
        /**
         * Get the number of hash functions used by the MinHash
         */
        get: function () {
            return this._nbHashes;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Test if the signature of the MinHash is empty
     * @return True if the MinHash is empty, False otherwise
     */
    MinHash.prototype.isEmpty = function () {
        return this._signature[0] === Infinity;
    };
    /**
     * Insert a value into the MinHash and update its signature.
     * @param value - Value to insert
     */
    MinHash.prototype.add = function (value) {
        for (var i = 0; i < this._nbHashes; i++) {
            var hash = applyHashFunction(value, this._hashFunctions[i]);
            this._signature[i] = Math.min(this._signature[i], hash);
        }
    };
    /**
     * Ingest a set of values into the MinHash, in an efficient manner, and update its signature.
     * @param values - Set of values to load
     */
    MinHash.prototype.bulkLoad = function (values) {
        var _this = this;
        var _loop_1 = function (i) {
            var candidateSignatures = values.map(function (value) {
                return applyHashFunction(value, _this._hashFunctions[i]);
            });
            // get the minimum of the candidate Signatures
            // dont supply too much parameters to Math.min or Math.max with risk of getting stack error
            // so we compute an iterative minimum
            var min = candidateSignatures[0];
            for (var i_1 = 1; i_1 < candidateSignatures.length; i_1++) {
                if (min > candidateSignatures[i_1]) {
                    min = candidateSignatures[i_1];
                }
            }
            this_1._signature[i] = Math.min(this_1._signature[i], min);
        };
        var this_1 = this;
        for (var i = 0; i < this._nbHashes; i++) {
            _loop_1(i);
        }
    };
    /**
     * Estimate the Jaccard similarity coefficient with another MinHash signature
     * @param other - MinHash to compare with
     * @return The estimated Jaccard similarity coefficient between the two sets
     */
    MinHash.prototype.compareWith = function (other) {
        if (this.isEmpty() || other.isEmpty()) {
            throw new EmptyMinHashError('Cannot compute a Jaccard similairty with a MinHash that contains no values');
        }
        // fix: we need to check for the number of equal signatures, not uniq equal signatures
        // lodash intersection ends with a uniq set of values
        var count = 0;
        for (var i = 0; i < this._nbHashes; i++) {
            if (this._signature[i] === other._signature[i]) {
                count++;
            }
        }
        return count / this._nbHashes;
    };
    __decorate([
        (0, exportable_1.Field)(),
        __metadata("design:type", Number)
    ], MinHash.prototype, "_nbHashes", void 0);
    __decorate([
        (0, exportable_1.Field)(),
        __metadata("design:type", Array)
    ], MinHash.prototype, "_hashFunctions", void 0);
    __decorate([
        (0, exportable_1.Field)(),
        __metadata("design:type", Array)
    ], MinHash.prototype, "_signature", void 0);
    MinHash = __decorate([
        (0, exportable_1.AutoExportable)('MinHash', ['_seed']),
        __param(0, (0, exportable_1.Parameter)('_nbHashes')),
        __param(1, (0, exportable_1.Parameter)('_hashFunctions')),
        __metadata("design:paramtypes", [Number, Array])
    ], MinHash);
    return MinHash;
}(base_filter_1.default));
exports.MinHash = MinHash;


/***/ }),

/***/ 6101:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

/* file: topk.ts
MIT License

Copyright (c) 2019-2020 Thomas Minier

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the 'Software'), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var base_filter_1 = __importDefault(__webpack_require__(4914));
var count_min_sketch_1 = __importDefault(__webpack_require__(7044));
var exportable_1 = __webpack_require__(8044);
var lodash_1 = __webpack_require__(2543);
/**
 * A MinHeap stores items sorted by ascending frequency
 * @author Thomas Minier
 */
var MinHeap = /** @class */ (function () {
    function MinHeap() {
        this._content = [];
    }
    Object.defineProperty(MinHeap.prototype, "length", {
        /**
         * Get the number of items in the heap
         */
        get: function () {
            return this._content.length;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(MinHeap.prototype, "content", {
        get: function () {
            return this._content;
        },
        set: function (value) {
            this._content = value;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Access an item at a given index
     * @param index - Index of the item
     * @return The item or `undefined` if the index is out of the array
     */
    MinHeap.prototype.get = function (index) {
        return this._content[index];
    };
    /**
     * Add a new element to the heap and keep items sorted by ascending frequency
     * @param element - Element to insert
     */
    MinHeap.prototype.add = function (element) {
        // kepp items sorted by frequency
        var index = (0, lodash_1.sortedIndexBy)(this._content, element, function (heapElement) { return heapElement.frequency; });
        this._content.splice(index, 0, element);
    };
    /**
     * Remove an item at a given index and keep items sorted by ascending frequency
     * @param index - Index of the item to remove
     */
    MinHeap.prototype.remove = function (index) {
        this._content.splice(index, 1);
    };
    /**
     * Remove and returns the element with the smallest frequency in the heap
     * @return The element with the smallest frequency in the heap
     */
    MinHeap.prototype.popMin = function () {
        return this._content.shift();
    };
    /**
     * Get the index of an element by its value
     * @param value - Value of the element to search for
     * @return Index of the element or -1 if it is not in the heap
     */
    MinHeap.prototype.indexOf = function (value) {
        // TODO optimize
        return this._content.findIndex(function (heapElement) { return heapElement.value === value; });
        // const index = sortedIndexBy(this._content, {value, frequency: 0}, heapElement => heapElement.value)
        // if (this._content[index] !== undefined && this._content[index].value === value) {
        //   return index
        // }
        // return -1
    };
    /**
     * Clear the content of the heap
     */
    MinHeap.prototype.clear = function () {
        this._content = [];
    };
    return MinHeap;
}());
/**
 * A TopK computes the ranking of elements in a multiset (by an arbitrary score) and returns the `k` results with the highest scores.
 * This implementation of the TopK problem sorts items based on their estimated cardinality in the multiset.
 * It is based on a Count Min Sketch, for estimating the cardinality of items, and a MinHeap, for implementing a sliding window over the `k` results with the highest scores.
 * @author Thomas Minier
 * @author Arnaud Grall
 */
var TopK = /** @class */ (function (_super) {
    __extends(TopK, _super);
    /**
     * Constructor
     * @param k - How many elements to store
     * @param errorRate - The error rate
     * @param accuracy  - The probability of accuracy
     */
    function TopK(k, errorRate, accuracy) {
        var _this = _super.call(this) || this;
        _this._k = k;
        _this._errorRate = errorRate;
        _this._accuracy = accuracy;
        _this._sketch = count_min_sketch_1.default.create(errorRate, accuracy);
        _this._heap = new MinHeap();
        return _this;
    }
    /**
     * Add an element to the TopK
     * @param element - Element to add
     */
    TopK.prototype.add = function (element, count) {
        if (count === void 0) { count = 1; }
        if (0 >= count) {
            throw "count must be > 0 (was ".concat(count, ")");
        }
        this._sketch.update(element, count);
        var frequency = this._sketch.count(element);
        if (this._heap.length < this._k ||
            frequency >= this._heap.get(0).frequency // eslint-disable-line @typescript-eslint/no-non-null-assertion
        ) {
            var index = this._heap.indexOf(element);
            // remove the entry if it is already in the MinHeap
            if (index > -1) {
                this._heap.remove(index);
            }
            // add the new entry
            this._heap.add({
                value: element,
                frequency: frequency,
            });
            // if there is more items than K, then remove the smallest item in the heap
            if (this._heap.length > this._k) {
                this._heap.popMin();
            }
        }
    };
    /**
     * Clear the content of the TopK
     */
    TopK.prototype.clear = function () {
        this._sketch = count_min_sketch_1.default.create(this._errorRate, this._accuracy);
        this._heap.clear();
    };
    /**
     * Get the top-k values as an array of objects {value: string, frequency: number, rank: number}
     * @return The top-k values as an array of objects {value: string, frequency: number, rank: number}
     */
    TopK.prototype.values = function () {
        var res = [];
        for (var i = this._heap.length - 1; i >= 0; i--) {
            var elt = this._heap.get(i); // eslint-disable-line @typescript-eslint/no-non-null-assertion
            res.push({
                value: elt.value,
                frequency: elt.frequency,
                rank: this._heap.length - i,
            });
        }
        return res;
    };
    /**
     * Get the top-k values as an iterator that yields objects {value: string, frequency: number, rank: number}.
     * WARNING: With this method, values are produced on-the-fly, hence you should not modify the TopK
     * while the iteration is not completed, otherwise the generated values may not respect the TopK properties.
     * @return The top-k values as an iterator of object {value: string, frequency: number, rank: number}
     */
    TopK.prototype.iterator = function () {
        var heap = this._heap;
        return (function () {
            var i, elt;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        i = heap.length - 1;
                        _a.label = 1;
                    case 1:
                        if (!(i >= 0)) return [3 /*break*/, 4];
                        elt = heap.get(i) // eslint-disable-line @typescript-eslint/no-non-null-assertion
                        ;
                        return [4 /*yield*/, {
                                value: elt.value,
                                frequency: elt.frequency,
                                rank: heap.length - i,
                            }];
                    case 2:
                        _a.sent();
                        _a.label = 3;
                    case 3:
                        i--;
                        return [3 /*break*/, 1];
                    case 4: return [2 /*return*/];
                }
            });
        })();
    };
    __decorate([
        (0, exportable_1.Field)(),
        __metadata("design:type", Number)
    ], TopK.prototype, "_k", void 0);
    __decorate([
        (0, exportable_1.Field)(),
        __metadata("design:type", Number)
    ], TopK.prototype, "_errorRate", void 0);
    __decorate([
        (0, exportable_1.Field)(),
        __metadata("design:type", Number)
    ], TopK.prototype, "_accuracy", void 0);
    __decorate([
        (0, exportable_1.Field)(
        // eslint-disable-next-line @typescript-eslint/no-unsafe-return
        function (sketch) { return sketch.saveAsJSON(); }, function (json) { return count_min_sketch_1.default.fromJSON(json); }),
        __metadata("design:type", count_min_sketch_1.default)
    ], TopK.prototype, "_sketch", void 0);
    __decorate([
        (0, exportable_1.Field)(function (heap) { return heap.content; }, function (json) {
            var heap = new MinHeap();
            heap.content = json;
            return heap;
        }),
        __metadata("design:type", MinHeap
        /**
         * Constructor
         * @param k - How many elements to store
         * @param errorRate - The error rate
         * @param accuracy  - The probability of accuracy
         */
        )
    ], TopK.prototype, "_heap", void 0);
    TopK = __decorate([
        (0, exportable_1.AutoExportable)('TopK', ['_seed']),
        __param(0, (0, exportable_1.Parameter)('_k')),
        __param(1, (0, exportable_1.Parameter)('_errorRate')),
        __param(2, (0, exportable_1.Parameter)('_accuracy')),
        __metadata("design:paramtypes", [Number, Number, Number])
    ], TopK);
    return TopK;
}(base_filter_1.default));
exports["default"] = TopK;


/***/ }),

/***/ 8609:
/***/ (function(__unused_webpack_module, exports) {

"use strict";

/* file : utils.ts
MIT License

Copyright (c) 2017-2020 Thomas Minier & Arnaud Grall

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getDefaultSeed = exports.isEmptyBuffer = exports.xorBuffer = exports.randomInt = exports.numberToHex = exports.allocateArray = exports.BufferError = void 0;
/**
 * BufferError
 */
exports.BufferError = 'The buffer class must be available, if you are a browser user use the buffer package (https://www.npmjs.com/package/buffer)';
/**
 * Create a new array fill with a base value
 * @param size - The size of the array
 * @param defaultValue - The default value used to fill the array. If it's a function, it will be invoked to get the default value.
 * @return A newly allocated array
 * @memberof Utils
 */
function allocateArray(size, defaultValue) {
    var array = new Array(size);
    var getDefault = typeof defaultValue === 'function'
        ? defaultValue
        : function () { return defaultValue; };
    for (var ind = 0; ind < size; ind++) {
        array[ind] = getDefault();
    }
    return array;
}
exports.allocateArray = allocateArray;
/**
 * Return a number to its Hex format by padding zeroes if length mod 4 != 0
 * @param elem the element to transform in HEX
 * @returns the HEX number padded of zeroes
 */
function numberToHex(elem) {
    var e = Number(elem).toString(16);
    if (e.length % 4 !== 0) {
        e = '0'.repeat(4 - (e.length % 4)) + e;
    }
    return e;
}
exports.numberToHex = numberToHex;
/**
 * Generate a random int between two bounds (included)
 * @param min - The lower bound
 * @param max - The upper bound
 * @param random - Function used to generate random floats
 * @return A random int bewteen lower and upper bound (included)
 * @memberof Utils
 * @author Thomas Minier
 */
function randomInt(min, max, random) {
    if (random === undefined) {
        random = Math.random;
    }
    min = Math.ceil(min);
    max = Math.floor(max);
    var rn = random();
    return Math.floor(rn * (max - min + 1)) + min;
}
exports.randomInt = randomInt;
/**
 * Return the non-destructive XOR of two buffers
 * @param a - The buffer to copy, then to xor with b
 * @param b - The buffer to xor with
 * @return The results of the XOR between the two buffers
 * @author Arnaud Grall
 */
function xorBuffer(a, b) {
    var length = Math.max(a.length, b.length);
    var buffer = Buffer.allocUnsafe(length).fill(0);
    for (var i = 0; i < length; ++i) {
        if (i < a.length && i < b.length) {
            buffer[length - i - 1] = a[a.length - i - 1] ^ b[b.length - i - 1];
        }
        else if (i < a.length && i >= b.length) {
            buffer[length - i - 1] ^= a[a.length - i - 1];
        }
        else if (i < b.length && i >= a.length) {
            buffer[length - i - 1] ^= b[b.length - i - 1];
        }
    }
    // now need to remove leading zeros in the buffer if any
    var start = 0;
    var it = buffer.values();
    var value = it.next();
    while (!value.done && value.value === 0) {
        start++;
        value = it.next();
    }
    return buffer.slice(start);
}
exports.xorBuffer = xorBuffer;
/**
 * Return true if the buffer is empty, i.e., all value are equals to 0.
 * @param  buffer - The buffer to inspect
 * @return True if the buffer only contains zero, False otherwise
 * @author Arnaud Grall
 */
function isEmptyBuffer(buffer) {
    var e_1, _a;
    if (buffer === null || !buffer)
        return true;
    try {
        for (var buffer_1 = __values(buffer), buffer_1_1 = buffer_1.next(); !buffer_1_1.done; buffer_1_1 = buffer_1.next()) {
            var value = buffer_1_1.value;
            if (value !== 0) {
                return false;
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (buffer_1_1 && !buffer_1_1.done && (_a = buffer_1.return)) _a.call(buffer_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return true;
}
exports.isEmptyBuffer = isEmptyBuffer;
/**
 * Return the default seed used in the package
 * @return A seed as a floating point number
 * @author Arnaud Grall
 */
function getDefaultSeed() {
    return 0x1234567890;
}
exports.getDefaultSeed = getDefaultSeed;


/***/ }),

/***/ 5017:
/***/ ((module, exports) => {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// GENERATED FILE. DO NOT EDIT.
var Long = (function(exports) {
  "use strict";
  
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  
  /**
   * @license
   * Copyright 2009 The Closure Library Authors
   * Copyright 2020 Daniel Wirtz / The long.js Authors.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * SPDX-License-Identifier: Apache-2.0
   */
  // WebAssembly optimizations to do native i64 multiplication and divide
  var wasm = null;
  
  try {
    wasm = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 13, 2, 96, 0, 1, 127, 96, 4, 127, 127, 127, 127, 1, 127, 3, 7, 6, 0, 1, 1, 1, 1, 1, 6, 6, 1, 127, 1, 65, 0, 11, 7, 50, 6, 3, 109, 117, 108, 0, 1, 5, 100, 105, 118, 95, 115, 0, 2, 5, 100, 105, 118, 95, 117, 0, 3, 5, 114, 101, 109, 95, 115, 0, 4, 5, 114, 101, 109, 95, 117, 0, 5, 8, 103, 101, 116, 95, 104, 105, 103, 104, 0, 0, 10, 191, 1, 6, 4, 0, 35, 0, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 126, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 127, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 128, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 129, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 130, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11])), {}).exports;
  } catch (e) {// no wasm support :(
  }
  /**
   * Constructs a 64 bit two's-complement integer, given its low and high 32 bit values as *signed* integers.
   *  See the from* functions below for more convenient ways of constructing Longs.
   * @exports Long
   * @class A Long class for representing a 64 bit two's-complement integer value.
   * @param {number} low The low (signed) 32 bits of the long
   * @param {number} high The high (signed) 32 bits of the long
   * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
   * @constructor
   */
  
  
  function Long(low, high, unsigned) {
    /**
     * The low 32 bits as a signed value.
     * @type {number}
     */
    this.low = low | 0;
    /**
     * The high 32 bits as a signed value.
     * @type {number}
     */
  
    this.high = high | 0;
    /**
     * Whether unsigned or not.
     * @type {boolean}
     */
  
    this.unsigned = !!unsigned;
  } // The internal representation of a long is the two given signed, 32-bit values.
  // We use 32-bit pieces because these are the size of integers on which
  // Javascript performs bit-operations.  For operations like addition and
  // multiplication, we split each number into 16 bit pieces, which can easily be
  // multiplied within Javascript's floating-point representation without overflow
  // or change in sign.
  //
  // In the algorithms below, we frequently reduce the negative case to the
  // positive case by negating the input(s) and then post-processing the result.
  // Note that we must ALWAYS check specially whether those values are MIN_VALUE
  // (-2^63) because -MIN_VALUE == MIN_VALUE (since 2^63 cannot be represented as
  // a positive number, it overflows back into a negative).  Not handling this
  // case would often result in infinite recursion.
  //
  // Common constant values ZERO, ONE, NEG_ONE, etc. are defined below the from*
  // methods on which they depend.
  
  /**
   * An indicator used to reliably determine if an object is a Long or not.
   * @type {boolean}
   * @const
   * @private
   */
  
  
  Long.prototype.__isLong__;
  Object.defineProperty(Long.prototype, "__isLong__", {
    value: true
  });
  /**
   * @function
   * @param {*} obj Object
   * @returns {boolean}
   * @inner
   */
  
  function isLong(obj) {
    return (obj && obj["__isLong__"]) === true;
  }
  /**
   * @function
   * @param {*} value number
   * @returns {number}
   * @inner
   */
  
  
  function ctz32(value) {
    var c = Math.clz32(value & -value);
    return value ? 31 - c : c;
  }
  /**
   * Tests if the specified object is a Long.
   * @function
   * @param {*} obj Object
   * @returns {boolean}
   */
  
  
  Long.isLong = isLong;
  /**
   * A cache of the Long representations of small integer values.
   * @type {!Object}
   * @inner
   */
  
  var INT_CACHE = {};
  /**
   * A cache of the Long representations of small unsigned integer values.
   * @type {!Object}
   * @inner
   */
  
  var UINT_CACHE = {};
  /**
   * @param {number} value
   * @param {boolean=} unsigned
   * @returns {!Long}
   * @inner
   */
  
  function fromInt(value, unsigned) {
    var obj, cachedObj, cache;
  
    if (unsigned) {
      value >>>= 0;
  
      if (cache = 0 <= value && value < 256) {
        cachedObj = UINT_CACHE[value];
        if (cachedObj) return cachedObj;
      }
  
      obj = fromBits(value, 0, true);
      if (cache) UINT_CACHE[value] = obj;
      return obj;
    } else {
      value |= 0;
  
      if (cache = -128 <= value && value < 128) {
        cachedObj = INT_CACHE[value];
        if (cachedObj) return cachedObj;
      }
  
      obj = fromBits(value, value < 0 ? -1 : 0, false);
      if (cache) INT_CACHE[value] = obj;
      return obj;
    }
  }
  /**
   * Returns a Long representing the given 32 bit integer value.
   * @function
   * @param {number} value The 32 bit integer in question
   * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
   * @returns {!Long} The corresponding Long value
   */
  
  
  Long.fromInt = fromInt;
  /**
   * @param {number} value
   * @param {boolean=} unsigned
   * @returns {!Long}
   * @inner
   */
  
  function fromNumber(value, unsigned) {
    if (isNaN(value)) return unsigned ? UZERO : ZERO;
  
    if (unsigned) {
      if (value < 0) return UZERO;
      if (value >= TWO_PWR_64_DBL) return MAX_UNSIGNED_VALUE;
    } else {
      if (value <= -TWO_PWR_63_DBL) return MIN_VALUE;
      if (value + 1 >= TWO_PWR_63_DBL) return MAX_VALUE;
    }
  
    if (value < 0) return fromNumber(-value, unsigned).neg();
    return fromBits(value % TWO_PWR_32_DBL | 0, value / TWO_PWR_32_DBL | 0, unsigned);
  }
  /**
   * Returns a Long representing the given value, provided that it is a finite number. Otherwise, zero is returned.
   * @function
   * @param {number} value The number in question
   * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
   * @returns {!Long} The corresponding Long value
   */
  
  
  Long.fromNumber = fromNumber;
  /**
   * @param {number} lowBits
   * @param {number} highBits
   * @param {boolean=} unsigned
   * @returns {!Long}
   * @inner
   */
  
  function fromBits(lowBits, highBits, unsigned) {
    return new Long(lowBits, highBits, unsigned);
  }
  /**
   * Returns a Long representing the 64 bit integer that comes by concatenating the given low and high bits. Each is
   *  assumed to use 32 bits.
   * @function
   * @param {number} lowBits The low 32 bits
   * @param {number} highBits The high 32 bits
   * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
   * @returns {!Long} The corresponding Long value
   */
  
  
  Long.fromBits = fromBits;
  /**
   * @function
   * @param {number} base
   * @param {number} exponent
   * @returns {number}
   * @inner
   */
  
  var pow_dbl = Math.pow; // Used 4 times (4*8 to 15+4)
  
  /**
   * @param {string} str
   * @param {(boolean|number)=} unsigned
   * @param {number=} radix
   * @returns {!Long}
   * @inner
   */
  
  function fromString(str, unsigned, radix) {
    if (str.length === 0) throw Error('empty string');
  
    if (typeof unsigned === 'number') {
      // For goog.math.long compatibility
      radix = unsigned;
      unsigned = false;
    } else {
      unsigned = !!unsigned;
    }
  
    if (str === "NaN" || str === "Infinity" || str === "+Infinity" || str === "-Infinity") return unsigned ? UZERO : ZERO;
    radix = radix || 10;
    if (radix < 2 || 36 < radix) throw RangeError('radix');
    var p;
    if ((p = str.indexOf('-')) > 0) throw Error('interior hyphen');else if (p === 0) {
      return fromString(str.substring(1), unsigned, radix).neg();
    } // Do several (8) digits each time through the loop, so as to
    // minimize the calls to the very expensive emulated div.
  
    var radixToPower = fromNumber(pow_dbl(radix, 8));
    var result = ZERO;
  
    for (var i = 0; i < str.length; i += 8) {
      var size = Math.min(8, str.length - i),
          value = parseInt(str.substring(i, i + size), radix);
  
      if (size < 8) {
        var power = fromNumber(pow_dbl(radix, size));
        result = result.mul(power).add(fromNumber(value));
      } else {
        result = result.mul(radixToPower);
        result = result.add(fromNumber(value));
      }
    }
  
    result.unsigned = unsigned;
    return result;
  }
  /**
   * Returns a Long representation of the given string, written using the specified radix.
   * @function
   * @param {string} str The textual representation of the Long
   * @param {(boolean|number)=} unsigned Whether unsigned or not, defaults to signed
   * @param {number=} radix The radix in which the text is written (2-36), defaults to 10
   * @returns {!Long} The corresponding Long value
   */
  
  
  Long.fromString = fromString;
  /**
   * @function
   * @param {!Long|number|string|!{low: number, high: number, unsigned: boolean}} val
   * @param {boolean=} unsigned
   * @returns {!Long}
   * @inner
   */
  
  function fromValue(val, unsigned) {
    if (typeof val === 'number') return fromNumber(val, unsigned);
    if (typeof val === 'string') return fromString(val, unsigned); // Throws for non-objects, converts non-instanceof Long:
  
    return fromBits(val.low, val.high, typeof unsigned === 'boolean' ? unsigned : val.unsigned);
  }
  /**
   * Converts the specified value to a Long using the appropriate from* function for its type.
   * @function
   * @param {!Long|number|string|!{low: number, high: number, unsigned: boolean}} val Value
   * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
   * @returns {!Long}
   */
  
  
  Long.fromValue = fromValue; // NOTE: the compiler should inline these constant values below and then remove these variables, so there should be
  // no runtime penalty for these.
  
  /**
   * @type {number}
   * @const
   * @inner
   */
  
  var TWO_PWR_16_DBL = 1 << 16;
  /**
   * @type {number}
   * @const
   * @inner
   */
  
  var TWO_PWR_24_DBL = 1 << 24;
  /**
   * @type {number}
   * @const
   * @inner
   */
  
  var TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;
  /**
   * @type {number}
   * @const
   * @inner
   */
  
  var TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;
  /**
   * @type {number}
   * @const
   * @inner
   */
  
  var TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;
  /**
   * @type {!Long}
   * @const
   * @inner
   */
  
  var TWO_PWR_24 = fromInt(TWO_PWR_24_DBL);
  /**
   * @type {!Long}
   * @inner
   */
  
  var ZERO = fromInt(0);
  /**
   * Signed zero.
   * @type {!Long}
   */
  
  Long.ZERO = ZERO;
  /**
   * @type {!Long}
   * @inner
   */
  
  var UZERO = fromInt(0, true);
  /**
   * Unsigned zero.
   * @type {!Long}
   */
  
  Long.UZERO = UZERO;
  /**
   * @type {!Long}
   * @inner
   */
  
  var ONE = fromInt(1);
  /**
   * Signed one.
   * @type {!Long}
   */
  
  Long.ONE = ONE;
  /**
   * @type {!Long}
   * @inner
   */
  
  var UONE = fromInt(1, true);
  /**
   * Unsigned one.
   * @type {!Long}
   */
  
  Long.UONE = UONE;
  /**
   * @type {!Long}
   * @inner
   */
  
  var NEG_ONE = fromInt(-1);
  /**
   * Signed negative one.
   * @type {!Long}
   */
  
  Long.NEG_ONE = NEG_ONE;
  /**
   * @type {!Long}
   * @inner
   */
  
  var MAX_VALUE = fromBits(0xFFFFFFFF | 0, 0x7FFFFFFF | 0, false);
  /**
   * Maximum signed value.
   * @type {!Long}
   */
  
  Long.MAX_VALUE = MAX_VALUE;
  /**
   * @type {!Long}
   * @inner
   */
  
  var MAX_UNSIGNED_VALUE = fromBits(0xFFFFFFFF | 0, 0xFFFFFFFF | 0, true);
  /**
   * Maximum unsigned value.
   * @type {!Long}
   */
  
  Long.MAX_UNSIGNED_VALUE = MAX_UNSIGNED_VALUE;
  /**
   * @type {!Long}
   * @inner
   */
  
  var MIN_VALUE = fromBits(0, 0x80000000 | 0, false);
  /**
   * Minimum signed value.
   * @type {!Long}
   */
  
  Long.MIN_VALUE = MIN_VALUE;
  /**
   * @alias Long.prototype
   * @inner
   */
  
  var LongPrototype = Long.prototype;
  /**
   * Converts the Long to a 32 bit integer, assuming it is a 32 bit integer.
   * @this {!Long}
   * @returns {number}
   */
  
  LongPrototype.toInt = function toInt() {
    return this.unsigned ? this.low >>> 0 : this.low;
  };
  /**
   * Converts the Long to a the nearest floating-point representation of this value (double, 53 bit mantissa).
   * @this {!Long}
   * @returns {number}
   */
  
  
  LongPrototype.toNumber = function toNumber() {
    if (this.unsigned) return (this.high >>> 0) * TWO_PWR_32_DBL + (this.low >>> 0);
    return this.high * TWO_PWR_32_DBL + (this.low >>> 0);
  };
  /**
   * Converts the Long to a string written in the specified radix.
   * @this {!Long}
   * @param {number=} radix Radix (2-36), defaults to 10
   * @returns {string}
   * @override
   * @throws {RangeError} If `radix` is out of range
   */
  
  
  LongPrototype.toString = function toString(radix) {
    radix = radix || 10;
    if (radix < 2 || 36 < radix) throw RangeError('radix');
    if (this.isZero()) return '0';
  
    if (this.isNegative()) {
      // Unsigned Longs are never negative
      if (this.eq(MIN_VALUE)) {
        // We need to change the Long value before it can be negated, so we remove
        // the bottom-most digit in this base and then recurse to do the rest.
        var radixLong = fromNumber(radix),
            div = this.div(radixLong),
            rem1 = div.mul(radixLong).sub(this);
        return div.toString(radix) + rem1.toInt().toString(radix);
      } else return '-' + this.neg().toString(radix);
    } // Do several (6) digits each time through the loop, so as to
    // minimize the calls to the very expensive emulated div.
  
  
    var radixToPower = fromNumber(pow_dbl(radix, 6), this.unsigned),
        rem = this;
    var result = '';
  
    while (true) {
      var remDiv = rem.div(radixToPower),
          intval = rem.sub(remDiv.mul(radixToPower)).toInt() >>> 0,
          digits = intval.toString(radix);
      rem = remDiv;
      if (rem.isZero()) return digits + result;else {
        while (digits.length < 6) digits = '0' + digits;
  
        result = '' + digits + result;
      }
    }
  };
  /**
   * Gets the high 32 bits as a signed integer.
   * @this {!Long}
   * @returns {number} Signed high bits
   */
  
  
  LongPrototype.getHighBits = function getHighBits() {
    return this.high;
  };
  /**
   * Gets the high 32 bits as an unsigned integer.
   * @this {!Long}
   * @returns {number} Unsigned high bits
   */
  
  
  LongPrototype.getHighBitsUnsigned = function getHighBitsUnsigned() {
    return this.high >>> 0;
  };
  /**
   * Gets the low 32 bits as a signed integer.
   * @this {!Long}
   * @returns {number} Signed low bits
   */
  
  
  LongPrototype.getLowBits = function getLowBits() {
    return this.low;
  };
  /**
   * Gets the low 32 bits as an unsigned integer.
   * @this {!Long}
   * @returns {number} Unsigned low bits
   */
  
  
  LongPrototype.getLowBitsUnsigned = function getLowBitsUnsigned() {
    return this.low >>> 0;
  };
  /**
   * Gets the number of bits needed to represent the absolute value of this Long.
   * @this {!Long}
   * @returns {number}
   */
  
  
  LongPrototype.getNumBitsAbs = function getNumBitsAbs() {
    if (this.isNegative()) // Unsigned Longs are never negative
      return this.eq(MIN_VALUE) ? 64 : this.neg().getNumBitsAbs();
    var val = this.high != 0 ? this.high : this.low;
  
    for (var bit = 31; bit > 0; bit--) if ((val & 1 << bit) != 0) break;
  
    return this.high != 0 ? bit + 33 : bit + 1;
  };
  /**
   * Tests if this Long's value equals zero.
   * @this {!Long}
   * @returns {boolean}
   */
  
  
  LongPrototype.isZero = function isZero() {
    return this.high === 0 && this.low === 0;
  };
  /**
   * Tests if this Long's value equals zero. This is an alias of {@link Long#isZero}.
   * @returns {boolean}
   */
  
  
  LongPrototype.eqz = LongPrototype.isZero;
  /**
   * Tests if this Long's value is negative.
   * @this {!Long}
   * @returns {boolean}
   */
  
  LongPrototype.isNegative = function isNegative() {
    return !this.unsigned && this.high < 0;
  };
  /**
   * Tests if this Long's value is positive or zero.
   * @this {!Long}
   * @returns {boolean}
   */
  
  
  LongPrototype.isPositive = function isPositive() {
    return this.unsigned || this.high >= 0;
  };
  /**
   * Tests if this Long's value is odd.
   * @this {!Long}
   * @returns {boolean}
   */
  
  
  LongPrototype.isOdd = function isOdd() {
    return (this.low & 1) === 1;
  };
  /**
   * Tests if this Long's value is even.
   * @this {!Long}
   * @returns {boolean}
   */
  
  
  LongPrototype.isEven = function isEven() {
    return (this.low & 1) === 0;
  };
  /**
   * Tests if this Long's value equals the specified's.
   * @this {!Long}
   * @param {!Long|number|string} other Other value
   * @returns {boolean}
   */
  
  
  LongPrototype.equals = function equals(other) {
    if (!isLong(other)) other = fromValue(other);
    if (this.unsigned !== other.unsigned && this.high >>> 31 === 1 && other.high >>> 31 === 1) return false;
    return this.high === other.high && this.low === other.low;
  };
  /**
   * Tests if this Long's value equals the specified's. This is an alias of {@link Long#equals}.
   * @function
   * @param {!Long|number|string} other Other value
   * @returns {boolean}
   */
  
  
  LongPrototype.eq = LongPrototype.equals;
  /**
   * Tests if this Long's value differs from the specified's.
   * @this {!Long}
   * @param {!Long|number|string} other Other value
   * @returns {boolean}
   */
  
  LongPrototype.notEquals = function notEquals(other) {
    return !this.eq(
    /* validates */
    other);
  };
  /**
   * Tests if this Long's value differs from the specified's. This is an alias of {@link Long#notEquals}.
   * @function
   * @param {!Long|number|string} other Other value
   * @returns {boolean}
   */
  
  
  LongPrototype.neq = LongPrototype.notEquals;
  /**
   * Tests if this Long's value differs from the specified's. This is an alias of {@link Long#notEquals}.
   * @function
   * @param {!Long|number|string} other Other value
   * @returns {boolean}
   */
  
  LongPrototype.ne = LongPrototype.notEquals;
  /**
   * Tests if this Long's value is less than the specified's.
   * @this {!Long}
   * @param {!Long|number|string} other Other value
   * @returns {boolean}
   */
  
  LongPrototype.lessThan = function lessThan(other) {
    return this.comp(
    /* validates */
    other) < 0;
  };
  /**
   * Tests if this Long's value is less than the specified's. This is an alias of {@link Long#lessThan}.
   * @function
   * @param {!Long|number|string} other Other value
   * @returns {boolean}
   */
  
  
  LongPrototype.lt = LongPrototype.lessThan;
  /**
   * Tests if this Long's value is less than or equal the specified's.
   * @this {!Long}
   * @param {!Long|number|string} other Other value
   * @returns {boolean}
   */
  
  LongPrototype.lessThanOrEqual = function lessThanOrEqual(other) {
    return this.comp(
    /* validates */
    other) <= 0;
  };
  /**
   * Tests if this Long's value is less than or equal the specified's. This is an alias of {@link Long#lessThanOrEqual}.
   * @function
   * @param {!Long|number|string} other Other value
   * @returns {boolean}
   */
  
  
  LongPrototype.lte = LongPrototype.lessThanOrEqual;
  /**
   * Tests if this Long's value is less than or equal the specified's. This is an alias of {@link Long#lessThanOrEqual}.
   * @function
   * @param {!Long|number|string} other Other value
   * @returns {boolean}
   */
  
  LongPrototype.le = LongPrototype.lessThanOrEqual;
  /**
   * Tests if this Long's value is greater than the specified's.
   * @this {!Long}
   * @param {!Long|number|string} other Other value
   * @returns {boolean}
   */
  
  LongPrototype.greaterThan = function greaterThan(other) {
    return this.comp(
    /* validates */
    other) > 0;
  };
  /**
   * Tests if this Long's value is greater than the specified's. This is an alias of {@link Long#greaterThan}.
   * @function
   * @param {!Long|number|string} other Other value
   * @returns {boolean}
   */
  
  
  LongPrototype.gt = LongPrototype.greaterThan;
  /**
   * Tests if this Long's value is greater than or equal the specified's.
   * @this {!Long}
   * @param {!Long|number|string} other Other value
   * @returns {boolean}
   */
  
  LongPrototype.greaterThanOrEqual = function greaterThanOrEqual(other) {
    return this.comp(
    /* validates */
    other) >= 0;
  };
  /**
   * Tests if this Long's value is greater than or equal the specified's. This is an alias of {@link Long#greaterThanOrEqual}.
   * @function
   * @param {!Long|number|string} other Other value
   * @returns {boolean}
   */
  
  
  LongPrototype.gte = LongPrototype.greaterThanOrEqual;
  /**
   * Tests if this Long's value is greater than or equal the specified's. This is an alias of {@link Long#greaterThanOrEqual}.
   * @function
   * @param {!Long|number|string} other Other value
   * @returns {boolean}
   */
  
  LongPrototype.ge = LongPrototype.greaterThanOrEqual;
  /**
   * Compares this Long's value with the specified's.
   * @this {!Long}
   * @param {!Long|number|string} other Other value
   * @returns {number} 0 if they are the same, 1 if the this is greater and -1
   *  if the given one is greater
   */
  
  LongPrototype.compare = function compare(other) {
    if (!isLong(other)) other = fromValue(other);
    if (this.eq(other)) return 0;
    var thisNeg = this.isNegative(),
        otherNeg = other.isNegative();
    if (thisNeg && !otherNeg) return -1;
    if (!thisNeg && otherNeg) return 1; // At this point the sign bits are the same
  
    if (!this.unsigned) return this.sub(other).isNegative() ? -1 : 1; // Both are positive if at least one is unsigned
  
    return other.high >>> 0 > this.high >>> 0 || other.high === this.high && other.low >>> 0 > this.low >>> 0 ? -1 : 1;
  };
  /**
   * Compares this Long's value with the specified's. This is an alias of {@link Long#compare}.
   * @function
   * @param {!Long|number|string} other Other value
   * @returns {number} 0 if they are the same, 1 if the this is greater and -1
   *  if the given one is greater
   */
  
  
  LongPrototype.comp = LongPrototype.compare;
  /**
   * Negates this Long's value.
   * @this {!Long}
   * @returns {!Long} Negated Long
   */
  
  LongPrototype.negate = function negate() {
    if (!this.unsigned && this.eq(MIN_VALUE)) return MIN_VALUE;
    return this.not().add(ONE);
  };
  /**
   * Negates this Long's value. This is an alias of {@link Long#negate}.
   * @function
   * @returns {!Long} Negated Long
   */
  
  
  LongPrototype.neg = LongPrototype.negate;
  /**
   * Returns the sum of this and the specified Long.
   * @this {!Long}
   * @param {!Long|number|string} addend Addend
   * @returns {!Long} Sum
   */
  
  LongPrototype.add = function add(addend) {
    if (!isLong(addend)) addend = fromValue(addend); // Divide each number into 4 chunks of 16 bits, and then sum the chunks.
  
    var a48 = this.high >>> 16;
    var a32 = this.high & 0xFFFF;
    var a16 = this.low >>> 16;
    var a00 = this.low & 0xFFFF;
    var b48 = addend.high >>> 16;
    var b32 = addend.high & 0xFFFF;
    var b16 = addend.low >>> 16;
    var b00 = addend.low & 0xFFFF;
    var c48 = 0,
        c32 = 0,
        c16 = 0,
        c00 = 0;
    c00 += a00 + b00;
    c16 += c00 >>> 16;
    c00 &= 0xFFFF;
    c16 += a16 + b16;
    c32 += c16 >>> 16;
    c16 &= 0xFFFF;
    c32 += a32 + b32;
    c48 += c32 >>> 16;
    c32 &= 0xFFFF;
    c48 += a48 + b48;
    c48 &= 0xFFFF;
    return fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);
  };
  /**
   * Returns the difference of this and the specified Long.
   * @this {!Long}
   * @param {!Long|number|string} subtrahend Subtrahend
   * @returns {!Long} Difference
   */
  
  
  LongPrototype.subtract = function subtract(subtrahend) {
    if (!isLong(subtrahend)) subtrahend = fromValue(subtrahend);
    return this.add(subtrahend.neg());
  };
  /**
   * Returns the difference of this and the specified Long. This is an alias of {@link Long#subtract}.
   * @function
   * @param {!Long|number|string} subtrahend Subtrahend
   * @returns {!Long} Difference
   */
  
  
  LongPrototype.sub = LongPrototype.subtract;
  /**
   * Returns the product of this and the specified Long.
   * @this {!Long}
   * @param {!Long|number|string} multiplier Multiplier
   * @returns {!Long} Product
   */
  
  LongPrototype.multiply = function multiply(multiplier) {
    if (this.isZero()) return this;
    if (!isLong(multiplier)) multiplier = fromValue(multiplier); // use wasm support if present
  
    if (wasm) {
      var low = wasm["mul"](this.low, this.high, multiplier.low, multiplier.high);
      return fromBits(low, wasm["get_high"](), this.unsigned);
    }
  
    if (multiplier.isZero()) return this.unsigned ? UZERO : ZERO;
    if (this.eq(MIN_VALUE)) return multiplier.isOdd() ? MIN_VALUE : ZERO;
    if (multiplier.eq(MIN_VALUE)) return this.isOdd() ? MIN_VALUE : ZERO;
  
    if (this.isNegative()) {
      if (multiplier.isNegative()) return this.neg().mul(multiplier.neg());else return this.neg().mul(multiplier).neg();
    } else if (multiplier.isNegative()) return this.mul(multiplier.neg()).neg(); // If both longs are small, use float multiplication
  
  
    if (this.lt(TWO_PWR_24) && multiplier.lt(TWO_PWR_24)) return fromNumber(this.toNumber() * multiplier.toNumber(), this.unsigned); // Divide each long into 4 chunks of 16 bits, and then add up 4x4 products.
    // We can skip products that would overflow.
  
    var a48 = this.high >>> 16;
    var a32 = this.high & 0xFFFF;
    var a16 = this.low >>> 16;
    var a00 = this.low & 0xFFFF;
    var b48 = multiplier.high >>> 16;
    var b32 = multiplier.high & 0xFFFF;
    var b16 = multiplier.low >>> 16;
    var b00 = multiplier.low & 0xFFFF;
    var c48 = 0,
        c32 = 0,
        c16 = 0,
        c00 = 0;
    c00 += a00 * b00;
    c16 += c00 >>> 16;
    c00 &= 0xFFFF;
    c16 += a16 * b00;
    c32 += c16 >>> 16;
    c16 &= 0xFFFF;
    c16 += a00 * b16;
    c32 += c16 >>> 16;
    c16 &= 0xFFFF;
    c32 += a32 * b00;
    c48 += c32 >>> 16;
    c32 &= 0xFFFF;
    c32 += a16 * b16;
    c48 += c32 >>> 16;
    c32 &= 0xFFFF;
    c32 += a00 * b32;
    c48 += c32 >>> 16;
    c32 &= 0xFFFF;
    c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;
    c48 &= 0xFFFF;
    return fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);
  };
  /**
   * Returns the product of this and the specified Long. This is an alias of {@link Long#multiply}.
   * @function
   * @param {!Long|number|string} multiplier Multiplier
   * @returns {!Long} Product
   */
  
  
  LongPrototype.mul = LongPrototype.multiply;
  /**
   * Returns this Long divided by the specified. The result is signed if this Long is signed or
   *  unsigned if this Long is unsigned.
   * @this {!Long}
   * @param {!Long|number|string} divisor Divisor
   * @returns {!Long} Quotient
   */
  
  LongPrototype.divide = function divide(divisor) {
    if (!isLong(divisor)) divisor = fromValue(divisor);
    if (divisor.isZero()) throw Error('division by zero'); // use wasm support if present
  
    if (wasm) {
      // guard against signed division overflow: the largest
      // negative number / -1 would be 1 larger than the largest
      // positive number, due to two's complement.
      if (!this.unsigned && this.high === -0x80000000 && divisor.low === -1 && divisor.high === -1) {
        // be consistent with non-wasm code path
        return this;
      }
  
      var low = (this.unsigned ? wasm["div_u"] : wasm["div_s"])(this.low, this.high, divisor.low, divisor.high);
      return fromBits(low, wasm["get_high"](), this.unsigned);
    }
  
    if (this.isZero()) return this.unsigned ? UZERO : ZERO;
    var approx, rem, res;
  
    if (!this.unsigned) {
      // This section is only relevant for signed longs and is derived from the
      // closure library as a whole.
      if (this.eq(MIN_VALUE)) {
        if (divisor.eq(ONE) || divisor.eq(NEG_ONE)) return MIN_VALUE; // recall that -MIN_VALUE == MIN_VALUE
        else if (divisor.eq(MIN_VALUE)) return ONE;else {
          // At this point, we have |other| >= 2, so |this/other| < |MIN_VALUE|.
          var halfThis = this.shr(1);
          approx = halfThis.div(divisor).shl(1);
  
          if (approx.eq(ZERO)) {
            return divisor.isNegative() ? ONE : NEG_ONE;
          } else {
            rem = this.sub(divisor.mul(approx));
            res = approx.add(rem.div(divisor));
            return res;
          }
        }
      } else if (divisor.eq(MIN_VALUE)) return this.unsigned ? UZERO : ZERO;
  
      if (this.isNegative()) {
        if (divisor.isNegative()) return this.neg().div(divisor.neg());
        return this.neg().div(divisor).neg();
      } else if (divisor.isNegative()) return this.div(divisor.neg()).neg();
  
      res = ZERO;
    } else {
      // The algorithm below has not been made for unsigned longs. It's therefore
      // required to take special care of the MSB prior to running it.
      if (!divisor.unsigned) divisor = divisor.toUnsigned();
      if (divisor.gt(this)) return UZERO;
      if (divisor.gt(this.shru(1))) // 15 >>> 1 = 7 ; with divisor = 8 ; true
        return UONE;
      res = UZERO;
    } // Repeat the following until the remainder is less than other:  find a
    // floating-point that approximates remainder / other *from below*, add this
    // into the result, and subtract it from the remainder.  It is critical that
    // the approximate value is less than or equal to the real value so that the
    // remainder never becomes negative.
  
  
    rem = this;
  
    while (rem.gte(divisor)) {
      // Approximate the result of division. This may be a little greater or
      // smaller than the actual value.
      approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber())); // We will tweak the approximate result by changing it in the 48-th digit or
      // the smallest non-fractional digit, whichever is larger.
  
      var log2 = Math.ceil(Math.log(approx) / Math.LN2),
          delta = log2 <= 48 ? 1 : pow_dbl(2, log2 - 48),
          // Decrease the approximation until it is smaller than the remainder.  Note
      // that if it is too large, the product overflows and is negative.
      approxRes = fromNumber(approx),
          approxRem = approxRes.mul(divisor);
  
      while (approxRem.isNegative() || approxRem.gt(rem)) {
        approx -= delta;
        approxRes = fromNumber(approx, this.unsigned);
        approxRem = approxRes.mul(divisor);
      } // We know the answer can't be zero... and actually, zero would cause
      // infinite recursion since we would make no progress.
  
  
      if (approxRes.isZero()) approxRes = ONE;
      res = res.add(approxRes);
      rem = rem.sub(approxRem);
    }
  
    return res;
  };
  /**
   * Returns this Long divided by the specified. This is an alias of {@link Long#divide}.
   * @function
   * @param {!Long|number|string} divisor Divisor
   * @returns {!Long} Quotient
   */
  
  
  LongPrototype.div = LongPrototype.divide;
  /**
   * Returns this Long modulo the specified.
   * @this {!Long}
   * @param {!Long|number|string} divisor Divisor
   * @returns {!Long} Remainder
   */
  
  LongPrototype.modulo = function modulo(divisor) {
    if (!isLong(divisor)) divisor = fromValue(divisor); // use wasm support if present
  
    if (wasm) {
      var low = (this.unsigned ? wasm["rem_u"] : wasm["rem_s"])(this.low, this.high, divisor.low, divisor.high);
      return fromBits(low, wasm["get_high"](), this.unsigned);
    }
  
    return this.sub(this.div(divisor).mul(divisor));
  };
  /**
   * Returns this Long modulo the specified. This is an alias of {@link Long#modulo}.
   * @function
   * @param {!Long|number|string} divisor Divisor
   * @returns {!Long} Remainder
   */
  
  
  LongPrototype.mod = LongPrototype.modulo;
  /**
   * Returns this Long modulo the specified. This is an alias of {@link Long#modulo}.
   * @function
   * @param {!Long|number|string} divisor Divisor
   * @returns {!Long} Remainder
   */
  
  LongPrototype.rem = LongPrototype.modulo;
  /**
   * Returns the bitwise NOT of this Long.
   * @this {!Long}
   * @returns {!Long}
   */
  
  LongPrototype.not = function not() {
    return fromBits(~this.low, ~this.high, this.unsigned);
  };
  /**
   * Returns count leading zeros of this Long.
   * @this {!Long}
   * @returns {!number}
   */
  
  
  LongPrototype.countLeadingZeros = function countLeadingZeros() {
    return this.high ? Math.clz32(this.high) : Math.clz32(this.low) + 32;
  };
  /**
   * Returns count leading zeros. This is an alias of {@link Long#countLeadingZeros}.
   * @function
   * @param {!Long}
   * @returns {!number}
   */
  
  
  LongPrototype.clz = LongPrototype.countLeadingZeros;
  /**
   * Returns count trailing zeros of this Long.
   * @this {!Long}
   * @returns {!number}
   */
  
  LongPrototype.countTrailingZeros = function countTrailingZeros() {
    return this.low ? ctz32(this.low) : ctz32(this.high) + 32;
  };
  /**
   * Returns count trailing zeros. This is an alias of {@link Long#countTrailingZeros}.
   * @function
   * @param {!Long}
   * @returns {!number}
   */
  
  
  LongPrototype.ctz = LongPrototype.countTrailingZeros;
  /**
   * Returns the bitwise AND of this Long and the specified.
   * @this {!Long}
   * @param {!Long|number|string} other Other Long
   * @returns {!Long}
   */
  
  LongPrototype.and = function and(other) {
    if (!isLong(other)) other = fromValue(other);
    return fromBits(this.low & other.low, this.high & other.high, this.unsigned);
  };
  /**
   * Returns the bitwise OR of this Long and the specified.
   * @this {!Long}
   * @param {!Long|number|string} other Other Long
   * @returns {!Long}
   */
  
  
  LongPrototype.or = function or(other) {
    if (!isLong(other)) other = fromValue(other);
    return fromBits(this.low | other.low, this.high | other.high, this.unsigned);
  };
  /**
   * Returns the bitwise XOR of this Long and the given one.
   * @this {!Long}
   * @param {!Long|number|string} other Other Long
   * @returns {!Long}
   */
  
  
  LongPrototype.xor = function xor(other) {
    if (!isLong(other)) other = fromValue(other);
    return fromBits(this.low ^ other.low, this.high ^ other.high, this.unsigned);
  };
  /**
   * Returns this Long with bits shifted to the left by the given amount.
   * @this {!Long}
   * @param {number|!Long} numBits Number of bits
   * @returns {!Long} Shifted Long
   */
  
  
  LongPrototype.shiftLeft = function shiftLeft(numBits) {
    if (isLong(numBits)) numBits = numBits.toInt();
    if ((numBits &= 63) === 0) return this;else if (numBits < 32) return fromBits(this.low << numBits, this.high << numBits | this.low >>> 32 - numBits, this.unsigned);else return fromBits(0, this.low << numBits - 32, this.unsigned);
  };
  /**
   * Returns this Long with bits shifted to the left by the given amount. This is an alias of {@link Long#shiftLeft}.
   * @function
   * @param {number|!Long} numBits Number of bits
   * @returns {!Long} Shifted Long
   */
  
  
  LongPrototype.shl = LongPrototype.shiftLeft;
  /**
   * Returns this Long with bits arithmetically shifted to the right by the given amount.
   * @this {!Long}
   * @param {number|!Long} numBits Number of bits
   * @returns {!Long} Shifted Long
   */
  
  LongPrototype.shiftRight = function shiftRight(numBits) {
    if (isLong(numBits)) numBits = numBits.toInt();
    if ((numBits &= 63) === 0) return this;else if (numBits < 32) return fromBits(this.low >>> numBits | this.high << 32 - numBits, this.high >> numBits, this.unsigned);else return fromBits(this.high >> numBits - 32, this.high >= 0 ? 0 : -1, this.unsigned);
  };
  /**
   * Returns this Long with bits arithmetically shifted to the right by the given amount. This is an alias of {@link Long#shiftRight}.
   * @function
   * @param {number|!Long} numBits Number of bits
   * @returns {!Long} Shifted Long
   */
  
  
  LongPrototype.shr = LongPrototype.shiftRight;
  /**
   * Returns this Long with bits logically shifted to the right by the given amount.
   * @this {!Long}
   * @param {number|!Long} numBits Number of bits
   * @returns {!Long} Shifted Long
   */
  
  LongPrototype.shiftRightUnsigned = function shiftRightUnsigned(numBits) {
    if (isLong(numBits)) numBits = numBits.toInt();
    if ((numBits &= 63) === 0) return this;
    if (numBits < 32) return fromBits(this.low >>> numBits | this.high << 32 - numBits, this.high >>> numBits, this.unsigned);
    if (numBits === 32) return fromBits(this.high, 0, this.unsigned);
    return fromBits(this.high >>> numBits - 32, 0, this.unsigned);
  };
  /**
   * Returns this Long with bits logically shifted to the right by the given amount. This is an alias of {@link Long#shiftRightUnsigned}.
   * @function
   * @param {number|!Long} numBits Number of bits
   * @returns {!Long} Shifted Long
   */
  
  
  LongPrototype.shru = LongPrototype.shiftRightUnsigned;
  /**
   * Returns this Long with bits logically shifted to the right by the given amount. This is an alias of {@link Long#shiftRightUnsigned}.
   * @function
   * @param {number|!Long} numBits Number of bits
   * @returns {!Long} Shifted Long
   */
  
  LongPrototype.shr_u = LongPrototype.shiftRightUnsigned;
  /**
   * Returns this Long with bits rotated to the left by the given amount.
   * @this {!Long}
   * @param {number|!Long} numBits Number of bits
   * @returns {!Long} Rotated Long
   */
  
  LongPrototype.rotateLeft = function rotateLeft(numBits) {
    var b;
    if (isLong(numBits)) numBits = numBits.toInt();
    if ((numBits &= 63) === 0) return this;
    if (numBits === 32) return fromBits(this.high, this.low, this.unsigned);
  
    if (numBits < 32) {
      b = 32 - numBits;
      return fromBits(this.low << numBits | this.high >>> b, this.high << numBits | this.low >>> b, this.unsigned);
    }
  
    numBits -= 32;
    b = 32 - numBits;
    return fromBits(this.high << numBits | this.low >>> b, this.low << numBits | this.high >>> b, this.unsigned);
  };
  /**
   * Returns this Long with bits rotated to the left by the given amount. This is an alias of {@link Long#rotateLeft}.
   * @function
   * @param {number|!Long} numBits Number of bits
   * @returns {!Long} Rotated Long
   */
  
  
  LongPrototype.rotl = LongPrototype.rotateLeft;
  /**
   * Returns this Long with bits rotated to the right by the given amount.
   * @this {!Long}
   * @param {number|!Long} numBits Number of bits
   * @returns {!Long} Rotated Long
   */
  
  LongPrototype.rotateRight = function rotateRight(numBits) {
    var b;
    if (isLong(numBits)) numBits = numBits.toInt();
    if ((numBits &= 63) === 0) return this;
    if (numBits === 32) return fromBits(this.high, this.low, this.unsigned);
  
    if (numBits < 32) {
      b = 32 - numBits;
      return fromBits(this.high << b | this.low >>> numBits, this.low << b | this.high >>> numBits, this.unsigned);
    }
  
    numBits -= 32;
    b = 32 - numBits;
    return fromBits(this.low << b | this.high >>> numBits, this.high << b | this.low >>> numBits, this.unsigned);
  };
  /**
   * Returns this Long with bits rotated to the right by the given amount. This is an alias of {@link Long#rotateRight}.
   * @function
   * @param {number|!Long} numBits Number of bits
   * @returns {!Long} Rotated Long
   */
  
  
  LongPrototype.rotr = LongPrototype.rotateRight;
  /**
   * Converts this Long to signed.
   * @this {!Long}
   * @returns {!Long} Signed long
   */
  
  LongPrototype.toSigned = function toSigned() {
    if (!this.unsigned) return this;
    return fromBits(this.low, this.high, false);
  };
  /**
   * Converts this Long to unsigned.
   * @this {!Long}
   * @returns {!Long} Unsigned long
   */
  
  
  LongPrototype.toUnsigned = function toUnsigned() {
    if (this.unsigned) return this;
    return fromBits(this.low, this.high, true);
  };
  /**
   * Converts this Long to its byte representation.
   * @param {boolean=} le Whether little or big endian, defaults to big endian
   * @this {!Long}
   * @returns {!Array.<number>} Byte representation
   */
  
  
  LongPrototype.toBytes = function toBytes(le) {
    return le ? this.toBytesLE() : this.toBytesBE();
  };
  /**
   * Converts this Long to its little endian byte representation.
   * @this {!Long}
   * @returns {!Array.<number>} Little endian byte representation
   */
  
  
  LongPrototype.toBytesLE = function toBytesLE() {
    var hi = this.high,
        lo = this.low;
    return [lo & 0xff, lo >>> 8 & 0xff, lo >>> 16 & 0xff, lo >>> 24, hi & 0xff, hi >>> 8 & 0xff, hi >>> 16 & 0xff, hi >>> 24];
  };
  /**
   * Converts this Long to its big endian byte representation.
   * @this {!Long}
   * @returns {!Array.<number>} Big endian byte representation
   */
  
  
  LongPrototype.toBytesBE = function toBytesBE() {
    var hi = this.high,
        lo = this.low;
    return [hi >>> 24, hi >>> 16 & 0xff, hi >>> 8 & 0xff, hi & 0xff, lo >>> 24, lo >>> 16 & 0xff, lo >>> 8 & 0xff, lo & 0xff];
  };
  /**
   * Creates a Long from its byte representation.
   * @param {!Array.<number>} bytes Byte representation
   * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
   * @param {boolean=} le Whether little or big endian, defaults to big endian
   * @returns {Long} The corresponding Long value
   */
  
  
  Long.fromBytes = function fromBytes(bytes, unsigned, le) {
    return le ? Long.fromBytesLE(bytes, unsigned) : Long.fromBytesBE(bytes, unsigned);
  };
  /**
   * Creates a Long from its little endian byte representation.
   * @param {!Array.<number>} bytes Little endian byte representation
   * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
   * @returns {Long} The corresponding Long value
   */
  
  
  Long.fromBytesLE = function fromBytesLE(bytes, unsigned) {
    return new Long(bytes[0] | bytes[1] << 8 | bytes[2] << 16 | bytes[3] << 24, bytes[4] | bytes[5] << 8 | bytes[6] << 16 | bytes[7] << 24, unsigned);
  };
  /**
   * Creates a Long from its big endian byte representation.
   * @param {!Array.<number>} bytes Big endian byte representation
   * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
   * @returns {Long} The corresponding Long value
   */
  
  
  Long.fromBytesBE = function fromBytesBE(bytes, unsigned) {
    return new Long(bytes[4] << 24 | bytes[5] << 16 | bytes[6] << 8 | bytes[7], bytes[0] << 24 | bytes[1] << 16 | bytes[2] << 8 | bytes[3], unsigned);
  };
  
  var _default = Long;
  exports.default = _default;
  return "default" in exports ? exports.default : exports;
})({});
if (true) !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function() { return Long; }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
else {}


/***/ }),

/***/ 9211:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

/* eslint-disable @typescript-eslint/strict-boolean-expressions */

// ---------------------------------------------------------------------------
// Specific encodings
// ---------------------------------------------------------------------------
var base16Encoding = {
  chars: '0123456789ABCDEF',
  bits: 4
};
var base32Encoding = {
  chars: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567',
  bits: 5
};
var base32HexEncoding = {
  chars: '0123456789ABCDEFGHIJKLMNOPQRSTUV',
  bits: 5
};
var base64Encoding = {
  chars: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/',
  bits: 6
};
var base64UrlEncoding = {
  chars: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_',
  bits: 6
};
var base16 = {
  parse: function parse(string, opts) {
    return _parse(string.toUpperCase(), base16Encoding, opts);
  },
  stringify: function stringify(data, opts) {
    return _stringify(data, base16Encoding, opts);
  }
};
var base32 = {
  parse: function parse(string, opts) {
    if (opts === void 0) {
      opts = {};
    }
    return _parse(opts.loose ? string.toUpperCase().replace(/0/g, 'O').replace(/1/g, 'L').replace(/8/g, 'B') : string, base32Encoding, opts);
  },
  stringify: function stringify(data, opts) {
    return _stringify(data, base32Encoding, opts);
  }
};
var base32hex = {
  parse: function parse(string, opts) {
    return _parse(string, base32HexEncoding, opts);
  },
  stringify: function stringify(data, opts) {
    return _stringify(data, base32HexEncoding, opts);
  }
};
var base64 = {
  parse: function parse(string, opts) {
    return _parse(string, base64Encoding, opts);
  },
  stringify: function stringify(data, opts) {
    return _stringify(data, base64Encoding, opts);
  }
};
var base64url = {
  parse: function parse(string, opts) {
    return _parse(string, base64UrlEncoding, opts);
  },
  stringify: function stringify(data, opts) {
    return _stringify(data, base64UrlEncoding, opts);
  }
};

// ---------------------------------------------------------------------------
// Codec implementation
// ---------------------------------------------------------------------------

var codec = {
  parse: _parse,
  stringify: _stringify
};
function _parse(string, encoding, opts) {
  var _opts$out;
  if (opts === void 0) {
    opts = {};
  }
  // Build the character lookup table:
  if (!encoding.codes) {
    encoding.codes = {};
    for (var i = 0; i < encoding.chars.length; ++i) {
      encoding.codes[encoding.chars[i]] = i;
    }
  }

  // The string must have a whole number of bytes:
  if (!opts.loose && string.length * encoding.bits & 7) {
    throw new SyntaxError('Invalid padding');
  }

  // Count the padding bytes:
  var end = string.length;
  while (string[end - 1] === '=') {
    --end;

    // If we get a whole number of bytes, there is too much padding:
    if (!opts.loose && !((string.length - end) * encoding.bits & 7)) {
      throw new SyntaxError('Invalid padding');
    }
  }

  // Allocate the output:
  var out = new ((_opts$out = opts.out) != null ? _opts$out : Uint8Array)(end * encoding.bits / 8 | 0);

  // Parse the data:
  var bits = 0; // Number of bits currently in the buffer
  var buffer = 0; // Bits waiting to be written out, MSB first
  var written = 0; // Next byte to write
  for (var _i = 0; _i < end; ++_i) {
    // Read one character from the string:
    var value = encoding.codes[string[_i]];
    if (value === undefined) {
      throw new SyntaxError('Invalid character ' + string[_i]);
    }

    // Append the bits to the buffer:
    buffer = buffer << encoding.bits | value;
    bits += encoding.bits;

    // Write out some bits if the buffer has a byte's worth:
    if (bits >= 8) {
      bits -= 8;
      out[written++] = 0xff & buffer >> bits;
    }
  }

  // Verify that we have received just enough bits:
  if (bits >= encoding.bits || 0xff & buffer << 8 - bits) {
    throw new SyntaxError('Unexpected end of data');
  }
  return out;
}
function _stringify(data, encoding, opts) {
  if (opts === void 0) {
    opts = {};
  }
  var _opts = opts,
    _opts$pad = _opts.pad,
    pad = _opts$pad === void 0 ? true : _opts$pad;
  var mask = (1 << encoding.bits) - 1;
  var out = '';
  var bits = 0; // Number of bits currently in the buffer
  var buffer = 0; // Bits waiting to be written out, MSB first
  for (var i = 0; i < data.length; ++i) {
    // Slurp data into the buffer:
    buffer = buffer << 8 | 0xff & data[i];
    bits += 8;

    // Write out as much as we can:
    while (bits > encoding.bits) {
      bits -= encoding.bits;
      out += encoding.chars[mask & buffer >> bits];
    }
  }

  // Partial character:
  if (bits) {
    out += encoding.chars[mask & buffer << encoding.bits - bits];
  }

  // Add padding characters until we hit a byte boundary:
  if (pad) {
    while (out.length * encoding.bits & 7) {
      out += '=';
    }
  }
  return out;
}

exports.base16 = base16;
exports.base32 = base32;
exports.base32hex = base32hex;
exports.base64 = base64;
exports.base64url = base64url;
exports.codec = codec;


/***/ }),

/***/ 5827:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.version = exports.validate = exports.v7 = exports.v6ToV1 = exports.v6 = exports.v5 = exports.v4 = exports.v3 = exports.v1ToV6 = exports.v1 = exports.stringify = exports.parse = exports.NIL = exports.MAX = void 0;
var max_js_1 = __webpack_require__(5609);
Object.defineProperty(exports, "MAX", ({ enumerable: true, get: function () { return max_js_1.default; } }));
var nil_js_1 = __webpack_require__(3588);
Object.defineProperty(exports, "NIL", ({ enumerable: true, get: function () { return nil_js_1.default; } }));
var parse_js_1 = __webpack_require__(2524);
Object.defineProperty(exports, "parse", ({ enumerable: true, get: function () { return parse_js_1.default; } }));
var stringify_js_1 = __webpack_require__(3202);
Object.defineProperty(exports, "stringify", ({ enumerable: true, get: function () { return stringify_js_1.default; } }));
var v1_js_1 = __webpack_require__(458);
Object.defineProperty(exports, "v1", ({ enumerable: true, get: function () { return v1_js_1.default; } }));
var v1ToV6_js_1 = __webpack_require__(3891);
Object.defineProperty(exports, "v1ToV6", ({ enumerable: true, get: function () { return v1ToV6_js_1.default; } }));
var v3_js_1 = __webpack_require__(32);
Object.defineProperty(exports, "v3", ({ enumerable: true, get: function () { return v3_js_1.default; } }));
var v4_js_1 = __webpack_require__(8597);
Object.defineProperty(exports, "v4", ({ enumerable: true, get: function () { return v4_js_1.default; } }));
var v5_js_1 = __webpack_require__(4502);
Object.defineProperty(exports, "v5", ({ enumerable: true, get: function () { return v5_js_1.default; } }));
var v6_js_1 = __webpack_require__(7971);
Object.defineProperty(exports, "v6", ({ enumerable: true, get: function () { return v6_js_1.default; } }));
var v6ToV1_js_1 = __webpack_require__(8959);
Object.defineProperty(exports, "v6ToV1", ({ enumerable: true, get: function () { return v6ToV1_js_1.default; } }));
var v7_js_1 = __webpack_require__(2508);
Object.defineProperty(exports, "v7", ({ enumerable: true, get: function () { return v7_js_1.default; } }));
var validate_js_1 = __webpack_require__(8873);
Object.defineProperty(exports, "validate", ({ enumerable: true, get: function () { return validate_js_1.default; } }));
var version_js_1 = __webpack_require__(9547);
Object.defineProperty(exports, "version", ({ enumerable: true, get: function () { return version_js_1.default; } }));


/***/ }),

/***/ 5609:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports["default"] = 'ffffffff-ffff-ffff-ffff-ffffffffffff';


/***/ }),

/***/ 7355:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const crypto_1 = __webpack_require__(6982);
function md5(bytes) {
    if (Array.isArray(bytes)) {
        bytes = Buffer.from(bytes);
    }
    else if (typeof bytes === 'string') {
        bytes = Buffer.from(bytes, 'utf8');
    }
    return (0, crypto_1.createHash)('md5').update(bytes).digest();
}
exports["default"] = md5;


/***/ }),

/***/ 1152:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const crypto_1 = __webpack_require__(6982);
exports["default"] = { randomUUID: crypto_1.randomUUID };


/***/ }),

/***/ 3588:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports["default"] = '00000000-0000-0000-0000-000000000000';


/***/ }),

/***/ 2524:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const validate_js_1 = __webpack_require__(8873);
function parse(uuid) {
    if (!(0, validate_js_1.default)(uuid)) {
        throw TypeError('Invalid UUID');
    }
    let v;
    return Uint8Array.of((v = parseInt(uuid.slice(0, 8), 16)) >>> 24, (v >>> 16) & 0xff, (v >>> 8) & 0xff, v & 0xff, (v = parseInt(uuid.slice(9, 13), 16)) >>> 8, v & 0xff, (v = parseInt(uuid.slice(14, 18), 16)) >>> 8, v & 0xff, (v = parseInt(uuid.slice(19, 23), 16)) >>> 8, v & 0xff, ((v = parseInt(uuid.slice(24, 36), 16)) / 0x10000000000) & 0xff, (v / 0x100000000) & 0xff, (v >>> 24) & 0xff, (v >>> 16) & 0xff, (v >>> 8) & 0xff, v & 0xff);
}
exports["default"] = parse;


/***/ }),

/***/ 3596:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports["default"] = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-8][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/i;


/***/ }),

/***/ 9942:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports["default"] = rng;
const crypto_1 = __webpack_require__(6982);
const rnds8Pool = new Uint8Array(256);
let poolPtr = rnds8Pool.length;
function rng() {
    if (poolPtr > rnds8Pool.length - 16) {
        (0, crypto_1.randomFillSync)(rnds8Pool);
        poolPtr = 0;
    }
    return rnds8Pool.slice(poolPtr, (poolPtr += 16));
}


/***/ }),

/***/ 5385:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const crypto_1 = __webpack_require__(6982);
function sha1(bytes) {
    if (Array.isArray(bytes)) {
        bytes = Buffer.from(bytes);
    }
    else if (typeof bytes === 'string') {
        bytes = Buffer.from(bytes, 'utf8');
    }
    return (0, crypto_1.createHash)('sha1').update(bytes).digest();
}
exports["default"] = sha1;


/***/ }),

/***/ 3202:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.unsafeStringify = unsafeStringify;
const validate_js_1 = __webpack_require__(8873);
const byteToHex = [];
for (let i = 0; i < 256; ++i) {
    byteToHex.push((i + 0x100).toString(16).slice(1));
}
function unsafeStringify(arr, offset = 0) {
    return (byteToHex[arr[offset + 0]] +
        byteToHex[arr[offset + 1]] +
        byteToHex[arr[offset + 2]] +
        byteToHex[arr[offset + 3]] +
        '-' +
        byteToHex[arr[offset + 4]] +
        byteToHex[arr[offset + 5]] +
        '-' +
        byteToHex[arr[offset + 6]] +
        byteToHex[arr[offset + 7]] +
        '-' +
        byteToHex[arr[offset + 8]] +
        byteToHex[arr[offset + 9]] +
        '-' +
        byteToHex[arr[offset + 10]] +
        byteToHex[arr[offset + 11]] +
        byteToHex[arr[offset + 12]] +
        byteToHex[arr[offset + 13]] +
        byteToHex[arr[offset + 14]] +
        byteToHex[arr[offset + 15]]).toLowerCase();
}
function stringify(arr, offset = 0) {
    const uuid = unsafeStringify(arr, offset);
    if (!(0, validate_js_1.default)(uuid)) {
        throw TypeError('Stringified UUID is invalid');
    }
    return uuid;
}
exports["default"] = stringify;


/***/ }),

/***/ 458:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.updateV1State = updateV1State;
const rng_js_1 = __webpack_require__(9942);
const stringify_js_1 = __webpack_require__(3202);
const _state = {};
function v1(options, buf, offset) {
    let bytes;
    const isV6 = options?._v6 ?? false;
    if (options) {
        const optionsKeys = Object.keys(options);
        if (optionsKeys.length === 1 && optionsKeys[0] === '_v6') {
            options = undefined;
        }
    }
    if (options) {
        bytes = v1Bytes(options.random ?? options.rng?.() ?? (0, rng_js_1.default)(), options.msecs, options.nsecs, options.clockseq, options.node, buf, offset);
    }
    else {
        const now = Date.now();
        const rnds = (0, rng_js_1.default)();
        updateV1State(_state, now, rnds);
        bytes = v1Bytes(rnds, _state.msecs, _state.nsecs, isV6 ? undefined : _state.clockseq, isV6 ? undefined : _state.node, buf, offset);
    }
    return buf ? bytes : (0, stringify_js_1.unsafeStringify)(bytes);
}
function updateV1State(state, now, rnds) {
    state.msecs ??= -Infinity;
    state.nsecs ??= 0;
    if (now === state.msecs) {
        state.nsecs++;
        if (state.nsecs >= 10000) {
            state.node = undefined;
            state.nsecs = 0;
        }
    }
    else if (now > state.msecs) {
        state.nsecs = 0;
    }
    else if (now < state.msecs) {
        state.node = undefined;
    }
    if (!state.node) {
        state.node = rnds.slice(10, 16);
        state.node[0] |= 0x01;
        state.clockseq = ((rnds[8] << 8) | rnds[9]) & 0x3fff;
    }
    state.msecs = now;
    return state;
}
function v1Bytes(rnds, msecs, nsecs, clockseq, node, buf, offset = 0) {
    if (!buf) {
        buf = new Uint8Array(16);
        offset = 0;
    }
    msecs ??= Date.now();
    nsecs ??= 0;
    clockseq ??= ((rnds[8] << 8) | rnds[9]) & 0x3fff;
    node ??= rnds.slice(10, 16);
    msecs += 12219292800000;
    const tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;
    buf[offset++] = (tl >>> 24) & 0xff;
    buf[offset++] = (tl >>> 16) & 0xff;
    buf[offset++] = (tl >>> 8) & 0xff;
    buf[offset++] = tl & 0xff;
    const tmh = ((msecs / 0x100000000) * 10000) & 0xfffffff;
    buf[offset++] = (tmh >>> 8) & 0xff;
    buf[offset++] = tmh & 0xff;
    buf[offset++] = ((tmh >>> 24) & 0xf) | 0x10;
    buf[offset++] = (tmh >>> 16) & 0xff;
    buf[offset++] = (clockseq >>> 8) | 0x80;
    buf[offset++] = clockseq & 0xff;
    for (let n = 0; n < 6; ++n) {
        buf[offset++] = node[n];
    }
    return buf;
}
exports["default"] = v1;


/***/ }),

/***/ 3891:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports["default"] = v1ToV6;
const parse_js_1 = __webpack_require__(2524);
const stringify_js_1 = __webpack_require__(3202);
function v1ToV6(uuid) {
    const v1Bytes = typeof uuid === 'string' ? (0, parse_js_1.default)(uuid) : uuid;
    const v6Bytes = _v1ToV6(v1Bytes);
    return typeof uuid === 'string' ? (0, stringify_js_1.unsafeStringify)(v6Bytes) : v6Bytes;
}
function _v1ToV6(v1Bytes) {
    return Uint8Array.of(((v1Bytes[6] & 0x0f) << 4) | ((v1Bytes[7] >> 4) & 0x0f), ((v1Bytes[7] & 0x0f) << 4) | ((v1Bytes[4] & 0xf0) >> 4), ((v1Bytes[4] & 0x0f) << 4) | ((v1Bytes[5] & 0xf0) >> 4), ((v1Bytes[5] & 0x0f) << 4) | ((v1Bytes[0] & 0xf0) >> 4), ((v1Bytes[0] & 0x0f) << 4) | ((v1Bytes[1] & 0xf0) >> 4), ((v1Bytes[1] & 0x0f) << 4) | ((v1Bytes[2] & 0xf0) >> 4), 0x60 | (v1Bytes[2] & 0x0f), v1Bytes[3], v1Bytes[8], v1Bytes[9], v1Bytes[10], v1Bytes[11], v1Bytes[12], v1Bytes[13], v1Bytes[14], v1Bytes[15]);
}


/***/ }),

/***/ 32:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.URL = exports.DNS = void 0;
const md5_js_1 = __webpack_require__(7355);
const v35_js_1 = __webpack_require__(8157);
var v35_js_2 = __webpack_require__(8157);
Object.defineProperty(exports, "DNS", ({ enumerable: true, get: function () { return v35_js_2.DNS; } }));
Object.defineProperty(exports, "URL", ({ enumerable: true, get: function () { return v35_js_2.URL; } }));
function v3(value, namespace, buf, offset) {
    return (0, v35_js_1.default)(0x30, md5_js_1.default, value, namespace, buf, offset);
}
v3.DNS = v35_js_1.DNS;
v3.URL = v35_js_1.URL;
exports["default"] = v3;


/***/ }),

/***/ 8157:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.URL = exports.DNS = void 0;
exports.stringToBytes = stringToBytes;
exports["default"] = v35;
const parse_js_1 = __webpack_require__(2524);
const stringify_js_1 = __webpack_require__(3202);
function stringToBytes(str) {
    str = unescape(encodeURIComponent(str));
    const bytes = new Uint8Array(str.length);
    for (let i = 0; i < str.length; ++i) {
        bytes[i] = str.charCodeAt(i);
    }
    return bytes;
}
exports.DNS = '6ba7b810-9dad-11d1-80b4-00c04fd430c8';
exports.URL = '6ba7b811-9dad-11d1-80b4-00c04fd430c8';
function v35(version, hash, value, namespace, buf, offset) {
    const valueBytes = typeof value === 'string' ? stringToBytes(value) : value;
    const namespaceBytes = typeof namespace === 'string' ? (0, parse_js_1.default)(namespace) : namespace;
    if (typeof namespace === 'string') {
        namespace = (0, parse_js_1.default)(namespace);
    }
    if (namespace?.length !== 16) {
        throw TypeError('Namespace must be array-like (16 iterable integer values, 0-255)');
    }
    let bytes = new Uint8Array(16 + valueBytes.length);
    bytes.set(namespaceBytes);
    bytes.set(valueBytes, namespaceBytes.length);
    bytes = hash(bytes);
    bytes[6] = (bytes[6] & 0x0f) | version;
    bytes[8] = (bytes[8] & 0x3f) | 0x80;
    if (buf) {
        offset = offset || 0;
        for (let i = 0; i < 16; ++i) {
            buf[offset + i] = bytes[i];
        }
        return buf;
    }
    return (0, stringify_js_1.unsafeStringify)(bytes);
}


/***/ }),

/***/ 8597:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const native_js_1 = __webpack_require__(1152);
const rng_js_1 = __webpack_require__(9942);
const stringify_js_1 = __webpack_require__(3202);
function v4(options, buf, offset) {
    if (native_js_1.default.randomUUID && !buf && !options) {
        return native_js_1.default.randomUUID();
    }
    options = options || {};
    const rnds = options.random || (options.rng || rng_js_1.default)();
    rnds[6] = (rnds[6] & 0x0f) | 0x40;
    rnds[8] = (rnds[8] & 0x3f) | 0x80;
    if (buf) {
        offset = offset || 0;
        for (let i = 0; i < 16; ++i) {
            buf[offset + i] = rnds[i];
        }
        return buf;
    }
    return (0, stringify_js_1.unsafeStringify)(rnds);
}
exports["default"] = v4;


/***/ }),

/***/ 4502:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.URL = exports.DNS = void 0;
const sha1_js_1 = __webpack_require__(5385);
const v35_js_1 = __webpack_require__(8157);
var v35_js_2 = __webpack_require__(8157);
Object.defineProperty(exports, "DNS", ({ enumerable: true, get: function () { return v35_js_2.DNS; } }));
Object.defineProperty(exports, "URL", ({ enumerable: true, get: function () { return v35_js_2.URL; } }));
function v5(value, namespace, buf, offset) {
    return (0, v35_js_1.default)(0x50, sha1_js_1.default, value, namespace, buf, offset);
}
v5.DNS = v35_js_1.DNS;
v5.URL = v35_js_1.URL;
exports["default"] = v5;


/***/ }),

/***/ 7971:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const stringify_js_1 = __webpack_require__(3202);
const v1_js_1 = __webpack_require__(458);
const v1ToV6_js_1 = __webpack_require__(3891);
function v6(options, buf, offset) {
    options ??= {};
    offset ??= 0;
    let bytes = (0, v1_js_1.default)({ ...options, _v6: true }, new Uint8Array(16));
    bytes = (0, v1ToV6_js_1.default)(bytes);
    if (buf) {
        for (let i = 0; i < 16; i++) {
            buf[offset + i] = bytes[i];
        }
        return buf;
    }
    return (0, stringify_js_1.unsafeStringify)(bytes);
}
exports["default"] = v6;


/***/ }),

/***/ 8959:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports["default"] = v6ToV1;
const parse_js_1 = __webpack_require__(2524);
const stringify_js_1 = __webpack_require__(3202);
function v6ToV1(uuid) {
    const v6Bytes = typeof uuid === 'string' ? (0, parse_js_1.default)(uuid) : uuid;
    const v1Bytes = _v6ToV1(v6Bytes);
    return typeof uuid === 'string' ? (0, stringify_js_1.unsafeStringify)(v1Bytes) : v1Bytes;
}
function _v6ToV1(v6Bytes) {
    return Uint8Array.of(((v6Bytes[3] & 0x0f) << 4) | ((v6Bytes[4] >> 4) & 0x0f), ((v6Bytes[4] & 0x0f) << 4) | ((v6Bytes[5] & 0xf0) >> 4), ((v6Bytes[5] & 0x0f) << 4) | (v6Bytes[6] & 0x0f), v6Bytes[7], ((v6Bytes[1] & 0x0f) << 4) | ((v6Bytes[2] & 0xf0) >> 4), ((v6Bytes[2] & 0x0f) << 4) | ((v6Bytes[3] & 0xf0) >> 4), 0x10 | ((v6Bytes[0] & 0xf0) >> 4), ((v6Bytes[0] & 0x0f) << 4) | ((v6Bytes[1] & 0xf0) >> 4), v6Bytes[8], v6Bytes[9], v6Bytes[10], v6Bytes[11], v6Bytes[12], v6Bytes[13], v6Bytes[14], v6Bytes[15]);
}


/***/ }),

/***/ 2508:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.updateV7State = updateV7State;
const rng_js_1 = __webpack_require__(9942);
const stringify_js_1 = __webpack_require__(3202);
const _state = {};
function v7(options, buf, offset) {
    let bytes;
    if (options) {
        bytes = v7Bytes(options.random ?? options.rng?.() ?? (0, rng_js_1.default)(), options.msecs, options.seq, buf, offset);
    }
    else {
        const now = Date.now();
        const rnds = (0, rng_js_1.default)();
        updateV7State(_state, now, rnds);
        bytes = v7Bytes(rnds, _state.msecs, _state.seq, buf, offset);
    }
    return buf ? bytes : (0, stringify_js_1.unsafeStringify)(bytes);
}
function updateV7State(state, now, rnds) {
    state.msecs ??= -Infinity;
    state.seq ??= 0;
    if (now > state.msecs) {
        state.seq = (rnds[6] << 23) | (rnds[7] << 16) | (rnds[8] << 8) | rnds[9];
        state.msecs = now;
    }
    else {
        state.seq = (state.seq + 1) | 0;
        if (state.seq === 0) {
            state.msecs++;
        }
    }
    return state;
}
function v7Bytes(rnds, msecs, seq, buf, offset = 0) {
    if (!buf) {
        buf = new Uint8Array(16);
        offset = 0;
    }
    msecs ??= Date.now();
    seq ??= ((rnds[6] * 0x7f) << 24) | (rnds[7] << 16) | (rnds[8] << 8) | rnds[9];
    buf[offset++] = (msecs / 0x10000000000) & 0xff;
    buf[offset++] = (msecs / 0x100000000) & 0xff;
    buf[offset++] = (msecs / 0x1000000) & 0xff;
    buf[offset++] = (msecs / 0x10000) & 0xff;
    buf[offset++] = (msecs / 0x100) & 0xff;
    buf[offset++] = msecs & 0xff;
    buf[offset++] = 0x70 | ((seq >>> 28) & 0x0f);
    buf[offset++] = (seq >>> 20) & 0xff;
    buf[offset++] = 0x80 | ((seq >>> 14) & 0x3f);
    buf[offset++] = (seq >>> 6) & 0xff;
    buf[offset++] = ((seq << 2) & 0xff) | (rnds[10] & 0x03);
    buf[offset++] = rnds[11];
    buf[offset++] = rnds[12];
    buf[offset++] = rnds[13];
    buf[offset++] = rnds[14];
    buf[offset++] = rnds[15];
    return buf;
}
exports["default"] = v7;


/***/ }),

/***/ 8873:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const regex_js_1 = __webpack_require__(3596);
function validate(uuid) {
    return typeof uuid === 'string' && regex_js_1.default.test(uuid);
}
exports["default"] = validate;


/***/ }),

/***/ 9547:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const validate_js_1 = __webpack_require__(8873);
function version(uuid) {
    if (!(0, validate_js_1.default)(uuid)) {
        throw TypeError('Invalid UUID');
    }
    return parseInt(uuid.slice(14, 15), 16);
}
exports["default"] = version;


/***/ }),

/***/ 1636:
/***/ ((module) => {

"use strict";
module.exports = {"rE":"6.6.1"};

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/amd define */
/******/ 	(() => {
/******/ 		__webpack_require__.amdD = function () {
/******/ 			throw new Error('define cannot be used indirect');
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/amd options */
/******/ 	(() => {
/******/ 		__webpack_require__.amdO = {};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/node module decorator */
/******/ 	(() => {
/******/ 		__webpack_require__.nmd = (module) => {
/******/ 			module.paths = [];
/******/ 			if (!module.children) module.children = [];
/******/ 			return module;
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__(9994);
/******/ 	var __webpack_export_target__ = exports;
/******/ 	for(var i in __webpack_exports__) __webpack_export_target__[i] = __webpack_exports__[i];
/******/ 	if(__webpack_exports__.__esModule) Object.defineProperty(__webpack_export_target__, "__esModule", { value: true });
/******/ 	
/******/ })()
;